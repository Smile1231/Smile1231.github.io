{
    "version": "https://jsonfeed.org/version/1",
    "title": "JIN MAO 's Blog • All posts by \"算法\" category",
    "description": "",
    "home_page_url": "https://smile1231.github.io",
    "items": [
        {
            "id": "https://smile1231.github.io/posts/14e6f1eb/",
            "url": "https://smile1231.github.io/posts/14e6f1eb/",
            "title": "冒泡排序",
            "date_published": "2022-03-12T13:58:14.000Z",
            "content_html": "<h2 id=\"冒泡排序稳定\"><a class=\"markdownIt-Anchor\" href=\"#冒泡排序稳定\">#</a> 冒泡排序（稳定）</h2>\n<h3 id=\"1-基本思想\"><a class=\"markdownIt-Anchor\" href=\"#1-基本思想\">#</a> 1、基本思想</h3>\n<p>冒泡排序（ <code>Bubble Sort</code> ）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</p>\n<span id=\"more\"></span>\n<h3 id=\"2-算法描述\"><a class=\"markdownIt-Anchor\" href=\"#2-算法描述\">#</a> 2、算法描述</h3>\n<p>冒泡排序算法的运作如下：</p>\n<p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>\n②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>\n③. 针对所有的元素重复以上的步骤，除了最后一个。<br>\n④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</p>\n<h3 id=\"3-代码实现\"><a class=\"markdownIt-Anchor\" href=\"#3-代码实现\">#</a> 3、代码实现</h3>\n<p>冒泡排序需要两个嵌套的循环。其中，外层循环移动游标；内层循环遍历游标及之后 (或之前) 的元素，通过两两交换的方式，每次只确保该内循环结束位置排序正确，然后内层循环周期结束，交由外层循环往后 (或前) 移动游标，随即开始下一轮内层循环，以此类推，直至循环结束.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = arr.length; i &gt; <span class=\"number\">0</span>; i--) &#123;      <span class=\"comment\">//外层循环移动游标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i &amp;&amp; (j+<span class=\"number\">1</span>) &lt; i; j++)&#123;    <span class=\"comment\">//内层循环遍历游标及之后(或之前)的元素</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &gt; arr[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = arr[j];</span><br><span class=\"line\">                arr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                arr[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Sorting: &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置，它并不改变相同元素之间的相对顺序，因此它是稳定的排序算法.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "冒泡排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/c2a5fdc5/",
            "url": "https://smile1231.github.io/posts/c2a5fdc5/",
            "title": "堆排序",
            "date_published": "2022-03-12T13:58:00.000Z",
            "content_html": "<h2 id=\"堆排序不稳定\"><a class=\"markdownIt-Anchor\" href=\"#堆排序不稳定\">#</a> 堆排序（不稳定）</h2>\n<p>个人感觉堆排序还是挺难的，虽然会有演示动画<br>\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAvIyVFNSU5QiU5QiVFMyU4MCU4MSVFNSVBMCU4NiVFNiU4RSU5MiVFNSVCQSU4RiVFRiVCQyU4OEhlYXAtU29ydCVFRiVCQyU4OQ==\">链接</span></p>\n<p>但是从代码层面就没有那么好的通俗</p>\n<span id=\"more\"></span>\n<p>堆的含义就是：完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序，使用小顶堆进行降序排序。</p>\n<h3 id=\"1-基本思想\"><a class=\"markdownIt-Anchor\" href=\"#1-基本思想\">#</a> 1、基本思想</h3>\n<p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p>\n<h3 id=\"2-算法描述\"><a class=\"markdownIt-Anchor\" href=\"#2-算法描述\">#</a> 2、算法描述</h3>\n<p>①. 先将初始序列 <code>K[1..n]</code>  建成一个大顶堆，那么此时第一个元素 <code>K1</code>  最大，此堆为初始的无序区.<br>\n②. 再将关键字最大的记录 <code>K1</code>  (即堆顶，第一个元素) 和无序区的最后一个记录  <code>Kn</code>  交换，由此得到新的无序区 <code>K[1..n−1]</code>  和有序区 <code>K[n]</code> , 且满足 <code>K[1..n−1].keys⩽K[n].key</code> <br>\n③. 交换 <code>K1</code>  和  <code>Kn</code>  后，堆顶可能违反堆性质，因此需将 <code>K[1..n−1]</code>  调整为堆。然后重复步骤②, 直到无序区只有一个元素时停止.</p>\n<h3 id=\"3-代码实现\"><a class=\"markdownIt-Anchor\" href=\"#3-代码实现\">#</a> 3、代码实现</h3>\n<p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p>\n<p>总结起来就是定义了以下几种操作：</p>\n<ul>\n<li>最大堆调整（ <code>Max_Heapify</code> ）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>\n<li>创建最大堆（ <code>Build_Max_Heap</code> ）：将堆所有数据重新排序</li>\n<li>堆排序（ <code>HeapSort</code> ）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>\n</ul>\n<p>对于堆节点的访问：</p>\n<ul>\n<li>父节点 i 的左子节点在位置： <code>(2*i+1);</code></li>\n<li>父节点 i 的右子节点在位置： <code>(2*i+2);</code></li>\n<li>子节点 i 的父节点在位置： <code>floor((i-1)/2);</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = arr.length; i &gt; <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        max_heapify(arr, i);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[<span class=\"number\">0</span>];      <span class=\"comment\">//堆顶元素(第一个元素)与Kn交换</span></span><br><span class=\"line\">        arr[<span class=\"number\">0</span>] = arr[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        arr[i-<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">max_heapify</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> limit)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arr.length &lt;= <span class=\"number\">0</span> || arr.length &lt; limit) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> parentIdx = limit / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; parentIdx &gt;= <span class=\"number\">0</span>; parentIdx--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(parentIdx * <span class=\"number\">2</span> &gt;= limit)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = parentIdx * <span class=\"number\">2</span>;       <span class=\"comment\">//左子节点位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = (left + <span class=\"number\">1</span>) &gt;= limit ? left : (left + <span class=\"number\">1</span>);    <span class=\"comment\">//右子节点位置，如果没有右节点，默认为左节点位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxChildId = arr[left] &gt;= arr[right] ? left : right;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[maxChildId] &gt; arr[parentIdx])&#123;   <span class=\"comment\">//交换父节点与左右子节点中的最大值</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = arr[parentIdx];</span><br><span class=\"line\">            arr[parentIdx] = arr[maxChildId];</span><br><span class=\"line\">            arr[maxChildId] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Max_Heapify: &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Tips: 由于堆排序中初始化堆的过程比较次数较多，因此它不太适用于小序列。同时由于多次任意下标相互交换位置，相同元素之间原本相对的顺序被破坏了，因此，它是不稳定的排序.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "堆排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/43d00a99/",
            "url": "https://smile1231.github.io/posts/43d00a99/",
            "title": "选择排序",
            "date_published": "2022-03-12T13:45:07.000Z",
            "content_html": "<h2 id=\"选择排序不稳定on2\"><a class=\"markdownIt-Anchor\" href=\"#选择排序不稳定on2\">#</a> 选择排序（不稳定）ON2</h2>\n<p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p>\n<h3 id=\"1-基本思想\"><a class=\"markdownIt-Anchor\" href=\"#1-基本思想\">#</a> 1、基本思想</h3>\n<p>选择排序的基本思想：比较 + 交换。</p>\n<p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>\n<h3 id=\"2-算法描述\"><a class=\"markdownIt-Anchor\" href=\"#2-算法描述\">#</a> 2、算法描述</h3>\n<p>①. 从待排序序列中，找到关键字最小的元素；<br>\n②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br>\n③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</p>\n<h3 id=\"3-代码实现\"><a class=\"markdownIt-Anchor\" href=\"#3-代码实现\">#</a> 3、代码实现</h3>\n<p>选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">selectionSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arr.length-<span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; arr.length; j++)&#123;    <span class=\"comment\">//选出之后待排序中值最小的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class=\"line\">                min = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(min != i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = arr[min];      <span class=\"comment\">//交换操作</span></span><br><span class=\"line\">            arr[min] = arr[i];</span><br><span class=\"line\">            arr[i] = temp;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Sorting:  &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "选择排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/2b06d603/",
            "url": "https://smile1231.github.io/posts/2b06d603/",
            "title": "直接插入排序",
            "date_published": "2022-03-12T09:57:45.000Z",
            "content_html": "<h2 id=\"插入排序稳定\"><a class=\"markdownIt-Anchor\" href=\"#插入排序稳定\">#</a> 插入排序（稳定）</h2>\n<p>一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：</p>\n<p>①. 从第一个元素开始，该元素可以认为已经被排序<br>\n②. 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>\n③. 如果该元素（已排序）大于新元素，将该元素移到下一位置<br>\n④. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置<br>\n⑤. 将新元素插入到该位置后<br>\n⑥. 重复步骤②~⑤</p>\n<span id=\"more\"></span>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertionSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; arr.length; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[i];    <span class=\"comment\">// 取出下一个元素，在已经排序的元素序列中从后向前扫描</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> j = i; j &gt;= <span class=\"number\">0</span>; j-- ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>( j &gt; <span class=\"number\">0</span> &amp;&amp; arr[j-<span class=\"number\">1</span>] &gt; temp ) &#123;</span><br><span class=\"line\">                arr[j] = arr[j-<span class=\"number\">1</span>];    <span class=\"comment\">// 如果该元素（已排序）大于取出的元素temp，将该元素移到下一位置</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Temping:  &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将新元素插入到该位置后</span></span><br><span class=\"line\">                arr[j] = temp;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Sorting:  &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交换次数较多的实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertionSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;arr.length-<span class=\"number\">1</span>; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>; j&gt;<span class=\"number\">0</span>; j-- ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>( arr[j-<span class=\"number\">1</span>] &lt;= arr[j] )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = arr[j];      <span class=\"comment\">//交换操作</span></span><br><span class=\"line\">            arr[j] = arr[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">            arr[j-<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Sorting:  &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//JDK直接插入排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a,<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ai = a[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ai &lt; a[j]) &#123;</span><br><span class=\"line\">            a[j + <span class=\"number\">1</span>] = a[j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j-- == left) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a[j + <span class=\"number\">1</span>] = ai;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "直接插入排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/ff8068c0/",
            "url": "https://smile1231.github.io/posts/ff8068c0/",
            "title": "快速排序",
            "date_published": "2022-03-12T05:24:41.000Z",
            "content_html": "<h2 id=\"快排-不稳定\"><a class=\"markdownIt-Anchor\" href=\"#快排-不稳定\">#</a> 快排 (不稳定)</h2>\n<p>快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。</p>\n<h3 id=\"快速排序的原理\"><a class=\"markdownIt-Anchor\" href=\"#快速排序的原理\">#</a> 快速排序的原理</h3>\n<span id=\"more\"></span>\n<p>排序算法的思想非常简单，在待排序的数列中，我们首先要找一个数字作为基准数（这只是个专用名词）。为了方便，我们一般选择第  <code>1</code>  个数字作为基准数（其实选择第几个并没有关系）。接下来我们需要把这个待排序的数列中小于基准数的元素移动到待排序的数列的左边，把大于基准数的元素移动到待排序的数列的右边。这时，左右两个分区的元素就相对有序了；接着把两个分区的元素分别按照上面两种方法继续对每个分区找出基准数，然后移动，直到各个分区只有一个数时为止。</p>\n<p>这是典型的分治思想，即分治法。下面我们对一个实际例子进行算法描述，讲解快速排序的排序步骤。</p>\n<p><code>以 47、29、71、99、78、19、24、47</code>  的待排序的数列为例进行排序，为了方便区分两个  <code>47</code> ，我们对后面的  <code>47</code>  增加一个下画线，即待排序的数列为  <code>47、29、71、99、78、19、24、47</code> 。</p>\n<p>首先我们需要在数列中选择一个基准数，我们一般会选择中间的一个数或者头尾的数，这里直接选择第  <code>1</code>  个数  <code>47</code>  作为基准数，接着把比  <code>47</code>  小的数字移动到左边，把比  <code>47</code>  大的数字移动到右边，对于相等的数字不做移动。所以实际上我们需要找到中间的某个位置  <code>k</code> ，这样  <code>k</code>  左边的值全部比  <code>k</code>  上的值小， <code>k</code>  右边的值全部比  <code>k</code>  上的值大。</p>\n<p>接下来开始移动元素。怎么移动呢？其实冒泡排序也涉及对元素的移动，但是那样移动起来很累，比如把最后一个元素移动到第  <code>1</code>  个，就需要比较  <code>n-1</code>  次，同时交换  <code>n-1</code>  次，效率很低。其实，只需把第  <code>1</code>  个元素和最后一个元素交换就好了，这种思想是不是在排序时可以借鉴呢？之前说快速排序就是对冒泡排序的一个改进，就是这个原因。</p>\n<p>快速排序的操作是这样的：首先从数列的右边开始往左边找，我们设这个下标为  <code>i</code> ，也就是进行减减操作（ <code>i--</code> ），找到第  <code>1</code>  个比基准数小的值，让它与基准值交换；接着从左边开始往右边找，设这个下标为  <code>j</code> ，然后执行加加操作 <code>（j++）</code> ，找到第  <code>1</code>  个比基准数大的值，让它与基准值交换；然后继续寻找，直到  <code>i </code> 与  <code>j</code>  相遇时结束，最后基准值所在的位置即  <code>k</code>  的位置，也就是说  <code>k</code>  左边的值均比  <code>k</code>  上的值小，而  <code>k</code>  右边的值都比  <code>k </code> 上的值大。</p>\n<p>所以对于上面的数列 47、29、71、99、78、19、24、 <u>47</u>，进行第  <code>1</code>  趟第  <code>1</code>  个交换的排序情况如下，第  <code>1</code>  次的操作情况如图 1 所示。</p>\n<img data-src=\"/posts/ff8068c0/2022-03-12-16-52-14.png\" class=\"\">\n<p>交换之后， <code>j</code>  移动到了下标为  <code>6</code>  的位置，对  <code>i</code>  继续扫描，如图  <code>2</code>  所示。</p>\n<img data-src=\"/posts/ff8068c0/2022-03-12-16-55-14.png\" class=\"\">\n<p>此时交换后的数列变为 24、29、47、99、78、19、71、<u>47</u>。接下来我们继续对 i、j 进行操作，如图 3 所示，继续进行 i-- 及 j++ 的比较操作。</p>\n<img data-src=\"/posts/ff8068c0/2022-03-12-16-58-42.png\" class=\"\">\n<p>进行了这两次 i、j 的移动、比较、交换之后，我们最终得到的数列是 24、29、19、47、78、99、71、<u>47</u>。接下来我们继续进行 i-- 的操作，发现在 i 为 4 时比 47 大不用交换，在 i 为 3 时与 j 相遇，这时就不需要继续移动、比较了，已经找到 k 了，并且 k 的值为 3。我们可以确认一下当前的数列是不是 k 左边的值都比 47 小，而 k 右边的值都比 47 大（由于要保持相对位置不变，所以 47 同样在基准值 47 的右边）。</p>\n<p>47 这个值已经落到了它该在的位置，第 1 趟排序完成了。接下来就是以 k 为基准，分为两部分，然后在左右两部分分别执行上述排序操作，最后数据会分为 4 部分；接着对每部分进行操作，直到每部分都只有一个值为止。</p>\n<p>接下来进行第 2 趟排序，现在左边部分为 24、29、19，我们选择第 1 个数 24 作为基准数，接着进行 i–、j++ 的操作，我们发现 i 最初的值为 19，比 24 这个基准值小，所以与基准值进行交换，得到的数列为 19、29、24；当 j 为 1 时，我们发现 29 比 24 大，所以与基准值进行交换，得到的数列 19、24、29，此时 i 为 2，j 为 1；继续 i-- 时发现 i 为 1，与 j 相遇，左边部分的数列的 k 为 1，并且左右两部分分别只有一个元素，此时第 2 轮排序的左边部分的排序结束，同时左边部分的所有数据都排序完成。</p>\n<p>我们接着看右边部分的排序，待排序的数列为 78、99、71、<u>47</u>，我们同样选择第 1 个值 78 为基准值，接下来进行 i 与 j 的移动与比较，发现 47 比 78 小，进行交换，得到的数列 47、99、71、78；从左往右发现 99 比基准值 78 大，进行交换，得到的数列为 47、78、71、99；继续从右向左看，发现 71 比基准值 78 小，进行交换，得到的数列为 <u>47</u>、71、78、99。此时 i 在整体数组中的下标为 6，j 为 5，若继续 j++ 则与 i 相遇，所以完成此轮排序。</p>\n<p>此时右边数列的 k 为 6，一般会是相遇的位置，也就是基准值所在的位置，这时数列又被分为两部分，左边是 47、71，右边是 99，需要继续对左边部分的数据进行排序，虽然只有两个数据，但我们还是继续按照快速排序的思想操作一下，选择 <u>47</u> 作为基准数，将 i 进行从右向左的移动、比较，发现 i 与 j 相等时没有产生移动，完成第 2 轮排序。</p>\n<p>至此，所有排序都已经完成，最终数列的结果是 19、24、29、47、47、71、78、99，怎么样，快速排序是不是非常简单地完成了所有的排序呢？虽然本次快速排序没有改变相同值的元素的顺序，但是由于快速排序需要对数列中的元素来回移动，有时还是会改变相对顺序的（比如 47 在第 1 轮的移动过程中就被移动到 47 的右边了），所以快速排序并不是一个稳定的算法。</p>\n<h2 id=\"快速排序的实现\"><a class=\"markdownIt-Anchor\" href=\"#快速排序的实现\">#</a> 快速排序的实现</h2>\n<p>通过以上的学习，你是否可以自己写出快速排序的实现代码呢？在接着学习之前，最好自己能对代码的实现进行一些思考，然后和下面的内容进行比对，看看自己有哪些疏忽之处。</p>\n<p>其实快速排序有一个比较简单的思想，就是递归。对于每一趟排序都是一样的思想，只不过需要进行排序的数组的范围越来越小了，使用递归实现这种排序最适合不过了。</p>\n<h3 id=\"实现一\"><a class=\"markdownIt-Anchor\" href=\"#实现一\">#</a> 实现一</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuickSort</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] array;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">QuickSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.array = array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        quickSort(array, <span class=\"number\">0</span>, array.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            System.out.println(array[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 递归排序</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> src</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> begin</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> end</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] src, <span class=\"keyword\">int</span> begin, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (begin &lt; end) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> key = src[begin];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = begin;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = end;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (i &lt; j &amp;&amp; src[j] &gt; key) &#123;</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; j) &#123;</span><br><span class=\"line\">                    src[i] = src[j];</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (i &lt; j &amp;&amp; src[i] &lt; key) &#123;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; j) &#123;</span><br><span class=\"line\">                    src[j] = src[i];</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            src[i] = key;</span><br><span class=\"line\">            quickSort(src, begin, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">            quickSort(src, i + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现二\"><a class=\"markdownIt-Anchor\" href=\"#实现二\">#</a> 实现二</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arr.length &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(low &gt;= high) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = high;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = arr[left];   <span class=\"comment\">//挖坑1：保存基准的值</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= temp)&#123;  <span class=\"comment\">//坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span></span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[left] = arr[right];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= temp)&#123;   <span class=\"comment\">//坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span></span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[right] = arr[left];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[left] = temp;   <span class=\"comment\">//基准值填补到坑3中，准备分治递归快排</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Sorting: &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">    quickSort(arr, low, left-<span class=\"number\">1</span>);</span><br><span class=\"line\">    quickSort(arr, left+<span class=\"number\">1</span>, high);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序的特点及性能\"><a class=\"markdownIt-Anchor\" href=\"#快速排序的特点及性能\">#</a> 快速排序的特点及性能</h2>\n<p>快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。</p>\n<p>但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是  <code>O(n2)</code> ，实际上每次比较都需要交换，但是这种情况并不常见。我们可以思考一下如果每次比较都需要交换，那么数列的平均时间复杂度是  <code>O(nlogn)</code> ，事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。</p>\n<p>快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的空间复杂度为  <code>O(logn)</code> ，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为 <code> O(n)</code> 。所以我们一般认为快速排序的空间复杂度为  <code>O(logn)</code> 。</p>\n<p>快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。</p>\n<p>快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2RhdGEuYmlhbmNoZW5nLm5ldC92aWV3LzExNy5odG1s\">本文链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "快速排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/a4ce31d2/",
            "url": "https://smile1231.github.io/posts/a4ce31d2/",
            "title": "贪心算法",
            "date_published": "2022-02-17T14:58:04.000Z",
            "content_html": "<h1 id=\"贪心算法\"><a class=\"markdownIt-Anchor\" href=\"#贪心算法\">#</a> 贪心算法</h1>\n<h2 id=\"基本概念\"><a class=\"markdownIt-Anchor\" href=\"#基本概念\">#</a> 基本概念</h2>\n<p>所谓贪心算法是指，在对问题求解时，总是做出<strong>在当前看来是最好的选择</strong>。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p>\n<p>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p>\n<span id=\"more\"></span>\n<p><strong>所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</strong></p>\n<h2 id=\"贪心算法的基本思路\"><a class=\"markdownIt-Anchor\" href=\"#贪心算法的基本思路\">#</a> 贪心算法的基本思路</h2>\n<ol>\n<li>\n<p>建立数学模型来描述问题。</p>\n</li>\n<li>\n<p>把求解的问题分成若干个子问题。</p>\n</li>\n<li>\n<p>对每一子问题求解，得到子问题的局部最优解。</p>\n</li>\n<li>\n<p>把子问题的解局部最优解合成原来解问题的一个解。</p>\n</li>\n</ol>\n<h2 id=\"贪心算法的实现框架\"><a class=\"markdownIt-Anchor\" href=\"#贪心算法的实现框架\">#</a> 贪心算法的实现框架</h2>\n<p>贪心算法适用的前提是：局部最优策略能导致产生全局最优解</p>\n<p>实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从问题的某一初始解出发；</span><br><span class=\"line\"><span class=\"keyword\">while</span> （能朝给定总目标前进一步）</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">        利用可行的决策，求出可行解的一个解元素;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">由所有解元素组合成问题的一个可行解;</span><br></pre></td></tr></table></figure>\n<h2 id=\"贪心策略的选择\"><a class=\"markdownIt-Anchor\" href=\"#贪心策略的选择\">#</a> 贪心策略的选择</h2>\n<p>因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p>\n<h2 id=\"经典例题\"><a class=\"markdownIt-Anchor\" href=\"#经典例题\">#</a> 经典例题</h2>\n<p>下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。</p>\n<blockquote>\n<p>[背包问题] 有一个背包，背包容量是 <code>M=150</code> 。有 <code>7</code>  个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</p>\n</blockquote>\n  <figure class=\"highlight plaintext\"><figcaption><span>A     B    C    D     E     F    G</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">重量 35   30   60   50   40   10   25</span><br><span class=\"line\">价值 10   40   30   50   35   40   30</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">目标函数： `∑pi`最大（价值总和最大）</span><br><span class=\"line\">约束条件是装入的物品总重量不超过背包容量：`∑wi&lt;=M( M=<span class=\"number\">150</span>)`</span><br><span class=\"line\">    （<span class=\"number\">1</span>）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？</span><br><span class=\"line\">    （<span class=\"number\">2</span>）每次挑选所占重量最小的物品装入是否能得到最优解？</span><br><span class=\"line\">    （<span class=\"number\">3</span>）每次选取单位重量价值最大的物品，成为解本题的策略。</span><br></pre></td></tr></table></figure>\n<p>值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。</p>\n<p>比如，求最小生成树的 <code>Prim</code>  算法和 <code>Kruskal</code>  算法都是漂亮的贪心算法。</p>\n<p>贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。</p>\n<p>可惜的是，它需要证明后才能真正运用到题目的算法中。</p>\n<p>一般来说，<strong>贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于例题中的<span class=\"number\">3</span>种贪心策略，都是无法成立（无法被证明）的，解释如下：</span><br><span class=\"line\">   （<span class=\"number\">1</span>）贪心策略：选取价值最大者。反例：</span><br><span class=\"line\">   W=<span class=\"number\">30</span></span><br><span class=\"line\">   物品：<span class=\"keyword\">A</span>     B   C</span><br><span class=\"line\">   重量：<span class=\"number\">28</span>  <span class=\"number\">12</span>  <span class=\"number\">12</span></span><br><span class=\"line\">   价值：<span class=\"number\">30</span>  <span class=\"number\">20</span>  <span class=\"number\">20</span></span><br><span class=\"line\">   根据策略，首先选取物品<span class=\"keyword\">A</span>，接下来就无法再选取了，可是，选取B、C则更好。</span><br><span class=\"line\"></span><br><span class=\"line\">   （<span class=\"number\">2</span>）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。</span><br><span class=\"line\"></span><br><span class=\"line\">   （<span class=\"number\">3</span>）贪心策略：选取单位重量价值最大的物品。反例：</span><br><span class=\"line\">   W=<span class=\"number\">30</span></span><br><span class=\"line\">   物品： <span class=\"keyword\">A</span>   B    C</span><br><span class=\"line\">   重量：<span class=\"number\">28</span>  <span class=\"number\">20</span>  <span class=\"number\">10</span></span><br><span class=\"line\">   价值：<span class=\"number\">28</span>  <span class=\"number\">20</span>  <span class=\"number\">10</span></span><br><span class=\"line\">   根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择<span class=\"keyword\">A</span>，则答案错误。</span><br></pre></td></tr></table></figure>\n<p><strong>其实该情况是符合贪心策略的</strong>，因为该总情况不管先选哪两个都会把背包塞满，因为该题物品可以分割成任意大小，所以，就算空下一下，也可以将最后一个物品分割，放进去，它们的单位重量的价值是一样的，所以，最后背包最后重量相同，重量相同那么价值也相同。</p>\n<p><strong><font color='yellow'>所以采用第三种策略，代码如下：(不是最优解)</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreedyPackage</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> MAX_WEIGHT = <span class=\"number\">150</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] weights = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">35</span>, <span class=\"number\">30</span>, <span class=\"number\">60</span>, <span class=\"number\">50</span>, <span class=\"number\">40</span>, <span class=\"number\">10</span>, <span class=\"number\">25</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] values = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">50</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">packageGreedy</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity, <span class=\"keyword\">int</span> weights[], <span class=\"keyword\">int</span>[] values)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = weights.length;<span class=\"comment\">//物品的数量</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span>[] r = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>[n];<span class=\"comment\">//性价比数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] index = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];<span class=\"comment\">//性价比排序物品的下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            r[i] = (<span class=\"keyword\">double</span>) values[i] / weights[i];</span><br><span class=\"line\">            index[i] = i;<span class=\"comment\">//默认排序</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> temp = <span class=\"number\">0</span>;<span class=\"comment\">//对性价比进行排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//降序，对性价比和对应下标进行排序</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r[i] &lt; r[j]) &#123;</span><br><span class=\"line\">                    temp = r[i];</span><br><span class=\"line\">                    r[i] = r[j];</span><br><span class=\"line\">                    r[j] = temp;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> x = index[i];</span><br><span class=\"line\">                    index[i] = index[j];</span><br><span class=\"line\">                    index[j] = x;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//排序好的重量和价值分别存到数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] w1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] v1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"comment\">//排序好的重量和价值分别存到数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            w1[i] = weights[index[i]];</span><br><span class=\"line\">            v1[i] = values[index[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//用来装物品的数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] x = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"comment\">//放入物品的最大价值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//放入物品的总重量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalweights = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//物品重量比包的总容量小，表示还可以装得下</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (w1[i] &lt; capacity) &#123;</span><br><span class=\"line\">                x[i] = <span class=\"number\">1</span>;<span class=\"comment\">//表示该物品被装了</span></span><br><span class=\"line\">                maxValue += v1[i];</span><br><span class=\"line\">                System.out.println(w1[i] + <span class=\"string\">&quot;kg的物品被放进包包,价值：&quot;</span> + v1[i]);</span><br><span class=\"line\">                totalweights += w1[i];</span><br><span class=\"line\">                capacity = capacity - w1[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;总共放入的物品数量：&quot;</span> + Arrays.toString(x));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;总共放入的物品总重量&quot;</span> + totalweights);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;放入物品的最大价值：&quot;</span> + maxValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        GreedyPackage greedyPackage = <span class=\"keyword\">new</span> GreedyPackage();</span><br><span class=\"line\">        greedyPackage.packageGreedy(greedyPackage.MAX_WEIGHT, greedyPackage.weights, greedyPackage.values);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Java面试",
                "算法"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/7474c898/",
            "url": "https://smile1231.github.io/posts/7474c898/",
            "title": "分治算法",
            "date_published": "2022-02-17T14:57:48.000Z",
            "content_html": "<h1 id=\"分治算法\"><a class=\"markdownIt-Anchor\" href=\"#分治算法\">#</a> 分治算法</h1>\n<h2 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\">#</a> 定义</h2>\n<p>将原问题划分成 <code>n</code>  个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解</p>\n<h2 id=\"分治策略\"><a class=\"markdownIt-Anchor\" href=\"#分治策略\">#</a> 分治策略</h2>\n<p>“分而治之”，大问题能够拆成相似的小问题，记住这些小问题需要具有相似性。而后将小问题的每个解合成为大问题的解。所以说大问题如何拆，小问题如何合并才是这个算法最主要的一个思想。实际上很多算法如贪心算法，动态规划等等都是要求把大问题拆成小问题。而分治算法的重要一点就是要适用于能够重新把小问题的解合并为大问题的解。</p>\n<span id=\"more\"></span>\n<h2 id=\"使用分治算法的前提条件\"><a class=\"markdownIt-Anchor\" href=\"#使用分治算法的前提条件\">#</a> 使用分治算法的前提条件</h2>\n<ul>\n<li>原问题与分解成的小问题具有相同的模式；</li>\n<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，<strong>这一点是分治算法跟动态规划的明显区别；</strong></li>\n<li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li>\n<li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了</li>\n</ul>\n<h2 id=\"每一次递归都会涉及三个操作\"><a class=\"markdownIt-Anchor\" href=\"#每一次递归都会涉及三个操作\">#</a> 每一次递归都会涉及三个操作</h2>\n<ul>\n<li><strong>分解</strong>：将原问题分解成一系列子问题；</li>\n<li><strong>解决</strong>：递归地求解各个子问题，若子问题足够小，则直接求解；</li>\n<li><strong>合并</strong>：将子问题的结果合并成原问题</li>\n</ul>\n<h2 id=\"分治法适用条件\"><a class=\"markdownIt-Anchor\" href=\"#分治法适用条件\">#</a> 分治法适用条件</h2>\n<ol>\n<li>\n<p>该问题的规模缩小到一定程度就可以很容易解决；</p>\n</li>\n<li>\n<p>该问题可以分解为若干个规模较小的相同问题，这里注意是最优子结构性质；</p>\n</li>\n<li>\n<p>利用该问题分解出的子问题的解可以合并为该问题的解；</p>\n</li>\n<li>\n<p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共子问题；</p>\n</li>\n</ol>\n<p><strong>对于很多算法而言，第一条往往是必要的，因为数据量一旦大起来，问题往往复杂度上升的特别快。这里就需要将这个大问题分解为小问题。小问题处理起来更加方便。第二、三条的才是分治思想的核心，因为很多时候我们会采用递归的方式进行解决，所以在大问题分解为小问题的时候需要保证小问题之间的相同性。单单分解为小问题之后还不能算完成，必须要能够将小问题的解合并为这个问题的最终解才能算真正用到了分治的思想。最后一条也是最关键的，各个子问题之间必须要保证独立性，即不互相影响。如果相互之间有影响，这时候我们采用的是动态规划就更加好一点。</strong></p>\n<h2 id=\"经典例题\"><a class=\"markdownIt-Anchor\" href=\"#经典例题\">#</a> 经典例题</h2>\n<p>其实算法的思想不用讲太多，能够化为几句话是最好的，下面就举几个例子来看看分治算法：</p>\n<blockquote>\n<p>例题一：二分查找，给定一个按照升序排好的数组 <code>array</code> ，要在这个数组中找出一个特定的元素 <code>x</code> ；<br>\n当我们遇到一个问题，完全可以在心里问自己下面四个问题：</p>\n</blockquote>\n<p>1、当前问题能不能切分？</p>\n<p>答：能切分，因为数组按照升序来排列。所以当 x 大于某个元素 array [mid] 时，x 一定在 array [mid] 的右边。以此再来切分。每次切一半</p>\n<p>2、分解出来的子问题相同吗？</p>\n<p>答：相同，每个子问题的数据集都是父问题的 1/2 倍。并且每次只比较子问题的中间的数据</p>\n<p>3、子问题的解能合并为父问题的解吗？</p>\n<p>答：不需要合并，子问题的解即为父问题的解。</p>\n<p>4、子问题之间相互独立吗？</p>\n<p>答：独立，子问题只是判断，不需要和父问题有很强的关联性（这里可以参考一下动态规划算法，就能理解子问题之间怎么判断是独立的）</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>分治算法只是一种思想，不是一个具体的套路，只能说在碰见具体问题时我们能够从这个思路去思考，切分问题？合并问题？子问题之间影响关联大不大？这些都是具体问题具体考虑。还有很多很多题目是用了分治算法。也可以多刷刷题</p>\n<h2 id=\"循环赛日常表\"><a class=\"markdownIt-Anchor\" href=\"#循环赛日常表\">#</a> 循环赛日常表</h2>\n<p>设有 <code>n=2^k</code>  个运动员，要进行网球循环赛。现在要设计一个满足以下要求的比赛日程表</p>\n<p>（1）每个选手必须与其他 <code>n-1</code>  个选手各赛一场</p>\n<p>（2）每个选手一天只能赛一次</p>\n<p>（3）循环赛一共进行 <code>n-1</code>  天</p>\n<p>将比赛日程表设计成 <code>n</code>  行 <code>n</code>  列，表中除了第一列，其他 <code>n-1</code>  列才是我们要的，数组下标行列都从 <code>0</code>  开始，第 i 行 j 列代表第 <code>（i+1）</code> 位选手在第 j 天的对手：</p>\n<img data-src=\"/posts/7474c898/2022-02-17-23-08-53.png\" class=\"\">\n<p>以 8 个选手为例子</p>\n<img data-src=\"/posts/7474c898/2022-02-17-23-09-01.png\" class=\"\">\n<p>①我们先初始化第一行各个数为 <code>1~8</code> （ <code>2~8</code>  为：第 <code>1</code>  天 — 第 <code>7</code>  天）；</p>\n<p>②因为是递归，那么要填 8x8 的左下角和右下角，分别需要知道它的右上角和左上角</p>\n<p>③而 <code>8x8</code>  的盒子它的左上角是一个 <code>4x4</code>  的盒子，要填 <code>4x4</code>  的左下角和右下角，也分别需要知道它的右上角和左上角</p>\n<p>④现在递归到 <code>4x4</code>  的盒子的左上角，是一个 <code>2x2</code>  的盒子，它不需要递归了，直接沿对角线填左下角和右下角的数字，也就是上面的图②</p>\n<p>⑤可以看到，经过上面的②③步，我们左上角 4x4 的盒子，它的・右上角和左上角已经知道了，那就可以沿对角线填它的左下角和右下角了，所以出现了图④</p>\n<p>⑥其他的依次类推</p>\n<p>通俗易懂地讲，就是<strong>如果你想填一个大的，你得先得出它左上角和右上角两个盒子 ， 再沿对角线分别抄到右下角和左下角。 而为了得出它左上角和右上角，就需要递归了</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SportsSchedule</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleTable</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] table, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            table[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 填充左上区域矩阵</span></span><br><span class=\"line\"><span class=\"comment\">            n值的变化：8  4  2  1</span></span><br><span class=\"line\"><span class=\"comment\">            m值的变化：4  2  1  1  */</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = n / <span class=\"number\">2</span>;</span><br><span class=\"line\">            scheduleTable(table, m);</span><br><span class=\"line\">            <span class=\"comment\">//填充右上区域矩阵</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = m; j &lt; n; j++) &#123;</span><br><span class=\"line\">                    table[i][j] = table[i][j - m] + m;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//填充左下区域矩阵</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                    table[i][j] = table[i - m][j] + m;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//填充右下区域矩阵</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = m; j &lt; n; j++) &#123;</span><br><span class=\"line\">                    table[i][j] = table[i - m][j - m];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] table = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">8</span>][<span class=\"number\">8</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">8</span>;</span><br><span class=\"line\">        SportsSchedule schedule = <span class=\"keyword\">new</span> SportsSchedule();</span><br><span class=\"line\">        schedule.scheduleTable(table, n);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//打印二维数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                System.out.print(table[i][j] + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">                c++;<span class=\"comment\">//每打印一个数，c++</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c % n == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//说明打印一行了</span></span><br><span class=\"line\">                    System.out.println();<span class=\"comment\">//换行</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"l型骨牌棋盘覆盖\"><a class=\"markdownIt-Anchor\" href=\"#l型骨牌棋盘覆盖\">#</a>  <code>L</code>  型骨牌棋盘覆盖</h2>\n<h3 id=\"问题描述\"><a class=\"markdownIt-Anchor\" href=\"#问题描述\">#</a> 问题描述</h3>\n<p>在一个 <code>2^k×2^k </code> 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格（特殊点），且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的 4 种不同形态的 L 型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何 <code>2</code>  个 <code>L</code>  型骨牌不得重叠覆盖。</p>\n<img data-src=\"/posts/7474c898/2022-02-17-23-09-17.png\" class=\"\">\n<h3 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h3>\n<blockquote>\n<p>分析</p>\n</blockquote>\n<p>当 <code>k&gt;0</code>  时，将 <code>2^k×2^k</code>  棋盘分割为 <code>4</code>  个 <code>2^k-1×2^k-1</code>  子棋盘 <code>(a)</code>  所示。特殊方格必位于 <code>4</code>  个较小子棋盘之一中，其余 <code>3</code>  个子棋盘中无特殊方格。为了将这 <code>3</code>  个无特殊方格的子棋盘转化为特殊棋盘，可以用一个 <code>L</code>  型骨牌覆盖这 <code>3</code>  个较小棋盘的会合处，如  <code>(b)</code>  所示，从而将原问题转化为 <code>4</code>  个较小规模的棋盘覆盖问题。递归地使用这种分割，直至棋盘简化为棋盘 <code>1×1</code> 。</p>\n<img data-src=\"/posts/7474c898/2022-02-17-23-09-30.png\" class=\"\">\n<blockquote>\n<p>实现：</p>\n</blockquote>\n<p>每次都对分割后的四个小方块进行判断，判断特殊方格是否在里面。这里的判断的方法是每次先记录下整个大方块的左上角方格的行列坐标，然后再与特殊方格坐标进行比较，就可以知道特殊方格是否在该块中。如果特殊方块在里面，这直接递归下去求即可，如果不在，这根据分割的四个方块的不同位置，把右下角、左下角、右上角或者左上角的方格标记为特殊方块，然后继续递归。在递归函数里，还要有一个变量 subSize 来记录边的方格数，每次对方块进行划分时，边的方格数都会减半，这个变量是为了方便判断特殊方格的位置。</p>\n<blockquote>\n<p>覆盖步骤如图：</p>\n</blockquote>\n<img data-src=\"/posts/7474c898/2022-02-17-23-09-51.png\" class=\"\">\n<blockquote>\n<p>代码实现:</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cn.itcast.recursion;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessBoradProblem</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[][] board;<span class=\"comment\">//棋盘</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> specialRow;<span class=\"comment\">//特殊点行下标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> specialCol;<span class=\"comment\">//特殊点列下标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;<span class=\"comment\">//矩阵大小</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> type = <span class=\"number\">0</span>;<span class=\"comment\">//骨牌类型，1,2,3,4  因为是用数字表示的，所以用int</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChessBoradProblem</span><span class=\"params\">(<span class=\"keyword\">int</span> specialRow, <span class=\"keyword\">int</span> specialCol, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.specialRow = specialRow;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.specialCol = specialCol;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">        board = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[size][size];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> specialRow 特殊点的行下标</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> specialCol 特殊点的列下标</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leftRow    分割成4个后每个矩阵的左边的起点行下标</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leftCol    分割成4个后每个矩阵的左边起点列下标</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> size       矩阵的宽或者高</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//相对于四个方格中右上的方格，左边起点的leftRow不一定是0了</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ChessBoard</span><span class=\"params\">(<span class=\"keyword\">int</span> specialRow, <span class=\"keyword\">int</span> specialCol, <span class=\"keyword\">int</span> leftRow, <span class=\"keyword\">int</span> leftCol, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> subSize = size / <span class=\"number\">2</span>;</span><br><span class=\"line\">        type = type % <span class=\"number\">4</span> + <span class=\"number\">1</span>;<span class=\"comment\">//不断+1，超过4就取模</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = type;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//假设特殊点在左上角，然后行和列都小于一半</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specialRow &lt; leftRow + subSize &amp;&amp; specialCol &lt; leftCol + subSize) &#123;</span><br><span class=\"line\">            ChessBoard(specialRow, specialCol, leftRow, leftCol, subSize);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//不在左上角，左上角矩阵的右下角就是特殊点</span></span><br><span class=\"line\">            board[leftRow + subSize - <span class=\"number\">1</span>][leftCol + subSize - <span class=\"number\">1</span>] = n;</span><br><span class=\"line\">            ChessBoard(leftRow + subSize - <span class=\"number\">1</span>, leftRow + subSize - <span class=\"number\">1</span>, leftRow, leftCol, subSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//特殊点在右上方，行小于一半，列大于一半</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specialRow &lt; leftRow + subSize &amp;&amp; specialCol &gt;= leftCol + subSize) &#123;</span><br><span class=\"line\">            ChessBoard(specialRow, specialCol, leftRow, leftCol + subSize, subSize);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            board[leftRow + subSize - <span class=\"number\">1</span>][leftCol + subSize] = n;</span><br><span class=\"line\">            ChessBoard(leftRow + subSize - <span class=\"number\">1</span>, leftCol + subSize, leftRow, leftCol + subSize, subSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//特殊点在左下方</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specialRow &gt;= leftRow + subSize &amp;&amp; specialCol &lt; leftCol + subSize) &#123;</span><br><span class=\"line\">            ChessBoard(specialRow, specialCol, leftRow + subSize, leftCol, subSize);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            board[leftRow + subSize][leftCol + subSize - <span class=\"number\">1</span>] = n;</span><br><span class=\"line\">            ChessBoard(leftRow + subSize, leftCol + subSize - <span class=\"number\">1</span>, leftRow + subSize, leftCol, subSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//特殊点在右下方</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specialRow &gt;= leftRow + subSize &amp;&amp; specialCol &gt;= leftCol + subSize) &#123;</span><br><span class=\"line\">            ChessBoard(specialRow, specialCol, leftRow + subSize, leftCol + subSize, subSize);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            board[leftRow + subSize][leftCol + subSize] = n;</span><br><span class=\"line\">            ChessBoard(leftRow + subSize, leftCol + subSize, leftRow + subSize, leftCol + subSize, subSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printBoard</span><span class=\"params\">(<span class=\"keyword\">int</span> specialRow, <span class=\"keyword\">int</span> specialCol, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        ChessBoard(specialRow, specialCol, <span class=\"number\">0</span>, <span class=\"number\">0</span>, size);</span><br><span class=\"line\">        printResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">printResult</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; size; j++) &#123;</span><br><span class=\"line\">                System.out.print(board[i][j] + <span class=\"string\">&quot; &quot;</span>);<span class=\"comment\">//注意：print</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = <span class=\"number\">4</span>;<span class=\"comment\">//矩阵大小</span></span><br><span class=\"line\">        <span class=\"comment\">//选取特殊点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> specialRow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specialCol = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ChessBoradProblem boradProblem = <span class=\"keyword\">new</span> ChessBoradProblem(specialRow, specialCol, N);</span><br><span class=\"line\">        boradProblem.printBoard(specialRow, specialCol, N);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Java面试",
                "算法"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/b9b9f7e7/",
            "url": "https://smile1231.github.io/posts/b9b9f7e7/",
            "title": "二叉树遍历",
            "date_published": "2022-02-17T14:52:52.000Z",
            "content_html": "<h1 id=\"二叉树遍历前序-中序-后序-层次遍历\"><a class=\"markdownIt-Anchor\" href=\"#二叉树遍历前序-中序-后序-层次遍历\">#</a> 二叉树遍历（前序、中序、后序、层次遍历）</h1>\n<p>二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆了。所以，对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。</p>\n<p>四种主要的遍历思想为：</p>\n<span id=\"more\"></span>\n<p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p>\n<p>中序遍历：左子树 —&gt; 根结点 —&gt; 右子树</p>\n<p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p>\n<p>层次遍历：只需按层次遍历即可</p>\n<p>例如，求下面二叉树的各种遍历</p>\n<img data-src=\"/posts/b9b9f7e7/2022-02-17-22-57-21.png\" class=\"\">\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">前序遍历：1 <span class=\"number\"> 2 </span><span class=\"number\"> 4 </span><span class=\"number\"> 5 </span><span class=\"number\"> 7 </span><span class=\"number\"> 8 </span><span class=\"number\"> 3 </span><span class=\"number\"> 6 </span></span><br><span class=\"line\"></span><br><span class=\"line\">中序遍历：4 <span class=\"number\"> 2 </span><span class=\"number\"> 7 </span><span class=\"number\"> 5 </span><span class=\"number\"> 8 </span><span class=\"number\"> 1 </span><span class=\"number\"> 3 </span> 6</span><br><span class=\"line\"></span><br><span class=\"line\">后序遍历：4 <span class=\"number\"> 7 </span><span class=\"number\"> 8 </span><span class=\"number\"> 5 </span><span class=\"number\"> 2 </span><span class=\"number\"> 6 </span><span class=\"number\"> 3 </span> 1</span><br><span class=\"line\"></span><br><span class=\"line\">层次遍历：1 <span class=\"number\"> 2 </span><span class=\"number\"> 3 </span><span class=\"number\"> 4 </span><span class=\"number\"> 5 </span><span class=\"number\"> 6 </span><span class=\"number\"> 7 </span> 8</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-前序遍历\"><a class=\"markdownIt-Anchor\" href=\"#1-前序遍历\">#</a> 1. 前序遍历</h2>\n<ol>\n<li>\n<p>根据上文提到的遍历思路， <code>根结点 ---&gt; 左子树 ---&gt; 右子树</code> ，很容易写出递归版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrderTraverse1</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tSystem.out.print(root.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t\tpreOrderTraverse1(root.left);</span><br><span class=\"line\">\t\tpreOrderTraverse1(root.right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>现在讨论非递归的版本：</p>\n<p>根据前序遍历的顺序，优先访问根结点，然后在访问左子树和右子树。所以，对于任意结点 <code>node</code> ，第一部分即直接访问之，之后在判断左子树是否为空，不为空时即重复上面的步骤，直到其为空。若为空，则需要访问右子树。注意，在访问过左孩子之后，需要反过来访问其右孩子，所以，需要<strong>栈</strong>这种数据结构的支持。对于任意一个结点 <code>node</code> ，具体步骤如下：</p>\n<p>a) 访问之，并把结点 <code>node</code>  入栈，当前结点置为左孩子；</p>\n<p>b) 判断结点 <code>node</code>  是否为空，若为空，则取出栈顶结点并出栈，将右孩子置为当前结点；否则重复 <code>a)</code>  步直到当前结点为空或者栈为空（可以发现栈中的结点就是为了访问右孩子才存储的）</p>\n<p>代码如下:</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrderTraverse2</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\tLinkedList&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">\tTreeNode pNode = root;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pNode != <span class=\"keyword\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.print(pNode.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t\t\tstack.push(pNode);</span><br><span class=\"line\">\t\t\tpNode = pNode.left;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class=\"line\">\t\t\tTreeNode node = stack.pop();</span><br><span class=\"line\">\t\t\tpNode = node.right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"2-中序遍历\"><a class=\"markdownIt-Anchor\" href=\"#2-中序遍历\">#</a> 2. 中序遍历</h2>\n<ol>\n<li>根据上文提到的遍历思路： <code>左子树 ---&gt; 根结点 ---&gt; 右子树</code> ，很容易写出递归版本： <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrderTraverse1</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tinOrderTraverse1(root.left);</span><br><span class=\"line\">\t\tSystem.out.print(root.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t\tinOrderTraverse1(root.right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>非递归实现，有了上面前序的解释，中序也就比较简单了，相同的道理。只不过访问的顺序移到出栈时。代码如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrderTraverse2</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\tLinkedList&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">\tTreeNode pNode = root;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pNode != <span class=\"keyword\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tstack.push(pNode);</span><br><span class=\"line\">\t\t\tpNode = pNode.left;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class=\"line\">\t\t\tTreeNode node = stack.pop();</span><br><span class=\"line\">\t\t\tSystem.out.print(node.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t\t\tpNode = node.right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"3-后续遍历\"><a class=\"markdownIt-Anchor\" href=\"#3-后续遍历\">#</a> 3. 后续遍历</h2>\n<ol>\n<li>根据上文提到的遍历思路： <code>左子树 ---&gt; 右子树 ---&gt; 根结点</code> ，很容易写出递归版本： <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postOrderTraverse1</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tpostOrderTraverse1(root.left);</span><br><span class=\"line\">\t\tpostOrderTraverse1(root.right);</span><br><span class=\"line\">\t\tSystem.out.print(root.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"4-层次遍历\"><a class=\"markdownIt-Anchor\" href=\"#4-层次遍历\">#</a> 4. 层次遍历</h2>\n<p>层次遍历的代码比较简单，只需要一个队列即可，先在队列中加入根结点。之后对于任意一个结点来说，在其出队列的时候，访问之。同时如果左孩子和右孩子有不为空的，入队列。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">levelTraverse</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LinkedList&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    queue.offer(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode node = queue.poll();</span><br><span class=\"line\">        System.out.print(node.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            queue.offer(node.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            queue.offer(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二叉树的深度优先遍历dfs与广度优先遍历bfs\"><a class=\"markdownIt-Anchor\" href=\"#二叉树的深度优先遍历dfs与广度优先遍历bfs\">#</a> 二叉树的深度优先遍历（ <code>DFS</code> ）与广度优先遍历（ <code>BFS</code> ）</h1>\n<p>二叉树的深度优先遍历（ <code>DFS</code> ）与广度优先遍历（ <code>BFS</code> ）</p>\n<ul>\n<li>\n<p><strong>深度优先遍历</strong>：从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点为止。</p>\n</li>\n<li>\n<p><strong>广度优先遍历</strong>：从根节点出发，在横向遍历二叉树层段节点的基础上纵向遍历二叉树的层次。</p>\n</li>\n</ul>\n<img data-src=\"/posts/b9b9f7e7/2022-02-17-23-00-13.png\" class=\"\">\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">DFS:</span>ABDECFG</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">BFS:</span>ABCDEFG</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><code>DFS</code>  实现：</p>\n<p>数据结构：栈</p>\n<p>父节点入栈，父节点出栈，先右子节点入栈，后左子节点入栈。递归遍历全部节点即可</p>\n</li>\n<li>\n<p><code>BFS</code>  实现：</p>\n<p>数据结构：队列</p>\n<p>父节点入队，父节点出队列，先左子节点入队，后右子节点入队。递归遍历全部节点即可</p>\n</li>\n</ul>\n<img data-src=\"/posts/b9b9f7e7/2022-02-17-23-00-38.png\" class=\"\">\n<p>深度优先搜索的步骤为：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）、首先节点<span class=\"number\"> 1 </span>进栈，节点1在栈顶；</span><br><span class=\"line\"></span><br><span class=\"line\">（2）、然后节点1出栈，访问节点1，节点1的孩子节点3进栈，节点2进栈；</span><br><span class=\"line\"></span><br><span class=\"line\">（3）、节点2在栈顶，然后节点2出栈，访问节点2</span><br><span class=\"line\"></span><br><span class=\"line\">（4）、节点2的孩子节点5进栈，节点4进栈</span><br><span class=\"line\"></span><br><span class=\"line\">（5）、节点4在栈顶，节点4出栈，访问节点4，</span><br><span class=\"line\"></span><br><span class=\"line\">（6）、节点4左右孩子为空，然后节点5在栈顶，节点5出栈，访问节点5；</span><br><span class=\"line\"></span><br><span class=\"line\">（7）、节点5左右孩子为空，然后节点3在站顶，节点3出栈，访问节点3；</span><br><span class=\"line\"></span><br><span class=\"line\">（8）、节点3的孩子节点7进栈，节点6进栈</span><br><span class=\"line\"></span><br><span class=\"line\">（9）、节点6在栈顶，节点6出栈，访问节点6；</span><br><span class=\"line\"></span><br><span class=\"line\">（10）、节点6的孩子为空，这个时候节点7在栈顶，节点7出栈，访问节点7</span><br><span class=\"line\"></span><br><span class=\"line\">（11）、节点7的左右孩子为空，此时栈为空，遍历结束。</span><br></pre></td></tr></table></figure>\n<p>广度优先遍历：广度优先遍历是连通图的一种遍历策略，因为它的思想是从一个顶点 V0 开始，辐射状地优先遍历其周围较广的区域故得名。</p>\n<p>根据广度优先遍历的特点我们利用 Java 数据结构队列 Queue 来实现。</p>\n<p>广度优先搜索的步骤为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）、节点1进队，节点1出队，访问节点1</span><br><span class=\"line\"></span><br><span class=\"line\">（2）、节点1的孩子节点2进队，节点3进队。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）、节点2出队，访问节点2，节点2的孩子节点4进队，节点5进队；</span><br><span class=\"line\"></span><br><span class=\"line\">（4）、节点3出队，访问节点3，节点3的孩子节点6进队，节点7进队；</span><br><span class=\"line\"></span><br><span class=\"line\">（5）、节点4出队，访问节点4，节点4没有孩子节点。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）、节点5出队，访问节点5，节点5没有孩子节点。</span><br><span class=\"line\"></span><br><span class=\"line\">（7）、节点6出队，访问节点6，节点6没有孩子节点。</span><br><span class=\"line\"></span><br><span class=\"line\">（8）、节点7出队，访问节点7，节点7没有孩子节点，结束。</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-深度优先遍历\"><a class=\"markdownIt-Anchor\" href=\"#5-深度优先遍历\">#</a> 5. 深度优先遍历</h2>\n<p>其实深度遍历就是上面的前序、中序和后序。但是为了保证与广度优先遍历相照应，也写在这。代码也比较好理解，其实就是前序遍历，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">depthOrderTraverse</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LinkedList&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode node = stack.pop();</span><br><span class=\"line\">        System.out.print(node.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            stack.push(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            stack.push(node.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-广度优先遍历\"><a class=\"markdownIt-Anchor\" href=\"#6-广度优先遍历\">#</a> 6. 广度优先遍历</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">depthFirstSearch</span><span class=\"params\">(TreeNode nodeHead)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nodeHead==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; myStack=<span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    myStack.add(nodeHead);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!myStack.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode node=myStack.pop();    <span class=\"comment\">//弹出栈顶元素</span></span><br><span class=\"line\">        System.out.print(node.data+<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node.rightNode!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            myStack.push(node.rightNode);    <span class=\"comment\">//深度优先遍历，先遍历左边，后遍历右边,栈先进后出</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node.leftNode!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            myStack.push(node.leftNode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Java面试",
                "算法"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/e8eb0481/",
            "url": "https://smile1231.github.io/posts/e8eb0481/",
            "title": "二分查找",
            "date_published": "2022-02-16T13:06:36.000Z",
            "content_html": "<h1 id=\"二分查找\"><a class=\"markdownIt-Anchor\" href=\"#二分查找\">#</a> 二分查找</h1>\n<p>二分查找（ <code>binary search</code> ），也称作折半查找（ <code>half-interval search</code> ），每次划分一半进行下一步搜索，所以时间复杂度无非就是 <code>while</code>  循环的次数！</p>\n<span id=\"more\"></span>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//二分查找 Java 实现 （升序数组）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(Integer[] srcArray, <span class=\"keyword\">int</span> des)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> high = srcArray.length - <span class=\"number\">1</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((low &lt;= high) &amp;&amp; (low &lt;= srcArray.length - <span class=\"number\">1</span>)</span><br><span class=\"line\">            &amp;&amp; (high &lt;= srcArray.length - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// &gt;&gt; 右移符号 表示除以 2</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> middle = (high + low) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (des == srcArray[middle]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> middle;</span><br><span class=\"line\">        <span class=\"comment\">// 如果要查找的值 小于最中间的值 就算选择 左边的区间</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (des &lt; srcArray[middle]) &#123;</span><br><span class=\"line\">            high = middle - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            low = middle + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度\">#</a> 时间复杂度</h2>\n<p>比如：总共有 <code>n</code>  个元素，每次查找的区间大小就是 <code>n，n/2，n/4，…，n/2^k</code> （接下来操作元素的剩余个数），其中 <code>k</code>  就是循环的次数。<br>\n由于 <code>n/2^k</code>  取整后 <code>&gt;=1</code> ，即令 <code>n/2^k=1</code> ，<br>\n可得 <code>k=log2n</code> ,（是以 <code>2</code>  为底， <code>n</code>  的对数），所以时间复杂度可以表示 <code>O()=O(log2n)</code></p>\n<h2 id=\"二分查找的缺点\"><a class=\"markdownIt-Anchor\" href=\"#二分查找的缺点\">#</a> 二分查找的缺点</h2>\n<p>虽然二分查找的效率高，但是要将表按关键字排序。而排序本身是一种很费时的运算。既使采用高效率的排序方法也要花费 <code>O(nlgn)</code>  的时间。</p>\n<p>二分查找只适用顺序存储结构。为保持表的有序性，在顺序结构里插入和删除都必须移动大量的结点。因此，二分查找特别适用于那种一经建立就很少改动、而又经常需要查找的线性表。</p>\n<p>对那些查找少而又经常需要改动的线性表，可采用链表作存储结构，进行顺序查找。链表上无法实现二分查找。</p>\n",
            "tags": [
                "Java面试",
                "算法",
                "二分查找"
            ]
        }
    ]
}
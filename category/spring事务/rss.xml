<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>JIN MAO &#39;s Blog • Posts by &#34;spring事务&#34; category</title>
        <link>https://smile1231.github.io</link>
        <description></description>
        <language>en</language>
        <pubDate>Wed, 16 Feb 2022 21:14:23 +0800</pubDate>
        <lastBuildDate>Wed, 16 Feb 2022 21:14:23 +0800</lastBuildDate>
        <category>SAP</category>
        <category>生物信息</category>
        <category>基因编辑</category>
        <category>Java</category>
        <category>Cache</category>
        <category>Cookie</category>
        <category>Session</category>
        <category>Java面试</category>
        <category>Corn</category>
        <category>前端</category>
        <category>Css</category>
        <category>DDD</category>
        <category>领域驱动设计</category>
        <category>FastJson</category>
        <category>Docker</category>
        <category>DisPlay属性</category>
        <category>blog</category>
        <category>hexo</category>
        <category>next</category>
        <category>IDEA</category>
        <category>SpringBoot</category>
        <category>JavaScript</category>
        <category>Html</category>
        <category>Jvm</category>
        <category>函数式接口</category>
        <category>map</category>
        <category>Stream流</category>
        <category>Assert</category>
        <category>java</category>
        <category>calender</category>
        <category>Springboot</category>
        <category>Python</category>
        <category>Jupyter</category>
        <category>Machine Learning</category>
        <category>LeetCode</category>
        <category>算法</category>
        <category>递归</category>
        <category>Linux</category>
        <category>numpy</category>
        <category>pandas</category>
        <category>sklearn</category>
        <category>Mybatis</category>
        <category>分页查询</category>
        <category>模糊查询</category>
        <category>Nginx</category>
        <category>Spring</category>
        <category>SrpingBoot</category>
        <category>文件上传</category>
        <category>事务</category>
        <category>TypeScript</category>
        <category>WebPack</category>
        <category>master</category>
        <category>Jenkins</category>
        <category>Groovy</category>
        <category>UML</category>
        <category>VsCode</category>
        <category>Shell</category>
        <category>Ubuntu</category>
        <category>Mysql</category>
        <category>VSCODE</category>
        <category>快捷键</category>
        <category>Vue</category>
        <category>Stream</category>
        <category>日期</category>
        <category>线程池</category>
        <category>ubuntu</category>
        <category>虚拟机</category>
        <category>二分查找</category>
        <category>Hadoop</category>
        <category>数据挖掘</category>
        <category>操作系统</category>
        <category>EasyExcel</category>
        <category>node</category>
        <category>JVM</category>
        <category>Yaml</category>
        <category>Hexo</category>
        <category>数据库</category>
        <category>junit</category>
        <category>Mysql事务</category>
        <category>git,npm,node</category>
        <category>Git</category>
        <category>冒泡排序</category>
        <category>堆排序</category>
        <category>动态规划</category>
        <category>幂等性</category>
        <category>多线程</category>
        <category>Google</category>
        <category>流</category>
        <category>归并排序</category>
        <category>快速排序</category>
        <category>正则表达式</category>
        <category>直接插入排序</category>
        <category>选择排序</category>
        <category>Java 面试</category>
        <category>数据结构</category>
        <category>阻塞队列</category>
        <category>Spring事务</category>
        <category>JDK</category>
        <category>动态代理</category>
        <category>Date</category>
        <category>ArrayList</category>
        <category>接口</category>
        <category>SpringMvc</category>
        <category>排序</category>
        <category>执行计划</category>
        <category>HashMap</category>
        <category>设计模式</category>
        <category>cheatsheet</category>
        <item>
            <guid isPermalink="true">https://smile1231.github.io/posts/7e4601e3/</guid>
            <title>面试之旅之关于Spring事务处理</title>
            <link>https://smile1231.github.io/posts/7e4601e3/</link>
            <category>Java面试</category>
            <category>Spring事务</category>
            <pubDate>Wed, 16 Feb 2022 21:14:23 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;spring事务处理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring事务处理&#34;&gt;#&lt;/a&gt;  &lt;code&gt;Spring&lt;/code&gt;  事务处理&lt;/h1&gt;
&lt;h2 id=&#34;spring和事务的关系&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring和事务的关系&#34;&gt;#&lt;/a&gt;  &lt;code&gt;Spring&lt;/code&gt;  和事务的关系&lt;/h2&gt;
&lt;p&gt;关系型数据库、某些消息队列等产品或中间件称为事务性资源，因为它们本身支持事务，也能够处理事务。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;  很显然不是事务性资源，但是它可以管理事务性资源，所以 &lt;code&gt;Spring&lt;/code&gt;  和事务之间是管理关系。&lt;/p&gt;
&lt;p&gt;就像 &lt;code&gt;Jack Ma&lt;/code&gt;  虽然不会写代码，但是他却管理者一大批会写代码的码农。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h2 id=&#34;spring事务三要素&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring事务三要素&#34;&gt;#&lt;/a&gt;  &lt;code&gt;Spring&lt;/code&gt;  事务三要素&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据源：表示具体的事务性资源，是事务的真正处理者，如 &lt;code&gt;MySQL&lt;/code&gt;  等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务管理器：像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务应用和属性配置：像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属性如隔离级别、超时时间等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;spring事务的注解配置&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring事务的注解配置&#34;&gt;#&lt;/a&gt;  &lt;code&gt;Spring&lt;/code&gt;  事务的注解配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;把一个 &lt;code&gt;DataSource（如DruidDataSource）&lt;/code&gt; 作为一个 &lt;code&gt;@Bean&lt;/code&gt;  注册到 &lt;code&gt;Spring&lt;/code&gt;  容器中，配置好事务性资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把一个 &lt;code&gt;@EnableTransactionManagement&lt;/code&gt;  注解放到一个 &lt;code&gt;@Configuration&lt;/code&gt;  类上，配置好事务管理器，并启用事务管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把一个 &lt;code&gt;@Transactional&lt;/code&gt;  注解放到类上或方法上，可以设置注解的属性，表明该方法按配置好的属性参与到事务中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;事务注解的本质&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务注解的本质&#34;&gt;#&lt;/a&gt; 事务注解的本质&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Transactional&lt;/code&gt;  这个注解仅仅是一些（和事务相关的）元数据，在运行时被事务基础设施读取消费，并使用这些元数据来配置 &lt;code&gt;bean&lt;/code&gt;  的事务行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大致来说具有两方面功能，一是表明该方法要参与事务，二是配置相关属性来定制事务的参与方式和运行行为。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;spring声明式事务实现原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring声明式事务实现原理&#34;&gt;#&lt;/a&gt;  &lt;code&gt;Spring&lt;/code&gt;  声明式事务实现原理&lt;/h2&gt;
&lt;p&gt;声明式事务成为可能，主要得益于 &lt;code&gt;Spring AOP&lt;/code&gt; 。使用一个事务拦截器，在方法调用的前后 / 周围进行事务性增强（ &lt;code&gt;advice&lt;/code&gt; ），来驱动事务完成。&lt;/p&gt;
&lt;h2 id=&#34;如何回滚一个事务&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#如何回滚一个事务&#34;&gt;#&lt;/a&gt; 如何回滚一个事务&lt;/h2&gt;
&lt;p&gt;就是在一个事务上下文中当前正在执行的代码里抛出一个异常，事务基础设施代码会捕获任何未处理的异常，并且做出决定是否标记这个事务为回滚。&lt;/p&gt;
&lt;h2 id=&#34;默认回滚规则&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#默认回滚规则&#34;&gt;#&lt;/a&gt; 默认回滚规则&lt;/h2&gt;
&lt;p&gt;默认只把 &lt;code&gt;runtime&lt;/code&gt; ,  &lt;code&gt;unchecked exceptions&lt;/code&gt;  标记为回滚，即 &lt;code&gt;RuntimeException&lt;/code&gt;  及其子类， &lt;code&gt;Error&lt;/code&gt;  默认也导致回滚。 &lt;code&gt;Checked exceptions&lt;/code&gt;  默认不导致回滚。这些规则和 &lt;code&gt;EJB&lt;/code&gt;  是一样的。&lt;/p&gt;
&lt;h2 id=&#34;如何配置回滚异常&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#如何配置回滚异常&#34;&gt;#&lt;/a&gt; 如何配置回滚异常&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;@Transactional&lt;/code&gt;  注解的 &lt;code&gt;rollbackFor/rollbackForClassName&lt;/code&gt;  属性，可以精确配置导致回滚的异常类型，包括 &lt;code&gt;checked exceptions&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;noRollbackFor/noRollbackForClassName&lt;/code&gt;  属性，可以配置不导致回滚的异常类型，当遇到这样的未处理异常时，照样提交相关事务。&lt;/p&gt;
&lt;h2 id=&#34;事务注解在类方法上&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务注解在类方法上&#34;&gt;#&lt;/a&gt; 事务注解在类 / 方法上&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;@Transactional&lt;/code&gt;  注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的所有方法。如果此时方法上也标注了，则方法上的优先级高。&lt;/p&gt;
&lt;h2 id=&#34;事务注解在类上的继承性&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务注解在类上的继承性&#34;&gt;#&lt;/a&gt; 事务注解在类上的继承性&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;@Transactional&lt;/code&gt;  注解的作用可以传播到子类，即如果父类标了子类就不用标了。但倒过来就不行了。&lt;/p&gt;
&lt;p&gt;子类标了，并不会传到父类，所以父类方法不会有事务。父类方法需要在子类中重新声明而参与到子类上的注解，这样才会有事务。&lt;/p&gt;
&lt;h2 id=&#34;事务注解在接口类上&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务注解在接口类上&#34;&gt;#&lt;/a&gt; 事务注解在接口 / 类上&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;@Transactional&lt;/code&gt;  注解可以用在接口上，也可以在类上。在接口上时，必须使用基于接口的代理才行，即 &lt;code&gt;JDK&lt;/code&gt;  动态代理。&lt;/p&gt;
&lt;p&gt;事实是 &lt;code&gt;Java&lt;/code&gt;  的注解不能从接口继承，如果你使用基于类的代理，即 &lt;code&gt;CGLIB&lt;/code&gt; ，或基于织入方面，即 &lt;code&gt;AspectJ&lt;/code&gt; ，事务设置不会被代理和织入基础设施认出来，目标对象不会被包装到一个事务代理中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;  团队建议注解标注在类上而非接口上。&lt;/p&gt;
&lt;h2 id=&#34;只在public方法上生效&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#只在public方法上生效&#34;&gt;#&lt;/a&gt; 只在 &lt;code&gt;public&lt;/code&gt;  方法上生效？&lt;/h2&gt;
&lt;p&gt;当采用代理来实现事务时，（注意是代理）， &lt;code&gt;@Transactional&lt;/code&gt;  注解只能应用在 &lt;code&gt;public&lt;/code&gt;  方法上。当标记在 &lt;code&gt;protected、private、package-visible&lt;/code&gt;  方法上时，不会产生错误，但也不会表现出为它指定的事务配置。可以认为它作为一个普通的方法参与到一个 &lt;code&gt;public&lt;/code&gt;  方法的事务中。&lt;/p&gt;
&lt;p&gt;如果想在非 &lt;code&gt;public&lt;/code&gt;  方法上生效，考虑使用 &lt;code&gt;AspectJ（织入方式）&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;目标类里的自我调用没有事务&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#目标类里的自我调用没有事务&#34;&gt;#&lt;/a&gt; 目标类里的自我调用没有事务？&lt;/h2&gt;
&lt;p&gt;在代理模式中（这是默认的），只有从外部的方法调用进入通过代理会被拦截，这意味着自我调用（实际就是，目标对象中的一个方法调用目标对象的另一个方法）在运行时不会导致一个实际的事务，即使被调用的方法标有注解。&lt;/p&gt;
&lt;p&gt;如果你希望自我调用也使用事务来包装，考虑使用 &lt;code&gt;AspectJ&lt;/code&gt;  的方式。在这种情况下，首先是没有代理。相反，目标类被织入（即它的字节码被修改）来把 &lt;code&gt;@Transactional&lt;/code&gt;  加入到运行时行为，在任何种类的方法上都可以。&lt;/p&gt;
&lt;h2 id=&#34;事务与线程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务与线程&#34;&gt;#&lt;/a&gt; 事务与线程&lt;/h2&gt;
&lt;p&gt;和 &lt;code&gt;JavaEE&lt;/code&gt;  事务上下文一样， &lt;code&gt;Spring&lt;/code&gt;  事务和一个线程的执行相关联，底层是一个 &lt;code&gt;ThreadLocal&amp;lt;Map&amp;lt;Object, Object&amp;gt;&amp;gt;&lt;/code&gt; ，就是每个线程一个 &lt;code&gt;map&lt;/code&gt; ， &lt;code&gt;key&lt;/code&gt;  是 &lt;code&gt;DataSource&lt;/code&gt; ， &lt;code&gt;value&lt;/code&gt;  是 &lt;code&gt;Connection&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;逻辑事务与物理事务&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#逻辑事务与物理事务&#34;&gt;#&lt;/a&gt; 逻辑事务与物理事务&lt;/h2&gt;
&lt;p&gt;事务性资源实际打开的事务就是物理事务，如数据库的 &lt;code&gt;Connection&lt;/code&gt;  打开的事务。 &lt;code&gt;Spring&lt;/code&gt;  会为每个 &lt;code&gt;@Transactional&lt;/code&gt;  方法创建一个事务范围，可以理解为是逻辑事务。&lt;/p&gt;
&lt;p&gt;在逻辑事务中，大范围的事务称为外围事务，小范围的事务称为内部事务，外围事务可以包含内部事务，但在逻辑上是互相独立的。每一个这样的逻辑事务范围，都能够单独地决定 &lt;code&gt;rollback-only&lt;/code&gt;  状态。&lt;/p&gt;
&lt;p&gt;那么如何处理逻辑事务和物理事务之间的关联关系呢，这就是传播特性解决的问题。&lt;/p&gt;
&lt;h2 id=&#34;事务传播行为&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务传播行为&#34;&gt;#&lt;/a&gt; 事务传播行为&lt;/h2&gt;
&lt;p&gt;事务传播行为 (为了解决业务层方法之间互相调用的事务问题): 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。&lt;/p&gt;
&lt;p&gt;例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在 &lt;code&gt;TransactionDefinition&lt;/code&gt;  定义中包括了如下几个表示传播行为的常量:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;REQUIRED，SUPPORTS，MANDATORY，REQUIRES_NEW，NOT_SUPPORTED，NEVER，NESTED&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;支持当前事务的情况:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_REQUIRED:&lt;/code&gt;  如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_SUPPORTS:&lt;/code&gt;  如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_MANDATORY:&lt;/code&gt;  如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。( &lt;code&gt;mandatory:强制性&lt;/code&gt; )&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;不支持当前事务的情况:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_REQUIRES_NEW:&lt;/code&gt;  创建一个新的事务，如果当前存在事务，则把当前事务挂起。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_NOT_SUPPORTED:&lt;/code&gt;  以非事务方式运行，如果当前存在事务，则把当前事务挂起。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_NEVER:&lt;/code&gt;  以非事务方式运行，如果当前存在事务，则抛出异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;其他情况:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_NESTED: &lt;/code&gt; 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 &lt;code&gt;TransactionDefinition.PROPAGATION_REQUIRED。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;隔离级别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#隔离级别&#34;&gt;#&lt;/a&gt; 隔离级别&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;TransactionDefinition&lt;/code&gt;  接口中定义了 &lt;code&gt;五个&lt;/code&gt; 表示隔离级别的常量:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DEFAULT，READ_UNCOMMITTED，READ_COMMITTED，REPEATABLE_READ，SERIALIZABLE&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.ISOLATION_DEFAULT:&lt;/code&gt;  使用后端数据库默认的隔离级别， &lt;code&gt;Mysql&lt;/code&gt;  默认采用的 &lt;code&gt;REPEATABLE_READ&lt;/code&gt;  隔离级别  &lt;code&gt;Oracle&lt;/code&gt;  默认采用的  &lt;code&gt;READ_COMMITTED&lt;/code&gt;  隔离级别。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.ISOLATION_READ_UNCOMMITTED: &lt;/code&gt; 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.ISOLATION_READ_COMMITTED:&lt;/code&gt;  允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.ISOLATION_REPEATABLE_READ:&lt;/code&gt;  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TransactionDefinition.ISOLATION_SERIALIZABLE:&lt;/code&gt;  最高的隔离级别，完全服从 &lt;code&gt;ACID&lt;/code&gt;  的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;脏读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个事务修改了一行数据但没有提交，第二个事务可以读取到这行被修改的数据，如果第一个事务回滚，第二个事务获取到的数据将是无效的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不可重复读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个事务读取了一行数据，第二个事务修改了这行数据，第一个事务重新读取这行数据，将获得到不同的值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;幻读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个事务按照一个 &lt;code&gt;where&lt;/code&gt;  条件读取所有符合的数据行，第二个事务插入了一行数据且恰好也满足这个 &lt;code&gt;where&lt;/code&gt;  条件，第一个事务再以这个 &lt;code&gt;where&lt;/code&gt;  条件重新读取，将会获取额外多出来的这一行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;帮助记忆：&lt;/strong&gt;&lt;br&gt;
写读是脏读，读写读是不可重复读， &lt;code&gt;where insert where&lt;/code&gt;  是幻读。&lt;/p&gt;
&lt;img data-src=&#34;/posts/7e4601e3/2022-02-16-21-43-16.png&#34; class=&#34;&#34;&gt;
 ]]></description>
        </item>
    </channel>
</rss>

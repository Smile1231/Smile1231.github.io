{
    "version": "https://jsonfeed.org/version/1",
    "title": "JIN MAO 's Blog • All posts by \"spring事务\" category",
    "description": "",
    "home_page_url": "https://smile1231.github.io",
    "items": [
        {
            "id": "https://smile1231.github.io/posts/7e4601e3/",
            "url": "https://smile1231.github.io/posts/7e4601e3/",
            "title": "面试之旅之关于Spring事务处理",
            "date_published": "2022-02-16T13:14:23.000Z",
            "content_html": "<h1 id=\"Spring事务处理\"><a href=\"#Spring事务处理\" class=\"headerlink\" title=\"Spring事务处理\"></a><code>Spring</code>事务处理</h1><h2 id=\"Spring和事务的关系\"><a href=\"#Spring和事务的关系\" class=\"headerlink\" title=\"Spring和事务的关系\"></a><code>Spring</code>和事务的关系</h2><p>关系型数据库、某些消息队列等产品或中间件称为事务性资源，因为它们本身支持事务，也能够处理事务。</p>\n<p><code>Spring</code>很显然不是事务性资源，但是它可以管理事务性资源，所以<code>Spring</code>和事务之间是管理关系。</p>\n<p>就像<code>Jack Ma</code>虽然不会写代码，但是他却管理者一大批会写代码的码农。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Spring事务三要素\"><a href=\"#Spring事务三要素\" class=\"headerlink\" title=\"Spring事务三要素\"></a><code>Spring</code>事务三要素</h2><ul>\n<li><p>数据源：表示具体的事务性资源，是事务的真正处理者，如<code>MySQL</code>等。</p>\n</li>\n<li><p>事务管理器：像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。</p>\n</li>\n<li><p>事务应用和属性配置：像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属性如隔离级别、超时时间等。</p>\n</li>\n</ul>\n<h2 id=\"Spring事务的注解配置\"><a href=\"#Spring事务的注解配置\" class=\"headerlink\" title=\"Spring事务的注解配置\"></a><code>Spring</code>事务的注解配置</h2><ul>\n<li><p>把一个<code>DataSource（如DruidDataSource）</code>作为一个<code>@Bean</code>注册到<code>Spring</code>容器中，配置好事务性资源。</p>\n</li>\n<li><p>把一个<code>@EnableTransactionManagement</code>注解放到一个<code>@Configuration</code>类上，配置好事务管理器，并启用事务管理。</p>\n</li>\n<li><p>把一个<code>@Transactional</code>注解放到类上或方法上，可以设置注解的属性，表明该方法按配置好的属性参与到事务中。</p>\n</li>\n</ul>\n<h2 id=\"事务注解的本质\"><a href=\"#事务注解的本质\" class=\"headerlink\" title=\"事务注解的本质\"></a>事务注解的本质</h2><ul>\n<li><p><code>@Transactional</code>这个注解仅仅是一些（和事务相关的）元数据，在运行时被事务基础设施读取消费，并使用这些元数据来配置<code>bean</code>的事务行为。</p>\n</li>\n<li><p>大致来说具有两方面功能，一是表明该方法要参与事务，二是配置相关属性来定制事务的参与方式和运行行为。</p>\n</li>\n</ul>\n<h2 id=\"Spring声明式事务实现原理\"><a href=\"#Spring声明式事务实现原理\" class=\"headerlink\" title=\"Spring声明式事务实现原理\"></a><code>Spring</code>声明式事务实现原理</h2><p>声明式事务成为可能，主要得益于<code>Spring AOP</code>。使用一个事务拦截器，在方法调用的前后/周围进行事务性增强（<code>advice</code>），来驱动事务完成。</p>\n<h2 id=\"如何回滚一个事务\"><a href=\"#如何回滚一个事务\" class=\"headerlink\" title=\"如何回滚一个事务\"></a>如何回滚一个事务</h2><p>就是在一个事务上下文中当前正在执行的代码里抛出一个异常，事务基础设施代码会捕获任何未处理的异常，并且做出决定是否标记这个事务为回滚。</p>\n<h2 id=\"默认回滚规则\"><a href=\"#默认回滚规则\" class=\"headerlink\" title=\"默认回滚规则\"></a>默认回滚规则</h2><p>默认只把<code>runtime</code>, <code>unchecked exceptions</code>标记为回滚，即<code>RuntimeException</code>及其子类，<code>Error</code>默认也导致回滚。<code>Checked exceptions</code>默认不导致回滚。这些规则和<code>EJB</code>是一样的。</p>\n<h2 id=\"如何配置回滚异常\"><a href=\"#如何配置回滚异常\" class=\"headerlink\" title=\"如何配置回滚异常\"></a>如何配置回滚异常</h2><p>使用<code>@Transactional</code>注解的<code>rollbackFor/rollbackForClassName</code>属性，可以精确配置导致回滚的异常类型，包括<code>checked exceptions</code>。</p>\n<p><code>noRollbackFor/noRollbackForClassName</code>属性，可以配置不导致回滚的异常类型，当遇到这样的未处理异常时，照样提交相关事务。</p>\n<h2 id=\"事务注解在类-方法上\"><a href=\"#事务注解在类-方法上\" class=\"headerlink\" title=\"事务注解在类/方法上\"></a>事务注解在类/方法上</h2><p><code>@Transactional</code>注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的所有方法。如果此时方法上也标注了，则方法上的优先级高。</p>\n<h2 id=\"事务注解在类上的继承性\"><a href=\"#事务注解在类上的继承性\" class=\"headerlink\" title=\"事务注解在类上的继承性\"></a>事务注解在类上的继承性</h2><p><code>@Transactional</code>注解的作用可以传播到子类，即如果父类标了子类就不用标了。但倒过来就不行了。</p>\n<p>子类标了，并不会传到父类，所以父类方法不会有事务。父类方法需要在子类中重新声明而参与到子类上的注解，这样才会有事务。</p>\n<h2 id=\"事务注解在接口-类上\"><a href=\"#事务注解在接口-类上\" class=\"headerlink\" title=\"事务注解在接口/类上\"></a>事务注解在接口/类上</h2><p><code>@Transactional</code>注解可以用在接口上，也可以在类上。在接口上时，必须使用基于接口的代理才行，即<code>JDK</code>动态代理。</p>\n<p>事实是<code>Java</code>的注解不能从接口继承，如果你使用基于类的代理，即<code>CGLIB</code>，或基于织入方面，即<code>AspectJ</code>，事务设置不会被代理和织入基础设施认出来，目标对象不会被包装到一个事务代理中。</p>\n<p><code>Spring</code>团队建议注解标注在类上而非接口上。</p>\n<h2 id=\"只在public方法上生效？\"><a href=\"#只在public方法上生效？\" class=\"headerlink\" title=\"只在public方法上生效？\"></a>只在<code>public</code>方法上生效？</h2><p>当采用代理来实现事务时，（注意是代理），<code>@Transactional</code>注解只能应用在<code>public</code>方法上。当标记在<code>protected、private、package-visible</code>方法上时，不会产生错误，但也不会表现出为它指定的事务配置。可以认为它作为一个普通的方法参与到一个<code>public</code>方法的事务中。</p>\n<p>如果想在非<code>public</code>方法上生效，考虑使用<code>AspectJ（织入方式）</code>。</p>\n<h2 id=\"目标类里的自我调用没有事务？\"><a href=\"#目标类里的自我调用没有事务？\" class=\"headerlink\" title=\"目标类里的自我调用没有事务？\"></a>目标类里的自我调用没有事务？</h2><p>在代理模式中（这是默认的），只有从外部的方法调用进入通过代理会被拦截，这意味着自我调用（实际就是，目标对象中的一个方法调用目标对象的另一个方法）在运行时不会导致一个实际的事务，即使被调用的方法标有注解。</p>\n<p>如果你希望自我调用也使用事务来包装，考虑使用<code>AspectJ</code>的方式。在这种情况下，首先是没有代理。相反，目标类被织入（即它的字节码被修改）来把<code>@Transactional</code>加入到运行时行为，在任何种类的方法上都可以。</p>\n<h2 id=\"事务与线程\"><a href=\"#事务与线程\" class=\"headerlink\" title=\"事务与线程\"></a>事务与线程</h2><p>和<code>JavaEE</code>事务上下文一样，<code>Spring</code>事务和一个线程的执行相关联，底层是一个<code>ThreadLocal&lt;Map&lt;Object, Object&gt;&gt;</code>，就是每个线程一个<code>map</code>，<code>key</code>是<code>DataSource</code>，<code>value</code>是<code>Connection</code>。</p>\n<h2 id=\"逻辑事务与物理事务\"><a href=\"#逻辑事务与物理事务\" class=\"headerlink\" title=\"逻辑事务与物理事务\"></a>逻辑事务与物理事务</h2><p>事务性资源实际打开的事务就是物理事务，如数据库的<code>Connection</code>打开的事务。<code>Spring</code>会为每个<code>@Transactional</code>方法创建一个事务范围，可以理解为是逻辑事务。</p>\n<p>在逻辑事务中，大范围的事务称为外围事务，小范围的事务称为内部事务，外围事务可以包含内部事务，但在逻辑上是互相独立的。每一个这样的逻辑事务范围，都能够单独地决定<code>rollback-only</code>状态。</p>\n<p>那么如何处理逻辑事务和物理事务之间的关联关系呢，这就是传播特性解决的问题。</p>\n<h2 id=\"事务传播行为\"><a href=\"#事务传播行为\" class=\"headerlink\" title=\"事务传播行为\"></a>事务传播行为</h2><p>事务传播行为(为了解决业务层方法之间互相调用的事务问题): 当事务方法被另一个事务方法调用时,必须指定事务应该如何传播。</p>\n<p>例如:方法可能继续在现有事务中运行,也可能开启一个新事务,并在自己的事务中运行。在<code>TransactionDefinition</code>定义中包括了如下几个表示传播行为的常量:</p>\n<p><code>REQUIRED，SUPPORTS，MANDATORY，REQUIRES_NEW，NOT_SUPPORTED，NEVER，NESTED</code></p>\n<blockquote>\n<p>支持当前事务的情况:</p>\n</blockquote>\n<ul>\n<li><code>TransactionDefinition.PROPAGATION_REQUIRED:</code> 如果当前存在事务,则加入该事务;如果当前没有事务,则创建一个新的事务。</li>\n<li><code>TransactionDefinition.PROPAGATION_SUPPORTS:</code> 如果当前存在事务,则加入该事务;如果当前没有事务,则以非事务的方式继续运行。</li>\n<li><code>TransactionDefinition.PROPAGATION_MANDATORY:</code> 如果当前存在事务,则加入该事务;如果当前没有事务,则抛出异常。(<code>mandatory:强制性</code>)</li>\n</ul>\n<blockquote>\n<p>不支持当前事务的情况:</p>\n</blockquote>\n<ul>\n<li><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW:</code> 创建一个新的事务,如果当前存在事务,则把当前事务挂起。</li>\n<li><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED:</code> 以非事务方式运行,如果当前存在事务,则把当前事务挂起。</li>\n<li><code>TransactionDefinition.PROPAGATION_NEVER:</code> 以非事务方式运行,如果当前存在事务,则抛出异常。</li>\n</ul>\n<blockquote>\n<p>其他情况:</p>\n</blockquote>\n<ul>\n<li><code>TransactionDefinition.PROPAGATION_NESTED: </code>如果当前存在事务,则创建一个事务作为当前事务的嵌套事务来运行;如果当前没有事务,则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED。</code></li>\n</ul>\n<h2 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h2><p><code>TransactionDefinition</code> 接口中定义了<code>五个</code>表示隔离级别的常量:</p>\n<p><code>DEFAULT，READ_UNCOMMITTED，READ_COMMITTED，REPEATABLE_READ，SERIALIZABLE</code></p>\n<ul>\n<li><code>TransactionDefinition.ISOLATION_DEFAULT:</code> 使用后端数据库默认的隔离级别,<code>Mysql</code> 默认采用的<code>REPEATABLE_READ</code>隔离级别 <code>Oracle</code> 默认采用的 <code>READ_COMMITTED</code>隔离级别。</li>\n<li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED: </code>最低的隔离级别,允许读取尚未提交的数据变更,可能会导致脏读、幻读或不可重复读。</li>\n<li><code>TransactionDefinition.ISOLATION_READ_COMMITTED:</code> 允许读取并发事务已经提交的数据,可以阻止脏读,但是幻读或不可重复读仍有可能发生。</li>\n<li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ:</code> 对同一字段的多次读取结果都是一致的,除非数据是被本身事务自己所修改,可以阻止脏读和不可重复读,但幻读仍有可能发生。</li>\n<li><code>TransactionDefinition.ISOLATION_SERIALIZABLE:</code> 最高的隔离级别,完全服从<code>ACID</code>的隔离级别。所有的事务依次逐个执行,这样事务之间就完全不可能产生干扰,也就是说,该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>\n</ul>\n<blockquote>\n<p>脏读</p>\n</blockquote>\n<p>一个事务修改了一行数据但没有提交，第二个事务可以读取到这行被修改的数据，如果第一个事务回滚，第二个事务获取到的数据将是无效的。</p>\n<blockquote>\n<p>不可重复读</p>\n</blockquote>\n<p>一个事务读取了一行数据，第二个事务修改了这行数据，第一个事务重新读取这行数据，将获得到不同的值。</p>\n<blockquote>\n<p>幻读</p>\n</blockquote>\n<p>一个事务按照一个<code>where</code>条件读取所有符合的数据行，第二个事务插入了一行数据且恰好也满足这个<code>where</code>条件，第一个事务再以这个<code>where</code>条件重新读取，将会获取额外多出来的这一行。</p>\n<p><strong>帮助记忆：</strong><br>写读是脏读，读写读是不可重复读，<code>where insert where</code>是幻读。</p>\n<img data-src=\"/blog/posts/7e4601e3/2022-02-16-21-43-16.png\" class=\"\">\n\n\n\n",
            "tags": [
                "Java面试",
                "Spring事务"
            ]
        }
    ]
}
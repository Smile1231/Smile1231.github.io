{
    "version": "https://jsonfeed.org/version/1",
    "title": "JIN MAO 's Blog • All posts by \"冒泡排序\" category",
    "description": "",
    "home_page_url": "https://smile1231.github.io",
    "items": [
        {
            "id": "https://smile1231.github.io/posts/14e6f1eb/",
            "url": "https://smile1231.github.io/posts/14e6f1eb/",
            "title": "冒泡排序",
            "date_published": "2022-03-12T13:58:14.000Z",
            "content_html": "<h2 id=\"冒泡排序稳定\"><a class=\"markdownIt-Anchor\" href=\"#冒泡排序稳定\">#</a> 冒泡排序（稳定）</h2>\n<h3 id=\"1-基本思想\"><a class=\"markdownIt-Anchor\" href=\"#1-基本思想\">#</a> 1、基本思想</h3>\n<p>冒泡排序（ <code>Bubble Sort</code> ）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</p>\n<span id=\"more\"></span>\n<h3 id=\"2-算法描述\"><a class=\"markdownIt-Anchor\" href=\"#2-算法描述\">#</a> 2、算法描述</h3>\n<p>冒泡排序算法的运作如下：</p>\n<p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>\n②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>\n③. 针对所有的元素重复以上的步骤，除了最后一个。<br>\n④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</p>\n<h3 id=\"3-代码实现\"><a class=\"markdownIt-Anchor\" href=\"#3-代码实现\">#</a> 3、代码实现</h3>\n<p>冒泡排序需要两个嵌套的循环。其中，外层循环移动游标；内层循环遍历游标及之后 (或之前) 的元素，通过两两交换的方式，每次只确保该内循环结束位置排序正确，然后内层循环周期结束，交由外层循环往后 (或前) 移动游标，随即开始下一轮内层循环，以此类推，直至循环结束.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = arr.length; i &gt; <span class=\"number\">0</span>; i--) &#123;      <span class=\"comment\">//外层循环移动游标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i &amp;&amp; (j+<span class=\"number\">1</span>) &lt; i; j++)&#123;    <span class=\"comment\">//内层循环遍历游标及之后(或之前)的元素</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &gt; arr[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = arr[j];</span><br><span class=\"line\">                arr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                arr[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Sorting: &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置，它并不改变相同元素之间的相对顺序，因此它是稳定的排序算法.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "冒泡排序"
            ]
        }
    ]
}
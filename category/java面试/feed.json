{
    "version": "https://jsonfeed.org/version/1",
    "title": "JIN MAO 's Blog • All posts by \"java面试\" category",
    "description": "",
    "home_page_url": "https://smile1231.github.io",
    "items": [
        {
            "id": "https://smile1231.github.io/posts/14e6f1eb/",
            "url": "https://smile1231.github.io/posts/14e6f1eb/",
            "title": "冒泡排序",
            "date_published": "2022-03-12T13:58:14.000Z",
            "content_html": "<h2 id=\"冒泡排序稳定\"><a class=\"markdownIt-Anchor\" href=\"#冒泡排序稳定\">#</a> 冒泡排序（稳定）</h2>\n<h3 id=\"1-基本思想\"><a class=\"markdownIt-Anchor\" href=\"#1-基本思想\">#</a> 1、基本思想</h3>\n<p>冒泡排序（ <code>Bubble Sort</code> ）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</p>\n<span id=\"more\"></span>\n<h3 id=\"2-算法描述\"><a class=\"markdownIt-Anchor\" href=\"#2-算法描述\">#</a> 2、算法描述</h3>\n<p>冒泡排序算法的运作如下：</p>\n<p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>\n②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>\n③. 针对所有的元素重复以上的步骤，除了最后一个。<br>\n④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</p>\n<h3 id=\"3-代码实现\"><a class=\"markdownIt-Anchor\" href=\"#3-代码实现\">#</a> 3、代码实现</h3>\n<p>冒泡排序需要两个嵌套的循环。其中，外层循环移动游标；内层循环遍历游标及之后 (或之前) 的元素，通过两两交换的方式，每次只确保该内循环结束位置排序正确，然后内层循环周期结束，交由外层循环往后 (或前) 移动游标，随即开始下一轮内层循环，以此类推，直至循环结束.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = arr.length; i &gt; <span class=\"number\">0</span>; i--) &#123;      <span class=\"comment\">//外层循环移动游标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i &amp;&amp; (j+<span class=\"number\">1</span>) &lt; i; j++)&#123;    <span class=\"comment\">//内层循环遍历游标及之后(或之前)的元素</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &gt; arr[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = arr[j];</span><br><span class=\"line\">                arr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                arr[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Sorting: &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置，它并不改变相同元素之间的相对顺序，因此它是稳定的排序算法.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "冒泡排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/c2a5fdc5/",
            "url": "https://smile1231.github.io/posts/c2a5fdc5/",
            "title": "堆排序",
            "date_published": "2022-03-12T13:58:00.000Z",
            "content_html": "<h2 id=\"堆排序不稳定\"><a class=\"markdownIt-Anchor\" href=\"#堆排序不稳定\">#</a> 堆排序（不稳定）</h2>\n<p>个人感觉堆排序还是挺难的，虽然会有演示动画<br>\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAvIyVFNSU5QiU5QiVFMyU4MCU4MSVFNSVBMCU4NiVFNiU4RSU5MiVFNSVCQSU4RiVFRiVCQyU4OEhlYXAtU29ydCVFRiVCQyU4OQ==\">链接</span></p>\n<p>但是从代码层面就没有那么好的通俗</p>\n<span id=\"more\"></span>\n<p>堆的含义就是：完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序，使用小顶堆进行降序排序。</p>\n<h3 id=\"1-基本思想\"><a class=\"markdownIt-Anchor\" href=\"#1-基本思想\">#</a> 1、基本思想</h3>\n<p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p>\n<h3 id=\"2-算法描述\"><a class=\"markdownIt-Anchor\" href=\"#2-算法描述\">#</a> 2、算法描述</h3>\n<p>①. 先将初始序列 <code>K[1..n]</code>  建成一个大顶堆，那么此时第一个元素 <code>K1</code>  最大，此堆为初始的无序区.<br>\n②. 再将关键字最大的记录 <code>K1</code>  (即堆顶，第一个元素) 和无序区的最后一个记录  <code>Kn</code>  交换，由此得到新的无序区 <code>K[1..n−1]</code>  和有序区 <code>K[n]</code> , 且满足 <code>K[1..n−1].keys⩽K[n].key</code> <br>\n③. 交换 <code>K1</code>  和  <code>Kn</code>  后，堆顶可能违反堆性质，因此需将 <code>K[1..n−1]</code>  调整为堆。然后重复步骤②, 直到无序区只有一个元素时停止.</p>\n<h3 id=\"3-代码实现\"><a class=\"markdownIt-Anchor\" href=\"#3-代码实现\">#</a> 3、代码实现</h3>\n<p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p>\n<p>总结起来就是定义了以下几种操作：</p>\n<ul>\n<li>最大堆调整（ <code>Max_Heapify</code> ）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>\n<li>创建最大堆（ <code>Build_Max_Heap</code> ）：将堆所有数据重新排序</li>\n<li>堆排序（ <code>HeapSort</code> ）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>\n</ul>\n<p>对于堆节点的访问：</p>\n<ul>\n<li>父节点 i 的左子节点在位置： <code>(2*i+1);</code></li>\n<li>父节点 i 的右子节点在位置： <code>(2*i+2);</code></li>\n<li>子节点 i 的父节点在位置： <code>floor((i-1)/2);</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = arr.length; i &gt; <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        max_heapify(arr, i);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[<span class=\"number\">0</span>];      <span class=\"comment\">//堆顶元素(第一个元素)与Kn交换</span></span><br><span class=\"line\">        arr[<span class=\"number\">0</span>] = arr[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        arr[i-<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">max_heapify</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> limit)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arr.length &lt;= <span class=\"number\">0</span> || arr.length &lt; limit) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> parentIdx = limit / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; parentIdx &gt;= <span class=\"number\">0</span>; parentIdx--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(parentIdx * <span class=\"number\">2</span> &gt;= limit)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = parentIdx * <span class=\"number\">2</span>;       <span class=\"comment\">//左子节点位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = (left + <span class=\"number\">1</span>) &gt;= limit ? left : (left + <span class=\"number\">1</span>);    <span class=\"comment\">//右子节点位置，如果没有右节点，默认为左节点位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxChildId = arr[left] &gt;= arr[right] ? left : right;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[maxChildId] &gt; arr[parentIdx])&#123;   <span class=\"comment\">//交换父节点与左右子节点中的最大值</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = arr[parentIdx];</span><br><span class=\"line\">            arr[parentIdx] = arr[maxChildId];</span><br><span class=\"line\">            arr[maxChildId] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Max_Heapify: &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Tips: 由于堆排序中初始化堆的过程比较次数较多，因此它不太适用于小序列。同时由于多次任意下标相互交换位置，相同元素之间原本相对的顺序被破坏了，因此，它是不稳定的排序.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "堆排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/43d00a99/",
            "url": "https://smile1231.github.io/posts/43d00a99/",
            "title": "选择排序",
            "date_published": "2022-03-12T13:45:07.000Z",
            "content_html": "<h2 id=\"选择排序不稳定on2\"><a class=\"markdownIt-Anchor\" href=\"#选择排序不稳定on2\">#</a> 选择排序（不稳定）ON2</h2>\n<p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p>\n<h3 id=\"1-基本思想\"><a class=\"markdownIt-Anchor\" href=\"#1-基本思想\">#</a> 1、基本思想</h3>\n<p>选择排序的基本思想：比较 + 交换。</p>\n<p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>\n<h3 id=\"2-算法描述\"><a class=\"markdownIt-Anchor\" href=\"#2-算法描述\">#</a> 2、算法描述</h3>\n<p>①. 从待排序序列中，找到关键字最小的元素；<br>\n②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br>\n③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</p>\n<h3 id=\"3-代码实现\"><a class=\"markdownIt-Anchor\" href=\"#3-代码实现\">#</a> 3、代码实现</h3>\n<p>选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">selectionSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arr.length-<span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; arr.length; j++)&#123;    <span class=\"comment\">//选出之后待排序中值最小的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class=\"line\">                min = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(min != i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = arr[min];      <span class=\"comment\">//交换操作</span></span><br><span class=\"line\">            arr[min] = arr[i];</span><br><span class=\"line\">            arr[i] = temp;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Sorting:  &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "选择排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/2b06d603/",
            "url": "https://smile1231.github.io/posts/2b06d603/",
            "title": "直接插入排序",
            "date_published": "2022-03-12T09:57:45.000Z",
            "content_html": "<h2 id=\"插入排序稳定\"><a class=\"markdownIt-Anchor\" href=\"#插入排序稳定\">#</a> 插入排序（稳定）</h2>\n<p>一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：</p>\n<p>①. 从第一个元素开始，该元素可以认为已经被排序<br>\n②. 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>\n③. 如果该元素（已排序）大于新元素，将该元素移到下一位置<br>\n④. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置<br>\n⑤. 将新元素插入到该位置后<br>\n⑥. 重复步骤②~⑤</p>\n<span id=\"more\"></span>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertionSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; arr.length; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[i];    <span class=\"comment\">// 取出下一个元素，在已经排序的元素序列中从后向前扫描</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> j = i; j &gt;= <span class=\"number\">0</span>; j-- ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>( j &gt; <span class=\"number\">0</span> &amp;&amp; arr[j-<span class=\"number\">1</span>] &gt; temp ) &#123;</span><br><span class=\"line\">                arr[j] = arr[j-<span class=\"number\">1</span>];    <span class=\"comment\">// 如果该元素（已排序）大于取出的元素temp，将该元素移到下一位置</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Temping:  &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将新元素插入到该位置后</span></span><br><span class=\"line\">                arr[j] = temp;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Sorting:  &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交换次数较多的实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertionSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;arr.length-<span class=\"number\">1</span>; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>; j&gt;<span class=\"number\">0</span>; j-- ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>( arr[j-<span class=\"number\">1</span>] &lt;= arr[j] )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = arr[j];      <span class=\"comment\">//交换操作</span></span><br><span class=\"line\">            arr[j] = arr[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">            arr[j-<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Sorting:  &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//JDK直接插入排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a,<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ai = a[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ai &lt; a[j]) &#123;</span><br><span class=\"line\">            a[j + <span class=\"number\">1</span>] = a[j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j-- == left) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a[j + <span class=\"number\">1</span>] = ai;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "直接插入排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/ff8068c0/",
            "url": "https://smile1231.github.io/posts/ff8068c0/",
            "title": "快速排序",
            "date_published": "2022-03-12T05:24:41.000Z",
            "content_html": "<h2 id=\"快排-不稳定\"><a class=\"markdownIt-Anchor\" href=\"#快排-不稳定\">#</a> 快排 (不稳定)</h2>\n<p>快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。</p>\n<h3 id=\"快速排序的原理\"><a class=\"markdownIt-Anchor\" href=\"#快速排序的原理\">#</a> 快速排序的原理</h3>\n<span id=\"more\"></span>\n<p>排序算法的思想非常简单，在待排序的数列中，我们首先要找一个数字作为基准数（这只是个专用名词）。为了方便，我们一般选择第  <code>1</code>  个数字作为基准数（其实选择第几个并没有关系）。接下来我们需要把这个待排序的数列中小于基准数的元素移动到待排序的数列的左边，把大于基准数的元素移动到待排序的数列的右边。这时，左右两个分区的元素就相对有序了；接着把两个分区的元素分别按照上面两种方法继续对每个分区找出基准数，然后移动，直到各个分区只有一个数时为止。</p>\n<p>这是典型的分治思想，即分治法。下面我们对一个实际例子进行算法描述，讲解快速排序的排序步骤。</p>\n<p><code>以 47、29、71、99、78、19、24、47</code>  的待排序的数列为例进行排序，为了方便区分两个  <code>47</code> ，我们对后面的  <code>47</code>  增加一个下画线，即待排序的数列为  <code>47、29、71、99、78、19、24、47</code> 。</p>\n<p>首先我们需要在数列中选择一个基准数，我们一般会选择中间的一个数或者头尾的数，这里直接选择第  <code>1</code>  个数  <code>47</code>  作为基准数，接着把比  <code>47</code>  小的数字移动到左边，把比  <code>47</code>  大的数字移动到右边，对于相等的数字不做移动。所以实际上我们需要找到中间的某个位置  <code>k</code> ，这样  <code>k</code>  左边的值全部比  <code>k</code>  上的值小， <code>k</code>  右边的值全部比  <code>k</code>  上的值大。</p>\n<p>接下来开始移动元素。怎么移动呢？其实冒泡排序也涉及对元素的移动，但是那样移动起来很累，比如把最后一个元素移动到第  <code>1</code>  个，就需要比较  <code>n-1</code>  次，同时交换  <code>n-1</code>  次，效率很低。其实，只需把第  <code>1</code>  个元素和最后一个元素交换就好了，这种思想是不是在排序时可以借鉴呢？之前说快速排序就是对冒泡排序的一个改进，就是这个原因。</p>\n<p>快速排序的操作是这样的：首先从数列的右边开始往左边找，我们设这个下标为  <code>i</code> ，也就是进行减减操作（ <code>i--</code> ），找到第  <code>1</code>  个比基准数小的值，让它与基准值交换；接着从左边开始往右边找，设这个下标为  <code>j</code> ，然后执行加加操作 <code>（j++）</code> ，找到第  <code>1</code>  个比基准数大的值，让它与基准值交换；然后继续寻找，直到  <code>i </code> 与  <code>j</code>  相遇时结束，最后基准值所在的位置即  <code>k</code>  的位置，也就是说  <code>k</code>  左边的值均比  <code>k</code>  上的值小，而  <code>k</code>  右边的值都比  <code>k </code> 上的值大。</p>\n<p>所以对于上面的数列 47、29、71、99、78、19、24、 <u>47</u>，进行第  <code>1</code>  趟第  <code>1</code>  个交换的排序情况如下，第  <code>1</code>  次的操作情况如图 1 所示。</p>\n<img data-src=\"/posts/ff8068c0/2022-03-12-16-52-14.png\" class=\"\">\n<p>交换之后， <code>j</code>  移动到了下标为  <code>6</code>  的位置，对  <code>i</code>  继续扫描，如图  <code>2</code>  所示。</p>\n<img data-src=\"/posts/ff8068c0/2022-03-12-16-55-14.png\" class=\"\">\n<p>此时交换后的数列变为 24、29、47、99、78、19、71、<u>47</u>。接下来我们继续对 i、j 进行操作，如图 3 所示，继续进行 i-- 及 j++ 的比较操作。</p>\n<img data-src=\"/posts/ff8068c0/2022-03-12-16-58-42.png\" class=\"\">\n<p>进行了这两次 i、j 的移动、比较、交换之后，我们最终得到的数列是 24、29、19、47、78、99、71、<u>47</u>。接下来我们继续进行 i-- 的操作，发现在 i 为 4 时比 47 大不用交换，在 i 为 3 时与 j 相遇，这时就不需要继续移动、比较了，已经找到 k 了，并且 k 的值为 3。我们可以确认一下当前的数列是不是 k 左边的值都比 47 小，而 k 右边的值都比 47 大（由于要保持相对位置不变，所以 47 同样在基准值 47 的右边）。</p>\n<p>47 这个值已经落到了它该在的位置，第 1 趟排序完成了。接下来就是以 k 为基准，分为两部分，然后在左右两部分分别执行上述排序操作，最后数据会分为 4 部分；接着对每部分进行操作，直到每部分都只有一个值为止。</p>\n<p>接下来进行第 2 趟排序，现在左边部分为 24、29、19，我们选择第 1 个数 24 作为基准数，接着进行 i–、j++ 的操作，我们发现 i 最初的值为 19，比 24 这个基准值小，所以与基准值进行交换，得到的数列为 19、29、24；当 j 为 1 时，我们发现 29 比 24 大，所以与基准值进行交换，得到的数列 19、24、29，此时 i 为 2，j 为 1；继续 i-- 时发现 i 为 1，与 j 相遇，左边部分的数列的 k 为 1，并且左右两部分分别只有一个元素，此时第 2 轮排序的左边部分的排序结束，同时左边部分的所有数据都排序完成。</p>\n<p>我们接着看右边部分的排序，待排序的数列为 78、99、71、<u>47</u>，我们同样选择第 1 个值 78 为基准值，接下来进行 i 与 j 的移动与比较，发现 47 比 78 小，进行交换，得到的数列 47、99、71、78；从左往右发现 99 比基准值 78 大，进行交换，得到的数列为 47、78、71、99；继续从右向左看，发现 71 比基准值 78 小，进行交换，得到的数列为 <u>47</u>、71、78、99。此时 i 在整体数组中的下标为 6，j 为 5，若继续 j++ 则与 i 相遇，所以完成此轮排序。</p>\n<p>此时右边数列的 k 为 6，一般会是相遇的位置，也就是基准值所在的位置，这时数列又被分为两部分，左边是 47、71，右边是 99，需要继续对左边部分的数据进行排序，虽然只有两个数据，但我们还是继续按照快速排序的思想操作一下，选择 <u>47</u> 作为基准数，将 i 进行从右向左的移动、比较，发现 i 与 j 相等时没有产生移动，完成第 2 轮排序。</p>\n<p>至此，所有排序都已经完成，最终数列的结果是 19、24、29、47、47、71、78、99，怎么样，快速排序是不是非常简单地完成了所有的排序呢？虽然本次快速排序没有改变相同值的元素的顺序，但是由于快速排序需要对数列中的元素来回移动，有时还是会改变相对顺序的（比如 47 在第 1 轮的移动过程中就被移动到 47 的右边了），所以快速排序并不是一个稳定的算法。</p>\n<h2 id=\"快速排序的实现\"><a class=\"markdownIt-Anchor\" href=\"#快速排序的实现\">#</a> 快速排序的实现</h2>\n<p>通过以上的学习，你是否可以自己写出快速排序的实现代码呢？在接着学习之前，最好自己能对代码的实现进行一些思考，然后和下面的内容进行比对，看看自己有哪些疏忽之处。</p>\n<p>其实快速排序有一个比较简单的思想，就是递归。对于每一趟排序都是一样的思想，只不过需要进行排序的数组的范围越来越小了，使用递归实现这种排序最适合不过了。</p>\n<h3 id=\"实现一\"><a class=\"markdownIt-Anchor\" href=\"#实现一\">#</a> 实现一</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuickSort</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] array;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">QuickSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.array = array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        quickSort(array, <span class=\"number\">0</span>, array.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            System.out.println(array[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 递归排序</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> src</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> begin</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> end</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] src, <span class=\"keyword\">int</span> begin, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (begin &lt; end) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> key = src[begin];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = begin;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = end;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (i &lt; j &amp;&amp; src[j] &gt; key) &#123;</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; j) &#123;</span><br><span class=\"line\">                    src[i] = src[j];</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (i &lt; j &amp;&amp; src[i] &lt; key) &#123;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; j) &#123;</span><br><span class=\"line\">                    src[j] = src[i];</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            src[i] = key;</span><br><span class=\"line\">            quickSort(src, begin, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">            quickSort(src, i + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现二\"><a class=\"markdownIt-Anchor\" href=\"#实现二\">#</a> 实现二</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arr.length &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(low &gt;= high) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = high;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = arr[left];   <span class=\"comment\">//挖坑1：保存基准的值</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= temp)&#123;  <span class=\"comment\">//坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span></span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[left] = arr[right];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= temp)&#123;   <span class=\"comment\">//坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span></span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[right] = arr[left];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[left] = temp;   <span class=\"comment\">//基准值填补到坑3中，准备分治递归快排</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Sorting: &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">    quickSort(arr, low, left-<span class=\"number\">1</span>);</span><br><span class=\"line\">    quickSort(arr, left+<span class=\"number\">1</span>, high);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序的特点及性能\"><a class=\"markdownIt-Anchor\" href=\"#快速排序的特点及性能\">#</a> 快速排序的特点及性能</h2>\n<p>快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。</p>\n<p>但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是  <code>O(n2)</code> ，实际上每次比较都需要交换，但是这种情况并不常见。我们可以思考一下如果每次比较都需要交换，那么数列的平均时间复杂度是  <code>O(nlogn)</code> ，事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。</p>\n<p>快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的空间复杂度为  <code>O(logn)</code> ，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为 <code> O(n)</code> 。所以我们一般认为快速排序的空间复杂度为  <code>O(logn)</code> 。</p>\n<p>快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。</p>\n<p>快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2RhdGEuYmlhbmNoZW5nLm5ldC92aWV3LzExNy5odG1s\">本文链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "快速排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/a80d0031/",
            "url": "https://smile1231.github.io/posts/a80d0031/",
            "title": "动态规划",
            "date_published": "2022-02-17T14:58:10.000Z",
            "content_html": "<h1 id=\"动态规划算法\"><a class=\"markdownIt-Anchor\" href=\"#动态规划算法\">#</a> 动态规划算法</h1>\n<h2 id=\"什么是动态规划\"><a class=\"markdownIt-Anchor\" href=\"#什么是动态规划\">#</a> 什么是动态规划</h2>\n<p>动态规划的大致思路是把一个复杂的问题转化成一个分阶段逐步递推的过程，从简单的初始状态一步一步递推，最终得到复杂问题的最优解。</p>\n<blockquote>\n<p>基本思想与策略编辑:</p>\n</blockquote>\n<p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中</p>\n<span id=\"more\"></span>\n<ol>\n<li>\n<p><font color=\"red\"><strong>拆分问题</strong></font>: 根据问题的可能性把问题划分成通过递推或者递归一步一步实现。关键就是这个步骤，动态规划有一类问题就是从后往前推到，有时候我们很容易知道：如果只有一种情况时，最佳的选择应该怎么做。然后根据这个最佳选择往前一步推导，得到前一步的最佳选择</p>\n</li>\n<li>\n<p><font color=\"blue\">定义问题状态和状态之间的关系：</font>用一种量化的形式表现出来，类似于高中学的推导公式，因为这种式子很容易用程序写出来，也可以说对程序比较亲和 (也就是最后所说的状态转移方程式)</p>\n</li>\n<li>\n<p>动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，<font color=\"white\">前一子问题的解，为后一子问题的求解提供了有用的信息。</font>在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>\n</li>\n</ol>\n<p><strong>我的理解是</strong>：比如我们找到最优解，我们应该讲最优解保存下来，为了往前推导时能够使用前一步的最优解，在这个过程中难免有一些相比于最优解差的解，此时我们应该放弃，只保存最优解，</p>\n<p>这样我们每一次都把最优解保存了下来，大大降低了时间复杂度。</p>\n<hr/>\n<p>动态规划解决问题的过程分为两步：</p>\n<ol>\n<li>\n<p>寻找状态转移方程式</p>\n</li>\n<li>\n<p>利用状态转移方程式自底向上求解问题</p>\n</li>\n</ol>\n<h2 id=\"动态规划原理\"><a class=\"markdownIt-Anchor\" href=\"#动态规划原理\">#</a> 动态规划原理</h2>\n<ul>\n<li>使用条件：可分为多个相关子问题，子问题的解被重复使用</li>\n<li><code>Optimal substructure（优化子结构）</code> ：\n<ul>\n<li>一个问题的优化解包含了子问题的优化解</li>\n<li>缩小子问题集合，只需那些优化问题中包含的子问题，降低实现复杂性</li>\n<li>我们可以自下而上的</li>\n</ul>\n</li>\n<li><code>Subteties（重叠子问题）</code> ：在问题的求解过程中，很多子问题的解将被多次使用。</li>\n<li><strong>动态规划算法的设计步骤：</strong>\n<ul>\n<li>分析优化解的结构</li>\n<li>递归地定义最优解的代价</li>\n<li>自底向上地计算优化解的代价保存之，并获取构造最优解的信息</li>\n<li>根据构造最优解的信息构造优化解</li>\n</ul>\n</li>\n<li>动态规划特点：\n<ul>\n<li>把原始问题划分成一系列子问题；</li>\n<li>求解每个子问题仅一次，并将其结果保存在一个表中，以后用到时直接存取，不重复计算，节省计算时间</li>\n<li>自底向上地计算。</li>\n<li>整体问题最优解取决于子问题的最优解（状态转移方程）（将子问题称为状态，最终状态的求解归结为其他状态的求解</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"经典例题\"><a class=\"markdownIt-Anchor\" href=\"#经典例题\">#</a> 经典例题</h2>\n<h3 id=\"最长公共子序列longest-common-subsequence-lcs\"><a class=\"markdownIt-Anchor\" href=\"#最长公共子序列longest-common-subsequence-lcs\">#</a> 最长公共子序列（ <code>longest-common-subsequence, LCS</code> ）</h3>\n<p><a href=\"https://leetcode-cn.com/problems/longest-common-subsequence/\"> <code>LeetCode</code> </a></p>\n<img data-src=\"/posts/a80d0031/2022-02-17-23-18-58.png\" class=\"\">\n<p>(1) 子序列：一个序列 <code>X ＝ x1x2...xn</code> , 中任意删除若干项，剩余的序列叫做 <code>A</code>  的一个子序列。也可以认为是从序列 <code>A</code>  按原顺序保留任意若干项得到的序列。<br>\n例如：对序列  <code>1,3,5,4,2,6,8,7</code>  来说，序列 <code>3,4,8,7</code>  是它的一个子序列。对于一个长度为 <code>n</code>  的序列，它一共有 <code>2^n</code>  个子序列，有 <code>(2^n – 1)</code>  个非空子序列。在这里需要提醒大家，子序列不是子集，它和原始序列的元素顺序是相关的。</p>\n<p>(2) 公共子序列：如果序列 <code>Z</code>  既是序列 <code>X</code>  的子序列，同时也是序列 Y 的子序列，则称它为序列 <code>X</code>  和序列 <code>Y</code>  的公共子序列。空序列是任何两个序列的公共子序列。</p>\n<p>(3) 最长公共子序列： <code>X</code>  和 <code>Y</code>  的公共子序列中长度最长的（包含元素最多的）叫做 <code>X</code>  和 <code>Y</code>  的最长公共子序列。</p>\n<p>这个问题如果用穷举法时间，最终求出最长公共子序列时，时间复杂度是 <code>Ο（2mn）</code> ，是指数级别的复杂度，对于长序列是不适用的。因此我们使用动态规划法来求解。</p>\n<h3 id=\"刻画最长公共子序列问题的最优子结构\"><a class=\"markdownIt-Anchor\" href=\"#刻画最长公共子序列问题的最优子结构\">#</a> 刻画最长公共子序列问题的最优子结构</h3>\n<p>设 <code>X=x1x2…xm</code>  和 <code>Y=y1y2…yn</code>  是两个序列， <code>Z=z1z2…zk</code>  是这两个序列的一个最长公共子序列。</p>\n<ol>\n<li>\n<p>如果 <code>xm=yn</code> ，那么 <code>zk=xm=yn</code> ，且 <code>Zk-1</code>  是 <code>Xm-1</code> ， <code>Yn-1</code>  的一个最长公共子序列；</p>\n</li>\n<li>\n<p>如果 <code>xm≠yn</code> ，那么 <code>zk≠xm</code> ，意味着 <code>Z</code>  是 <code>Xm-1</code> ， <code>Y</code>  的一个最长公共子序列；</p>\n</li>\n<li>\n<p>如果 <code>xm≠yn</code> ，那么 <code>zk≠yn</code> ，意味着 <code>Z</code>  是 <code>X</code> ， <code>Yn-1</code>  的一个最长公共子序列。</p>\n</li>\n</ol>\n<p>从上面三种情况可以看出，两个序列的 <code>LCS</code>  包含两个序列的前缀的 <code>LCS</code> 。因此， <code>LCS</code>  问题具有最优子结构特征。</p>\n<h3 id=\"递归的定义最优质\"><a class=\"markdownIt-Anchor\" href=\"#递归的定义最优质\">#</a> 递归的定义最优质</h3>\n<p>从最优子结构可以看出，如果 <code>xm=yn</code> ，那么我们应该求解 <code>Xm-1</code> ， <code>Yn-1</code>  的一个 <code>LCS</code> ，并且将 <code>xm=yn</code>  加入到这个 <code>LCS</code>  的末尾，这样得到的一个新的 <code>LCS</code>  就是所求。</p>\n<p>如果 <code>xm≠yn</code> ，我们需要求解两个子问题，分别求 <code>Xm-1</code> ， <code>Y</code>  的一个 <code>LCS</code>  和 <code>X</code> ， <code>Yn-1</code>  的一个 <code>LCS</code> 。两个 <code>LCS</code>  中较长者就是 <code>X</code>  和 <code>Y</code>  的一个 <code>LCS</code> 。</p>\n<p>可以看出 <code>LCS</code>  问题具有重叠子问题性质。为了求 <code>X</code>  和 <code>Y</code>  的一个 <code>LCS</code> ，我们需要分别求出 <code>Xm-1</code> ， <code>Y</code>  的一个 <code>LCS</code>  和 <code>X</code> ， <code>Yn-1</code>  的一个 <code>LCS</code> ，这几个字问题又包含了求出 <code>Xm-1</code> ， <code>Yn-1</code>  的一个 <code>LCS</code>  的子子问题。（有点绕了。。。晕没晕。。。。）</p>\n<p>根据上面的分析，我们可以得出下面的公式；</p>\n<img data-src=\"/posts/a80d0031/2022-02-17-23-19-37.png\" class=\"\">\n<h3 id=\"计算最优的解\"><a class=\"markdownIt-Anchor\" href=\"#计算最优的解\">#</a> 计算最优的解</h3>\n<p>根据上面的，我们很容易就可以写出递归计算 <code>LCS</code>  问题的程序，通过这个程序我们可以求出各个子问题的 <code>LCS</code>  的值，此外，为了求解最优解本身，我们好需要一个表 <code>dp，dp[i，j]</code>  记录使 <code>C[i，j]</code>  取值的最优子结构。</p>\n<h3 id=\"数组的填表过程\"><a class=\"markdownIt-Anchor\" href=\"#数组的填表过程\">#</a> 数组的填表过程</h3>\n<img data-src=\"/posts/a80d0031/2022-02-17-23-19-46.png\" class=\"\">\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LCS</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findLCS</span><span class=\"params\">(String A, String B)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = A.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = B.length();</span><br><span class=\"line\">        <span class=\"comment\">//返回一个字符数组，该字符数组中存放了当前字符串中的所有字符</span></span><br><span class=\"line\">        <span class=\"comment\">//返回的是字符数组char[]a</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] a = A.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] b = B.toCharArray();</span><br><span class=\"line\">        <span class=\"comment\">//创建一个二维矩阵，用来推到公共子序列</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n][m];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果找到第一列其中一个字符等于第一行第一个字符</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[i] == b[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//找到第一列与第一行b[0]的相等的值，把其变成1</span></span><br><span class=\"line\">                dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">//并将其后面的字符都变成1</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                    dp[j][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果找到第一列其中一个字符等于第一行第一个字符</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b[i] == a[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//则把第一列后面的字符都变成1</span></span><br><span class=\"line\">                dp[<span class=\"number\">0</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                    dp[<span class=\"number\">0</span>][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//从1开始是因为横向和纵向下标为0的都遍历过了</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//横向和纵向有相等的值</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a[i] == b[j]) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//当前位置左边的值+1</span></span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//取当前位置（左边的值，上边的值）的最大值</span></span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i][j - <span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                System.out.print(dp[i][j] + <span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n - <span class=\"number\">1</span>][m - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LCS lcs = <span class=\"keyword\">new</span> LCS();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> findLCS = lcs.findLCS(<span class=\"string\">&quot;android&quot;</span>, <span class=\"string\">&quot;random&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;最长子序列长度：&quot;</span> + findLCS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Java面试",
                "动态规划"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/a4ce31d2/",
            "url": "https://smile1231.github.io/posts/a4ce31d2/",
            "title": "贪心算法",
            "date_published": "2022-02-17T14:58:04.000Z",
            "content_html": "<h1 id=\"贪心算法\"><a class=\"markdownIt-Anchor\" href=\"#贪心算法\">#</a> 贪心算法</h1>\n<h2 id=\"基本概念\"><a class=\"markdownIt-Anchor\" href=\"#基本概念\">#</a> 基本概念</h2>\n<p>所谓贪心算法是指，在对问题求解时，总是做出<strong>在当前看来是最好的选择</strong>。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p>\n<p>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p>\n<span id=\"more\"></span>\n<p><strong>所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</strong></p>\n<h2 id=\"贪心算法的基本思路\"><a class=\"markdownIt-Anchor\" href=\"#贪心算法的基本思路\">#</a> 贪心算法的基本思路</h2>\n<ol>\n<li>\n<p>建立数学模型来描述问题。</p>\n</li>\n<li>\n<p>把求解的问题分成若干个子问题。</p>\n</li>\n<li>\n<p>对每一子问题求解，得到子问题的局部最优解。</p>\n</li>\n<li>\n<p>把子问题的解局部最优解合成原来解问题的一个解。</p>\n</li>\n</ol>\n<h2 id=\"贪心算法的实现框架\"><a class=\"markdownIt-Anchor\" href=\"#贪心算法的实现框架\">#</a> 贪心算法的实现框架</h2>\n<p>贪心算法适用的前提是：局部最优策略能导致产生全局最优解</p>\n<p>实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从问题的某一初始解出发；</span><br><span class=\"line\"><span class=\"keyword\">while</span> （能朝给定总目标前进一步）</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">        利用可行的决策，求出可行解的一个解元素;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">由所有解元素组合成问题的一个可行解;</span><br></pre></td></tr></table></figure>\n<h2 id=\"贪心策略的选择\"><a class=\"markdownIt-Anchor\" href=\"#贪心策略的选择\">#</a> 贪心策略的选择</h2>\n<p>因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p>\n<h2 id=\"经典例题\"><a class=\"markdownIt-Anchor\" href=\"#经典例题\">#</a> 经典例题</h2>\n<p>下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。</p>\n<blockquote>\n<p>[背包问题] 有一个背包，背包容量是 <code>M=150</code> 。有 <code>7</code>  个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</p>\n</blockquote>\n  <figure class=\"highlight plaintext\"><figcaption><span>A     B    C    D     E     F    G</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">重量 35   30   60   50   40   10   25</span><br><span class=\"line\">价值 10   40   30   50   35   40   30</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">目标函数： `∑pi`最大（价值总和最大）</span><br><span class=\"line\">约束条件是装入的物品总重量不超过背包容量：`∑wi&lt;=M( M=<span class=\"number\">150</span>)`</span><br><span class=\"line\">    （<span class=\"number\">1</span>）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？</span><br><span class=\"line\">    （<span class=\"number\">2</span>）每次挑选所占重量最小的物品装入是否能得到最优解？</span><br><span class=\"line\">    （<span class=\"number\">3</span>）每次选取单位重量价值最大的物品，成为解本题的策略。</span><br></pre></td></tr></table></figure>\n<p>值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。</p>\n<p>比如，求最小生成树的 <code>Prim</code>  算法和 <code>Kruskal</code>  算法都是漂亮的贪心算法。</p>\n<p>贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。</p>\n<p>可惜的是，它需要证明后才能真正运用到题目的算法中。</p>\n<p>一般来说，<strong>贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于例题中的<span class=\"number\">3</span>种贪心策略，都是无法成立（无法被证明）的，解释如下：</span><br><span class=\"line\">   （<span class=\"number\">1</span>）贪心策略：选取价值最大者。反例：</span><br><span class=\"line\">   W=<span class=\"number\">30</span></span><br><span class=\"line\">   物品：<span class=\"keyword\">A</span>     B   C</span><br><span class=\"line\">   重量：<span class=\"number\">28</span>  <span class=\"number\">12</span>  <span class=\"number\">12</span></span><br><span class=\"line\">   价值：<span class=\"number\">30</span>  <span class=\"number\">20</span>  <span class=\"number\">20</span></span><br><span class=\"line\">   根据策略，首先选取物品<span class=\"keyword\">A</span>，接下来就无法再选取了，可是，选取B、C则更好。</span><br><span class=\"line\"></span><br><span class=\"line\">   （<span class=\"number\">2</span>）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。</span><br><span class=\"line\"></span><br><span class=\"line\">   （<span class=\"number\">3</span>）贪心策略：选取单位重量价值最大的物品。反例：</span><br><span class=\"line\">   W=<span class=\"number\">30</span></span><br><span class=\"line\">   物品： <span class=\"keyword\">A</span>   B    C</span><br><span class=\"line\">   重量：<span class=\"number\">28</span>  <span class=\"number\">20</span>  <span class=\"number\">10</span></span><br><span class=\"line\">   价值：<span class=\"number\">28</span>  <span class=\"number\">20</span>  <span class=\"number\">10</span></span><br><span class=\"line\">   根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择<span class=\"keyword\">A</span>，则答案错误。</span><br></pre></td></tr></table></figure>\n<p><strong>其实该情况是符合贪心策略的</strong>，因为该总情况不管先选哪两个都会把背包塞满，因为该题物品可以分割成任意大小，所以，就算空下一下，也可以将最后一个物品分割，放进去，它们的单位重量的价值是一样的，所以，最后背包最后重量相同，重量相同那么价值也相同。</p>\n<p><strong><font color='yellow'>所以采用第三种策略，代码如下：(不是最优解)</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreedyPackage</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> MAX_WEIGHT = <span class=\"number\">150</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] weights = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">35</span>, <span class=\"number\">30</span>, <span class=\"number\">60</span>, <span class=\"number\">50</span>, <span class=\"number\">40</span>, <span class=\"number\">10</span>, <span class=\"number\">25</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] values = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">50</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">packageGreedy</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity, <span class=\"keyword\">int</span> weights[], <span class=\"keyword\">int</span>[] values)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = weights.length;<span class=\"comment\">//物品的数量</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span>[] r = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>[n];<span class=\"comment\">//性价比数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] index = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];<span class=\"comment\">//性价比排序物品的下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            r[i] = (<span class=\"keyword\">double</span>) values[i] / weights[i];</span><br><span class=\"line\">            index[i] = i;<span class=\"comment\">//默认排序</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> temp = <span class=\"number\">0</span>;<span class=\"comment\">//对性价比进行排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//降序，对性价比和对应下标进行排序</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r[i] &lt; r[j]) &#123;</span><br><span class=\"line\">                    temp = r[i];</span><br><span class=\"line\">                    r[i] = r[j];</span><br><span class=\"line\">                    r[j] = temp;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> x = index[i];</span><br><span class=\"line\">                    index[i] = index[j];</span><br><span class=\"line\">                    index[j] = x;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//排序好的重量和价值分别存到数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] w1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] v1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"comment\">//排序好的重量和价值分别存到数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            w1[i] = weights[index[i]];</span><br><span class=\"line\">            v1[i] = values[index[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//用来装物品的数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] x = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"comment\">//放入物品的最大价值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//放入物品的总重量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalweights = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//物品重量比包的总容量小，表示还可以装得下</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (w1[i] &lt; capacity) &#123;</span><br><span class=\"line\">                x[i] = <span class=\"number\">1</span>;<span class=\"comment\">//表示该物品被装了</span></span><br><span class=\"line\">                maxValue += v1[i];</span><br><span class=\"line\">                System.out.println(w1[i] + <span class=\"string\">&quot;kg的物品被放进包包,价值：&quot;</span> + v1[i]);</span><br><span class=\"line\">                totalweights += w1[i];</span><br><span class=\"line\">                capacity = capacity - w1[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;总共放入的物品数量：&quot;</span> + Arrays.toString(x));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;总共放入的物品总重量&quot;</span> + totalweights);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;放入物品的最大价值：&quot;</span> + maxValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        GreedyPackage greedyPackage = <span class=\"keyword\">new</span> GreedyPackage();</span><br><span class=\"line\">        greedyPackage.packageGreedy(greedyPackage.MAX_WEIGHT, greedyPackage.weights, greedyPackage.values);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Java面试",
                "算法"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/7474c898/",
            "url": "https://smile1231.github.io/posts/7474c898/",
            "title": "分治算法",
            "date_published": "2022-02-17T14:57:48.000Z",
            "content_html": "<h1 id=\"分治算法\"><a class=\"markdownIt-Anchor\" href=\"#分治算法\">#</a> 分治算法</h1>\n<h2 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\">#</a> 定义</h2>\n<p>将原问题划分成 <code>n</code>  个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解</p>\n<h2 id=\"分治策略\"><a class=\"markdownIt-Anchor\" href=\"#分治策略\">#</a> 分治策略</h2>\n<p>“分而治之”，大问题能够拆成相似的小问题，记住这些小问题需要具有相似性。而后将小问题的每个解合成为大问题的解。所以说大问题如何拆，小问题如何合并才是这个算法最主要的一个思想。实际上很多算法如贪心算法，动态规划等等都是要求把大问题拆成小问题。而分治算法的重要一点就是要适用于能够重新把小问题的解合并为大问题的解。</p>\n<span id=\"more\"></span>\n<h2 id=\"使用分治算法的前提条件\"><a class=\"markdownIt-Anchor\" href=\"#使用分治算法的前提条件\">#</a> 使用分治算法的前提条件</h2>\n<ul>\n<li>原问题与分解成的小问题具有相同的模式；</li>\n<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，<strong>这一点是分治算法跟动态规划的明显区别；</strong></li>\n<li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li>\n<li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了</li>\n</ul>\n<h2 id=\"每一次递归都会涉及三个操作\"><a class=\"markdownIt-Anchor\" href=\"#每一次递归都会涉及三个操作\">#</a> 每一次递归都会涉及三个操作</h2>\n<ul>\n<li><strong>分解</strong>：将原问题分解成一系列子问题；</li>\n<li><strong>解决</strong>：递归地求解各个子问题，若子问题足够小，则直接求解；</li>\n<li><strong>合并</strong>：将子问题的结果合并成原问题</li>\n</ul>\n<h2 id=\"分治法适用条件\"><a class=\"markdownIt-Anchor\" href=\"#分治法适用条件\">#</a> 分治法适用条件</h2>\n<ol>\n<li>\n<p>该问题的规模缩小到一定程度就可以很容易解决；</p>\n</li>\n<li>\n<p>该问题可以分解为若干个规模较小的相同问题，这里注意是最优子结构性质；</p>\n</li>\n<li>\n<p>利用该问题分解出的子问题的解可以合并为该问题的解；</p>\n</li>\n<li>\n<p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共子问题；</p>\n</li>\n</ol>\n<p><strong>对于很多算法而言，第一条往往是必要的，因为数据量一旦大起来，问题往往复杂度上升的特别快。这里就需要将这个大问题分解为小问题。小问题处理起来更加方便。第二、三条的才是分治思想的核心，因为很多时候我们会采用递归的方式进行解决，所以在大问题分解为小问题的时候需要保证小问题之间的相同性。单单分解为小问题之后还不能算完成，必须要能够将小问题的解合并为这个问题的最终解才能算真正用到了分治的思想。最后一条也是最关键的，各个子问题之间必须要保证独立性，即不互相影响。如果相互之间有影响，这时候我们采用的是动态规划就更加好一点。</strong></p>\n<h2 id=\"经典例题\"><a class=\"markdownIt-Anchor\" href=\"#经典例题\">#</a> 经典例题</h2>\n<p>其实算法的思想不用讲太多，能够化为几句话是最好的，下面就举几个例子来看看分治算法：</p>\n<blockquote>\n<p>例题一：二分查找，给定一个按照升序排好的数组 <code>array</code> ，要在这个数组中找出一个特定的元素 <code>x</code> ；<br>\n当我们遇到一个问题，完全可以在心里问自己下面四个问题：</p>\n</blockquote>\n<p>1、当前问题能不能切分？</p>\n<p>答：能切分，因为数组按照升序来排列。所以当 x 大于某个元素 array [mid] 时，x 一定在 array [mid] 的右边。以此再来切分。每次切一半</p>\n<p>2、分解出来的子问题相同吗？</p>\n<p>答：相同，每个子问题的数据集都是父问题的 1/2 倍。并且每次只比较子问题的中间的数据</p>\n<p>3、子问题的解能合并为父问题的解吗？</p>\n<p>答：不需要合并，子问题的解即为父问题的解。</p>\n<p>4、子问题之间相互独立吗？</p>\n<p>答：独立，子问题只是判断，不需要和父问题有很强的关联性（这里可以参考一下动态规划算法，就能理解子问题之间怎么判断是独立的）</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>分治算法只是一种思想，不是一个具体的套路，只能说在碰见具体问题时我们能够从这个思路去思考，切分问题？合并问题？子问题之间影响关联大不大？这些都是具体问题具体考虑。还有很多很多题目是用了分治算法。也可以多刷刷题</p>\n<h2 id=\"循环赛日常表\"><a class=\"markdownIt-Anchor\" href=\"#循环赛日常表\">#</a> 循环赛日常表</h2>\n<p>设有 <code>n=2^k</code>  个运动员，要进行网球循环赛。现在要设计一个满足以下要求的比赛日程表</p>\n<p>（1）每个选手必须与其他 <code>n-1</code>  个选手各赛一场</p>\n<p>（2）每个选手一天只能赛一次</p>\n<p>（3）循环赛一共进行 <code>n-1</code>  天</p>\n<p>将比赛日程表设计成 <code>n</code>  行 <code>n</code>  列，表中除了第一列，其他 <code>n-1</code>  列才是我们要的，数组下标行列都从 <code>0</code>  开始，第 i 行 j 列代表第 <code>（i+1）</code> 位选手在第 j 天的对手：</p>\n<img data-src=\"/posts/7474c898/2022-02-17-23-08-53.png\" class=\"\">\n<p>以 8 个选手为例子</p>\n<img data-src=\"/posts/7474c898/2022-02-17-23-09-01.png\" class=\"\">\n<p>①我们先初始化第一行各个数为 <code>1~8</code> （ <code>2~8</code>  为：第 <code>1</code>  天 — 第 <code>7</code>  天）；</p>\n<p>②因为是递归，那么要填 8x8 的左下角和右下角，分别需要知道它的右上角和左上角</p>\n<p>③而 <code>8x8</code>  的盒子它的左上角是一个 <code>4x4</code>  的盒子，要填 <code>4x4</code>  的左下角和右下角，也分别需要知道它的右上角和左上角</p>\n<p>④现在递归到 <code>4x4</code>  的盒子的左上角，是一个 <code>2x2</code>  的盒子，它不需要递归了，直接沿对角线填左下角和右下角的数字，也就是上面的图②</p>\n<p>⑤可以看到，经过上面的②③步，我们左上角 4x4 的盒子，它的・右上角和左上角已经知道了，那就可以沿对角线填它的左下角和右下角了，所以出现了图④</p>\n<p>⑥其他的依次类推</p>\n<p>通俗易懂地讲，就是<strong>如果你想填一个大的，你得先得出它左上角和右上角两个盒子 ， 再沿对角线分别抄到右下角和左下角。 而为了得出它左上角和右上角，就需要递归了</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SportsSchedule</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleTable</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] table, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            table[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 填充左上区域矩阵</span></span><br><span class=\"line\"><span class=\"comment\">            n值的变化：8  4  2  1</span></span><br><span class=\"line\"><span class=\"comment\">            m值的变化：4  2  1  1  */</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = n / <span class=\"number\">2</span>;</span><br><span class=\"line\">            scheduleTable(table, m);</span><br><span class=\"line\">            <span class=\"comment\">//填充右上区域矩阵</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = m; j &lt; n; j++) &#123;</span><br><span class=\"line\">                    table[i][j] = table[i][j - m] + m;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//填充左下区域矩阵</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                    table[i][j] = table[i - m][j] + m;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//填充右下区域矩阵</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = m; j &lt; n; j++) &#123;</span><br><span class=\"line\">                    table[i][j] = table[i - m][j - m];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] table = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">8</span>][<span class=\"number\">8</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">8</span>;</span><br><span class=\"line\">        SportsSchedule schedule = <span class=\"keyword\">new</span> SportsSchedule();</span><br><span class=\"line\">        schedule.scheduleTable(table, n);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//打印二维数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                System.out.print(table[i][j] + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">                c++;<span class=\"comment\">//每打印一个数，c++</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c % n == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//说明打印一行了</span></span><br><span class=\"line\">                    System.out.println();<span class=\"comment\">//换行</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"l型骨牌棋盘覆盖\"><a class=\"markdownIt-Anchor\" href=\"#l型骨牌棋盘覆盖\">#</a>  <code>L</code>  型骨牌棋盘覆盖</h2>\n<h3 id=\"问题描述\"><a class=\"markdownIt-Anchor\" href=\"#问题描述\">#</a> 问题描述</h3>\n<p>在一个 <code>2^k×2^k </code> 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格（特殊点），且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的 4 种不同形态的 L 型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何 <code>2</code>  个 <code>L</code>  型骨牌不得重叠覆盖。</p>\n<img data-src=\"/posts/7474c898/2022-02-17-23-09-17.png\" class=\"\">\n<h3 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h3>\n<blockquote>\n<p>分析</p>\n</blockquote>\n<p>当 <code>k&gt;0</code>  时，将 <code>2^k×2^k</code>  棋盘分割为 <code>4</code>  个 <code>2^k-1×2^k-1</code>  子棋盘 <code>(a)</code>  所示。特殊方格必位于 <code>4</code>  个较小子棋盘之一中，其余 <code>3</code>  个子棋盘中无特殊方格。为了将这 <code>3</code>  个无特殊方格的子棋盘转化为特殊棋盘，可以用一个 <code>L</code>  型骨牌覆盖这 <code>3</code>  个较小棋盘的会合处，如  <code>(b)</code>  所示，从而将原问题转化为 <code>4</code>  个较小规模的棋盘覆盖问题。递归地使用这种分割，直至棋盘简化为棋盘 <code>1×1</code> 。</p>\n<img data-src=\"/posts/7474c898/2022-02-17-23-09-30.png\" class=\"\">\n<blockquote>\n<p>实现：</p>\n</blockquote>\n<p>每次都对分割后的四个小方块进行判断，判断特殊方格是否在里面。这里的判断的方法是每次先记录下整个大方块的左上角方格的行列坐标，然后再与特殊方格坐标进行比较，就可以知道特殊方格是否在该块中。如果特殊方块在里面，这直接递归下去求即可，如果不在，这根据分割的四个方块的不同位置，把右下角、左下角、右上角或者左上角的方格标记为特殊方块，然后继续递归。在递归函数里，还要有一个变量 subSize 来记录边的方格数，每次对方块进行划分时，边的方格数都会减半，这个变量是为了方便判断特殊方格的位置。</p>\n<blockquote>\n<p>覆盖步骤如图：</p>\n</blockquote>\n<img data-src=\"/posts/7474c898/2022-02-17-23-09-51.png\" class=\"\">\n<blockquote>\n<p>代码实现:</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cn.itcast.recursion;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessBoradProblem</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[][] board;<span class=\"comment\">//棋盘</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> specialRow;<span class=\"comment\">//特殊点行下标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> specialCol;<span class=\"comment\">//特殊点列下标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;<span class=\"comment\">//矩阵大小</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> type = <span class=\"number\">0</span>;<span class=\"comment\">//骨牌类型，1,2,3,4  因为是用数字表示的，所以用int</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChessBoradProblem</span><span class=\"params\">(<span class=\"keyword\">int</span> specialRow, <span class=\"keyword\">int</span> specialCol, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.specialRow = specialRow;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.specialCol = specialCol;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">        board = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[size][size];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> specialRow 特殊点的行下标</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> specialCol 特殊点的列下标</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leftRow    分割成4个后每个矩阵的左边的起点行下标</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leftCol    分割成4个后每个矩阵的左边起点列下标</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> size       矩阵的宽或者高</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//相对于四个方格中右上的方格，左边起点的leftRow不一定是0了</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ChessBoard</span><span class=\"params\">(<span class=\"keyword\">int</span> specialRow, <span class=\"keyword\">int</span> specialCol, <span class=\"keyword\">int</span> leftRow, <span class=\"keyword\">int</span> leftCol, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> subSize = size / <span class=\"number\">2</span>;</span><br><span class=\"line\">        type = type % <span class=\"number\">4</span> + <span class=\"number\">1</span>;<span class=\"comment\">//不断+1，超过4就取模</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = type;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//假设特殊点在左上角，然后行和列都小于一半</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specialRow &lt; leftRow + subSize &amp;&amp; specialCol &lt; leftCol + subSize) &#123;</span><br><span class=\"line\">            ChessBoard(specialRow, specialCol, leftRow, leftCol, subSize);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//不在左上角，左上角矩阵的右下角就是特殊点</span></span><br><span class=\"line\">            board[leftRow + subSize - <span class=\"number\">1</span>][leftCol + subSize - <span class=\"number\">1</span>] = n;</span><br><span class=\"line\">            ChessBoard(leftRow + subSize - <span class=\"number\">1</span>, leftRow + subSize - <span class=\"number\">1</span>, leftRow, leftCol, subSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//特殊点在右上方，行小于一半，列大于一半</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specialRow &lt; leftRow + subSize &amp;&amp; specialCol &gt;= leftCol + subSize) &#123;</span><br><span class=\"line\">            ChessBoard(specialRow, specialCol, leftRow, leftCol + subSize, subSize);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            board[leftRow + subSize - <span class=\"number\">1</span>][leftCol + subSize] = n;</span><br><span class=\"line\">            ChessBoard(leftRow + subSize - <span class=\"number\">1</span>, leftCol + subSize, leftRow, leftCol + subSize, subSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//特殊点在左下方</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specialRow &gt;= leftRow + subSize &amp;&amp; specialCol &lt; leftCol + subSize) &#123;</span><br><span class=\"line\">            ChessBoard(specialRow, specialCol, leftRow + subSize, leftCol, subSize);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            board[leftRow + subSize][leftCol + subSize - <span class=\"number\">1</span>] = n;</span><br><span class=\"line\">            ChessBoard(leftRow + subSize, leftCol + subSize - <span class=\"number\">1</span>, leftRow + subSize, leftCol, subSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//特殊点在右下方</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specialRow &gt;= leftRow + subSize &amp;&amp; specialCol &gt;= leftCol + subSize) &#123;</span><br><span class=\"line\">            ChessBoard(specialRow, specialCol, leftRow + subSize, leftCol + subSize, subSize);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            board[leftRow + subSize][leftCol + subSize] = n;</span><br><span class=\"line\">            ChessBoard(leftRow + subSize, leftCol + subSize, leftRow + subSize, leftCol + subSize, subSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printBoard</span><span class=\"params\">(<span class=\"keyword\">int</span> specialRow, <span class=\"keyword\">int</span> specialCol, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        ChessBoard(specialRow, specialCol, <span class=\"number\">0</span>, <span class=\"number\">0</span>, size);</span><br><span class=\"line\">        printResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">printResult</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; size; j++) &#123;</span><br><span class=\"line\">                System.out.print(board[i][j] + <span class=\"string\">&quot; &quot;</span>);<span class=\"comment\">//注意：print</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = <span class=\"number\">4</span>;<span class=\"comment\">//矩阵大小</span></span><br><span class=\"line\">        <span class=\"comment\">//选取特殊点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> specialRow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specialCol = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ChessBoradProblem boradProblem = <span class=\"keyword\">new</span> ChessBoradProblem(specialRow, specialCol, N);</span><br><span class=\"line\">        boradProblem.printBoard(specialRow, specialCol, N);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Java面试",
                "算法"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/b9b9f7e7/",
            "url": "https://smile1231.github.io/posts/b9b9f7e7/",
            "title": "二叉树遍历",
            "date_published": "2022-02-17T14:52:52.000Z",
            "content_html": "<h1 id=\"二叉树遍历前序-中序-后序-层次遍历\"><a class=\"markdownIt-Anchor\" href=\"#二叉树遍历前序-中序-后序-层次遍历\">#</a> 二叉树遍历（前序、中序、后序、层次遍历）</h1>\n<p>二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆了。所以，对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。</p>\n<p>四种主要的遍历思想为：</p>\n<span id=\"more\"></span>\n<p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p>\n<p>中序遍历：左子树 —&gt; 根结点 —&gt; 右子树</p>\n<p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p>\n<p>层次遍历：只需按层次遍历即可</p>\n<p>例如，求下面二叉树的各种遍历</p>\n<img data-src=\"/posts/b9b9f7e7/2022-02-17-22-57-21.png\" class=\"\">\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">前序遍历：1 <span class=\"number\"> 2 </span><span class=\"number\"> 4 </span><span class=\"number\"> 5 </span><span class=\"number\"> 7 </span><span class=\"number\"> 8 </span><span class=\"number\"> 3 </span><span class=\"number\"> 6 </span></span><br><span class=\"line\"></span><br><span class=\"line\">中序遍历：4 <span class=\"number\"> 2 </span><span class=\"number\"> 7 </span><span class=\"number\"> 5 </span><span class=\"number\"> 8 </span><span class=\"number\"> 1 </span><span class=\"number\"> 3 </span> 6</span><br><span class=\"line\"></span><br><span class=\"line\">后序遍历：4 <span class=\"number\"> 7 </span><span class=\"number\"> 8 </span><span class=\"number\"> 5 </span><span class=\"number\"> 2 </span><span class=\"number\"> 6 </span><span class=\"number\"> 3 </span> 1</span><br><span class=\"line\"></span><br><span class=\"line\">层次遍历：1 <span class=\"number\"> 2 </span><span class=\"number\"> 3 </span><span class=\"number\"> 4 </span><span class=\"number\"> 5 </span><span class=\"number\"> 6 </span><span class=\"number\"> 7 </span> 8</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-前序遍历\"><a class=\"markdownIt-Anchor\" href=\"#1-前序遍历\">#</a> 1. 前序遍历</h2>\n<ol>\n<li>\n<p>根据上文提到的遍历思路， <code>根结点 ---&gt; 左子树 ---&gt; 右子树</code> ，很容易写出递归版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrderTraverse1</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tSystem.out.print(root.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t\tpreOrderTraverse1(root.left);</span><br><span class=\"line\">\t\tpreOrderTraverse1(root.right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>现在讨论非递归的版本：</p>\n<p>根据前序遍历的顺序，优先访问根结点，然后在访问左子树和右子树。所以，对于任意结点 <code>node</code> ，第一部分即直接访问之，之后在判断左子树是否为空，不为空时即重复上面的步骤，直到其为空。若为空，则需要访问右子树。注意，在访问过左孩子之后，需要反过来访问其右孩子，所以，需要<strong>栈</strong>这种数据结构的支持。对于任意一个结点 <code>node</code> ，具体步骤如下：</p>\n<p>a) 访问之，并把结点 <code>node</code>  入栈，当前结点置为左孩子；</p>\n<p>b) 判断结点 <code>node</code>  是否为空，若为空，则取出栈顶结点并出栈，将右孩子置为当前结点；否则重复 <code>a)</code>  步直到当前结点为空或者栈为空（可以发现栈中的结点就是为了访问右孩子才存储的）</p>\n<p>代码如下:</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrderTraverse2</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\tLinkedList&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">\tTreeNode pNode = root;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pNode != <span class=\"keyword\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.print(pNode.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t\t\tstack.push(pNode);</span><br><span class=\"line\">\t\t\tpNode = pNode.left;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class=\"line\">\t\t\tTreeNode node = stack.pop();</span><br><span class=\"line\">\t\t\tpNode = node.right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"2-中序遍历\"><a class=\"markdownIt-Anchor\" href=\"#2-中序遍历\">#</a> 2. 中序遍历</h2>\n<ol>\n<li>根据上文提到的遍历思路： <code>左子树 ---&gt; 根结点 ---&gt; 右子树</code> ，很容易写出递归版本： <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrderTraverse1</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tinOrderTraverse1(root.left);</span><br><span class=\"line\">\t\tSystem.out.print(root.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t\tinOrderTraverse1(root.right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>非递归实现，有了上面前序的解释，中序也就比较简单了，相同的道理。只不过访问的顺序移到出栈时。代码如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrderTraverse2</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\tLinkedList&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">\tTreeNode pNode = root;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pNode != <span class=\"keyword\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tstack.push(pNode);</span><br><span class=\"line\">\t\t\tpNode = pNode.left;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class=\"line\">\t\t\tTreeNode node = stack.pop();</span><br><span class=\"line\">\t\t\tSystem.out.print(node.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t\t\tpNode = node.right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"3-后续遍历\"><a class=\"markdownIt-Anchor\" href=\"#3-后续遍历\">#</a> 3. 后续遍历</h2>\n<ol>\n<li>根据上文提到的遍历思路： <code>左子树 ---&gt; 右子树 ---&gt; 根结点</code> ，很容易写出递归版本： <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postOrderTraverse1</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tpostOrderTraverse1(root.left);</span><br><span class=\"line\">\t\tpostOrderTraverse1(root.right);</span><br><span class=\"line\">\t\tSystem.out.print(root.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"4-层次遍历\"><a class=\"markdownIt-Anchor\" href=\"#4-层次遍历\">#</a> 4. 层次遍历</h2>\n<p>层次遍历的代码比较简单，只需要一个队列即可，先在队列中加入根结点。之后对于任意一个结点来说，在其出队列的时候，访问之。同时如果左孩子和右孩子有不为空的，入队列。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">levelTraverse</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LinkedList&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    queue.offer(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode node = queue.poll();</span><br><span class=\"line\">        System.out.print(node.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            queue.offer(node.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            queue.offer(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二叉树的深度优先遍历dfs与广度优先遍历bfs\"><a class=\"markdownIt-Anchor\" href=\"#二叉树的深度优先遍历dfs与广度优先遍历bfs\">#</a> 二叉树的深度优先遍历（ <code>DFS</code> ）与广度优先遍历（ <code>BFS</code> ）</h1>\n<p>二叉树的深度优先遍历（ <code>DFS</code> ）与广度优先遍历（ <code>BFS</code> ）</p>\n<ul>\n<li>\n<p><strong>深度优先遍历</strong>：从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点为止。</p>\n</li>\n<li>\n<p><strong>广度优先遍历</strong>：从根节点出发，在横向遍历二叉树层段节点的基础上纵向遍历二叉树的层次。</p>\n</li>\n</ul>\n<img data-src=\"/posts/b9b9f7e7/2022-02-17-23-00-13.png\" class=\"\">\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">DFS:</span>ABDECFG</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">BFS:</span>ABCDEFG</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><code>DFS</code>  实现：</p>\n<p>数据结构：栈</p>\n<p>父节点入栈，父节点出栈，先右子节点入栈，后左子节点入栈。递归遍历全部节点即可</p>\n</li>\n<li>\n<p><code>BFS</code>  实现：</p>\n<p>数据结构：队列</p>\n<p>父节点入队，父节点出队列，先左子节点入队，后右子节点入队。递归遍历全部节点即可</p>\n</li>\n</ul>\n<img data-src=\"/posts/b9b9f7e7/2022-02-17-23-00-38.png\" class=\"\">\n<p>深度优先搜索的步骤为：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）、首先节点<span class=\"number\"> 1 </span>进栈，节点1在栈顶；</span><br><span class=\"line\"></span><br><span class=\"line\">（2）、然后节点1出栈，访问节点1，节点1的孩子节点3进栈，节点2进栈；</span><br><span class=\"line\"></span><br><span class=\"line\">（3）、节点2在栈顶，然后节点2出栈，访问节点2</span><br><span class=\"line\"></span><br><span class=\"line\">（4）、节点2的孩子节点5进栈，节点4进栈</span><br><span class=\"line\"></span><br><span class=\"line\">（5）、节点4在栈顶，节点4出栈，访问节点4，</span><br><span class=\"line\"></span><br><span class=\"line\">（6）、节点4左右孩子为空，然后节点5在栈顶，节点5出栈，访问节点5；</span><br><span class=\"line\"></span><br><span class=\"line\">（7）、节点5左右孩子为空，然后节点3在站顶，节点3出栈，访问节点3；</span><br><span class=\"line\"></span><br><span class=\"line\">（8）、节点3的孩子节点7进栈，节点6进栈</span><br><span class=\"line\"></span><br><span class=\"line\">（9）、节点6在栈顶，节点6出栈，访问节点6；</span><br><span class=\"line\"></span><br><span class=\"line\">（10）、节点6的孩子为空，这个时候节点7在栈顶，节点7出栈，访问节点7</span><br><span class=\"line\"></span><br><span class=\"line\">（11）、节点7的左右孩子为空，此时栈为空，遍历结束。</span><br></pre></td></tr></table></figure>\n<p>广度优先遍历：广度优先遍历是连通图的一种遍历策略，因为它的思想是从一个顶点 V0 开始，辐射状地优先遍历其周围较广的区域故得名。</p>\n<p>根据广度优先遍历的特点我们利用 Java 数据结构队列 Queue 来实现。</p>\n<p>广度优先搜索的步骤为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）、节点1进队，节点1出队，访问节点1</span><br><span class=\"line\"></span><br><span class=\"line\">（2）、节点1的孩子节点2进队，节点3进队。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）、节点2出队，访问节点2，节点2的孩子节点4进队，节点5进队；</span><br><span class=\"line\"></span><br><span class=\"line\">（4）、节点3出队，访问节点3，节点3的孩子节点6进队，节点7进队；</span><br><span class=\"line\"></span><br><span class=\"line\">（5）、节点4出队，访问节点4，节点4没有孩子节点。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）、节点5出队，访问节点5，节点5没有孩子节点。</span><br><span class=\"line\"></span><br><span class=\"line\">（7）、节点6出队，访问节点6，节点6没有孩子节点。</span><br><span class=\"line\"></span><br><span class=\"line\">（8）、节点7出队，访问节点7，节点7没有孩子节点，结束。</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-深度优先遍历\"><a class=\"markdownIt-Anchor\" href=\"#5-深度优先遍历\">#</a> 5. 深度优先遍历</h2>\n<p>其实深度遍历就是上面的前序、中序和后序。但是为了保证与广度优先遍历相照应，也写在这。代码也比较好理解，其实就是前序遍历，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">depthOrderTraverse</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LinkedList&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode node = stack.pop();</span><br><span class=\"line\">        System.out.print(node.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            stack.push(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            stack.push(node.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-广度优先遍历\"><a class=\"markdownIt-Anchor\" href=\"#6-广度优先遍历\">#</a> 6. 广度优先遍历</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">depthFirstSearch</span><span class=\"params\">(TreeNode nodeHead)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nodeHead==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; myStack=<span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    myStack.add(nodeHead);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!myStack.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode node=myStack.pop();    <span class=\"comment\">//弹出栈顶元素</span></span><br><span class=\"line\">        System.out.print(node.data+<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node.rightNode!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            myStack.push(node.rightNode);    <span class=\"comment\">//深度优先遍历，先遍历左边，后遍历右边,栈先进后出</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node.leftNode!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            myStack.push(node.leftNode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Java面试",
                "算法"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/7e4601e3/",
            "url": "https://smile1231.github.io/posts/7e4601e3/",
            "title": "面试之旅之关于Spring事务处理",
            "date_published": "2022-02-16T13:14:23.000Z",
            "content_html": "<h1 id=\"spring事务处理\"><a class=\"markdownIt-Anchor\" href=\"#spring事务处理\">#</a>  <code>Spring</code>  事务处理</h1>\n<h2 id=\"spring和事务的关系\"><a class=\"markdownIt-Anchor\" href=\"#spring和事务的关系\">#</a>  <code>Spring</code>  和事务的关系</h2>\n<p>关系型数据库、某些消息队列等产品或中间件称为事务性资源，因为它们本身支持事务，也能够处理事务。</p>\n<p><code>Spring</code>  很显然不是事务性资源，但是它可以管理事务性资源，所以 <code>Spring</code>  和事务之间是管理关系。</p>\n<p>就像 <code>Jack Ma</code>  虽然不会写代码，但是他却管理者一大批会写代码的码农。</p>\n<span id=\"more\"></span>\n<h2 id=\"spring事务三要素\"><a class=\"markdownIt-Anchor\" href=\"#spring事务三要素\">#</a>  <code>Spring</code>  事务三要素</h2>\n<ul>\n<li>\n<p>数据源：表示具体的事务性资源，是事务的真正处理者，如 <code>MySQL</code>  等。</p>\n</li>\n<li>\n<p>事务管理器：像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。</p>\n</li>\n<li>\n<p>事务应用和属性配置：像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属性如隔离级别、超时时间等。</p>\n</li>\n</ul>\n<h2 id=\"spring事务的注解配置\"><a class=\"markdownIt-Anchor\" href=\"#spring事务的注解配置\">#</a>  <code>Spring</code>  事务的注解配置</h2>\n<ul>\n<li>\n<p>把一个 <code>DataSource（如DruidDataSource）</code> 作为一个 <code>@Bean</code>  注册到 <code>Spring</code>  容器中，配置好事务性资源。</p>\n</li>\n<li>\n<p>把一个 <code>@EnableTransactionManagement</code>  注解放到一个 <code>@Configuration</code>  类上，配置好事务管理器，并启用事务管理。</p>\n</li>\n<li>\n<p>把一个 <code>@Transactional</code>  注解放到类上或方法上，可以设置注解的属性，表明该方法按配置好的属性参与到事务中。</p>\n</li>\n</ul>\n<h2 id=\"事务注解的本质\"><a class=\"markdownIt-Anchor\" href=\"#事务注解的本质\">#</a> 事务注解的本质</h2>\n<ul>\n<li>\n<p><code>@Transactional</code>  这个注解仅仅是一些（和事务相关的）元数据，在运行时被事务基础设施读取消费，并使用这些元数据来配置 <code>bean</code>  的事务行为。</p>\n</li>\n<li>\n<p>大致来说具有两方面功能，一是表明该方法要参与事务，二是配置相关属性来定制事务的参与方式和运行行为。</p>\n</li>\n</ul>\n<h2 id=\"spring声明式事务实现原理\"><a class=\"markdownIt-Anchor\" href=\"#spring声明式事务实现原理\">#</a>  <code>Spring</code>  声明式事务实现原理</h2>\n<p>声明式事务成为可能，主要得益于 <code>Spring AOP</code> 。使用一个事务拦截器，在方法调用的前后 / 周围进行事务性增强（ <code>advice</code> ），来驱动事务完成。</p>\n<h2 id=\"如何回滚一个事务\"><a class=\"markdownIt-Anchor\" href=\"#如何回滚一个事务\">#</a> 如何回滚一个事务</h2>\n<p>就是在一个事务上下文中当前正在执行的代码里抛出一个异常，事务基础设施代码会捕获任何未处理的异常，并且做出决定是否标记这个事务为回滚。</p>\n<h2 id=\"默认回滚规则\"><a class=\"markdownIt-Anchor\" href=\"#默认回滚规则\">#</a> 默认回滚规则</h2>\n<p>默认只把 <code>runtime</code> ,  <code>unchecked exceptions</code>  标记为回滚，即 <code>RuntimeException</code>  及其子类， <code>Error</code>  默认也导致回滚。 <code>Checked exceptions</code>  默认不导致回滚。这些规则和 <code>EJB</code>  是一样的。</p>\n<h2 id=\"如何配置回滚异常\"><a class=\"markdownIt-Anchor\" href=\"#如何配置回滚异常\">#</a> 如何配置回滚异常</h2>\n<p>使用 <code>@Transactional</code>  注解的 <code>rollbackFor/rollbackForClassName</code>  属性，可以精确配置导致回滚的异常类型，包括 <code>checked exceptions</code> 。</p>\n<p><code>noRollbackFor/noRollbackForClassName</code>  属性，可以配置不导致回滚的异常类型，当遇到这样的未处理异常时，照样提交相关事务。</p>\n<h2 id=\"事务注解在类方法上\"><a class=\"markdownIt-Anchor\" href=\"#事务注解在类方法上\">#</a> 事务注解在类 / 方法上</h2>\n<p><code>@Transactional</code>  注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的所有方法。如果此时方法上也标注了，则方法上的优先级高。</p>\n<h2 id=\"事务注解在类上的继承性\"><a class=\"markdownIt-Anchor\" href=\"#事务注解在类上的继承性\">#</a> 事务注解在类上的继承性</h2>\n<p><code>@Transactional</code>  注解的作用可以传播到子类，即如果父类标了子类就不用标了。但倒过来就不行了。</p>\n<p>子类标了，并不会传到父类，所以父类方法不会有事务。父类方法需要在子类中重新声明而参与到子类上的注解，这样才会有事务。</p>\n<h2 id=\"事务注解在接口类上\"><a class=\"markdownIt-Anchor\" href=\"#事务注解在接口类上\">#</a> 事务注解在接口 / 类上</h2>\n<p><code>@Transactional</code>  注解可以用在接口上，也可以在类上。在接口上时，必须使用基于接口的代理才行，即 <code>JDK</code>  动态代理。</p>\n<p>事实是 <code>Java</code>  的注解不能从接口继承，如果你使用基于类的代理，即 <code>CGLIB</code> ，或基于织入方面，即 <code>AspectJ</code> ，事务设置不会被代理和织入基础设施认出来，目标对象不会被包装到一个事务代理中。</p>\n<p><code>Spring</code>  团队建议注解标注在类上而非接口上。</p>\n<h2 id=\"只在public方法上生效\"><a class=\"markdownIt-Anchor\" href=\"#只在public方法上生效\">#</a> 只在 <code>public</code>  方法上生效？</h2>\n<p>当采用代理来实现事务时，（注意是代理）， <code>@Transactional</code>  注解只能应用在 <code>public</code>  方法上。当标记在 <code>protected、private、package-visible</code>  方法上时，不会产生错误，但也不会表现出为它指定的事务配置。可以认为它作为一个普通的方法参与到一个 <code>public</code>  方法的事务中。</p>\n<p>如果想在非 <code>public</code>  方法上生效，考虑使用 <code>AspectJ（织入方式）</code> 。</p>\n<h2 id=\"目标类里的自我调用没有事务\"><a class=\"markdownIt-Anchor\" href=\"#目标类里的自我调用没有事务\">#</a> 目标类里的自我调用没有事务？</h2>\n<p>在代理模式中（这是默认的），只有从外部的方法调用进入通过代理会被拦截，这意味着自我调用（实际就是，目标对象中的一个方法调用目标对象的另一个方法）在运行时不会导致一个实际的事务，即使被调用的方法标有注解。</p>\n<p>如果你希望自我调用也使用事务来包装，考虑使用 <code>AspectJ</code>  的方式。在这种情况下，首先是没有代理。相反，目标类被织入（即它的字节码被修改）来把 <code>@Transactional</code>  加入到运行时行为，在任何种类的方法上都可以。</p>\n<h2 id=\"事务与线程\"><a class=\"markdownIt-Anchor\" href=\"#事务与线程\">#</a> 事务与线程</h2>\n<p>和 <code>JavaEE</code>  事务上下文一样， <code>Spring</code>  事务和一个线程的执行相关联，底层是一个 <code>ThreadLocal&lt;Map&lt;Object, Object&gt;&gt;</code> ，就是每个线程一个 <code>map</code> ， <code>key</code>  是 <code>DataSource</code> ， <code>value</code>  是 <code>Connection</code> 。</p>\n<h2 id=\"逻辑事务与物理事务\"><a class=\"markdownIt-Anchor\" href=\"#逻辑事务与物理事务\">#</a> 逻辑事务与物理事务</h2>\n<p>事务性资源实际打开的事务就是物理事务，如数据库的 <code>Connection</code>  打开的事务。 <code>Spring</code>  会为每个 <code>@Transactional</code>  方法创建一个事务范围，可以理解为是逻辑事务。</p>\n<p>在逻辑事务中，大范围的事务称为外围事务，小范围的事务称为内部事务，外围事务可以包含内部事务，但在逻辑上是互相独立的。每一个这样的逻辑事务范围，都能够单独地决定 <code>rollback-only</code>  状态。</p>\n<p>那么如何处理逻辑事务和物理事务之间的关联关系呢，这就是传播特性解决的问题。</p>\n<h2 id=\"事务传播行为\"><a class=\"markdownIt-Anchor\" href=\"#事务传播行为\">#</a> 事务传播行为</h2>\n<p>事务传播行为 (为了解决业务层方法之间互相调用的事务问题): 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p>\n<p>例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在 <code>TransactionDefinition</code>  定义中包括了如下几个表示传播行为的常量:</p>\n<p><code>REQUIRED，SUPPORTS，MANDATORY，REQUIRES_NEW，NOT_SUPPORTED，NEVER，NESTED</code></p>\n<blockquote>\n<p>支持当前事务的情况:</p>\n</blockquote>\n<ul>\n<li><code>TransactionDefinition.PROPAGATION_REQUIRED:</code>  如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>\n<li><code>TransactionDefinition.PROPAGATION_SUPPORTS:</code>  如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>\n<li><code>TransactionDefinition.PROPAGATION_MANDATORY:</code>  如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。( <code>mandatory:强制性</code> )</li>\n</ul>\n<blockquote>\n<p>不支持当前事务的情况:</p>\n</blockquote>\n<ul>\n<li><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW:</code>  创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>\n<li><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED:</code>  以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>\n<li><code>TransactionDefinition.PROPAGATION_NEVER:</code>  以非事务方式运行，如果当前存在事务，则抛出异常。</li>\n</ul>\n<blockquote>\n<p>其他情况:</p>\n</blockquote>\n<ul>\n<li><code>TransactionDefinition.PROPAGATION_NESTED: </code> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 <code>TransactionDefinition.PROPAGATION_REQUIRED。</code></li>\n</ul>\n<h2 id=\"隔离级别\"><a class=\"markdownIt-Anchor\" href=\"#隔离级别\">#</a> 隔离级别</h2>\n<p><code>TransactionDefinition</code>  接口中定义了 <code>五个</code> 表示隔离级别的常量:</p>\n<p><code>DEFAULT，READ_UNCOMMITTED，READ_COMMITTED，REPEATABLE_READ，SERIALIZABLE</code></p>\n<ul>\n<li><code>TransactionDefinition.ISOLATION_DEFAULT:</code>  使用后端数据库默认的隔离级别， <code>Mysql</code>  默认采用的 <code>REPEATABLE_READ</code>  隔离级别  <code>Oracle</code>  默认采用的  <code>READ_COMMITTED</code>  隔离级别。</li>\n<li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED: </code> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>\n<li><code>TransactionDefinition.ISOLATION_READ_COMMITTED:</code>  允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>\n<li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ:</code>  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>\n<li><code>TransactionDefinition.ISOLATION_SERIALIZABLE:</code>  最高的隔离级别，完全服从 <code>ACID</code>  的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>\n</ul>\n<blockquote>\n<p>脏读</p>\n</blockquote>\n<p>一个事务修改了一行数据但没有提交，第二个事务可以读取到这行被修改的数据，如果第一个事务回滚，第二个事务获取到的数据将是无效的。</p>\n<blockquote>\n<p>不可重复读</p>\n</blockquote>\n<p>一个事务读取了一行数据，第二个事务修改了这行数据，第一个事务重新读取这行数据，将获得到不同的值。</p>\n<blockquote>\n<p>幻读</p>\n</blockquote>\n<p>一个事务按照一个 <code>where</code>  条件读取所有符合的数据行，第二个事务插入了一行数据且恰好也满足这个 <code>where</code>  条件，第一个事务再以这个 <code>where</code>  条件重新读取，将会获取额外多出来的这一行。</p>\n<p><strong>帮助记忆：</strong><br>\n写读是脏读，读写读是不可重复读， <code>where insert where</code>  是幻读。</p>\n<img data-src=\"/posts/7e4601e3/2022-02-16-21-43-16.png\" class=\"\">\n",
            "tags": [
                "Java面试",
                "Spring事务"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/6b5f7afc/",
            "url": "https://smile1231.github.io/posts/6b5f7afc/",
            "title": "面试之旅关于Java知识点",
            "date_published": "2022-02-16T13:14:07.000Z",
            "content_html": "<h1 id=\"java知识点\"><a class=\"markdownIt-Anchor\" href=\"#java知识点\">#</a>  <code>Java</code>  知识点</h1>\n<h2 id=\"collection类\"><a class=\"markdownIt-Anchor\" href=\"#collection类\">#</a>  <code>Collection</code>  类</h2>\n<img data-src=\"/posts/6b5f7afc/2022-02-16-21-41-42.png\" class=\"\">\n<span id=\"more\"></span>\n<blockquote>\n<p><code>Collection</code></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">子接口</span><br><span class=\"line\"></span><br><span class=\"line\">\tSet,List</span><br><span class=\"line\">集合中只能放置对象的引用,不能放置原生数据类型,</span><br><span class=\"line\"></span><br><span class=\"line\">我们需要使用原生数据类型的封装类才能加入到集合中</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Ordered</code>  与 <code>Sorted</code>  接口</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ordered排序,按照某种由具体情况决定的顺序排序,是后天指定的</span><br><span class=\"line\"></span><br><span class=\"line\">Sorted排序,按照天然顺序进行排序,是先天指定的</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>List</code></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">实现类包括</span><br><span class=\"line\">\tLinkedList,Vector,ArrayList</span><br><span class=\"line\">列表接口,继承与Collection,可以按索引的顺序访问,有索引的Collection</span><br><span class=\"line\">\t具有列表的功能,元素顺序均是按添加的先后进行排列的,</span><br><span class=\"line\">\t允许重复的元素,允许多个<span class=\"keyword\">null</span>元素</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Java面试"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/666b2933/",
            "url": "https://smile1231.github.io/posts/666b2933/",
            "title": "面试之旅关于数据库",
            "date_published": "2022-02-16T13:13:54.000Z",
            "content_html": "<h1 id=\"常见面试题整理数据库篇每位开发者必备\"><a class=\"markdownIt-Anchor\" href=\"#常见面试题整理数据库篇每位开发者必备\">#</a> 常见面试题整理–数据库篇（每位开发者必备）</h1>\n<img data-src=\"/posts/666b2933/2022-02-16-21-40-29.png\" class=\"\">\n<h2 id=\"1-什么是存储过程有哪些优缺点\"><a class=\"markdownIt-Anchor\" href=\"#1-什么是存储过程有哪些优缺点\">#</a> 1. 什么是存储过程？有哪些优缺点？</h2>\n<span id=\"more\"></span>\n<p>存储过程是一些预编译的 <code>SQL</code>  语句。</p>\n<p>更加直白的理解：存储过程可以说是一个记录集，它是由一些 <code>T-SQL</code>  语句组成的代码块，这些 <code>T-SQL</code>  语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。</p>\n<p>存储过程是一个预编译的代码块，执行效率比较高<br>\n一个存储过程替代大量 <code>T_SQL</code>  语句 ，可以降低网络通信量，提高通信速率<br>\n可以一定程度上确保数据安全</p>\n<h2 id=\"2-索引是什么有什么作用以及优缺点\"><a class=\"markdownIt-Anchor\" href=\"#2-索引是什么有什么作用以及优缺点\">#</a> 2. 索引是什么？有什么作用以及优缺点</h2>\n<p>索引是对数据库表中一或多个列的值进行排序的结构，是帮助 <code>MySQL</code>  高效获取数据的数据结构</p>\n<p>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</p>\n<p><code>MySQL</code>  数据库几个基本的索引类型：<em> <code>普通索引</code> 、 <code>唯一索引</code> 、 <code>主键索引</code> 、 <code>全文索引</code> </em></p>\n<ul>\n<li>索引加快数据库的检索速度</li>\n<li>索引降低了插入、删除、修改等维护任务的速度</li>\n<li>唯一索引可以确保每一行数据的唯一性</li>\n<li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li>\n<li>索引需要占物理和数据空间</li>\n</ul>\n<h2 id=\"3-什么是事务\"><a class=\"markdownIt-Anchor\" href=\"#3-什么是事务\">#</a> 3. 什么是事务？</h2>\n<p>事务（ <code>Transaction</code> ）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</p>\n<h2 id=\"4-数据库的乐观锁和悲观锁是什么\"><a class=\"markdownIt-Anchor\" href=\"#4-数据库的乐观锁和悲观锁是什么\">#</a> 4. 数据库的乐观锁和悲观锁是什么？</h2>\n<p>数据库管理系统（ <code>DBMS</code> ）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p>\n<p>乐观并发控制 (乐观锁) 和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>\n<ul>\n<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</li>\n<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li>\n</ul>\n<h2 id=\"5-使用索引查询一定能提高查询的性能吗为什么\"><a class=\"markdownIt-Anchor\" href=\"#5-使用索引查询一定能提高查询的性能吗为什么\">#</a> 5. 使用索引查询一定能提高查询的性能吗？为什么</h2>\n<p>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价.</p>\n<p>索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的 <code>INSERT,DELETE,UPDATE</code>  将为此多付出 <code>4,5次</code> 的磁盘 <code>I/O</code> . 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询 ( <code>INDEX RANGE SCAN</code> ) 适用于两种情况:</p>\n<p>基于一个范围的检索，一般查询返回结果集小于表中记录数的 <code>30%</code>  基于非唯一性索引的检索</p>\n<h2 id=\"6-简单说一说drop-delete与truncate的区别\"><a class=\"markdownIt-Anchor\" href=\"#6-简单说一说drop-delete与truncate的区别\">#</a> 6. 简单说一说 <code>drop</code> 、 <code>delete</code>  与 <code>truncate</code>  的区别</h2>\n<p><code>SQL</code>  中的 <code>drop</code> 、 <code>delete</code> 、 <code>truncate</code>  都表示删除，但是三者有一些差别</p>\n<ul>\n<li><code>delete</code>  和 <code>truncate</code>  只删除表的数据不删除表的结构</li>\n<li>速度，一般来说:  <code>drop &gt; truncate &gt;delete</code></li>\n<li><code>delete</code>  语句是 <code>dml</code> , 这个操作会放到 <code>rollback segement</code>  中，事务提交之后才生效；</li>\n<li>如果有相应的 <code>trigger</code> , 执行的时候将被触发.  <code>truncate,drop</code>  是 <code>ddl</code> , 操作立即生效，原数据不放到 <code>rollback segment</code>  中，不能回滚。操作不触发 <code>trigger</code> .</li>\n</ul>\n<h2 id=\"7-drop-delete与truncate分别在什么场景之下使用\"><a class=\"markdownIt-Anchor\" href=\"#7-drop-delete与truncate分别在什么场景之下使用\">#</a> 7.  <code>drop</code> 、 <code>delete</code>  与 <code>truncate</code>  分别在什么场景之下使用？</h2>\n<ul>\n<li>不再需要一张表的时候，用 <code>drop</code></li>\n<li>想删除部分数据行时候，用 <code>delete</code> ，并且带上 <code>where</code>  子句</li>\n<li>保留表而删除所有数据的时候用 <code>truncate</code></li>\n</ul>\n<h2 id=\"8-超键-候选键-主键-外键分别是什么\"><a class=\"markdownIt-Anchor\" href=\"#8-超键-候选键-主键-外键分别是什么\">#</a> 8. 超键、候选键、主键、外键分别是什么？</h2>\n<ul>\n<li>\n<p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>\n</li>\n<li>\n<p>候选键：是最小超键，即没有冗余元素的超键。</p>\n</li>\n<li>\n<p>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（ <code>Null</code> ）。</p>\n</li>\n<li>\n<p>外键：在一个表中存在的另一个表的主键称此表的外键。</p>\n</li>\n</ul>\n<h2 id=\"9-什么是视图以及视图的使用场景有哪些\"><a class=\"markdownIt-Anchor\" href=\"#9-什么是视图以及视图的使用场景有哪些\">#</a> 9. 什么是视图？以及视图的使用场景有哪些？</h2>\n<blockquote>\n<p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p>\n</blockquote>\n<blockquote>\n<p>只暴露部分字段给访问者，所以就建一个虚表，就是视图。<br>\n查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</p>\n</blockquote>\n<h2 id=\"10-说一说三个范式\"><a class=\"markdownIt-Anchor\" href=\"#10-说一说三个范式\">#</a> 10. 说一说三个范式。</h2>\n<p><strong>第一范式（ <code>1NF</code> ）</strong>：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</p>\n<p><strong>第二范式（ <code>2NF</code> ）</strong>：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</p>\n<p><strong>第三范式（ <code>3NF</code> ）</strong>：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在 <code>&quot;A → B → C&quot;</code>  的决定关系，则 <code>C</code>  传递函数依赖于 <code>A</code> 。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段  <code>x </code> → 非关键字段 <code>y</code></p>\n",
            "tags": [
                "Java面试",
                "数据库"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/9f9a6182/",
            "url": "https://smile1231.github.io/posts/9f9a6182/",
            "title": "面试之旅关于数据结构",
            "date_published": "2022-02-16T13:13:39.000Z",
            "content_html": "<h1 id=\"面试之旅关于数据结构\"><a class=\"markdownIt-Anchor\" href=\"#面试之旅关于数据结构\">#</a> 面试之旅关于数据结构</h1>\n<p><strong><span class=\"exturl\" data-url=\"aHR0cDovL2RhdGEuYmlhbmNoZW5nLm5ldC9pbnRyby8=\">数据结构详细讲解</span></strong></p>\n<p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p>\n<h2 id=\"数据结构中的逻辑结构\"><a class=\"markdownIt-Anchor\" href=\"#数据结构中的逻辑结构\">#</a> 数据结构中的逻辑结构</h2>\n<blockquote>\n<p>集合结构</p>\n</blockquote>\n<p>集合结构的里面的元素关系是孤立的</p>\n<img data-src=\"/posts/9f9a6182/2022-02-16-21-37-01.png\" class=\"\">\n<blockquote>\n<p>线性结构</p>\n</blockquote>\n<p>线性结构里面的元素关系：一对一</p>\n<img data-src=\"/posts/9f9a6182/2022-02-16-21-37-13.png\" class=\"\">\n<blockquote>\n<p>树形结构</p>\n</blockquote>\n<p>树形结构里面的元素关系：一对多</p>\n<img data-src=\"/posts/9f9a6182/2022-02-16-21-37-28.png\" class=\"\">\n<blockquote>\n<p>图结构</p>\n</blockquote>\n<p>图结构里面的元素关系：多对多</p>\n<img data-src=\"/posts/9f9a6182/2022-02-16-21-37-47.png\" class=\"\">\n<h2 id=\"数据结构的物理结构\"><a class=\"markdownIt-Anchor\" href=\"#数据结构的物理结构\">#</a> 数据结构的物理结构</h2>\n<p>物理结构：是指数据的逻辑结构在计算机中的存储形式。存储结构有两种：</p>\n<blockquote>\n<p>顺序存储结构：</p>\n</blockquote>\n<p>顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</p>\n<img data-src=\"/posts/9f9a6182/2022-02-16-21-37-57.png\" class=\"\">\n<blockquote>\n<p>链式存储结构</p>\n</blockquote>\n<p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</p>\n<img data-src=\"/posts/9f9a6182/2022-02-16-21-38-04.png\" class=\"\">\n<h2 id=\"常见的数据结构\"><a class=\"markdownIt-Anchor\" href=\"#常见的数据结构\">#</a> 常见的数据结构</h2>\n<ul>\n<li>\n<p>数组（ <code>Array</code> ）</p>\n</li>\n<li>\n<p>堆栈（ <code>Stack</code> ）</p>\n</li>\n<li>\n<p>队列（ <code>Queue</code> ）</p>\n</li>\n<li>\n<p>链表（ <code>Linked List</code> ）</p>\n</li>\n<li>\n<p>树（ <code>Tree</code> ）</p>\n</li>\n<li>\n<p>图（ <code>Graph</code> ）</p>\n</li>\n<li>\n<p>堆（ <code>Heap</code> ）</p>\n</li>\n<li>\n<p>散列表（ <code>Hash</code> ）</p>\n</li>\n</ul>\n<h2 id=\"链表\"><a class=\"markdownIt-Anchor\" href=\"#链表\">#</a> 链表</h2>\n<p>链表是一种数据结构，和数组同级。比如， <code>Java</code>  中我们使用的 <code>ArrayList</code> ，其实现原理是数组。而 <code>LinkedList</code>  的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。下面对单向链表做一个介绍。</p>\n<p>单向链表是一种线性表，实际上是由节点（ <code>Node</code> ）组成的，一个链表拥有不定数量的节点。其数据在内存中存储是不连续的，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由 N 各节点（ <code>Node</code> ）组成单向链表，每一个 <code>Node</code>  记录本 <code>Node</code>  的数据及下一个 <code>Node</code> 。向外暴露的只有一个头节点（ <code>Head</code> ），我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。</p>\n<img data-src=\"/posts/9f9a6182/2022-02-16-21-38-15.png\" class=\"\">\n<p>上图中最左边的节点即为头结点（ <code>Head</code> ），但是添加节点的顺序是从右向左的，添加的新节点会被作为新节点。最先添加的节点对下一节点的引用可以为空。引用是引用下一个节点而非下一个节点的对象。因为有着不断的引用，所以头节点就可以操作所有节点了。</p>\n<p>下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成了一个单向链表。</p>\n<img data-src=\"/posts/9f9a6182/2022-02-16-21-38-25.png\" class=\"\">\n<p>节点（ <code>Node</code> ）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。下面图是具体的说明：</p>\n<img data-src=\"/posts/9f9a6182/2022-02-16-21-38-31.png\" class=\"\">\n<blockquote>\n<p>单链表实现</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.zjn.LinkAndQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 自定义链表设计</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zjn</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyLink</span> </span>&#123;</span><br><span class=\"line\">    Node head = <span class=\"keyword\">null</span>; <span class=\"comment\">// 头节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 链表中的节点，data代表节点的值，next是指向下一个节点的引用</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@author</span> zjn</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        Node next = <span class=\"keyword\">null</span>;<span class=\"comment\">// 节点的引用，指向下一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> data;<span class=\"comment\">// 节点的对象，即内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 向链表中插入数据</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> d</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addNode</span><span class=\"params\">(<span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">        Node newNode = <span class=\"keyword\">new</span> Node(d);<span class=\"comment\">// 实例化一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            head = newNode;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node tmp = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tmp.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            tmp = tmp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tmp.next = newNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index:删除第index个节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">deleteNode</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">1</span> || index &gt; length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">        Node preNode = head;</span><br><span class=\"line\">        Node curNode = preNode.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (curNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == index) &#123;</span><br><span class=\"line\">                preNode.next = curNode.next;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            preNode = curNode;</span><br><span class=\"line\">            curNode = curNode.next;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回节点长度</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">length</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Node tmp = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tmp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            length++;</span><br><span class=\"line\">            tmp = tmp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在不知道头指针的情况下删除指定节点</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> n</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">deleteNode11</span><span class=\"params\">(Node n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"keyword\">null</span> || n.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = n.data;</span><br><span class=\"line\">        n.data = n.next.data;</span><br><span class=\"line\">        n.next.data = tmp;</span><br><span class=\"line\">        n.next = n.next.next;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除成功！&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Node tmp = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tmp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.println(tmp.data);</span><br><span class=\"line\">            tmp = tmp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyLink list = <span class=\"keyword\">new</span> MyLink();</span><br><span class=\"line\">        list.addNode(<span class=\"number\">5</span>);</span><br><span class=\"line\">        list.addNode(<span class=\"number\">3</span>);</span><br><span class=\"line\">        list.addNode(<span class=\"number\">1</span>);</span><br><span class=\"line\">        list.addNode(<span class=\"number\">2</span>);</span><br><span class=\"line\">        list.addNode(<span class=\"number\">55</span>);</span><br><span class=\"line\">        list.addNode(<span class=\"number\">36</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;linkLength:&quot;</span> + list.length());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;head.data:&quot;</span> + list.head.data);</span><br><span class=\"line\">        list.printList();</span><br><span class=\"line\">        list.deleteNode(<span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After deleteNode(4):&quot;</span>);</span><br><span class=\"line\">        list.printList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"树\"><a class=\"markdownIt-Anchor\" href=\"#树\">#</a> 树</h2>\n<p>非线性存储结构</p>\n<img data-src=\"/posts/9f9a6182/2022-02-16-21-38-44.png\" class=\"\">\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2RhdGEuYmlhbmNoZW5nLm5ldC92aWV3LzIzLmh0bWw=\">树的详细讲解</span></p>\n",
            "tags": [
                "Java面试",
                "数据结构"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/c7cf6e41/",
            "url": "https://smile1231.github.io/posts/c7cf6e41/",
            "title": "面试之旅关于计算机网络",
            "date_published": "2022-02-16T13:13:16.000Z",
            "content_html": "<h1 id=\"常见面试题整理计算机网络篇每位开发者必备\"><a class=\"markdownIt-Anchor\" href=\"#常见面试题整理计算机网络篇每位开发者必备\">#</a> 常见面试题整理–计算机网络篇（每位开发者必备）</h1>\n<img data-src=\"/posts/c7cf6e41/2022-02-16-21-31-41.png\" class=\"\">\n<h2 id=\"1-请简述tcpudp的区别\"><a class=\"markdownIt-Anchor\" href=\"#1-请简述tcpudp的区别\">#</a> 1. 请简述 <code>TCP\\UDP</code>  的区别</h2>\n<p><code>TCP</code>  和 <code>UDP</code>  是 <code>OSI</code>  模型中的运输层中的协议。 <code>TCP</code>  提供可靠的通信传输，而 <code>UDP</code>  则常被用于让广播和细节控制交给应用的通信传输。</p>\n<p>两者的区别大致如下：</p>\n<ul>\n<li><code>TCP</code>  面向连接， <code>UDP</code>  面向非连接即发送数据前不需要建立链接</li>\n<li><code>TCP</code>  提供可靠的服务（数据传输）， <code>UDP</code>  无法保证</li>\n<li><code>TCP</code>  面向字节流， <code>UDP</code>  面向报文</li>\n<li><code>TCP</code>  数据传输慢， <code>UDP</code>  数据传输快</li>\n</ul>\n<h2 id=\"2-请简单说一下你了解的端口及对应的服务\"><a class=\"markdownIt-Anchor\" href=\"#2-请简单说一下你了解的端口及对应的服务\">#</a> 2. 请简单说一下你了解的端口及对应的服务？</h2>\n<span id=\"more\"></span>\n<img data-src=\"/posts/c7cf6e41/2022-02-16-21-31-53.png\" class=\"\">\n<p><strong>端口简介：本文介绍端口的概念，分类，以及如何关闭 / 开启一个端口</strong></p>\n<ul>\n<li>\n<p><code>21端口</code> ：21 端口主要用于 <code>FTP（File Transfer Protocol，文件传输协议）</code> 服务。</p>\n</li>\n<li>\n<p><code>23</code>  端口：23 端口主要用于 <code>Telnet（远程登录）</code> 服务，是 <code>Internet</code>  上普遍采用的登录和仿真程序。</p>\n</li>\n<li>\n<p><code>25端口</code> ：25 端口为 <code>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</code> 服务器所开放，主要用于发送邮件，如今绝大多数邮件服务器都使用该协议。</p>\n</li>\n<li>\n<p><code>53端口</code> ：53 端口为 <code>DNS（Domain Name Server，域名服务器）</code> 服务器所开放，主要用于域名解析， <code>DNS</code>  服务在 <code>NT</code>  系统中使用的最为广泛。</p>\n</li>\n<li>\n<p><code>67、68端口</code> ：67、68 端口分别是为 <code>Bootstrap</code>  服务的 <code>Bootstrap Protocol Server（引导程序协议服务端）</code> 和 <code>Bootstrap Protocol Client（引导程序协议客户端）</code> 开放的端口。</p>\n</li>\n<li>\n<p><code>69端口</code> ： <code>TFTP</code>  是 Cisco 公司开发的一个 <code>简单文件传输协议</code> ，类似于 <code>FTP</code> 。</p>\n</li>\n<li>\n<p><code>79端口</code> ：79 端口是为 <code>Finger</code>  服务开放的，主要用于查询远程主机在线用户、操作系统类型以及是否缓冲区溢出等用户的详细信息。</p>\n</li>\n<li>\n<p><code>80端口</code> ：80 端口是为 <code>HTTP（HyperText Transport Protocol，超文本传输协议）</code> 开放的，这是上网冲浪使用最多的协议，主要用于在 <code>WWW（World Wide Web，万维网）</code> 服务上传输信息的协议。</p>\n</li>\n<li>\n<p><code>99端口</code> ：99 端口是用于一个名为 <code>“Metagram Relay”（亚对策延时）</code> 的服务，该服务比较少见，一般是用不到的。</p>\n</li>\n<li>\n<p><code>109、110端口</code> ：109 端口是为 <code>POP2（Post Office Protocol Version 2，邮局协议2）</code> 服务开放的， <code>110端口是为POP3（邮件协议3）</code> 服务开放的， <code>POP2、POP3</code>  都是主要用于接收邮件的。</p>\n</li>\n<li>\n<p><code>111端口</code> ：111 端口是 <code>SUN</code>  公司的 <code>RPC（Remote Procedure Call，远程过程调用）</code> 服务所开放的端口，主要用于分布式系统中不同计算机的内部进程通信，RPC 在多种网络服务中都是很重要的组件。</p>\n</li>\n<li>\n<p><code>113端口</code> ：113 端口主要用于 <code>Windows</code>  的 <code>“Authentication Service”（验证服务）</code> 。</p>\n</li>\n<li>\n<p><code>119端口</code> ：119 端口是为 <code>“Network News Transfer Protocol”（网络新闻组传输协议，简称NNTP）</code> 开放的。</p>\n</li>\n<li>\n<p><code>135端口</code> ：135 端口主要用于使用 <code>RPC（Remote Procedure Call，远程过程调用）</code> 协议并提供 <code>DCOM（分布式组件对象模型）</code> 服务。</p>\n</li>\n<li>\n<p><code>137端口</code> ：137 端口主要用于 <code>“NetBIOS Name Service”（NetBIOS名称服务）</code> 。</p>\n</li>\n<li>\n<p><code>139端口</code> ：139 端口是为 <code>“NetBIOS Session Service”</code>  提供的，主要用于提供 <code>Windows</code>  文件和打印机共享以及 <code>Unix</code>  中的 <code>Samba</code>  服务。</p>\n</li>\n<li>\n<p><code>143端口</code> ：143 端口主要是用于 <code>“Internet Message Access Protocol”v2（Internet消息访问协议，简称IMAP）</code> 。</p>\n</li>\n<li>\n<p><code>161端口</code> ：161 端口是用于 <code>“Simple Network Management Protocol”（简单网络管理协议，简称SNMP）</code> 。</p>\n</li>\n<li>\n<p><code>443端口</code> ：43 端口即网页浏览端口，主要是用于 <code>HTTPS</code>  服务，是提供加密和通过安全端口传输的另一种 <code>HTTP</code> 。</p>\n</li>\n<li>\n<p><code>554端口</code> ：554 端口默认情况下用于 <code>“Real Time Streaming Protocol”（实时流协议，简称RTSP）</code> 。</p>\n</li>\n<li>\n<p><code>1024端口</code> ：1024 端口一般不固定分配给某个服务，在英文中的解释是 <code>“Reserved”（保留）</code> 。</p>\n</li>\n<li>\n<p><code>1080端口</code> ：1080 端口是 Socks 代理服务使用的端口，大家平时上网使用的 WWW 服务使用的是 HTTP 协议的代理服务。</p>\n</li>\n<li>\n<p><code>1755端口</code> ：1755 端口默认情况下用于 <code>“Microsoft Media Server”（微软媒体服务器，简称MMS）</code> 。</p>\n</li>\n<li>\n<p><code>4000端口</code> ：4000 端口是用于大家经常使用的 <code>QQ</code>  聊天工具的，再细说就是为 <code>QQ</code>  客户端开放的端口， <code>QQ</code>  服务端使用的端口是 <code>8000</code> 。</p>\n</li>\n<li>\n<p><code>5554端口</code> ：在今年 4 月 30 日就报道出现了一种针对微软 <code>lsass服务</code> 的新蠕虫病毒 —— 震荡波（Worm.Sasser），该病毒可以利用 <code>TCP 5554端口</code> 开启一个 <code>FTP</code>  服务，主要被用于病毒的传播。</p>\n</li>\n<li>\n<p><code>5632端口</code> ：5632 端口是被大家所熟悉的远程控制软件 <code>pcAnywhere</code>  所开启的端口。</p>\n</li>\n<li>\n<p><code>8080端口</code> ：8080 端口同 80 端口，是被用于 <code>WWW</code>  代理服务的，可以实现网页</p>\n</li>\n</ul>\n<h2 id=\"3-说一说tcp的三次握手\"><a class=\"markdownIt-Anchor\" href=\"#3-说一说tcp的三次握手\">#</a> 3. 说一说 <code>TCP</code>  的三次握手</h2>\n<p>在 <code>TCP/IP</code>  协议中， <code>TCP协议</code> 提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 <code>TCP</code>  窗口大小信息。</p>\n<p>下面详细说一下三次握手（来自简析 <code>TCP</code>  的三次握手与四次分手）</p>\n<img data-src=\"/posts/c7cf6e41/2022-02-16-21-32-08.png\" class=\"\">\n<img data-src=\"/posts/c7cf6e41/2022-02-16-21-32-16.png\" class=\"\">\n<h2 id=\"4-有哪些私有保留地址\"><a class=\"markdownIt-Anchor\" href=\"#4-有哪些私有保留地址\">#</a> 4. 有哪些私有（保留）地址？</h2>\n<ul>\n<li><code>A</code>  类： <code>10.0.0.0 - 10.255.255.255</code></li>\n<li><code>B</code>  类： <code>172.16.0.0 - 172.31.255.255</code></li>\n<li><code>C</code>  类： <code>192.168.0.0 - 192.168.255.255</code></li>\n</ul>\n<h2 id=\"5-ip地址分为哪几类简单说一下各个分类\"><a class=\"markdownIt-Anchor\" href=\"#5-ip地址分为哪几类简单说一下各个分类\">#</a> 5.  <code>IP</code>  地址分为哪几类？简单说一下各个分类</h2>\n<img data-src=\"/posts/c7cf6e41/2022-02-16-21-32-36.png\" class=\"\">\n<p><code>IPv6 </code> – 采用 <code>128bit</code> ，首部固定部分为 <code>40</code>  字节。</p>\n<h2 id=\"6-在浏览器中输入网址之后执行会发生什么\"><a class=\"markdownIt-Anchor\" href=\"#6-在浏览器中输入网址之后执行会发生什么\">#</a> 6. 在浏览器中输入网址之后执行会发生什么？</h2>\n<ul>\n<li>查找域名对应的 <code>IP</code>  地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存， <code>ISPNDS</code>  缓存，根域名服务器</li>\n<li>浏览器向 <code>IP</code>  对应的 <code>web</code>  服务器发送一个 <code>HTTP</code>  请求</li>\n<li>服务器响应请求，发回网页内容</li>\n<li>浏览器解析网页内容</li>\n</ul>\n<p>更加详细的一种说法（以百度为例）（来自计算机网络之面试常考 - 牛客网）</p>\n<img data-src=\"/posts/c7cf6e41/2022-02-16-21-32-47.png\" class=\"\">\n<h2 id=\"7-简单解释一些arp协议的工作过程\"><a class=\"markdownIt-Anchor\" href=\"#7-简单解释一些arp协议的工作过程\">#</a> 7. 简单解释一些 <code>ARP</code>  协议的工作过程</h2>\n<img data-src=\"/posts/c7cf6e41/2022-02-16-21-33-01.png\" class=\"\">\n<h2 id=\"8-说一说osi七层模型\"><a class=\"markdownIt-Anchor\" href=\"#8-说一说osi七层模型\">#</a> 8. 说一说 <code>OSI</code>  七层模型</h2>\n<img data-src=\"/posts/c7cf6e41/2022-02-16-21-33-15.png\" class=\"\">\n<h2 id=\"9-说一说tcpip四层模型\"><a class=\"markdownIt-Anchor\" href=\"#9-说一说tcpip四层模型\">#</a> 9. 说一说 <code>TCP/IP</code>  四层模型</h2>\n<p><code>ISO</code>  制定的 <code>OSI</code>  参考模型的过于庞大、复杂招致了许多批评。与此对照，由技术人员自己开发的 <code>TCP/IP</code>  协议栈获得了更为广泛的应用。如图所示，是 <code>TCP/IP</code>  参考模型和 <code>OSI</code>  参考模型的对比示意图。</p>\n<img data-src=\"/posts/c7cf6e41/2022-02-16-21-33-24.png\" class=\"\">\n<img data-src=\"/posts/c7cf6e41/2022-02-16-21-33-31.png\" class=\"\">\n<p>具体讲解：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vQmx1ZVR6YXIvYXJ0aWNsZXMvODExMTYwLmh0bWw=\">链接</span></p>\n<h2 id=\"10-http-协议包括哪些请求\"><a class=\"markdownIt-Anchor\" href=\"#10-http-协议包括哪些请求\">#</a> 10.  <code>HTTP</code>  协议包括哪些请求？</h2>\n<ul>\n<li>\n<p><code>GET</code> ：对服务器资源的简单请求</p>\n</li>\n<li>\n<p><code>POST</code> ：用于发送包含用户提交数据的请求<br>\n ------------ 以及 ------------</p>\n</li>\n<li>\n<p><code>HEAD</code> ：类似于 GET 请求，不过返回的响应中没有具体内容，用于获取报头</p>\n</li>\n<li>\n<p><code>PUT</code> ：传说中请求文档的一个版本</p>\n</li>\n<li>\n<p><code>DELETE</code> ：发出一个删除指定文档的请求</p>\n</li>\n<li>\n<p><code>TRACE</code> ：发送一个请求副本，以跟踪其处理进程</p>\n</li>\n<li>\n<p><code>OPTIONS</code> ：返回所有可用的方法，检查服务器支持哪些方法</p>\n</li>\n<li>\n<p><code>CONNECT</code> ：用于 <code>ssl</code>  隧道的基于代理的请求</p>\n</li>\n</ul>\n<h2 id=\"11-简述http中get和post的区别\"><a class=\"markdownIt-Anchor\" href=\"#11-简述http中get和post的区别\">#</a> 11. 简述 <code>HTTP</code>  中 <code>GET</code>  和 <code>POST</code>  的区别</h2>\n<p>从原理性看：</p>\n<ul>\n<li>根据 <code>HTTP</code>  规范， <code>GET</code>  用于信息获取，而且应该是安全和幂等的</li>\n<li>根据 <code>HTTP</code>  规范， <code>POST</code>  请求表示可能修改服务器上资源的请求</li>\n</ul>\n<p>从表面上看：</p>\n<ul>\n<li><code>GET</code>  请求的数据会附在 <code>URL</code>  后面， <code>POST</code>  的数据放在 <code>HTTP</code>  包体</li>\n<li><code>POST</code>  安全性比 <code>GET</code>  安全性高</li>\n</ul>\n",
            "tags": [
                "Java面试",
                "操作系统"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/4847d2e5/",
            "url": "https://smile1231.github.io/posts/4847d2e5/",
            "title": "面试之旅关于操作系统",
            "date_published": "2022-02-16T13:10:40.000Z",
            "content_html": "<h1 id=\"常见面试题整理操作系统篇每位开发者必备\"><a class=\"markdownIt-Anchor\" href=\"#常见面试题整理操作系统篇每位开发者必备\">#</a> 常见面试题整理–操作系统篇（每位开发者必备）</h1>\n<img data-src=\"/posts/4847d2e5/2022-02-16-21-18-10.png\" class=\"\">\n<h2 id=\"1-请分别简单说一说进程和线程以及它们的区别\"><a class=\"markdownIt-Anchor\" href=\"#1-请分别简单说一说进程和线程以及它们的区别\">#</a> 1. 请分别简单说一说进程和线程以及它们的区别。</h2>\n<blockquote>\n<p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。线程是进程的实体，是 <code>CPU</code>  调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。一个进程可以有多个线程，多个线程也可以并发执行</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"2-线程同步的方式有哪些\"><a class=\"markdownIt-Anchor\" href=\"#2-线程同步的方式有哪些\">#</a> 2. 线程同步的方式有哪些？</h2>\n<ul>\n<li>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li>\n<li>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>\n<li>事件（信号): 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>\n</ul>\n<h2 id=\"3-进程的通信方式有哪些\"><a class=\"markdownIt-Anchor\" href=\"#3-进程的通信方式有哪些\">#</a> 3. 进程的通信方式有哪些？</h2>\n<p>主要分为：管道、系统 <code>IPC</code> （包括消息队列、信号量、共享存储）、 <code>SOCKET</code></p>\n<p>管道主要分为：普通管道 <code>PIPE</code>  、流管道（ <code>s_pipe</code> ）、命名管道（ <code>name_pipe</code> ）</p>\n<ul>\n<li>管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程</li>\n<li>命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信</li>\n<li>信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。</li>\n<li>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</li>\n<li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>\n<li>共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。</li>\n</ul>\n<h2 id=\"4-什么是缓冲区溢出有什么危害其原因是什么\"><a class=\"markdownIt-Anchor\" href=\"#4-什么是缓冲区溢出有什么危害其原因是什么\">#</a> 4. 什么是缓冲区溢出？有什么危害？其原因是什么？</h2>\n<p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p>\n<p>危害有以下两点：</p>\n<ul>\n<li>程序崩溃，导致拒绝额服务</li>\n<li>跳转并且执行一段恶意代码</li>\n</ul>\n<p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p>\n<h2 id=\"5-什么是死锁死锁产生的条件\"><a class=\"markdownIt-Anchor\" href=\"#5-什么是死锁死锁产生的条件\">#</a> 5. 什么是死锁？死锁产生的条件</h2>\n<p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p>\n<p>死锁产生的四个条件（有一个条件不成立，则不会产生死锁）</p>\n<ol>\n<li>互斥条件：一个资源一次只能被一个进程使用</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>\n<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>\n<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>\n</ol>\n<h2 id=\"6-进程有哪几种状态\"><a class=\"markdownIt-Anchor\" href=\"#6-进程有哪几种状态\">#</a> 6. 进程有哪几种状态？</h2>\n<ul>\n<li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源</li>\n<li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于 <code>CPU</code>  数</li>\n<li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行</li>\n</ul>\n<h2 id=\"7-分页和分段有什么区别\"><a class=\"markdownIt-Anchor\" href=\"#7-分页和分段有什么区别\">#</a> 7. 分页和分段有什么区别？</h2>\n<ul>\n<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</li>\n<li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定</li>\n<li>段向用户提供二维地址空间；页向用户提供的是一维地址空间</li>\n<li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li>\n</ul>\n<h2 id=\"8-操作系统中进程调度策略有哪几种\"><a class=\"markdownIt-Anchor\" href=\"#8-操作系统中进程调度策略有哪几种\">#</a> 8. 操作系统中进程调度策略有哪几种？</h2>\n<p><code>FCFS</code>  (先来先服务)，优先级，时间片轮转，多级反馈</p>\n<h2 id=\"9-说一说进程同步有哪几种机制\"><a class=\"markdownIt-Anchor\" href=\"#9-说一说进程同步有哪几种机制\">#</a> 9. 说一说进程同步有哪几种机制？</h2>\n<p>原子操作、信号量机制、自旋锁管程、会合、分布式系统</p>\n<h2 id=\"10-说一说死锁的处理基本策略和常用方法\"><a class=\"markdownIt-Anchor\" href=\"#10-说一说死锁的处理基本策略和常用方法\">#</a> 10. 说一说死锁的处理基本策略和常用方法</h2>\n<ul>\n<li>\n<p>解决死锁的基本方法如下：<br>\n预防死锁、避免死锁、检测死锁、解除死锁</p>\n</li>\n<li>\n<p>解决四多的常用策略如下：<br>\n鸵鸟策略、预防策略、避免策略、检测与解除死锁</p>\n</li>\n</ul>\n",
            "tags": [
                "Java面试",
                "操作系统"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/e8eb0481/",
            "url": "https://smile1231.github.io/posts/e8eb0481/",
            "title": "二分查找",
            "date_published": "2022-02-16T13:06:36.000Z",
            "content_html": "<h1 id=\"二分查找\"><a class=\"markdownIt-Anchor\" href=\"#二分查找\">#</a> 二分查找</h1>\n<p>二分查找（ <code>binary search</code> ），也称作折半查找（ <code>half-interval search</code> ），每次划分一半进行下一步搜索，所以时间复杂度无非就是 <code>while</code>  循环的次数！</p>\n<span id=\"more\"></span>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//二分查找 Java 实现 （升序数组）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(Integer[] srcArray, <span class=\"keyword\">int</span> des)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> high = srcArray.length - <span class=\"number\">1</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((low &lt;= high) &amp;&amp; (low &lt;= srcArray.length - <span class=\"number\">1</span>)</span><br><span class=\"line\">            &amp;&amp; (high &lt;= srcArray.length - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// &gt;&gt; 右移符号 表示除以 2</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> middle = (high + low) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (des == srcArray[middle]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> middle;</span><br><span class=\"line\">        <span class=\"comment\">// 如果要查找的值 小于最中间的值 就算选择 左边的区间</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (des &lt; srcArray[middle]) &#123;</span><br><span class=\"line\">            high = middle - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            low = middle + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度\">#</a> 时间复杂度</h2>\n<p>比如：总共有 <code>n</code>  个元素，每次查找的区间大小就是 <code>n，n/2，n/4，…，n/2^k</code> （接下来操作元素的剩余个数），其中 <code>k</code>  就是循环的次数。<br>\n由于 <code>n/2^k</code>  取整后 <code>&gt;=1</code> ，即令 <code>n/2^k=1</code> ，<br>\n可得 <code>k=log2n</code> ,（是以 <code>2</code>  为底， <code>n</code>  的对数），所以时间复杂度可以表示 <code>O()=O(log2n)</code></p>\n<h2 id=\"二分查找的缺点\"><a class=\"markdownIt-Anchor\" href=\"#二分查找的缺点\">#</a> 二分查找的缺点</h2>\n<p>虽然二分查找的效率高，但是要将表按关键字排序。而排序本身是一种很费时的运算。既使采用高效率的排序方法也要花费 <code>O(nlgn)</code>  的时间。</p>\n<p>二分查找只适用顺序存储结构。为保持表的有序性，在顺序结构里插入和删除都必须移动大量的结点。因此，二分查找特别适用于那种一经建立就很少改动、而又经常需要查找的线性表。</p>\n<p>对那些查找少而又经常需要改动的线性表，可采用链表作存储结构，进行顺序查找。链表上无法实现二分查找。</p>\n",
            "tags": [
                "Java面试",
                "算法",
                "二分查找"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/20ac1950/",
            "url": "https://smile1231.github.io/posts/20ac1950/",
            "title": "SpringBoot文件上传下载",
            "date_published": "2022-02-15T14:44:58.000Z",
            "content_html": "<blockquote>\n<p>文件上传与下载</p>\n</blockquote>\n<ol>\n<li><code>Spring Boot</code>  默认单个文件上传大小是 <code>1MB</code> , 默认多个文件上传总大小是 <code>10MB</code></li>\n</ol>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">servlet:</span></span><br><span class=\"line\">    <span class=\"comment\">#配置单个上传文件的大小的限制</span></span><br><span class=\"line\">    <span class=\"attr\">multipart:</span></span><br><span class=\"line\">      <span class=\"attr\">max-file-size:</span> <span class=\"string\">20MB</span></span><br><span class=\"line\">    <span class=\"comment\">#配置在一次请求中上传文件的总容量的限制</span></span><br><span class=\"line\">      <span class=\"attr\">max-request-size:</span> <span class=\"string\">50MB</span></span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;/upload&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">uploadFile</span><span class=\"params\">(MultipartFile file)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//生成文件在服务器端存放的名字</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//扩展名</span></span><br><span class=\"line\">            String fileSuffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(<span class=\"string\">&quot;.&quot;</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            String fileName = System.currentTimeMillis() + <span class=\"string\">&quot;.&quot;</span> +fileSuffix;</span><br><span class=\"line\">            <span class=\"comment\">//获取项目路径</span></span><br><span class=\"line\">            System.out.println(System.getProperty(<span class=\"string\">&quot;user.dir&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">            File files = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/Users/jinmao/Documents/IDEASpace/springboot01/src/&quot;</span> + fileName);</span><br><span class=\"line\">            <span class=\"comment\">//上传</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!files.exists()) files.mkdirs();</span><br><span class=\"line\">            file.transferTo(files);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;上传失败&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;上传成功&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//多文件上传</span></span><br><span class=\"line\">     <span class=\"meta\">@PostMapping(&quot;/batch&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleFileUpload</span><span class=\"params\">(HttpServletRequest request)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;MultipartFile&gt; files = ((MultipartHttpServletRequest) request).getFiles(<span class=\"string\">&quot;file&quot;</span>);</span><br><span class=\"line\">        MultipartFile file = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        BufferedOutputStream stream = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; files.size(); ++i) &#123;</span><br><span class=\"line\">            file = files.get(i);</span><br><span class=\"line\">            String filePath = <span class=\"string\">&quot;/Users/dalaoyang/Downloads/&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!file.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] bytes = file.getBytes();</span><br><span class=\"line\">                    stream = <span class=\"keyword\">new</span> BufferedOutputStream(<span class=\"keyword\">new</span> FileOutputStream(</span><br><span class=\"line\">                            <span class=\"keyword\">new</span> File(filePath + file.getOriginalFilename())));<span class=\"comment\">//设置文件路径及名字</span></span><br><span class=\"line\">                    stream.write(bytes);<span class=\"comment\">// 写入</span></span><br><span class=\"line\">                    stream.close();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    stream = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">&quot;第 &quot;</span> + i + <span class=\"string\">&quot; 个文件上传失败 ==&gt; &quot;</span></span><br><span class=\"line\">                            + e.getMessage();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&quot;第 &quot;</span> + i</span><br><span class=\"line\">                        + <span class=\"string\">&quot; 个文件上传失败因为文件为空&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;上传成功&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//文件下载</span></span><br><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/download&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">downloadFile</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class=\"line\">        String fileName = <span class=\"string\">&quot;dalaoyang.jpeg&quot;</span>;<span class=\"comment\">// 文件名</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fileName != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//设置文件路径</span></span><br><span class=\"line\">            File file = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/Users/dalaoyang/Documents/dalaoyang.jpeg&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">//File file = new File(realPath , fileName);</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (file.exists()) &#123;</span><br><span class=\"line\">                response.setContentType(<span class=\"string\">&quot;application/force-download&quot;</span>);<span class=\"comment\">// 设置强制下载不打开</span></span><br><span class=\"line\">                response.addHeader(<span class=\"string\">&quot;Content-Disposition&quot;</span>, <span class=\"string\">&quot;attachment;fileName=&quot;</span> + fileName);<span class=\"comment\">// 设置文件名</span></span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">                FileInputStream fis = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                BufferedInputStream bis = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    fis = <span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\">                    bis = <span class=\"keyword\">new</span> BufferedInputStream(fis);</span><br><span class=\"line\">                    OutputStream os = response.getOutputStream();</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> i = bis.read(buffer);</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (i != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        os.write(buffer, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">                        i = bis.read(buffer);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">&quot;下载成功&quot;</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (bis != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            bis.close();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fis != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            fis.close();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;下载失败&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"关于文件上传的理解\"><a class=\"markdownIt-Anchor\" href=\"#关于文件上传的理解\">#</a> 关于文件上传的理解</h2>\n<p>以前是这样认为的，就像代码中所展示的那样</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">swiper-item</span> &gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">image</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;/Users/jinmao/Documents/Vscode/Space/StudyPlatform/images/swiper/1.png&quot;</span> <span class=\"attr\">mode</span>=<span class=\"string\">&quot;widthFix&quot;</span> <span class=\"attr\">lazy-load</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"attr\">binderror</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">bindload</span>=<span class=\"string\">&quot;&quot;</span>&gt;</span>  <span class=\"tag\">&lt;/<span class=\"name\">image</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">swiper-item</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>image</code>  标签只要 <code>src</code>  是静态的文件目录，感觉就是可以的，然后这就犯了一个很严重的错误，他是无法被解析的，必须是后端项目所带有的资源</p>\n<p>类似于一个服务端，一个客户端去访问他的资源，这个资源是服务端所带有的，并不是服务器上有的，只要是有他的全限定类名就 <code>ok</code>  的</p>\n<p>所以任何资源都要通过后端去获取，后端所带有的，所以这个代码有很严重的错误，也是一个关于文件上传的大误区</p>\n<img data-src=\"/posts/20ac1950/2022-02-16-21-04-44.png\" class=\"\">\n<img data-src=\"/posts/20ac1950/2022-02-16-21-04-53.png\" class=\"\">\n<p>就可以显示出来了</p>\n<p><strong>续：</strong></p>\n<p>后来我又发现了新的问题，就是需要重启项目之后才能访问到相应的资源</p>\n<h3 id=\"配置访问虚拟路径\"><a class=\"markdownIt-Anchor\" href=\"#配置访问虚拟路径\">#</a> 配置访问虚拟路径</h3>\n<p>文件实际是存在 路径下面，但是当访问 <code>http://ip:port/upload/xxx.jpg</code>  时，虚拟路径会映射到  <code>file://Users/path/xxx.jpg</code>  的路径中访问文件。也是对服务器文件的一种保护措施吧.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebMvcConfig</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebMvcConfigurer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addResourceHandlers</span><span class=\"params\">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        String path = System.getProperty(<span class=\"string\">&quot;user.dir&quot;</span>) + <span class=\"string\">&quot;/src/main/resources/upload/&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;);</span></span><br><span class=\"line\">        <span class=\"comment\">//linux服务器文件目录</span></span><br><span class=\"line\">        <span class=\"comment\">//配置磁盘映射 , pathPattern  访问路径                                        磁盘映射路径，不然不能够访问</span></span><br><span class=\"line\">                                        <span class=\"comment\">//这是因为对服务器的保护措施导致的，服务器不能对外部暴露真实的资源路径，需要配置虚拟路径映射访问。</span></span><br><span class=\"line\">        registry.addResourceHandler(<span class=\"string\">&quot;/upload/**&quot;</span>).addResourceLocations(<span class=\"string\">&quot;file:&quot;</span>+path);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Java面试",
                "SpringBoot"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/eec4b728/",
            "url": "https://smile1231.github.io/posts/eec4b728/",
            "title": "SpringBoot中如何优雅的使用多线程",
            "date_published": "2022-02-15T14:36:33.000Z",
            "content_html": "<h1 id=\"springboot中如何优雅的使用多线程\"><a class=\"markdownIt-Anchor\" href=\"#springboot中如何优雅的使用多线程\">#</a>  <code>SpringBoot</code>  中如何优雅的使用多线程</h1>\n<p>在  <code>SpringBoot</code>  应用中，经常会遇到在一个接口中，同时做事情 1，事情 2，事情 3，如果同步执行的话，则本次接口时间取决于事情 1 2 3 执行时间之和；如果三件事同时执行，则本次接口时间取决于事情 1 2 3 执行时间最长的那个，合理使用多线程，可以大大缩短接口时间。那么在  <code>SpringBoot</code>  应用中如何优雅的使用多线程呢？</p>\n<p><code>Don't bb, show me code.</code></p>\n<h2 id=\"快速使用\"><a class=\"markdownIt-Anchor\" href=\"#快速使用\">#</a> <strong>快速使用</strong></h2>\n<span id=\"more\"></span>\n<p><code>SpringBoot</code>  应用中需要添加 <code>@EnableAsync</code>  注解，来开启异步调用，一般还会配置一个线程池，异步的方法交给特定的线程池完成，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAsync</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;doSomethingExecutor&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Executor <span class=\"title\">doSomethingExecutor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ThreadPoolTaskExecutor executor = <span class=\"keyword\">new</span> ThreadPoolTaskExecutor();</span><br><span class=\"line\">        <span class=\"comment\">// 核心线程数：线程池创建时候初始化的线程数</span></span><br><span class=\"line\">        executor.setCorePoolSize(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 最大线程数：线程池最大的线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span></span><br><span class=\"line\">        executor.setMaxPoolSize(<span class=\"number\">20</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 缓冲队列：用来缓冲执行任务的队列</span></span><br><span class=\"line\">        executor.setQueueCapacity(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 允许线程的空闲时间60秒：当超过了核心线程之外的线程在空闲时间到达之后会被销毁</span></span><br><span class=\"line\">        executor.setKeepAliveSeconds(<span class=\"number\">60</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 线程池名的前缀：设置好了之后可以方便我们定位处理任务所在的线程池</span></span><br><span class=\"line\">        executor.setThreadNamePrefix(<span class=\"string\">&quot;do-something-&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 缓冲队列满了之后的拒绝策略：由调用线程处理（一般是主线程）</span></span><br><span class=\"line\">        executor.setRejectedExecutionHandler(<span class=\"keyword\">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class=\"line\">        executor.initialize();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> executor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用的方式非常简单，在需要异步的方法上加 <code>@Async</code>  注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AsyncService asyncService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/open/something&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">something</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            asyncService.doSomething(<span class=\"string\">&quot;index = &quot;</span> + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lon</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定使用beanname为doSomethingExecutor的线程池</span></span><br><span class=\"line\">    <span class=\"meta\">@Async(&quot;doSomethingExecutor&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">doSomething</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;do something, message=&#123;&#125;&quot;</span>, message);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;do something error: &quot;</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>访问： <code>127.0.0.1:8080/open/something</code> ，日志如下</p>\n<img data-src=\"/posts/eec4b728/2022-02-16-21-01-21.png\" class=\"\">\n<p>由此可见已经达到异步执行的效果了，并且使用到了咱们配置的线程池。</p>\n<h2 id=\"获取异步方法返回值\"><a class=\"markdownIt-Anchor\" href=\"#获取异步方法返回值\">#</a> <strong>获取异步方法返回值</strong></h2>\n<p>当异步方法有返回值时，如何获取异步方法执行的返回结果呢？这时需要异步调用的方法带有返回 <code>CompletableFuture</code> 。</p>\n<p><code>CompletableFuture</code>  是对 <code>Feature</code>  的增强， <code>Feature</code>  只能处理简单的异步任务，而 <code>CompletableFuture</code>  可以将多个异步任务进行复杂的组合。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AsyncService asyncService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SneakyThrows</span></span><br><span class=\"line\">    <span class=\"meta\">@ApiOperation(&quot;异步 有返回值&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/open/somethings&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">somethings</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        CompletableFuture&lt;String&gt; createOrder = asyncService.doSomething1(<span class=\"string\">&quot;create order&quot;</span>);</span><br><span class=\"line\">        CompletableFuture&lt;String&gt; reduceAccount = asyncService.doSomething2(<span class=\"string\">&quot;reduce account&quot;</span>);</span><br><span class=\"line\">        CompletableFuture&lt;String&gt; saveLog = asyncService.doSomething3(<span class=\"string\">&quot;save log&quot;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 等待所有任务都执行完</span></span><br><span class=\"line\">        CompletableFuture.allOf(createOrder, reduceAccount, saveLog).join();</span><br><span class=\"line\">        <span class=\"comment\">// 获取每个任务的返回结果</span></span><br><span class=\"line\">        String result = createOrder.get() + reduceAccount.get() + saveLog.get();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Async(&quot;doSomethingExecutor&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CompletableFuture&lt;String&gt; <span class=\"title\">doSomething1</span><span class=\"params\">(String message)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;do something1: &#123;&#125;&quot;</span>, message);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CompletableFuture.completedFuture(<span class=\"string\">&quot;do something1: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Async(&quot;doSomethingExecutor&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CompletableFuture&lt;String&gt; <span class=\"title\">doSomething2</span><span class=\"params\">(String message)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;do something2: &#123;&#125;&quot;</span>, message);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CompletableFuture.completedFuture(<span class=\"string\">&quot;; do something2: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Async(&quot;doSomethingExecutor&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CompletableFuture&lt;String&gt; <span class=\"title\">doSomething3</span><span class=\"params\">(String message)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;do something3: &#123;&#125;&quot;</span>, message);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CompletableFuture.completedFuture(<span class=\"string\">&quot;; do something3: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台上日志：</p>\n<img data-src=\"/posts/eec4b728/2022-02-16-21-01-47.png\" class=\"\">\n<h2 id=\"注意事项\"><a class=\"markdownIt-Anchor\" href=\"#注意事项\">#</a> <strong>注意事项</strong></h2>\n<p><code>@Async</code>  注解会在以下几个场景失效，也就是说明明使用了 <code>@Async</code>  注解，但就没有走多线程。</p>\n<ul>\n<li>异步方法使用 <code>static</code>  关键词修饰；</li>\n<li>异步类不是一个 <code>Spring</code>  容器的 <code>bean</code> （一般使用注解 <code>@Component</code>  和 <code>@Service</code> ，并且能被 <code>Spring</code>  扫描到）；</li>\n<li><code>SpringBoot</code>  应用中没有添加 <code>@EnableAsync</code>  注解；</li>\n<li>在同一个类中，一个方法调用另外一个有 <code>@Async</code>  注解的方法，注解不会生效。原因是 <code>@Async</code>  注解的方法，是在代理类中执行的。</li>\n</ul>\n<p>需要注意的是： 异步方法使用注解 <code>@Async</code>  的返回值只能为 <code>void</code>  或者 <code>Future</code>  及其子类，当返回结果为其他类型时，方法还是会异步执行，但是返回值都是 <code>null</code> ，部分源码如下：</p>\n<p><code>AsyncExecutionInterceptor</code> - <code>#invoke</code></p>\n<img data-src=\"/posts/eec4b728/2022-02-16-21-01-58.png\" class=\"\">\n<p>通过上边几个示例， <code>@Async</code>  实际还是通过 <code>Future</code>  或 <code>CompletableFuture</code>  来异步执行的， <code>Spring</code>  又封装了一下，让我们使用的更方便。</p>\n",
            "tags": [
                "Java面试",
                "SpringBoot"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/89080a8e/",
            "url": "https://smile1231.github.io/posts/89080a8e/",
            "title": "Spring Bean的生命周期",
            "date_published": "2022-02-15T14:34:55.000Z",
            "content_html": "<h1 id=\"spring-bean的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean的生命周期\">#</a>  <code>Spring Bean</code>  的生命周期</h1>\n<p>大致流程：</p>\n<p>本文将从以下两方面去帮助理解  <code>Bean</code>  的生命周期：</p>\n<span id=\"more\"></span>\n<ul>\n<li>生命周期的概要流程：对  <code>Bean</code>  的生命周期进行概括，并且结合代码来理解；</li>\n<li>扩展点的作用：详细介绍  <code>Bean</code>  生命周期中所涉及到的扩展点的作用。</li>\n</ul>\n<h2 id=\"生命周期的概要流程\"><a class=\"markdownIt-Anchor\" href=\"#生命周期的概要流程\">#</a> 生命周期的概要流程</h2>\n<p><code>Bean</code>  的生命周期概括起来就是  <code>4</code>  个阶段：</p>\n<ul>\n<li>\n<p>实例化（ <code>Instantiation</code> ）</p>\n</li>\n<li>\n<p>属性赋值（ <code>Populate</code> ）</p>\n</li>\n<li>\n<p>初始化（ <code>Initialization</code> ）</p>\n</li>\n<li>\n<p>销毁（ <code>Destruction</code> ）</p>\n</li>\n<li>\n<p>实例化：第  <code>1</code>  步，实例化一个  <code>bean</code>  对象；</p>\n</li>\n<li>\n<p>属性赋值：第  <code>2</code>  步，为  <code>bean</code>  设置相关属性和依赖；</p>\n</li>\n<li>\n<p>初始化：第  <code>3~7</code>  步，步骤较多，其中第  <code>5、6</code>  步为初始化操作，第  <code>3、4</code>  步为在初始化前执行，第  <code>7</code>  步在初始化后执行，该阶段结束，才能被用户使用；</p>\n</li>\n<li>\n<p>销毁：第  <code>8~10</code>  步，第 <code>8</code>  步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第 <code>9、10</code>  步真正销毁  <code>bean</code>  时再执行相应的方法。</p>\n</li>\n</ul>\n<p>下面我们结合代码来直观的看下，在  <code>doCreateBean()</code>  方法中能看到依次执行了这  <code>4</code>  个阶段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AbstractAutowireCapableBeanFactory.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">doCreateBean</span><span class=\"params\">(<span class=\"keyword\">final</span> String beanName, <span class=\"keyword\">final</span> RootBeanDefinition mbd, <span class=\"keyword\">final</span> <span class=\"meta\">@Nullable</span> Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> BeanCreationException </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 1. 实例化</span></span><br><span class=\"line\">    BeanWrapper instanceWrapper = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instanceWrapper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Object exposedObject = bean;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 属性赋值</span></span><br><span class=\"line\">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class=\"line\">        <span class=\"comment\">// 3. 初始化</span></span><br><span class=\"line\">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 4. 销毁-注册回调接口</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> exposedObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于初始化包含了第  <code>3~7</code>  步，较复杂，所以我们进到  <code>initializeBean()</code>  方法里具体看下其过程（注释的序号对应图中序号）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AbstractAutowireCapableBeanFactory.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">initializeBean</span><span class=\"params\">(<span class=\"keyword\">final</span> String beanName, <span class=\"keyword\">final</span> Object bean, <span class=\"meta\">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 检查 Aware 相关接口并设置相关依赖</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (System.getSecurityManager() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class=\"line\">            invokeAwareMethods(beanName, bean);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;, getAccessControlContext());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        invokeAwareMethods(beanName, bean);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 4. BeanPostProcessor 前置处理</span></span><br><span class=\"line\">    Object wrappedBean = bean;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mbd == <span class=\"keyword\">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class=\"line\">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 5. 若实现 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class=\"line\">    <span class=\"comment\">// 6. 若配置自定义的 init-method方法，则执行</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BeanCreationException(</span><br><span class=\"line\">            (mbd != <span class=\"keyword\">null</span> ? mbd.getResourceDescription() : <span class=\"keyword\">null</span>),</span><br><span class=\"line\">            beanName, <span class=\"string\">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 7. BeanPostProceesor 后置处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mbd == <span class=\"keyword\">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class=\"line\">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrappedBean;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"comment\">// AbstractAutowireCapableBeanFactory.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">initializeBean</span><span class=\"params\">(<span class=\"keyword\">final</span> String beanName, <span class=\"keyword\">final</span> Object bean, <span class=\"meta\">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 检查 Aware 相关接口并设置相关依赖</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (System.getSecurityManager() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class=\"line\">            invokeAwareMethods(beanName, bean);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;, getAccessControlContext());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        invokeAwareMethods(beanName, bean);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 4. BeanPostProcessor 前置处理</span></span><br><span class=\"line\">    Object wrappedBean = bean;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mbd == <span class=\"keyword\">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class=\"line\">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 5. 若实现 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class=\"line\">    <span class=\"comment\">// 6. 若配置自定义的 init-method方法，则执行</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BeanCreationException(</span><br><span class=\"line\">            (mbd != <span class=\"keyword\">null</span> ? mbd.getResourceDescription() : <span class=\"keyword\">null</span>),</span><br><span class=\"line\">            beanName, <span class=\"string\">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 7. BeanPostProceesor 后置处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mbd == <span class=\"keyword\">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class=\"line\">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrappedBean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在  <code>invokInitMethods()</code>  方法中会检查  <code>InitializingBean</code>  接口和  <code>init-method</code>  方法，销毁的过程也与其类似：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// DisposableBeanAdapter.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 9. 若实现 DisposableBean 接口，则执行 destory()方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.invokeDisposableBean) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (System.getSecurityManager() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class=\"line\">                    ((DisposableBean) <span class=\"keyword\">this</span>.bean).destroy();</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;, <span class=\"keyword\">this</span>.acc);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ((DisposableBean) <span class=\"keyword\">this</span>.bean).destroy();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">// 10. 若配置自定义的 detory-method 方法，则执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.destroyMethod != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        invokeCustomDestroyMethod(<span class=\"keyword\">this</span>.destroyMethod);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.destroyMethodName != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Method methodToInvoke = determineDestroyMethod(<span class=\"keyword\">this</span>.destroyMethodName);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (methodToInvoke != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>从  <code>Spring</code>  的源码我们可以直观的看到其执行过程，而我们记忆其过程便可以从这  <code>4</code>  个阶段出发，实例化、属性赋值、初始化、销毁。其中细节较多的便是初始化，涉及了  <code>Aware、BeanPostProcessor、InitializingBean、init-method</code>  的概念。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psMXpsMnpsMy9hcnRpY2xlL2RldGFpbHMvMTA1MDQ0OTU0\">拓展点讲解</span></p>\n",
            "tags": [
                "Java面试",
                "Spring"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/31d0fffb/",
            "url": "https://smile1231.github.io/posts/31d0fffb/",
            "title": "Mybatis中#号和$号的区别",
            "date_published": "2022-02-15T14:33:42.000Z",
            "content_html": "<h1 id=\"mybatis中号和号的区别\"><a class=\"markdownIt-Anchor\" href=\"#mybatis中号和号的区别\">#</a>  <code>Mybatis</code>  中 <code>#</code> 号和 <code>$</code>  号的区别</h1>\n<h2 id=\"默认会用引号将参数引起来\"><a class=\"markdownIt-Anchor\" href=\"#默认会用引号将参数引起来\">#</a>  <code>#&#123;&#125;</code>  默认会用引号将参数引起来</h2>\n<h2 id=\"单纯替代\"><a class=\"markdownIt-Anchor\" href=\"#单纯替代\">#</a>  <code>$&#123;&#125;</code>  单纯替代</h2>\n<p>示例：</p>\n<span id=\"more\"></span>\n<p>之前的写法， <code>select * from product_tree_v pv where pv.product_code in(#&#123;product&#125;)</code></p>\n<p>预编译出来的结果： <code>select * from product_tree_v pv where pv.product_code in ？</code> ;</p>\n<p><code>#&#123;&#125;</code>  被当作一个占位符了，而参数前后也会被加上引号。</p>\n<p>运行时的 <code>sql</code>  是： <code>select * from product_tree_v pv where pv.product_code in('‘p001','p002','p003'')</code> ;</p>\n<p>所以无论如何都是查不到数据的。</p>\n<p>换成 <code>$&#123;&#125;</code> ： <code>select * from product_tree_v pv where pv.product_code in($product&#125;)</code> ;</p>\n<p>预编译出来的结果 ： <code>select * from product_tree_v pv where pv.product_code in (‘p001','p002','p003')</code> ;</p>\n<p>这样就是纯粹的将参数传进去，没有做任何的转义操作。这才是我们真正想要的。</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><code>mybatis</code>  作为 <code>ORM</code>  框架，从性能，系统维护性，实用性上来说，都是非常优秀的，</p>\n<p>其所有的 <code>sql</code>  在执行前都会通过数据库驱动进行预编译，这样 <code>DBMS</code>  就可以不用编译直接接收参数运行，</p>\n<p>而 <code>#</code> 和 <code>$</code>  号的区别在预编译后就能看出来了， <code>#&#123;&#125;</code>  预编译完是占位符 <code>?</code> ，而 <code>$&#123;&#125;</code>  预编译完就是传进来的参数。</p>\n<h2 id=\"的优点\"><a class=\"markdownIt-Anchor\" href=\"#的优点\">#</a>  <code>#&#123;&#125;</code>  的优点：</h2>\n<p>使用 <code>#&#123;&#125;</code>  可以预防 <code>sql</code>  攻击，而 <code>$&#123;&#125;</code>  却不能</p>\n<p>例如  <code>select * from $&#123;tablename&#125; </code>   如果传入的是  <code>product; drop product;</code></p>\n<p>那么你的表数据就会被无声无息的干掉了。</p>\n<p>使用 <code>$&#123;&#125;</code>  的场景：</p>\n<ol>\n<li>\n<p>作为 <code>in</code>  条件时，</p>\n</li>\n<li>\n<p>参数为 <code>int</code>  类型并且数据库中字段的类型是 <code>number</code> ，</p>\n</li>\n<li>\n<p>表名</p>\n</li>\n<li>\n<p><code>order by $&#123;&#125;</code> ，排序字段</p>\n</li>\n</ol>\n<p><code>--------------------------ps----------------------------</code></p>\n<p><code>&lt;![CDATA[]]&gt;</code>  的用法，在该符号内的语句，将不会被当成字符串来处理，而是直接当成 <code>sql</code>  语句，比如有大于，小于号，要执行一个存储过程都需要加上这个。</p>\n",
            "tags": [
                "Java面试",
                "Mybatis"
            ]
        }
    ]
}
<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CEST与北京时间转换表</title>
    <url>/blog/posts/ef55dc85/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9kYXRldGltZTM2MC5jb20vY24vY2V0LWJlaWppbmctdGltZS8=">参考链接</span></p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>中欧夏令时间(CEST)</th>
<th>北京时间(Beijing)</th>
</tr>
</thead>
<tbody><tr>
<td>00:00</td>
<td>06:00</td>
</tr>
<tr>
<td>01:00</td>
<td>07:00</td>
</tr>
<tr>
<td>02:00</td>
<td>08:00</td>
</tr>
<tr>
<td>03:00</td>
<td>09:00</td>
</tr>
<tr>
<td>04:00</td>
<td>10:00</td>
</tr>
<tr>
<td>05:00</td>
<td>11:00</td>
</tr>
<tr>
<td>06:00</td>
<td>12:00</td>
</tr>
<tr>
<td>07:00</td>
<td>13:00</td>
</tr>
<tr>
<td>08:00</td>
<td>14:00</td>
</tr>
<tr>
<td>09:00</td>
<td>15:00</td>
</tr>
<tr>
<td>10:00</td>
<td>16:00</td>
</tr>
<tr>
<td>11:00</td>
<td>17:00</td>
</tr>
<tr>
<td>12:00</td>
<td>18:00</td>
</tr>
<tr>
<td>13:00</td>
<td>19:00</td>
</tr>
<tr>
<td>14:00</td>
<td>20:00</td>
</tr>
<tr>
<td>15:00</td>
<td>21:00</td>
</tr>
<tr>
<td>16:00</td>
<td>22:00</td>
</tr>
<tr>
<td>17:00</td>
<td>23:00</td>
</tr>
<tr>
<td>18:00</td>
<td>00:00+1天</td>
</tr>
<tr>
<td>19:00</td>
<td>01:00+1天</td>
</tr>
<tr>
<td>20:00</td>
<td>02:00+1天</td>
</tr>
<tr>
<td>21:00</td>
<td>03:00+1天</td>
</tr>
<tr>
<td>22:00</td>
<td>04:00+1天</td>
</tr>
<tr>
<td>23:00</td>
<td>05:00+1天</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>SAP</category>
      </categories>
      <tags>
        <tag>SAP</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache、Cookie、Session、Token</title>
    <url>/blog/posts/b42f0c87/</url>
    <content><![CDATA[<h1 id="Cache、Cookie、Session、Token"><a href="#Cache、Cookie、Session、Token" class="headerlink" title="Cache、Cookie、Session、Token"></a><code>Cache、Cookie、Session、Token</code></h1><h2 id="协议是什么"><a href="#协议是什么" class="headerlink" title="协议是什么"></a>协议是什么</h2><p>在接口测试中，客户端发送的<code>request</code>至服务端反馈的<code>response</code>中传输的数据就是接口测试最重要的部分</p>
<h2 id="Cache是什么"><a href="#Cache是什么" class="headerlink" title="Cache是什么"></a><code>Cache</code>是什么</h2><span id="more"></span>

<p>打开浏览器或者应用的时候，用户的等待时间叫做响应时间，打开速度影响到用户体验，提高反应速度的一个方法就是使用缓存策略，缓存策略能带来什么好处呢？</p>
<ol>
<li><p>减少延迟：因为网页请求指向的是更接近的客户端缓存，而不是资源服务器，所以花费的时间更短，提高用户体验</p>
</li>
<li><p>降低网络负荷：因为缓存可以重复使用，节省带宽，降低网络负荷，也就可以更加节省用户的流量</p>
</li>
</ol>
<blockquote>
<p>缓存一般分为以下几种：</p>
</blockquote>
<ol>
<li><p>浏览器缓存　　　　<br>（缓存在本地）</p>
</li>
<li><p>代理缓存　　　　　<br>（缓存在网络路由，也就是共享缓存）</p>
</li>
<li><p>网关缓存　　　　　<br>(缓存在CDN)</p>
</li>
</ol>
<h2 id="缓存策略一般分两种情况："><a href="#缓存策略一般分两种情况：" class="headerlink" title="缓存策略一般分两种情况："></a>缓存策略一般分两种情况：</h2><ol>
<li><p>强缓存　　　　(直接在本地缓存中读取资源)</p>
</li>
<li><p>协商缓存　　  (通过服务器告知是否能用本地缓存，先和服务器协商，如果可以，就从本地缓存中读取。如果不可以，就返回最新的资源)</p>
</li>
</ol>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><code>Cookie</code></h2><p><code>Cookie</code>的内容是保存一小段文本信息。组成一个通行证，用来处理客户端无状态协议的一种解决方案</p>
<p><code>Cookie</code>使用原理如下：</p>
<ol>
<li><p>用户会提供信息提交给服务器</p>
</li>
<li><p>服务端向客户端回传相应数据的同时，也会发回<code>Cookie</code></p>
</li>
<li><p>客户端接收到服务器相应后，浏览器将<code>Cookie</code>保存在同一个位置</p>
</li>
<li><p>客户端向服务端发送请求的实话，会把<code>Cookie</code>再次发回服务端</p>
</li>
</ol>
<h2 id="获取Cookie的途径"><a href="#获取Cookie的途径" class="headerlink" title="获取Cookie的途径"></a>获取<code>Cookie</code>的途径</h2><ol>
<li><p>浏览器自带的开发工具或者抓包工具<code>（Fiddler,Charles）</code></p>
</li>
<li><p>本地获取（<code>ie</code>的路径为<code>C</code>盘<code>appdata/Microsoft/Windows/Cookies，Firefox位于C盘appdata/Mozilla/Firefox/Profiles，Charome位于C盘appdata/Goole/Chrome/User Date /Default）</code></p>
</li>
<li><p><code>js</code>代码查看(浏览器地址栏输入<code>Javascript:alert(document.cookie)</code>)</p>
</li>
</ol>
<h2 id="Session是什么"><a href="#Session是什么" class="headerlink" title="Session是什么"></a><code>Session</code>是什么</h2><p><code>Session</code>是另外一种记录用户状态的机制，不同于<code>Cookie</code>的是<code>Session</code>是保存在服务器上，用来解决服务端对无状态协议</p>
<p><code>Session</code>的传输步骤</p>
<ol>
<li><p>服务端创建<code>Session</code>，并创建唯一的<code>id</code></p>
</li>
<li><p>服务器将<code>id</code>发给客户端</p>
</li>
<li><p>客户端再次发送请求的实话带上<code>Session</code>的<code>id</code></p>
</li>
<li><p>服务器接收到请求后根据<code>Seesion</code>的<code>id</code>找到相应的<code>Session</code>，完成相应</p>
</li>
</ol>
<h2 id="Session的传输媒介"><a href="#Session的传输媒介" class="headerlink" title="Session的传输媒介"></a><code>Session</code>的传输媒介</h2><ol>
<li><p>通过<code>Cookie</code>传输</p>
</li>
<li><p>通过<code>URL</code>地址重写</p>
</li>
</ol>
<blockquote>
<p>很多同学不知道<code>Session</code>和<code>Cookie</code>的区别，那么我来大概讲解一下我理解的</p>
</blockquote>
<ol>
<li><p>存储位置不同：大多数情况<code>Cookie</code>存储在浏览器，<code>Session</code>存储在服务器</p>
</li>
<li><p>存储容量不同：单个<code>Cookie</code>保存的数据不得超过<code>4kb</code>，一个站点最多<code>20</code>个<code>Cookie</code>，<code>Session</code>一般情况下没有上限，不过建议不要存放太多东西影响性能</p>
</li>
<li><p>存取方式不同：<code>Cookie</code>只能用<code>ASCII</code>字符串。通过编码方式获取<code>Unicode</code>字符或者<code>二进制</code>数据。不好存储复杂的信息，<code>Session</code>能存储任何类型的数据</p>
</li>
<li><p>隐私策略不同：<code>Cookie</code>放在客户端，可以进行<code>Cookie</code>欺骗，所以不安全。<code>Session</code>放在服务端，更加安全</p>
</li>
<li><p>有效期不同：<code>Cookie</code>可以设置属性达到长期有效，<code>Session</code>依赖于<code>JSESSIONID</code>的<code>Cookie</code>，<code>Cookie JSESSIONID</code>的过期时间默认为<code>-1</code>，只需要关闭窗口<code>Session</code>就会失效，，就算不依赖<code>Cookie</code>，</p>
</li>
</ol>
<blockquote>
<p>用<code>UrL</code>重写也不能完成，如果<code>Session</code>超时时间过长，容易导致内存溢出</p>
</blockquote>
<ol start="6">
<li>服务器压力不同：<code>Cookie</code>保存子本地。不存在服务端压力。<code>Session</code>保存在服务端，每个用户产生一个<code>Session</code>，并发过多非常占用内存</li>
</ol>
<p>7.浏览器支持不同：如果浏览器禁用<code>Cookie</code>，那么<code>Cookie</code>直接失效。<code>Session</code>比较好点。可以用<code>URL</code>重写</p>
<p>8.跨域不同：<code>Cookie</code>支持跨域访问，<code>Session</code>不支持跨域</p>
<h2 id="Token是什么："><a href="#Token是什么：" class="headerlink" title="Token是什么："></a><code>Token</code>是什么：</h2><ol>
<li><p>当客户端第一次请求的实话，发送用户信息到服务端，服务器对用户信息使用<code>HSA256</code>算法以及密钥进行签名，再将这个签名和数据一次作为<code>Token</code>返回给客户端</p>
</li>
<li><p>服务端不保存<code>Token</code>，客户端保存<code>Token</code></p>
</li>
<li><p>客户端再次请求的实话，将<code>Token</code>发送给服务端</p>
</li>
<li><p>服务端同样用<code>HSA256</code>算法和同样的密钥对数据再一次计算签名，和<code>Token</code>中的签名做比较（如果相同，直接登录，不相同，登录失败）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Cache</tag>
        <tag>Cookie</tag>
        <tag>Session</tag>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title>CRISPR-Cas9英文介绍</title>
    <url>/blog/posts/1f142005/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Every cell in our body contains a copy of our genome(基因组)--over 20,000 genes, 3 billion letters of DNA. DNA consists of two strings twisted into a double helix and held together by a simple pairing rule -- A pairs with T and G pairs with C. Our genes shape who we are as individuals and as a species. Genes also have profound effects on health. And thanks to advances in DNA sequencing, researchers have identified thousands of genes that affect our risk of disease. To understand how genes work, researchers need ways to control them. Changing genes and living cells are not easy. But recently, a new method has been developed that promised to dramatically improve our ability to edit the DNA of any species, including humans.</span><br><span class="line">在我们的身体每一个细胞都包含一份我们的基因组(基因组)——超过20000个基因,30亿个字母的DNA。扭成一个双螺旋DNA包含两个字符串,由一个简单的配对规则——一个对与T和G双c基因形状我们个人和作为一个物种。基因对健康也有深远的影响。由于DNA测序技术的发展,研究人员已经确定了成千上万的基因,影响我们的疾病的风险。为了理解基因是如何工作的,研究人员需要一些方法来控制它们。改变基因和活细胞是不容易的。但最近,科学家发明了一种新方法,承诺将大大提高我们编辑任何物种的DNA的能力,包括人类。</span><br><span class="line"></span><br><span class="line">The CRISPR method is based on a natural system used by bacteria to protect themselves from infection by viruses. When the bacteria detects the presents of virus DNA, it produces two types of short RNA, one of which contains sequence that matches that of the invading virus. These two RNAs from a complex with a protein called CAS 9. CAS 9 is a nuclease(核酸酶), a type of enzyme that can cut DNA. When the matching sequence, known as a guide RNA, finds its target within the viral genome, the CAS 9 cuts the target DNA, disabling the virus.</span><br><span class="line">CRISPR方法是基于自然系统所使用的保护自己免受细菌感染病毒。当细菌检测到病毒DNA的礼物,它产生两种类型的短RNA,其中一个包含入侵病毒的序列相匹配。这两个rna从一个复杂的蛋白质称为CAS 9。中科院9是一个核酸酶(核酸酶),一种酶,这种酶能降低DNA。当匹配序列,称为指南RNA,发现其目标在病毒基因组,CAS 9削减目标DNA,禁用病毒。</span><br><span class="line"></span><br><span class="line">Over the past few years, researchers studying the system realized that it could be engineered to cut not just viral DNA but any DNA sequence at a precisely chosen location by changing the guide RNA to match the target. And this can be done not just in a test tube, but also within the nucleus of a living cell. Once inside the nucleus, the resulting complex will lock onto a short sequence known as the PAM.</span><br><span class="line">在过去的几年中,研究人员系统意识到它可以改造不仅减少病毒DNA,任何DNA序列精确选择位置通过改变引导RNA与目标相匹配。这不仅可以在试管中,但是也活细胞的细胞核内。一旦进入细胞核,由此产生的复杂将锁定一个短序列称为PAM。</span><br><span class="line"></span><br><span class="line">The CAS 9 will unzip the DNA, and matches to its target RNA. If the match is complete, the CAS 9 will use two tiny molecular scissors to cut the DNA. When this happens, the cell tries to repair the cut. But the repair processes error-prone, leading to mutations(突变) that can disable the gene, allowing researchers to understand its function. These mutations are random, but sometimes researchers need to be more precise. For example, by replacing the muton gene with the healthy copy. This can be done by adding another piece of DNA that carries the desired sequence. Once the CRIPSR system has made a cut, this DNA template(模板) can pair up(配对) with a cut ends, recombining and replacing the original sequence with the new version.</span><br><span class="line">CAS 9将解压DNA、RNA和匹配目标。如果匹配完成,CAS 9将使用两个小分子剪刀切断DNA。当这种情况发生时,细胞试图修复。但修复过程出错,导致突变(突变),可以禁用该基因,让研究人员了解其功能。这些突变是随机的,但有时人员需要更精确。例如,通过替换突变子基因与健康的副本。可以通过添加另一个DNA片段,携带所需的序列。一旦CRIPSR系统使得削减,这DNA模板(模板)可以配对(配对)将结束,重组和新版本替换原有的序列。</span><br><span class="line"></span><br><span class="line">All this can be done in cultured cells including stem cells that can give rise to many different cell types. It can also be done in a fertilized egg(受精卵), allowing the creation of transgenic animals with targeted mutations. And unlike previous methods, CRISPR can be used to target many genes at once. A big advantage for studying in complex human diseases that are caused not by a single mutation, but by many genes acting together. These methods are being improved rapidly and will have many applications in basic research, in drug development, in agriculture, and perhaps eventually for treating human patients with genetic disease.</span><br><span class="line">所有这一切都可以通过培养细胞包括干细胞,可以产生许多不同的细胞类型。也可以做在一个受精卵(受精卵),允许建立转基因动物和有针对性的突变。和以前的方法不同,CRISPR可用于目标许多基因。研究在复杂的人类疾病的一大优势,而不是单一突变引起的,而是由许多基因一起表演。这些方法正在迅速改善,将会有许多应用基础研究,在药物开发,农业,或许最终治疗人类遗传性疾病患者。</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>基因编辑</category>
      </categories>
      <tags>
        <tag>生物信息</tag>
        <tag>基因编辑</tag>
      </tags>
  </entry>
  <entry>
    <title>Corn表达式</title>
    <url>/blog/posts/9dcbb5fa/</url>
    <content><![CDATA[<h1 id="Corn表达式"><a href="#Corn表达式" class="headerlink" title="Corn表达式"></a><code>Corn</code>表达式</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个cron表达式有至少6个（也可能7个）有空格分隔的时间元素。</span><br><span class="line">按顺序依次为</span><br><span class="line">秒（0~59）</span><br><span class="line">分钟（0~59）</span><br><span class="line">小时（0~23）</span><br><span class="line">天（月）（0~31，但是你需要考虑你月的天数）</span><br><span class="line">月（0~11）</span><br><span class="line">天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）</span><br><span class="line">年份（1970－2099）</span><br><span class="line"></span><br><span class="line">其中每个元素可以是一个值(如6),一个连续区间(9-12),一个间隔时间(8-18/4)(/表示每隔4小时),一个列表(1,3,5),通配符。由于&quot;月份中的日期&quot;和&quot;星期中的日期&quot;这两个元素互斥的,必须要对其中一个设置?</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<table>
<thead>
<tr>
<th>字段</th>
<th>是否必填</th>
<th>允许值</th>
<th>允许特殊字符</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>Seconds</code></td>
<td>是</td>
<td>0–59</td>
<td><code>*,-</code></td>
<td>标准实现不支持此字段。</td>
</tr>
<tr>
<td><code>Minutes</code></td>
<td>是</td>
<td>0–59</td>
<td><code>*,-</code></td>
<td></td>
</tr>
<tr>
<td><code>Hours</code></td>
<td>是</td>
<td>0–23</td>
<td><code>*,-</code></td>
<td></td>
</tr>
<tr>
<td><code>Day of month</code></td>
<td>是</td>
<td>1–31</td>
<td><code>*,-?LW</code></td>
<td><code>?LW</code>只有部分软件实现了</td>
</tr>
<tr>
<td><code>Month</code></td>
<td>是</td>
<td><code>1–12 or JAN–DEC</code>    <code>*,-</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Day of week</code></td>
<td>是</td>
<td><code>0–7 or SUN–SAT</code></td>
<td><code>*,-?L#</code></td>
<td><code>?L#</code>只有部分软件实现了<code>Linux</code>和<code>Spring</code>的允许值为<code>0-7</code>，<code>0</code>和<code>7</code>为周日<code>Quartz</code>的允许值为<code>1-7</code>，<code>1</code>为周日</td>
</tr>
<tr>
<td><code>Year</code></td>
<td>否</td>
<td><code>1970–2099</code></td>
<td><code>*,-</code></td>
<td>标准实现不支持此字段。</td>
</tr>
</tbody></table>
<p>每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是：</p>
<ol>
<li><p><code>*</code>：表示匹配该域的任意值，假如在<code>Minutes</code>域使用*, 即表示每分钟都会触发事件。</p>
</li>
<li><p><code>?</code>:只能用在<code>DayofMonth</code>和<code>DayofWeek</code>两个域。它也匹配域的任意值，但实际不会。因为<code>DayofMonth</code>和<code>DayofWeek</code>会相互影响。例如想在每月的<code>20</code>日触发调度，不管<code>20</code>日到底是星期几，则只能使用如下写法： <code>13 13 15 20 * ?</code>, 其中最后一位只能用<code>？</code>，而不能使用<code>*</code>，如果使用<code>*</code>表示不管星期几都会触发，实际上并不是这样。</p>
</li>
<li><p><code>-</code>:表示范围，例如在<code>Minutes</code>域使用<code>5-20</code>，表示从<code>5</code>分到<code>20</code>分钟每分钟触发一次</p>
</li>
<li><p><code>/</code>：表示起始时间开始触发，然后每隔固定时间触发一次，例如在<code>Minutes</code>域使用<code>5/20</code>,则意味着<code>5</code>分钟触发一次，而<code>25，45</code>等分别触发一次.</p>
</li>
<li><p><code>,</code>:表示列出枚举值值。例如：在<code>Minutes</code>域使用<code>5,20</code>，则意味着在<code>5</code>和<code>20</code>分每分钟触发一次。</p>
</li>
<li><p><code>L</code>:表示最后，只能出现在<code>DayofWeek</code>和<code>DayofMonth</code>域，如果在<code>DayofWeek</code>域使用<code>5L</code>,意味着在最后的一个星期四触发。</p>
</li>
<li><p><code>W</code>:表示有效工作日(周一到周五),只能出现在<code>DayofMonth</code>域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 <code>DayofMonth</code>使用<code>5W</code>，如果<code>5</code>日是星期六，则将在最近的工作日：星期五，即<code>4</code>日触发。如果<code>5</code>日是星期天，则在<code>6</code>日(周一)触发；如果<code>5</code>日在星期一到星期五中的一天，则就在<code>5</code>日触发。另外一点，<code>W</code>的最近寻找不会跨过月份</p>
</li>
<li><p><code>LW</code>:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。</p>
</li>
<li><p><code>#</code>:用于确定每个月第几个星期几，只能出现在<code>DayofMonth</code>域。例如在<code>4#2</code>，表示某月的第二个星期三。</p>
</li>
</ol>
<p>一些例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举几个例子:</span><br><span class="line">0 0 2 1 * ? *    表示在每月的1日的凌晨2点调度任务</span><br><span class="line">0 15 10 ? * MON-FRI    表示周一到周五每天上午10：15执行作业</span><br><span class="line">0 15 10 ? 6L 2002-2006    表示2002-2006年的每个月的最后一个星期五上午10:15执行作</span><br></pre></td></tr></table></figure>

<p>其中每个元素可以是一个值<code>(如6)</code>,一个连续区间<code>(9-12)</code>,一个间隔时间<code>(8-18/4)(/表示每隔4小时)</code>,一个列表<code>(1,3,5)</code>,通配符。由于”月份中的日期”和”星期中的日期”这两个元素互斥的,必须要对其中一个设置?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 10,14,16 * * ? 每天上午10点，下午2点，4点</span><br><span class="line">0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时</span><br><span class="line">0 0 12 ? * WED 表示每个星期三中午12点</span><br><span class="line">&quot;0 0 12 * * ?&quot; 每天中午12点触发</span><br><span class="line">&quot;0 15 10 ? * *&quot; 每天上午10:15触发</span><br><span class="line">&quot;0 15 10 * * ?&quot; 每天上午10:15触发</span><br><span class="line">&quot;0 15 10 * * ? *&quot; 每天上午10:15触发</span><br><span class="line">&quot;0 15 10 * * ? 2005&quot; 2005年的每天上午10:15触发</span><br><span class="line">&quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发</span><br><span class="line">&quot;0 0/5 14 * * ?&quot; 在每天下午2点到下午2:55期间的每5分钟触发</span><br><span class="line">&quot;0 0/5 14,18 * * ?&quot; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</span><br><span class="line">&quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发</span><br><span class="line">&quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午2:10和2:44触发</span><br><span class="line">&quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午10:15触发</span><br><span class="line">&quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发</span><br><span class="line">&quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发</span><br><span class="line">&quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发</span><br><span class="line">&quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月的最后一个星期五上午10:15触发</span><br><span class="line">&quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发</span><br></pre></td></tr></table></figure>

<p>有些子表达式能包含一些范围或列表</p>
<p>例如：子表达式（天（星期））可以为 <code>“MON-FRI”</code>，<code>“MON，WED，FRI”</code>，<code>“MON-WED,SAT”</code></p>
<p><code>“*”</code>字符代表所有可能的值</p>
<p>因此，<code>“*”</code>在子表达式（月）里表示每个月的含义，<code>“*”</code>在子表达式（天（星期））表示星期的每一天</p>
<p><code>“/”</code>字符用来指定数值的增量<br>例如：在子表达式（分钟）里的<code>“0/15”</code>表示从第<code>0</code>分钟开始，每<code>15</code>分钟<br>在子表达式（分钟）里的<code>“3/20”</code>表示从第<code>3</code>分钟开始，每<code>20</code>分钟（它和<code>“3，23，43”</code>）的含义一样</p>
<p><code>“？”</code>字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值<br>当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为<code>“?”</code></p>
<p><code>“L” </code>字符仅被用于天（月）和天（星期）两个子表达式，它是单词<code>“last”</code>的缩写<br>但是它在两个子表达式里的含义是不同的。<br>在天（月）子表达式中，<code>“L”</code>表示一个月的最后一天<br>在天（星期）自表达式中，<code>“L”</code>表示一个星期的最后一天，也就是<code>SAT</code></p>
<p>如果在<code>“L”</code>前有具体的内容，它就具有其他的含义了</p>
<p>例如：<code>“6L”</code>表示这个月的倒数第<code>６</code>天，<code>“FRIL”</code>表示这个月的最一个星期五<br>注意：在使用<code>“L”</code>参数时，不要指定列表或范围，因为这会导致问题</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">字段 允许值 允许的特殊字符</span><br><span class="line">秒 0<span class="string">-59</span> , - * /</span><br><span class="line">分 0<span class="string">-59</span> , - * /</span><br><span class="line">小时 0<span class="string">-23</span> , - * /</span><br><span class="line">日期 1<span class="string">-31</span> , - * ? / L W C</span><br><span class="line">月份 1<span class="string">-12</span> 或者 JAN-DEC , - * /</span><br><span class="line">星期 1<span class="string">-7</span> 或者 SUN-SAT , - * ? / L C #</span><br><span class="line">年（可选） 留空, 1970<span class="string">-2099</span> , - * /</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Corn</tag>
      </tags>
  </entry>
  <entry>
    <title>Css选择器</title>
    <url>/blog/posts/7f59931c/</url>
    <content><![CDATA[<h1 id="Css-选择器"><a href="#Css-选择器" class="headerlink" title="Css 选择器"></a>Css 选择器</h1><table>
<thead>
<tr>
<th>选择器</th>
<th align="center">例子</th>
<th align="center">例子描述</th>
<th align="right">CSS</th>
</tr>
</thead>
<tbody><tr>
<td>.class</td>
<td align="center">.intro</td>
<td align="center">选择 class=”intro” 的所有元素.</td>
<td align="right">1</td>
</tr>
<tr>
<td>#id</td>
<td align="center">#firstname</td>
<td align="center">选择 id=”firstname” 的所有元素</td>
<td align="right">1</td>
</tr>
<tr>
<td>*</td>
<td align="center">*</td>
<td align="center">选择所有元素。</td>
<td align="right">2</td>
</tr>
<tr>
<td>element</td>
<td align="center">p</td>
<td align="center">选择所有 <p> 元素。</td>
<td align="right">1</td>
</tr>
<tr>
<td>element,element</td>
<td align="center">div,p</td>
<td align="center">选择所有 <div> 元素和所有 <p> 元素。</td>
<td align="right">1</td>
</tr>
<tr>
<td>element element</td>
<td align="center">div p</td>
<td align="center">选择 <div> 元素内部的所有 <p> 元素。</td>
<td align="right">1</td>
</tr>
<tr>
<td>element&gt;element</td>
<td align="center">div&gt;p</td>
<td align="center">选择父元素为 <div> 元素的所有 <p> 元素。</td>
<td align="right">2</td>
</tr>
<tr>
<td>element+element</td>
<td align="center">div+p</td>
<td align="center">选择紧接在 <div> 元素之后的所有 <p> 元素。</td>
<td align="right">2</td>
</tr>
<tr>
<td>[attribute]</td>
<td align="center">[target]</td>
<td align="center">选择带有 target 属性所有元素。</td>
<td align="right">2</td>
</tr>
<tr>
<td>[attribute=value]</td>
<td align="center">[target=_blank]</td>
<td align="center">选择 target=”_blank” 的所有元素。</td>
<td align="right">2</td>
</tr>
<tr>
<td>[attribute~=value]</td>
<td align="center">[title~=flower]</td>
<td align="center">选择 title 属性包含单词 “flower” 的所有元素。</td>
<td align="right">2</td>
</tr>
<tr>
<td>[attribute=value]</td>
<td align="center">[lang=en]</td>
<td align="center">选择 lang 属性值以 “en” 开头的所有元素。</td>
<td align="right">2</td>
</tr>
<tr>
<td>:link</td>
<td align="center">a:link</td>
<td align="center">选择所有未被访问的链接。</td>
<td align="right">1</td>
</tr>
<tr>
<td>:visited</td>
<td align="center">a:visited</td>
<td align="center">选择所有已被访问的链接。</td>
<td align="right">1</td>
</tr>
<tr>
<td>:active</td>
<td align="center">a:active</td>
<td align="center">选择活动链接。</td>
<td align="right">1</td>
</tr>
<tr>
<td>:hover</td>
<td align="center">a:hover</td>
<td align="center">选择鼠标指针位于其上的链接。</td>
<td align="right">1</td>
</tr>
<tr>
<td>:focus</td>
<td align="center">input:focus</td>
<td align="center">选择获得焦点的 input 元素。</td>
<td align="right">2</td>
</tr>
<tr>
<td>:first-letter</td>
<td align="center">p:first-letter</td>
<td align="center">选择每个 <p> 元素的首字母。</td>
<td align="right">1</td>
</tr>
<tr>
<td>:first-line</td>
<td align="center">p:first-line</td>
<td align="center">选择每个 <p> 元素的首行。</td>
<td align="right">1</td>
</tr>
<tr>
<td>:first-child</td>
<td align="center">p:first-child</td>
<td align="center">选择属于父元素的第一个子元素的每个 <p> 元素。</td>
<td align="right">2</td>
</tr>
<tr>
<td>:before</td>
<td align="center">p:before</td>
<td align="center">在每个 <p> 元素的内容之前插入内容。</td>
<td align="right">2</td>
</tr>
<tr>
<td>:after</td>
<td align="center">p:after</td>
<td align="center">在每个 <p> 元素的内容之后插入内容。</td>
<td align="right">2</td>
</tr>
<tr>
<td>:lang(language)</td>
<td align="center">p:lang(it)</td>
<td align="center">选择带有以 “it” 开头的 lang 属性值的每个 <p> 元素。</td>
<td align="right">2</td>
</tr>
<tr>
<td>element1~element2</td>
<td align="center">p~ul</td>
<td align="center">选择前面有 <p> 元素的每个 <ul> 元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>[attribute^=value]</td>
<td align="center">a[src^=”https”]</td>
<td align="center">选择其 src 属性值以 “https” 开头的每个 <a> 元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td align="center">a[src$=”.pdf”]</td>
<td align="center">选择其 src 属性以 “.pdf” 结尾的所有 <a> 元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>[attribute*=value]</td>
<td align="center">a[src*=”abc”]</td>
<td align="center">选择其 src 属性中包含 “abc” 子串的每个 <a> 元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:first-of-type</td>
<td align="center">p:first-of-type</td>
<td align="center">选择属于其父元素的首个 <p> 元素的每个 <p> 元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:last-of-type</td>
<td align="center">p:last-of-type</td>
<td align="center">选择属于其父元素的最后 <p> 元素的每个 <p> 元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:only-of-type</td>
<td align="center">p:only-of-type</td>
<td align="center">选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:only-child</td>
<td align="center">p:only-child</td>
<td align="center">选择属于其父元素的唯一子元素的每个 <p> 元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td align="center">p:nth-child(2)</td>
<td align="center">选择属于其父元素的第二个子元素的每个 <p> 元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td align="center">p:nth-last-child(2)</td>
<td align="center">同上，从最后一个子元素开始计数。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td align="center">p:nth-of-type(2)</td>
<td align="center">选择属于其父元素第二个 <p> 元素的每个 <p> 元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td align="center">p:nth-last-of-type(2)</td>
<td align="center">同上，但是从最后一个子元素开始计数。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:last-child</td>
<td align="center">p:last-child</td>
<td align="center">选择属于其父元素最后一个子元素每个 <p> 元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:root</td>
<td align="center">:root</td>
<td align="center">选择文档的根元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:empty</td>
<td align="center">p:empty</td>
<td align="center">选择没有子元素的每个 <p> 元素（包括文本节点）。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:target</td>
<td align="center">#news:target</td>
<td align="center">选择当前活动的 #news 元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:enabled</td>
<td align="center">input:enabled</td>
<td align="center">选择每个启用的 input元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:disabled</td>
<td align="center">input:disabled</td>
<td align="center">选择每个禁用的 input 元素</td>
<td align="right">3</td>
</tr>
<tr>
<td>:checked</td>
<td align="center">input:checked</td>
<td align="center">选择每个被选中的 input 元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>:not(selector)</td>
<td align="center">:not(p)</td>
<td align="center">选择非 p 元素的每个元素。</td>
<td align="right">3</td>
</tr>
<tr>
<td>::selection</td>
<td align="center">::selection</td>
<td align="center">选择被用户选取的元素部分。</td>
<td align="right">3</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>Css样式</title>
    <url>/blog/posts/54880bcd/</url>
    <content><![CDATA[<h1 id="Css样式"><a href="#Css样式" class="headerlink" title="Css样式"></a>Css样式</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9jc3NyZWYvY3NzLXJlZmVyZW5jZS5odG1s">CSS菜鸟学习链接</span></p>
<blockquote>
<p><strong>opacity</strong></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">透明度 </span><br><span class="line">value	规定不透明度。从 <span class="number">0.0</span> （完全透明）到 <span class="number">1.0</span>（完全不透明）。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>text-align</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>value</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>把文本排列到左边。默认值：由浏览器决定。</td>
</tr>
<tr>
<td>right</td>
<td>把文本排列到右边。</td>
</tr>
<tr>
<td>center</td>
<td>把文本排列到中间。</td>
</tr>
<tr>
<td>justify</td>
<td>实现两端对齐文本效果。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 text-align 属性的值。</td>
</tr>
</tbody></table>
<span id="more"></span>

<blockquote>
<p><strong>overflow</strong></p>
</blockquote>
<p>这个属性定义溢出元素内容区的内容会如何处理。如果值为 scroll，不论是否需要，用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也会出现滚动条。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>visible</td>
<td>默认值。内容不会被修剪，会呈现在元素框之外。</td>
</tr>
<tr>
<td>hidden</td>
<td>内容会被修剪，并且其余内容是不可见的。</td>
</tr>
<tr>
<td>scroll</td>
<td>内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</td>
</tr>
<tr>
<td>auto</td>
<td>如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 overflow 属性的值。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>border-collapse</strong></p>
</blockquote>
<p>border-collapse 属性设置表格的边框是否被合并为一个单一的边框，还是象在标准的 HTML 中那样分开显示。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>collapse</td>
<td>如果可能，边框会合并为一个单一的边框。会忽略 border-spacing 和 empty-cells 属性</td>
</tr>
<tr>
<td>separate</td>
<td>默认值。边框会被分开。不会忽略 border-spacing 和 empty-cells 属性</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 border-collapse 属性的值</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>vertical-align</strong></p>
</blockquote>
<p>vertical-align 属性设置一个元素的垂直对齐方式。</p>
<p>该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。允许指定负长度值和百分比值。这会使元素降低而不是升高。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>baseline</td>
<td>默认。元素放置在父元素的基线上。</td>
</tr>
<tr>
<td>sub</td>
<td>垂直对齐文本的下标。</td>
</tr>
<tr>
<td>super</td>
<td>垂直对齐文本的上标</td>
</tr>
<tr>
<td>top</td>
<td>把元素的顶端与行中最高元素的顶端对齐</td>
</tr>
<tr>
<td>text-top</td>
<td>把元素的顶端与父元素字体的顶端对齐</td>
</tr>
<tr>
<td>middle</td>
<td>把此元素放置在父元素的中部。</td>
</tr>
<tr>
<td>bottom</td>
<td>使元素及其后代元素的底部与整行的底部对齐。</td>
</tr>
<tr>
<td>text-bottom</td>
<td>把元素的底端与父元素字体的底端对齐。</td>
</tr>
<tr>
<td>length</td>
<td>将元素升高或降低指定的高度，可以是负数。</td>
</tr>
<tr>
<td>%</td>
<td>使用 “line-height” 属性的百分比值来排列此元素。允许使用负值。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 vertical-align 属性的值。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>border-color</strong></p>
</blockquote>
<p>例子</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">border</span>-<span class="built_in">color</span>属性设置一个元素的四个边框颜色。此属性可以有一到四个值。</span><br><span class="line"></span><br><span class="line">实例:</span><br><span class="line"></span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">color</span>:红，绿，蓝,粉红色;</span><br><span class="line"></span><br><span class="line">上边框是红色</span><br><span class="line">右边框是绿色</span><br><span class="line">底部边框是蓝</span><br><span class="line">左边框是粉红色</span><br><span class="line"></span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">color</span>：红，绿，蓝;</span><br><span class="line"></span><br><span class="line">上边框是红色</span><br><span class="line">左，右边框是绿色</span><br><span class="line">底部边框是蓝</span><br><span class="line"></span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">color</span>：红，绿;</span><br><span class="line"></span><br><span class="line">顶部和底部边框是红色</span><br><span class="line">左右边框是绿色</span><br><span class="line"></span><br><span class="line"><span class="built_in">border</span>-<span class="built_in">color</span>：红色;</span><br><span class="line"></span><br><span class="line">所有四个边框是红色</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>指定背景颜色。在CSS颜色值查找颜色值的完整列表</td>
</tr>
<tr>
<td>transparent</td>
<td>指定边框的颜色应该是透明的。这是默认</td>
</tr>
<tr>
<td>inherit</td>
<td>指定边框的颜色，应该从父元素继承</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>justify-content</strong></p>
</blockquote>
<p>justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。</p>
<p>提示：使用 align-content 属性对齐交叉轴上的各项（垂直）。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>默认值。项目位于容器的开头。</td>
</tr>
<tr>
<td>flex-end</td>
<td>项目位于容器的结尾。</td>
</tr>
<tr>
<td>center</td>
<td>项目位于容器的中心。</td>
</tr>
<tr>
<td>space-between</td>
<td>项目位于各行之间留有空白的容器内。</td>
</tr>
<tr>
<td>space-around</td>
<td>项目位于各行之前、之间、之后都留有空白的容器内。</td>
</tr>
<tr>
<td>initial</td>
<td>设置该属性为它的默认值。请参阅 initial。</td>
</tr>
<tr>
<td>inherit</td>
<td>从父元素继承该属性。请参阅 inherit。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>float</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>元素向左浮动</td>
</tr>
<tr>
<td>right</td>
<td>元素向右浮动</td>
</tr>
<tr>
<td>none</td>
<td>默认值,元素不浮动,并会显示其在文本出现的位置</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素中继承属性的值</td>
</tr>
</tbody></table>
<p><strong>方便理解 ,上图</strong></p>
<img data-src="/blog/posts/54880bcd/2022-02-14-22-24-03.png" class="">

<p>==<strong>敲黑板最重要的是结合demo理解以下两句话</strong>==</p>
<p>float:left 应该理解为：在自己本身的位置上脱离文档流，元素从包含框的右边缘向左移动，直到碰到包含框的左边缘或者其他浮动元素框停下，当空间不足以绘制自己则另起一行。</p>
<p>float:right 应该理解为：在自己本身的位置上脱离文档流， 元素从包含框的左边缘向右移动，直到碰到包含框的右边缘或者其他浮动元素的框停下，当空间不足以绘制自己则另起一行。</p>
<blockquote>
<p><strong>position</strong></p>
</blockquote>
<p>这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>absolute</td>
<td>生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td>
</tr>
<tr>
<td>fixed</td>
<td>生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td>
</tr>
<tr>
<td>relative</td>
<td>生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</td>
</tr>
<tr>
<td>static</td>
<td>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right或者z-index声明）。inherit    规定应该从父元素继承 position 属性的值。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>padding(内边距)</strong></p>
</blockquote>
<p>Padding属性，可以有一到四个值。</p>
<ul>
<li><p>padding:25px 50px 75px 100px;</p>
<p>  上填充为25px </p>
<p>  右填充为50px</p>
<p>  下填充为75px</p>
<p>  左填充为100px</p>
</li>
<li><p>padding:25px 50px 75px;</p>
<p>  上填充为25px</p>
<p>  左右填充为50px</p>
<p>  下填充为75px</p>
</li>
<li><p>padding:25px 50px;</p>
<p> 上下填充为25px</p>
<p> 左右填充为50px</p>
</li>
<li><p>padding:25px;</p>
<p> 所有的填充都是25px</p>
</li>
</ul>
<h2 id="对齐弹性容器中的弹性项目"><a href="#对齐弹性容器中的弹性项目" class="headerlink" title="对齐弹性容器中的弹性项目"></a>对齐弹性容器中的弹性项目</h2>


<ul>
<li><code>justify-content</code> - 控制主轴（横轴）上所有 <code>flex</code> 项目的对齐。</li>
<li><code>align-items</code> - 控制交叉轴（纵轴）上所有 <code>flex</code> 项目的对齐。</li>
<li><code>align-self</code> - 控制交叉轴（纵轴）上的单个 <code>flex</code> 项目的对齐。</li>
<li><code>align-content</code> - 控制“多条主轴”的 <code>flex</code> 项目在交叉轴的对齐。</li>
</ul>



<blockquote>
<p>align-items</p>
</blockquote>
<p><code>align-itema: flex-start</code> — <code>flex</code> 项目的开始端的对齐</p>
<p><code>align-items: flex-end </code> — <code>flex</code>项目的结束端对齐</p>
<p><code>align-items: center</code> — <code>flex</code> 项目居中对齐</p>
<p><code>align-items: stretch</code> — <code>flex</code> 项目撑满 <code>flex</code> 容器</p>
<p><code>align-items: baseline</code> — <code>flex</code> 项目的基线对齐</p>
<blockquote>
<p><code>align-self</code> 用于对齐单个<code>flex</code> 子项</p>
</blockquote>
<p><code>align-items</code> 属性是给所有 <code>flex</code>项目统一设置 <code>align-self</code> 的对齐属性。这意味着你能给单个 <code>flex</code> 项目明确地声明 <code>align-self</code> 属性。<code>align-self</code> 拥有 <code>align-items</code> 的所有属性值，另外还有一个 <code>auto</code> 能重置自身的值为 <code>align-items</code> 定义的值。</p>
<blockquote>
<p>改变主轴方向</p>
</blockquote>






<blockquote>
<p>轴对齐内容—— <code>align-content</code>属性</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*align-content不采用左右值 */</span></span><br><span class="line">align-content: center;     <span class="comment">/* 将项目放置在中点 */</span></span><br><span class="line">align-content: start;      <span class="comment">/* 最先放置项目 */</span></span><br><span class="line">align-content: end;        <span class="comment">/* 最后放置项目 */</span></span><br><span class="line">align-content: flex-start; <span class="comment">/* 从起始点开始放置flex元素 */</span></span><br><span class="line">align-content: flex-end;   <span class="comment">/* 从终止点开始放置flex元素 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 默认对齐 */</span></span><br><span class="line">align-content: normal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基线对齐*/</span></span><br><span class="line">align-content: baseline;</span><br><span class="line">align-content: first baseline;</span><br><span class="line">align-content: last baseline;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分布式对齐 */</span></span><br><span class="line">align-content: space-between; <span class="comment">/* 均匀分布项目</span></span><br><span class="line"><span class="comment">                                 第一项与起始点齐平，</span></span><br><span class="line"><span class="comment">                                 最后一项与终止点齐平 */</span></span><br><span class="line">align-content: space-around;  <span class="comment">/* 均匀分布项目</span></span><br><span class="line"><span class="comment">                                 项目在两端有一半大小的空间*/</span></span><br><span class="line">align-content: space-evenly;  <span class="comment">/* 均匀分布项目</span></span><br><span class="line"><span class="comment">                                 项目周围有相等的空间 */</span></span><br><span class="line">align-content: stretch;       <span class="comment">/* 均匀分布项目</span></span><br><span class="line"><span class="comment">                                 拉伸‘自动’-大小的项目以充满容器 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 溢出对齐 */</span></span><br><span class="line">align-content: safe center;</span><br><span class="line">align-content: unsafe center;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局属性 */</span></span><br><span class="line">align-content: inherit; <span class="comment">/* 继承 */</span></span><br><span class="line">align-content: initial;  <span class="comment">/* 初始值 */</span></span><br><span class="line">align-content: unset; <span class="comment">/* 未设置 */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>letter-spacing</p>
</blockquote>
<p>这个用过不少次，主要是表示字体之间的间距大小</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker指令以及部署</title>
    <url>/blog/posts/11faeb76/</url>
    <content><![CDATA[<p>文档地址：<span class="exturl" data-url="aHR0cHM6Ly95ZWFzeS5naXRib29rLmlvL2RvY2tlcl9wcmFjdGljZS8=">https://yeasy.gitbook.io/docker_practice/</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=">Docker hub</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2luc3RhbGwv">Docker Install</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgxNjczOC9hcnRpY2xlL2RldGFpbHMvMTE3NjUyNzM2">Docker 部署 Springboot</span></p>
<h2 id="列出所有镜像"><a href="#列出所有镜像" class="headerlink" title="列出所有镜像"></a>列出所有镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<h2 id="查看运行的容器"><a href="#查看运行的容器" class="headerlink" title="查看运行的容器"></a>查看运行的容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<blockquote>
<p>列出所有容器ID</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -aq</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="查看所有的容器包括停止的"><a href="#查看所有的容器包括停止的" class="headerlink" title="查看所有的容器包括停止的"></a>查看所有的容器包括停止的</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><blockquote>
<p>删除容器  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm &lt;NAMES&gt;/&lt;CONTAINER ID&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除镜像</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image rm &lt;IMAGES&gt;</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/11faeb76/2022-06-30-22-57-53.png" class="">

<h2 id="停止、启动、杀死、重启一个容器"><a href="#停止、启动、杀死、重启一个容器" class="headerlink" title="停止、启动、杀死、重启一个容器"></a>停止、启动、杀死、重启一个容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop Name或者ID  </span><br><span class="line">docker start Name或者ID  </span><br><span class="line">docker <span class="built_in">kill</span> Name或者ID  </span><br><span class="line">docker restart name或者ID</span><br></pre></td></tr></table></figure>

<h2 id="docker启动失败如何查看容器日志"><a href="#docker启动失败如何查看容器日志" class="headerlink" title="docker启动失败如何查看容器日志"></a><code>docker</code>启动失败如何查看容器日志</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们可以通过如下命令来获取容器的日志地址</span></span><br><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123;.LogPath&#125;&#125;&#x27;</span> &lt;NAMES&gt;</span><br><span class="line"><span class="comment">#  然后通过cat命令查看上述命令找到的日志地址</span></span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/11faeb76/2022-06-30-23-11-07.png" class="">

<blockquote>
<p>更简单的方式</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs &lt;NAMES&gt;</span><br></pre></td></tr></table></figure>

<h2 id="M1拉取Mysql数据库"><a href="#M1拉取Mysql数据库" class="headerlink" title="M1拉取Mysql数据库"></a><code>M1</code>拉取<code>Mysql</code>数据库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull --platform linux/x86_64 mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动mysql</span></span><br><span class="line">docker run --name mymysql -e MYSQL_ROOT_PASSWORD=root -v /etc/localtime:/etc/localtime -d -p 3306:3306  mysql:5.7</span><br></pre></td></tr></table></figure>

<h2 id="Docker安装Nginx并且部署Vue项目"><a href="#Docker安装Nginx并且部署Vue项目" class="headerlink" title="Docker安装Nginx并且部署Vue项目"></a><code>Docker</code>安装<code>Nginx</code>并且部署<code>Vue</code>项目</h2><h3 id="拉取Nginx"><a href="#拉取Nginx" class="headerlink" title="拉取Nginx"></a>拉取<code>Nginx</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<h3 id="创建挂载目录"><a href="#创建挂载目录" class="headerlink" title="创建挂载目录"></a>创建挂载目录</h3><p>找个目录创建一下目录（在<code>/Users/jinmao/Documents/Docker/</code>下创建<code>/nginx</code>）</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">mkdir</span><br></pre></td></tr></table></figure>

<h3 id="运行并且挂载nginx"><a href="#运行并且挂载nginx" class="headerlink" title="运行并且挂载nginx"></a>运行并且挂载<code>nginx</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 --name nginx_BEBA  -v /Users/jinmao/Documents/Docker/nginx/dist:/usr/share/nginx/html --restart=always nginx</span><br></pre></td></tr></table></figure>

<h3 id="把vue的目录上传到挂载的目录"><a href="#把vue的目录上传到挂载的目录" class="headerlink" title="把vue的目录上传到挂载的目录"></a>把<code>vue</code>的目录上传到挂载的目录</h3><p><code>vue</code>项目打包</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">npm <span class="builtin-name">run</span> build</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/11faeb76/2022-07-02-09-15-41.png" class="">

<h3 id="重启Docker容器"><a href="#重启Docker容器" class="headerlink" title="重启Docker容器"></a>重启<code>Docker</code>容器</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker restart <span class="tag">&lt;<span class="name">NAMES</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时就可以了，<code>nginx</code>开放端口为<code>80</code>,直接<code>ip</code>访问即可</p>
<h3 id="为什么要挂载在到docker的-usr-share-nginx-html"><a href="#为什么要挂载在到docker的-usr-share-nginx-html" class="headerlink" title="为什么要挂载在到docker的/usr/share/nginx/html"></a>为什么要挂载在到<code>docker</code>的<code>/usr/share/nginx/html</code></h3><p>看<code>nginx</code>的默认配置就知道<br>进入<code>docker</code>的容器里面：<br>通过命令<code>docker ps</code>查看运行容器信息；<br>在通过命令 <code>docker exec -it 容器id /bin/bash </code>进入容器目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;NAMES&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<p>进入<code>cd /etc/nginx/conf.d</code> , 查看<code>default.conf</code>文件</p>
<img data-src="/blog/posts/11faeb76/2022-07-02-09-34-32.png" class="">


<p>但是你会发现<code>etc/nginx</code>下有个<code>nginx.conf</code> 配置文件我们查看配置发现这里有条语句是引用了上面<code>default.conf</code>的配置，由此可见我们以后需要配置其他项目路径就直接配置<code>default.conf</code>就行了。</p>
<img data-src="/blog/posts/11faeb76/2022-07-02-09-36-44.png" class="">

<p>但是这个有个缺点每次修改都需要进入容器的内部求修改。</p>
<h3 id="优化nginx的配置文件（为了以后多项目部署方便修改Nginx）"><a href="#优化nginx的配置文件（为了以后多项目部署方便修改Nginx）" class="headerlink" title="优化nginx的配置文件（为了以后多项目部署方便修改Nginx）"></a>优化<code>nginx</code>的配置文件（为了以后多项目部署方便修改<code>Nginx</code>）</h3><p>我们可以通过把<code>etc/nginx</code> 复制到宿主机的目录下这样我们就可以修改宿主机的配置文件在重新启动一下容器就可以实现最新的配置</p>
<ol>
<li><p>使用命令复制容器的文件到宿主机：<code>docker cp &lt;NAMES&gt;:/etc/nginx /Users/jinmao/Documents/Docker/nginx/</code></p>
<blockquote>
<p><code>/etc/nginx</code>:为需要复制的文件</p>
</blockquote>
<blockquote>
<p><code>/Users/jinmao/Documents/Docker/nginx/dist</code> :把他保存到那个目录下</p>
</blockquote>
 <img data-src="/blog/posts/11faeb76/2022-07-02-09-52-09.png" class=""></li>
<li><p>进入<code>/nginx</code>修改宿主机(本地的)的<code>default.conf</code>配置文件命令</p>
 <img data-src="/blog/posts/11faeb76/2022-07-02-10-35-29.png" class=""></li>
<li><p>通过命令删除就的<code>nginx</code>容器：<code>docker rm 容器id</code> 删除容器</p>
</li>
<li><p>重新启动容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name &lt;name&gt; -p 80:80 -v /Users/jinmao/Documents/Docker/nginx/dist:/Users/jinmao/Documents/Study/doctor/Topic1/frontPro/dist -v /Users/jinmao/Documents/Docker/nginx/nginx:/etc/nginx -d nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释：</span></span><br><span class="line"><span class="comment"># –name：后面的是容器名称</span></span><br><span class="line"><span class="comment"># -p:冒号前面是宿主机的对外端口，冒号后面的是容器的端口</span></span><br><span class="line"><span class="comment"># -v：冒号前面的是宿主机的文件目录，冒号后面是容器的内部文件目录</span></span><br><span class="line"><span class="comment"># -d:表示后端运行</span></span><br><span class="line"><span class="comment"># nginx：最后面的nginx是镜像的名称</span></span><br></pre></td></tr></table></figure>
 <img data-src="/blog/posts/11faeb76/2022-07-02-11-08-24.png" class=""></li>
</ol>
<p>现在已经把宿主机的<code>vue</code>项目<code>dist</code>挂载到<code>nginx</code>容器中，这样监听的请求就会被<code>nginx</code>代理到对应的目录中访问资源，还有宿主机的<code>/Users/jinmao/Documents/Docker/nginx/nginx</code>也被挂载到了容器<code>etc/nginx</code>中，这样只要修改宿主机的<code>nginx</code>配置,只要重启容器最新配置就会生效。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjUxY3RvLmNvbS91XzE1NTg1Njk5LzUxNzk2ODg=">参考链接</span></p>
<h2 id="制作Dockerfile-Springboot"><a href="#制作Dockerfile-Springboot" class="headerlink" title="制作Dockerfile(Springboot)"></a>制作<code>Dockerfile</code>(<code>Springboot</code>)</h2><p><code>Maven</code> 打包完<code>jar</code>包，忽略。。</p>
<h3 id="编辑DockerFile文件"><a href="#编辑DockerFile文件" class="headerlink" title="编辑DockerFile文件"></a>编辑<code>DockerFile</code>文件</h3><p>和 <code>jar</code>包在同一级</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure>
<p>example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker image for springboot file run</span></span><br><span class="line"><span class="comment"># VERSION 1.0.0</span></span><br><span class="line"><span class="comment"># Author: jinmao</span></span><br><span class="line">FROM java:8</span><br><span class="line">VOLUME /tmp</span><br><span class="line">EXPOSE 9999</span><br><span class="line">ADD thesis-project.jar /app.jar</span><br><span class="line">RUN bash -c <span class="string">&#x27;touch /app.jar&#x27;</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>打包命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t &lt;lower_name&gt; .</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/11faeb76/2022-07-02-13-32-00.png" class="">

<blockquote>
<p>运行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 9999:9999 --name BABE_Thesis -d babe_end</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/11faeb76/2022-07-02-13-35-28.png" class="">


<h2 id="Docker安装Jenkins"><a href="#Docker安装Jenkins" class="headerlink" title="Docker安装Jenkins"></a><code>Docker</code>安装<code>Jenkins</code></h2><p>原理图：</p>
<img data-src="/blog/posts/11faeb76/2022-08-04-23-24-21.png" class="">

<ol>
<li><p>拉取镜像(稳定版本)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull jenkins/jenkins:lts</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/11faeb76/2022-08-04-23-21-06.png" class=""></li>
<li><p>创建挂载目录</p>
</li>
</ol>
<blockquote>
<p>创建目录</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/Users/jinmao/Documents/Docker/jenkins_mount</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行容器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -d 后台运行镜像</span></span><br><span class="line"><span class="comment"># -p 10240:8080 将镜像的8080端口映射到服务器的10240端口。</span></span><br><span class="line"><span class="comment"># -p 10241:50000 将镜像的50000端口映射到服务器的10241端口</span></span><br><span class="line"><span class="comment"># -v /Users/jinmao/Documents/Docker/jenkins_mount:/var/jenkins_home /var/jenkins_home目录为容器jenkins工作目录，我们将硬盘上的一个目录挂载到这个位置，方便后续更新镜像后继续使用原来的工作目录。这里我们设置的就是上面我们创建的 /Users/jinmao/Documents/Docker/jenkins_mount 目录</span></span><br><span class="line"><span class="comment"># -v /etc/localtime:/etc/localtime让容器使用和服务器同样的时间设置。</span></span><br><span class="line"><span class="comment"># --name myJenkins 给容器起一个别名</span></span><br><span class="line">docker run -d -p 10240:8080 -p 10241:50000 -v /Users/jinmao/Documents/Docker/jenkins_mount:/var/jenkins_home -v /etc/localtime:/etc/localtime --name myJenkins jenkins/jenkins:lts</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/11faeb76/2022-08-05-00-10-33.png" class="">

<blockquote>
<p>链接别的容器(<code>--link</code>，前面为容器名，后面为别名)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run -d -p 10242:8080 -p 10243:50000 -v /Users/jinmao/Documents/Docker/jenkins_m/jenkins_10242:/var/jenkins_home -v /etc/localtime:/etc/localtime --link mysql57:mysql  --name myJenkins10242  jenkins/jenkins:lts</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>查看<code>jenkins</code>是否启动成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/11faeb76/2022-08-05-00-12-41.png" class=""></li>
<li><p>查看<code>docker</code>容器日志。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs &lt;name&gt; </span><br><span class="line"><span class="comment"># docker logs myJenkins</span></span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/11faeb76/2022-08-05-00-14-43.png" class="">

<ol start="6">
<li>进入挂载目录</li>
</ol>
<img data-src="/blog/posts/11faeb76/2022-08-05-00-15-42.png" class="">

<ol start="7">
<li>访问<code>Jenkins</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">localhost:10240</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/11faeb76/2022-08-05-00-20-45.png" class=""></li>
</ol>
<p>根据提示输入密码</p>
<img data-src="/blog/posts/11faeb76/2022-08-05-00-26-18.png" class="">

<ol start="8">
<li>安装 <code>plugin</code></li>
</ol>
<img data-src="/blog/posts/11faeb76/2022-08-05-00-27-44.png" class="">

<p>安装完成创建一下账户即可使用(账户截图未展示)</p>
<img data-src="/blog/posts/11faeb76/2022-08-05-00-28-01.png" class="">

<h2 id="Jenkins-关闭跨域"><a href="#Jenkins-关闭跨域" class="headerlink" title="Jenkins 关闭跨域"></a><code>Jenkins</code> 关闭跨域</h2><p>低版本可以直接在图形化界面中关闭，高版本只能进入<code>Docker</code>容器中更改</p>
<blockquote>
<p>进入容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker exec -u root -it myJenkins bash</span></span><br><span class="line">docker <span class="built_in">exec</span> -u root -it &lt;name&gt; bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># apt update</span></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># install vim</span></span><br><span class="line">apt-get install vim</span><br><span class="line"></span><br><span class="line"><span class="comment"># change configuration</span></span><br><span class="line">vim /usr/<span class="built_in">local</span>/bin/jenkins.sh</span><br><span class="line"></span><br><span class="line">-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/11faeb76/2022-08-05-11-25-46.png" class="">

<blockquote>
<p>需要重启</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker restart myJenkins</span></span><br><span class="line">docker restart &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>关闭成功</p>
<img data-src="/blog/posts/11faeb76/2022-08-05-11-39-50.png" class="">




]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD领域驱动设计</title>
    <url>/blog/posts/3fec5852/</url>
    <content><![CDATA[<img data-src="/blog/posts/3fec5852/2021-11-22-14-55-31.png" class="">
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>领域驱动设计</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson序列化使用</title>
    <url>/blog/posts/6714b4a9/</url>
    <content><![CDATA[<h2 id="需要导入依赖"><a href="#需要导入依赖" class="headerlink" title="需要导入依赖"></a>需要导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--fastJson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.75<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h2 id="实体类转换为Json字符串"><a href="#实体类转换为Json字符串" class="headerlink" title="实体类转换为Json字符串"></a>实体类转换为<code>Json</code>字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSON.toJSONString(实体类)</span><br></pre></td></tr></table></figure>



<h2 id="Json字符串转换为实体类"><a href="#Json字符串转换为实体类" class="headerlink" title="Json字符串转换为实体类"></a><code>Json</code>字符串转换为实体类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSON.parseObject(str(json字符串), (实体类).class);</span><br></pre></td></tr></table></figure>


<img data-src="/blog/posts/6714b4a9/2022-02-16-00-24-22.png" class="">




<h2 id="常见使用"><a href="#常见使用" class="headerlink" title="常见使用"></a>常见使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把JSON文本parse为JSONObject或者JSONArray </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">parse</span><span class="params">(String text)</span></span>; </span><br><span class="line"><span class="comment">// 把JSON文本parse成JSONObject    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> JSONObject <span class="title">parseObject</span><span class="params">(String text)</span>； </span></span><br><span class="line"><span class="function"><span class="comment">// 把JSON文本parse为JavaBean </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; T <span class="title">parseObject</span><span class="params">(String text, Class&lt;T&gt; clazz)</span></span>; </span><br><span class="line"><span class="comment">// 把JSON文本parse成JSONArray </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> JSONArray <span class="title">parseArray</span><span class="params">(String text)</span></span>; </span><br><span class="line"><span class="comment">//把JSON文本parse成JavaBean集合 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">parseArray</span><span class="params">(String text, Class&lt;T&gt; clazz)</span></span>; </span><br><span class="line"> <span class="comment">// 将JavaBean序列化为JSON文本 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">toJSONString</span><span class="params">(Object object)</span></span>;</span><br><span class="line"><span class="comment">// 将JavaBean序列化为带格式的JSON文本 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">toJSONString</span><span class="params">(Object object, <span class="keyword">boolean</span> prettyFormat)</span></span>; </span><br><span class="line"><span class="comment">//将JavaBean转换为JSONObject或者JSONArray。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">toJSON</span><span class="params">(Object javaObject)</span></span>; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java面试</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Next主题如何文章置顶</title>
    <url>/blog/posts/575a6046/</url>
    <content><![CDATA[<h1 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h1><p><code>Hexo</code> 本身并没有内置文章置顶功能，因此需要自行安装。不过 <code>Hexo</code> 本身有一个对文章排序的组件，也就是在站点配置文件内的 <code>index_generator</code> 选项，置顶功能其实就是每次排序的时候，把其中的置顶文章排在最前，本质上是一个排序组件，<code>Hexo</code> 默认的是 <code>hexo-generator-index</code>，所以先卸载再重新安装一个可以置顶的排序组件：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先卸载</span><br><span class="line">npm uninstall --save hexo-generator-index</span><br><span class="line"></span><br><span class="line"># 再安装</span><br><span class="line">npm install --save hexo-generator-index-pin-top</span><br></pre></td></tr></table></figure>
<p>从插件名字上就能看得出来支持置顶了。该插件的 <code>GitHub</code> 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25ldGNhbi9oZXhvLWdlbmVyYXRvci1pbmRleC1waW4tdG9w">hexo-generator-index-pin-top</span>。插件安装完之后，只需要在文章头部信息栏内设置 <code>top</code> 属性即可：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 写在最前面</span><br><span class="line">hide: false</span><br><span class="line"><span class="section">top: true</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<p>这样这篇文章就具有置顶效果了。不过，仅仅只是这么做，文章虽然确实置顶了，但是从文章列表上来看，和普通的文章没什么不同。如果不特意去对比文章发布时间，可能会以为只是最新的文章而已。例如一些说明、通知之类的，为了能有个比较突出的标志，可以在 <code>next/layout/_macro/post.swig</code> 文件中找到以下位置并添加代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-thumb-tack&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: #EB6D39&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#FFFF00</span>	&gt;</span>置顶<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/575a6046/2021-11-17-13-47-07.png" class="">

<p>效果如下:</p>
<img data-src="/blog/posts/575a6046/2021-11-17-13-54-56.png" class="">

<h2 id="关于在Hexo中的小图标"><a href="#关于在Hexo中的小图标" class="headerlink" title="关于在Hexo中的小图标"></a>关于在<code>Hexo</code>中的小图标</h2><p>使用<code>Hexo</code>搭建的<code>Blog</code>中,都是从专门的图标库中获取:</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9mb250YXdlc29tZS5jb20vaWNvbnM/ZD1nYWxsZXJ5">国外地址</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9mb250YXdlc29tZS5kYXNoZ2FtZS5jb20v">国内地址</span></li>
</ul>
<p>例如在主题的配置文件<code>_config.yml</code>中</p>
<img data-src="/blog/posts/575a6046/2021-11-17-14-01-18.png" class="">

<p>都是使用的图标库中的图标</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Dokcer镜像推送到DockerHub</title>
    <url>/blog/posts/e2b12017/</url>
    <content><![CDATA[<p>关于推送本地的镜像到<code>Docker Hub</code>上</p>
<p>关于如何制作镜像：<a href="https://smile1231.github.io/posts/11faeb76/">make DockerFile</a></p>
<h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=">official Website</span></p>
<p>注册完成之后，进入自己的账户信息页创建<code>Token</code></p>
<img data-src="/blog/posts/e2b12017/2022-08-13-10-51-18.png" class="">

<h2 id="本地登陆账号"><a href="#本地登陆账号" class="headerlink" title="本地登陆账号"></a>本地登陆账号</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment"># Username: jinmaohub</span></span><br><span class="line"><span class="comment"># Password: $&#123;token&#125;</span></span><br><span class="line"><span class="comment"># Login Successed</span></span><br></pre></td></tr></table></figure>

<h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><blockquote>
<p>get images </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/e2b12017/2022-08-13-10-48-38.png" class="">

<blockquote>
<p>用<code>docker tag</code>来进行标记</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag &lt;image-name&gt; &lt;docekerhub-name&gt;/&lt;iamges-name&gt;:&lt;tag-name&gt;</span><br><span class="line"><span class="comment"># docker tag local_vue jinmaohub/local_vue:latest</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>推送<code>images</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker push &lt;docekerhub-name&gt;/&lt;iamges-name&gt;:&lt;tag-name&gt;</span><br><span class="line"><span class="comment"># docker push jinmaohub/local_hub:latest</span></span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/e2b12017/2022-08-13-11-20-34.png" class="">

<p>就会发现镜像推送成功了</p>
<img data-src="/blog/posts/e2b12017/2022-08-13-11-20-56.png" class="">



]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo中添加动态2d二次元人物模型</title>
    <url>/blog/posts/5c2529f6/</url>
    <content><![CDATA[<p><code>Hexo</code>添加<code>helper-live2d</code>型插件</p>
<p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md"><code>github</code>地址</a></p>
<h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h1 id="下载模型"><a href="#下载模型" class="headerlink" title="下载模型"></a>下载模型</h1><p>作者提供以下模型的模型包，模型包预览地址见下面的链接，选择你想用的模型，记住名字，选择对应的后缀模型包</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYXpleXUvbGl2ZTJkLXdpZGdldC1tb2RlbHM=">模型包展示</span></p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">live2d-widget-<span class="keyword">model</span>-chitose</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-epsilon2_1</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-gf</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-haru/<span class="number">01</span> (use npm install --save live2d-widget-<span class="keyword">model</span>-haru)</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-haru/<span class="number">02</span> (use npm install --save live2d-widget-<span class="keyword">model</span>-haru)</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-haruto</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-hibiki</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-hijiki</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-izumi</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-koharu</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-miku</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-ni-j</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-nico</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-nietzsche</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-nipsilon</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-nito</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-shizuku</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-tororo</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-tsumiki</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-unitychan</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-wanko</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-z16</span><br></pre></td></tr></table></figure>

<p>选择好对应的模型，使用 <code>npm install</code> 模型的包名来安装</p>
<h1 id="打开个人Hexo博客文件根目录下的-config-yml-文件，在最后添加一下代码"><a href="#打开个人Hexo博客文件根目录下的-config-yml-文件，在最后添加一下代码" class="headerlink" title="打开个人Hexo博客文件根目录下的 _config.yml 文件，在最后添加一下代码"></a>打开个人<code>Hexo</code>博客文件根目录下的 <code>_config.yml</code> 文件，在最后添加一下代码</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-koharu</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="重启项目"><a href="#重启项目" class="headerlink" title="重启项目"></a>重启项目</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>DisPlay属性</title>
    <url>/blog/posts/2e6621e1/</url>
    <content><![CDATA[<h1 id="Display属性"><a href="#Display属性" class="headerlink" title="Display属性"></a>Display属性</h1><h2 id="display所有属性"><a href="#display所有属性" class="headerlink" title="display所有属性"></a><strong>display所有属性</strong></h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CSS 1 */</span></span><br><span class="line"><span class="attribute">display</span>: none;</span><br><span class="line"><span class="attribute">display</span>: inline;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">display</span>: list-item;</span><br><span class="line"><span class="comment">/* CSS 2.1 */</span></span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">display</span>: table;</span><br><span class="line"><span class="attribute">display</span>: inline-table;</span><br><span class="line"><span class="attribute">display</span>: table-cell;</span><br><span class="line"><span class="attribute">display</span>: table-column;</span><br><span class="line"><span class="attribute">display</span>: table-column-group;</span><br><span class="line"><span class="attribute">display</span>: table-footer-group;</span><br><span class="line"><span class="attribute">display</span>: table-header-group;</span><br><span class="line"><span class="attribute">display</span>: table-row;</span><br><span class="line"><span class="attribute">display</span>: table-row-group;</span><br><span class="line"><span class="attribute">display</span>: table-caption;</span><br><span class="line"><span class="comment">/* CSS 2.1 */</span></span><br><span class="line"><span class="comment">/* CSS 3 */</span></span><br><span class="line"><span class="attribute">display</span>: inline-list-item;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">display</span>: box;</span><br><span class="line"><span class="attribute">display</span>: inline-flex;</span><br><span class="line"></span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line"><span class="attribute">display</span>: inline-grid;</span><br><span class="line"><span class="attribute">display</span>: ruby;</span><br><span class="line"><span class="attribute">display</span>: ruby-base;</span><br><span class="line"><span class="attribute">display</span>: ruby-text;</span><br><span class="line"><span class="attribute">display</span>: ruby-base-container;</span><br><span class="line"><span class="attribute">display</span>: ruby-text-container;</span><br><span class="line"><span class="comment">/* CSS 3 */</span></span><br><span class="line"><span class="comment">/* Experimental values */</span></span><br><span class="line"><span class="attribute">display</span>: contents;</span><br><span class="line"><span class="attribute">display</span>: run-in;</span><br><span class="line"><span class="comment">/* Experimental values */</span></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="attribute">display</span>: inherit;</span><br><span class="line"><span class="attribute">display</span>: initial;</span><br><span class="line"><span class="attribute">display</span>: unset;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>
<p>下面就display的重要属性进行讲解，并配合一些相关的例子</p>
<h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><h3 id="display-none"><a href="#display-none" class="headerlink" title="display: none"></a>display: none</h3><p>none 是 CSS 1 就提出来的属性，将元素设置为none的时候既不会占据空间，也无法显示，相当于该元素不存在。</p>
<p>该属性可以用来改善重排与重绘，同时我也经常用它来做模态窗等效果。</p>
<h3 id="display-inline"><a href="#display-inline" class="headerlink" title="display: inline"></a>display: inline</h3><p>inline也是 CSS 1 提出的属性，它主要用来设置行内元素属性，设置了该属性之后设置高度、宽度都无效，同时text-align属性设置也<br>无效，但是设置了line-height会让inline元素居中</p>
<p>同时从上图可以看到两个inline标签之间出现了奇怪的间隔，改间隔的原因是div换行产生的换行空白，解决办法</p>
<ul>
<li>将两个inline标签写到一行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>或者使用一点技巧</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>zhan<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">html&#123;</span></span><br><span class="line"><span class="xml">  -webkit-text-size-adjust:none;/* 使用webkit的私有属性，让字体大小不受设备终端的调整，可定义字体大小小于12px */</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">.main&#123;</span></span><br><span class="line"><span class="xml">  font-size:0;</span></span><br><span class="line"><span class="xml">  *word-spacing:-1px;/* 使用word-spacing 修复 IE6、7 中始终存在的 1px 空隙，减少单词间的空白（即字间隔） */</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">.test&#123;</span></span><br><span class="line"><span class="xml">  display:inline;</span></span><br><span class="line"><span class="xml">  width: 10000px;</span></span><br><span class="line"><span class="xml">  height:10000px;</span></span><br><span class="line"><span class="xml">  border:1px solid;</span></span><br><span class="line"><span class="xml">  font-size:12px;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  letter-spacing: normal;/* 设置字母、字间距为0 */ </span></span><br><span class="line"><span class="xml">  word-spacing: normal; /* 设置单词、字段间距为0 */</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>实测chome49浏览器只用设置父元素的font-size为0即可。</p>
<p><code>目前有很多原生的元素都是inline的，span、a、label、input、 img、 strong 和em就是典型的行内元素元素。 链接：http://www.css88.com/archives...</code></p>
<h3 id="display-block"><a href="#display-block" class="headerlink" title="display: block"></a>display: block</h3><p>设置元素为块状元素，如果不指定宽高，默认会继承父元素的宽度，并且独占一行，即使宽度有剩余也会独占一行，高度一般以子元素撑开的高度为准，当然也可以自己设置宽度和高度。</p>
<blockquote>
<p>在设计的过程中有时需要设计一个div宽高都是整个屏幕，整个时候宽度很好设置，可是高度一般很难设置，因为页面一般都是可以滚动的，所以高度一般可变，所以这个时候可以使用一个小技巧，如下。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">html&#123;</span></span><br><span class="line"><span class="xml">  height: 100%;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">body&#123;</span></span><br><span class="line"><span class="xml">  height: 100%;</span></span><br><span class="line"><span class="xml">  padding: 0;</span></span><br><span class="line"><span class="xml">  margin:0;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">.main&#123;</span></span><br><span class="line"><span class="xml">  background: red;</span></span><br><span class="line"><span class="xml">  width: 100%;</span></span><br><span class="line"><span class="xml">  height: 100%;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>基本原理：div继承的是父元素body的高度，body是继承html的高度，html是继承的浏览器屏幕的高度。</code></p>
<h3 id="display-list-item"><a href="#display-list-item" class="headerlink" title="display: list-item"></a>display: list-item</h3><p>此属性默认会把元素作为列表显示，要完全模仿列表的话还需要加上 list-style-position，list-style-type</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>111111<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>222222<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>333333<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>


<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">padding-left</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span>&#123; </span><br><span class="line">  <span class="attribute">display</span>:list-item;</span><br><span class="line">  <span class="attribute">list-style</span>:disc outside none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下:</p>



<p>通过上面样式设置，就能仿出一个类似的列表，一定要在div上加padding，因为默认的列表之前的·在box外面</p>
<h3 id="display-inline-block"><a href="#display-inline-block" class="headerlink" title="display: inline-block"></a>display: inline-block</h3><p>inline-block为 CSS 2.1 新增的属性。 <strong>inline-block既具有block的宽高特性又具有inline的同行元素特性。</strong> 通过inline-block结合text-align: justify 还可以实现固定宽高的列表两端对齐布局，如下例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col col1&quot;</span>&gt;</span>111111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col col2&quot;</span>&gt;</span>222222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col col3&quot;</span>&gt;</span>333333<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col col1&quot;</span>&gt;</span>111111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col col2&quot;</span>&gt;</span>222222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col col3&quot;</span>&gt;</span>333333<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col fix&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col fix&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col fix&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col fix&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col fix&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">//实现两端对齐文本效果。</span><br><span class="line">  <span class="attribute">text-align</span>:justify;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col</span>&#123; </span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin-top</span>:<span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col1</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col2</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col3</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fix</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>; </span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0</span>; </span><br><span class="line">  <span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果:</p>
<p><img data-src="https://segmentfault.com/img/remote/1460000006047879" alt="image"></p>
<p><code>text-align: justify 属性会使行内元素两端对齐，但是要求这些行内元素总宽度至少占满一行，所以在总宽度不足一行的时候这个属性没用，因此在最后需要加上一些占位符。</code></p>
<p>==Tip: inline-block会形成一个BFC==</p>
<h3 id="display-table"><a href="#display-table" class="headerlink" title="display: table"></a>display: table</h3><p>table 此元素会作为块级表格来显示（类似table），表格前后带有换行符。CSS表格能够解决所有那些我们在使用绝对定位和浮动定位进行多列布局时所遇到的问题。例如，display:table的CSS声明能够让一个HTML元素和它的子节点像table元素一样。使用基于表格的CSS布局，使我们能够轻松定义一个单元格的边界、背景等样式， <strong>而不会产生因为使用了table那样的制表标签所导致的语义化问题。</strong></p>
<p>利用table的特性，我们能够轻易的实现三栏布局，并且能够兼容IE8，如下是使用table属性，实现三栏布局的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tr tr1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;td&quot;</span>&gt;</span>head1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;td&quot;</span>&gt;</span>head2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;td&quot;</span>&gt;</span>head3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tr tr2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;td&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;td&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;td&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">border-collapse</span>: collapse;<span class="comment">/*为表格设置合并边框模型：*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tr</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: table-row;</span><br><span class="line">  <span class="attribute">border-color</span>: inherit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tr1</span> <span class="selector-class">.td</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.td</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.td</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.td</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">3</span>)&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果:</p>



<p><strong>CSS2.1表格模型中的元素，可能不会全部包含在除HTML之外的文档语言中。这时，那些“丢失”的元素会被模拟出来，从而使得表格模型能够正常工作。所有的表格元素将会自动在自身周围生成所需的匿名table对象，使其符合table/inline-table、table-row、table-cell的三层嵌套关系。</strong></p>
<p>所以在一般情况下我们也可以不写外面的table-row元素以及table元素。</p>
<h3 id="display-inline-list-item"><a href="#display-inline-list-item" class="headerlink" title="display: inline-list-item"></a>display: inline-list-item</h3><p>我在MDN上面看到有这个属性，但是我实际尝试发现这个属性是不能使用的，在 <span class="exturl" data-url="aHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9aW4=">http://caniuse.com/#search=in</span>… 上面也没有找到这个元素的兼容性，所以应该是不能使用的，支持度全无。</p>
<h3 id="display-flex-重要"><a href="#display-flex-重要" class="headerlink" title="display: flex(重要)"></a><strong>display: flex(重要)</strong></h3><p>flex是一种弹性布局属性<br><strong>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</strong><br>主要属性有两大类：容器属性和项目的属性</p>
<ul>
<li><h4 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h4><p>值 |  解释</p>
</li>
<li><p>–|—<br>flex-direction | 属性决定主轴的方向（即项目的排列方向）。<br>flex-wrap| 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br>flex-flow|属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。<br>justify-content|属性定义了项目在主轴上的对齐方式。<br>align-items |属性定义项目在交叉轴上如何对齐。<br>align-content| 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
</li>
<li><h4 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h4></li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>order</td>
<td>定义项目的排列顺序。数值越小，排列越靠前，默认为0。</td>
</tr>
<tr>
<td>flex-grow</td>
<td>定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</td>
</tr>
<tr>
<td>flex-shrink</td>
<td>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</td>
</tr>
<tr>
<td>flex-basis</td>
<td>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</td>
</tr>
<tr>
<td>flex</td>
<td>属性是flex-grow, flex-shrink 和flex-basis的简写，默认值为0 1 auto。后两个属性可选。</td>
</tr>
<tr>
<td>align-self:</td>
<td>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</td>
</tr>
</tbody></table>
<p>以上关于flex的基础知识基本是从阮一峰老师那copy过来的，有兴趣的同学，可以到阮一峰老师的博客深入阅读</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG8=">http://www.ruanyifeng.com/blo</span>…</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG8=">http://www.ruanyifeng.com/blo</span>…</p>
<ul>
<li><h4 id="实例：实现一个固定宽度但内容可变的列表"><a href="#实例：实现一个固定宽度但内容可变的列表" class="headerlink" title="实例：实现一个固定宽度但内容可变的列表"></a>实例：实现一个固定宽度但内容可变的列表</h4>目前我有一个需求，有一个列表页，左侧固定，右侧固定，总宽度固定，但是左侧的内容可能会增加，右侧的内容也可能会增加，要求平时一行展示，增加的时候两行展示，左侧两行，右侧还是一行，并且都居中。</li>
</ul>
<p>先上效果图，不然可能会迷糊：</p>



<p>为了实现上述效果，代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;col1&quot;</span>&gt;</span>累积的分为：123<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col2&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>123<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>x 10<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;col1&quot;</span>&gt;</span>累积的分为：1234<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col2&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://7xltvd.com1.z0.glb.clouddn.com/css1.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;col2-span&quot;</span>&gt;</span>x 10<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">button</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">  <span class="attribute">outline</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col2-span</span>&#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col1</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">130px</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>:<span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col2</span>&#123;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="display-webkit-box"><a href="#display-webkit-box" class="headerlink" title="display: -webkit-box"></a>display: -webkit-box</h3><p>由于某X5浏览器某些版本还不支持最新版的flex布局，所以为了保证良好的运行，建议还是使用display: box，box和flex布局的主要差别如下:</p>
<ul>
<li><h4 id="容器属性-1"><a href="#容器属性-1" class="headerlink" title="容器属性"></a>容器属性</h4>值 | 解释</li>
<li>–|—:<br>display: box |该显示样式的新值可将此元素及其直系子代加入弹性框模型中。Flexbox 模型只适用于直系子代。<br>box-orient| 值：horizontal | vertical | inherit</li>
</ul>
<p>框的子代是如何排列的？还有两个值：inline-axis（真正的默认值）和 block-axis，但是它们分别映射到水平和垂直方向。<br>值 | 解释<br>—|—<br>box-pack 值：start | end | center | justify</p>
<p>设置沿 box-orient 轴的框排列方式。因此，如果 box-orient 是水平方向，就会选择框的子代的水平排列方式，反之亦然。<br>值 | 解释<br>—|—<br>box-align | 值：start | end | center | baseline | stretch</p>
<p>基本上而言是 box-pack 的同级属性。设置框的子代在框中的排列方式。如果方向是水平的，该属性就会决定垂直排列，反之亦然。</p>
<ul>
<li><h4 id="项目属性-1"><a href="#项目属性-1" class="headerlink" title="项目属性"></a>项目属性</h4>值 | 解释</li>
<li>–|—<br>box-flex| 值：0 | 任意整数</li>
</ul>
<p>该子代的弹性比。弹性比为 1 的子代占据父代框的空间是弹性比为 2 的同级属性的两倍。其默认值为 0，也就是不具有弹性。</p>
<p>用box改造上述例子<br>基本只修改了容器元素li的属性，如下所示:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  -webkit-box-orient:horizontal;</span><br><span class="line">  -webkit-box-pack: justify;</span><br><span class="line">  -webkit-box-align: center;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="display-inline-flex"><a href="#display-inline-flex" class="headerlink" title="display: inline-flex"></a>display: inline-flex</h3><p>我发现在chrome条件下设置了inline-flex，其子元素全部变成了inline模式，设置flex并没有什么用，不知道是不是我写的有问题，目前没找到这个属性的用法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sp1&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sp1&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-inline-flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sp1</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>以下属性是实验性质的，支持度都很低，不建议使用，知道就行。<br>值 | 解释<br>—|—<br>run-in:| 此元素会根据上下文作为块级元素或内联元素显示；<br>grid | 栅格模型，类似block<br>inline-grid | 栅格模型，类似inline-block<br>ruby, ruby-base, ruby-text, ruby-base-container, ruby-text-container|<br>contents |</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>DisPlay属性</tag>
      </tags>
  </entry>
  <entry>
    <title>Html页面插入地图</title>
    <url>/blog/posts/7b604068/</url>
    <content><![CDATA[<h1 id="html页面插入百度谷歌地图-react中插入百度地图"><a href="#html页面插入百度谷歌地图-react中插入百度地图" class="headerlink" title="html页面插入百度谷歌地图,react中插入百度地图"></a><code>html</code>页面插入百度谷歌地图,<code>react</code>中插入百度地图</h1><h2 id="Google地图"><a href="#Google地图" class="headerlink" title="Google地图"></a><code>Google</code>地图</h2><ol>
<li>在谷歌地图中 <code>http://www.google.cn/maps/</code></li>
</ol>
<p>输入地址，搜索到指定地点之后，点击“共享”按钮</p>
<span id="more"></span>

<img data-src="/blog/posts/7b604068/2022-02-14-22-35-40.png" class="">

<ol start="2">
<li>然后使用嵌入地图</li>
</ol>
<img data-src="/blog/posts/7b604068/2022-02-14-22-35-49.png" class="">

<ol start="3">
<li>将复制的<code>HTML</code>代码粘贴到相应位置，根据自己需求修改宽高</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;contact-map&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">class</span>=<span class="string">&quot;contact-map-size&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3392.8449822382095!2d119.92011513973418!3d31.747432000000007!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x35b46cf8c886febb%3A0x54a85cdf7ef32ab9!2z5rGf6IuP55CG5bel5a2m6Zmi55S15rCU5L-h5oGv5bel56iL5a2m6Zmi!5e0!3m2!1szh-CN!2sus!4v1617931666774!5m2!1szh-CN!2sus&quot;</span>   <span class="attr">allowfullscreen</span>=<span class="string">&quot;&quot;</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>Html</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA小图标含义</title>
    <url>/blog/posts/579bb697/</url>
    <content><![CDATA[<h1 id="IDEA小图标含义"><a href="#IDEA小图标含义" class="headerlink" title="IDEA小图标含义"></a><code>IDEA</code>小图标含义</h1><p>日常图标</p>
<img data-src="/blog/posts/579bb697/2022-02-13-22-13-27.png" class="">

<span id="more"></span>

<img data-src="/blog/posts/579bb697/2022-02-13-22-13-37.png" class="">

<img data-src="/blog/posts/579bb697/2022-02-13-22-13-47.png" class="">

<img data-src="/blog/posts/579bb697/2022-02-13-22-13-56.png" class="">

<h1 id="官网所有小图标解释"><a href="#官网所有小图标解释" class="headerlink" title="官网所有小图标解释"></a><span class="exturl" data-url="aHR0cHM6Ly9qZXRicmFpbnMuZGVzaWduL2ludGVsbGlqL3Jlc291cmNlcy9pY29uc19saXN0Lw==">官网所有小图标解释</span></h1>]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-jar包运行及日志输出</title>
    <url>/blog/posts/f35c5140/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbHNoLWFkbWluL3AvMTUzNDUxNzYuaHRtbA==">原文地址</span></p>
<p>一般情况下运行jar包，当前是可运行的jar包，直接命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar common.jar </span><br></pre></td></tr></table></figure>
<p>按下<code>ctrl+C</code> ，关闭当前<code>ssh</code>或者直接关闭窗口，当前程序都会退出。</p>
<span id="more"></span>


<p>我们在命令的结尾添加 <code>“&amp;”</code> ，&amp;表示该程序可以在后台执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar common.jar &amp;</span><br></pre></td></tr></table></figure>
<p> 但是在当窗口关闭时，程序也会中止运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nohup java -jar common.jar &amp;</span><br></pre></td></tr></table></figure>
<p>命令最前面个<code>nohub</code>关键字，这样程序就会不挂断运行命令, 当ssh终端关闭时,程序仍然在运行，当前程序的日志会被写入到当前目录的<code>nohup.out</code>文件中</p>
<p>我们可以改下输入的日志文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nohup java -jar common.jar &gt; log.out &amp;</span><br></pre></td></tr></table></figure>
<p>当前程序的日志会被写入到当前目录的<code>log.out</code>文件中</p>
<p>如果不想写日志，可以将日志重定向到 <code>/dev/null</code> 中，<code>/dev/null</code>代表<code>linux</code>的空设备文件，所有往这个文件里面写入的内容都会丢失</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nohup java -jar common.jar &gt; /dev/<span class="keyword">null</span> &amp;</span><br></pre></td></tr></table></figure>
<p>标准输出就会不再存在，没有任何地方能够找到输出的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nohup java -jar common-api.jar &gt;/dev/<span class="keyword">null</span> <span class="number">2</span>&gt;log.error &amp; </span><br></pre></td></tr></table></figure>
<p>只输出错误信息到日志文件，标准输出不写入日志文件，直接丢弃</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nohup java -jar common-api.jar &gt;/dev/<span class="keyword">null</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp; </span><br></pre></td></tr></table></figure>
<p>标准输出<code>(stdout)</code>重定向到<code>/dev/null</code>中（丢弃标准输出），然后标准错误输出<code>(stderror)</code>由于重用了标准输出的描述符，所以标准错误输出也被定向到了<code>/dev/null</code>中，错误输出同样也被丢弃了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nohup java -jar common-api.jar &gt;log.out <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp; </span><br></pre></td></tr></table></figure>
<p>标准输出重定向到<code>log.out</code>中，然后错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了<code>log.out</code>中 </p>
<p>但是不管那种情况，如果日志输出，日志文件都会增加很快，造成单个文件很大。所以需要拆分文件</p>
<ol>
<li><p>定时作业，每天将日志文件复制一份，然后将当前的日志文件清空。</p>
</li>
<li><p>借助 <code>cronolog</code>来分隔日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nohup java -jar common-api.jar | /usr/local/cronolog/sbin/cronolog logs/console-%Y-%m-%d.out &amp;</span><br></pre></td></tr></table></figure>
<p>这样每天会产生一个<code>console</code>开头的日志文件。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM简单原理</title>
    <url>/blog/posts/57681474/</url>
    <content><![CDATA[<h1 id="Jvm原理的第一次接触"><a href="#Jvm原理的第一次接触" class="headerlink" title="Jvm原理的第一次接触"></a><code>Jvm</code>原理的第一次接触</h1><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a><code>JVM</code>内存结构</h2><span id="more"></span>

<img data-src="/blog/posts/57681474/2022-02-16-20-49-46.png" class="">

<ul>
<li>第一，<code>JVM</code>分为五个区域：虚拟机栈(<code>VM Stack</code>)、本地方法栈(<code>Native Method Stack</code>)、方法区(<code>Method Area</code>)、堆(<code>Heap</code>)、程序计数器(<code>Program Counter Register</code>)。<code>PS</code>：大家不要排斥英语，此处用英文记忆反而更容易理解。</li>
<li>第二，<code>JVM</code>五个区中虚拟机栈、本地方法栈、程序计数器为线程私有，方法区和堆为线程共享区。图中已经用颜色区分，绿色表示“通行”，橘黄色表示停一停（需等待）。</li>
<li>第三，<code>JVM</code>不同区域的占用内存大小不同，一般情况下堆最大，程序计数器较小。那么最大的区域会放什么？当然就是<code>Java中最多的“对象”</code>了。<br>学习延伸：如果你记住了这张图，是不是就可以说出关于<code>JVM</code>的内存结构了呢？可以尝试一下，切记不用死记硬背，发挥你的想象。</li>
</ul>
<h2 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(<code>Heap</code>)</h2><p>上面已经得出结论，堆内存最大，堆是被线程共享，堆的目的就是存放对象。几乎所有的对象实例都在此分配。当然，随着优化技术的更新，某些数据也会被放在栈上等。</p>
<p>枪打出头鸟，树大招风。因为堆占用内存空间最大，堆也是<code>Java</code>垃圾回收的主要区域（重点对象），因此也称作<code>“GC堆”</code>（<code>Garbage Collected Heap</code>）。</p>
<p>关于<code>GC</code>的操作，我们后面章节会详细讲，但正因为<code>GC</code>的存在，而现代收集器基本都采用分代收集算法，堆又被细化了。</p>
<img data-src="/blog/posts/57681474/2022-02-16-20-49-59.png" class="">

<p>同样，对上图呈现内容汇总分析。</p>
<ul>
<li>第一，堆的<code>GC</code>操作采用分代收集算法。</li>
<li>第二，堆区分了新生代和老年代；</li>
<li>第三，新生代又分为：<code>Eden</code>空间、<code>From Survivor（S0）</code>空间、<code>To Survivor（S1）</code>空间。</li>
</ul>
<p><code>Java</code>虚拟机规范规定，<code>Java</code>堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。也就是说堆的内存是一块块拼凑起来的。要增加堆空间时，往上“拼凑”（可扩展性）即可，但当堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p>
<h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区<code>（Method Area）</code></h2><p>方法区与堆有很多共性：线程共享、内存不连续、可扩展、可垃圾回收，同样当无法再扩展时会抛出<code>OutOfMemoryError</code>异常。</p>
<p>正因为如此相像，<code>Java</code>虚拟机规范把<em><strong>方法区描述为堆</strong></em>的一个逻辑部分，但目前实际上是与<code>Java</code>堆分开的（<code>Non-Heap</code>）。</p>
<p>方法区个性化的是，它存储的是<em><strong>已被虚拟机加载的类信息、常量、静态变量</strong></em>即时编译器编译后的代码等数据。</p>
<p>方法区的内存回收目标主要是针对<em><strong>常量池的回收和对类型的卸载</strong></em>，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是回收确实是有必要的。</p>
<img data-src="/blog/posts/57681474/2022-02-16-20-50-12.png" class="">


<h2 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（<code>Program Counter Register</code>）</h2><p>关于程序计数器我们已经得知：占用内存较小，现成私有。它是唯一没有<code>OutOfMemoryError</code>异常的区域。</p>
<p>程序计数器的作用可以看做是当前线程所执行的<strong>字节码的行号指示器</strong>，字节码解释器工作时就是通过改变计数器的值来选取下一条字节码指令。其中，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器来完成。</p>
<p><code>Java</code>虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。</p>
<img data-src="/blog/posts/57681474/2022-02-16-20-50-23.png" class="">



<p>因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>如果线程正在执行的是一个<code>Java</code>方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<code>Natvie</code>方法，这个计数器值则为空（<code>Undefined</code>）。</p>
<h2 id="虚拟机栈（JVM-Stacks）"><a href="#虚拟机栈（JVM-Stacks）" class="headerlink" title="虚拟机栈（JVM Stacks）"></a>虚拟机栈（<code>JVM Stacks</code>）</h2><p>虚拟机栈线程私有，生命周期与线程相同。</p>
<p>栈帧(<code>Stack Frame</code>)是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。</p>
<img data-src="/blog/posts/57681474/2022-02-16-20-50-34.png" class="">


<p>局部变量表(<code>Local Variable Table</code>)是一组变量值存储空间，用于<code>存放方法参数</code>和<code>方法内定义</code>的局部变量。包括8种基本数据类型、对象引用（<code>reference</code>类型）和<code>returnAddress</code>类型（指向一条字节码指令的地址）。</p>
<p>其中<code>64位</code>长度的<code>long</code>和<code>double</code>类型的数据会占用2个局部变量空间（<code>Slot</code>），其余的数据类型只占用<code>1</code>个。</p>
<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常；如果虚拟机栈动态扩展时无法申请到足够的内存时会抛出<code>OutOfMemoryError</code>异常。</p>
<p>操作数栈(<code>Operand Stack</code>)也称作操作栈，是一个<code>后入先出栈(LIFO)</code>。随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。</p>
<p>动态链接：<code>Java</code>虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接(<code>Dynamic Linking</code>)。</p>
<p>方法返回：无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行。</p>
<h2 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（<code>Native Method Stacks</code>）</h2><p>本地方法栈（<code>Native Method Stacks</code>）与虚拟机栈作用相似，也会抛出<code>StackOverflowError和OutOfMemoryError</code>异常。</p>
<p>区别在于虚拟机栈为虚拟机执行<code>Java</code>方法（<code>字节码</code>）服务，而本地方法栈是为虚拟机使用到的<code>Native</code>方法服务。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img data-src="/blog/posts/57681474/2022-02-16-20-50-46.png" class="">








]]></content>
      <categories>
        <category>Java面试</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8遍历Map的三种方式</title>
    <url>/blog/posts/fc16798c/</url>
    <content><![CDATA[<p>常见的<code>Java8</code>遍历<code>Map</code>的三种方式</p>
<ul>
<li><code>for</code>循环</li>
<li><code>stream</code>流的方式处理</li>
<li><code>forEach</code>方法遍历</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzOTI3MDk2Mjk1NDMy">转载</span></p>
<p><code>Show me the code first!</code>以下是代码，解释一下逻辑，原来的<code>cookies</code>数据结构为<code>Map&lt;String, List&lt;HttpCookie&gt;&gt;</code>,其中<code>HttpCookie</code>为<code>cookie</code>键值对，由于业务需要，我们需要将其转换成<code>Map&lt;String, String&gt;</code>才更方便处理，于是乎就有了以下代码。（我这里直接用了<code>foreach</code>循环，也可以用<code>fori</code>循环，例如<code>for(int i = 0; i&lt; xx; i++)</code>）</p>
<span id="more"></span>
<h2 id="for循环遍历"><a href="#for循环遍历" class="headerlink" title="for循环遍历"></a><code>for</code>循环遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从request中获取原始的cookie</span></span><br><span class="line">MultiValueMap&lt;String, HttpCookie&gt; cookies = request.getCookies(); </span><br><span class="line">Map&lt;String, String&gt; cookieMap = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 新建一个map，将cookie转入该map中</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, List&lt;HttpCookie&gt;&gt; itemList : cookies.entrySet()) &#123; <span class="comment">// 遍历原始的MultiValueMap</span></span><br><span class="line">	<span class="keyword">for</span> (HttpCookie item :itemList.getValue()) &#123; <span class="comment">// 遍历每个item中的List&lt;HttpCookie&gt;，其中的HttpCookie是我们需要的内容</span></span><br><span class="line">		cookieMap.put(item.getName(), item.getValue()); <span class="comment">// 存入内容</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="stream流的方式处理"><a href="#stream流的方式处理" class="headerlink" title="stream流的方式处理"></a><code>stream</code>流的方式处理</h2><p>在<code>Java8</code>中，我们可以使用流，将<code>Collections</code>或者数组转化成<code>Stream</code>，并用链式的调用更加逻辑更加清晰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MultiValueMap&lt;String, HttpCookie&gt; cookies = request.getCookies();</span><br><span class="line">Map&lt;String, String&gt; cookieMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">cookies.entrySet() <span class="comment">// 获取entrySet</span></span><br><span class="line">	.stream() <span class="comment">// 将其转化成流</span></span><br><span class="line">	.map(Map.Entry&lt;String, List&lt;HttpCookie&gt;&gt;::getValue) <span class="comment">// MultiValueMap&lt;String, HttpCookie&gt; -&gt; List&lt;HttpCookie&gt;</span></span><br><span class="line">	.flatMap(List&lt;HttpCookie&gt;::stream) <span class="comment">// List&lt;HttpCookie&gt; -&gt; HttpCookie</span></span><br><span class="line">	.forEach(cookie -&gt; cookieMap.put(cookie.getName(), cookie.getValue())); <span class="comment">// 遍历，存入内容</span></span><br></pre></td></tr></table></figure>
<h2 id="Collection具有的forEach方法遍历"><a href="#Collection具有的forEach方法遍历" class="headerlink" title="Collection具有的forEach方法遍历"></a><code>Collection</code>具有的<code>forEach</code>方法遍历</h2><h3 id="继续用Stream处理"><a href="#继续用Stream处理" class="headerlink" title="继续用Stream处理"></a>继续用<code>Stream</code>处理</h3><p>我们可以看到通过流的方法处理<code>cookie</code>的方法，接下来，我们接着用相同的方法来处理请求参数，请求参数原本的数据格式依然为<code>MultiValueMap&lt;String, String&gt;</code>，可以看做是<code>Map&lt;String, List&lt;String&gt;&gt;</code>，其中请求参数名（<code>key</code>）对应的值（<code>value</code>）可能为多行，我们需要将其处理成一行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MultiValueMap&lt;String, String&gt; params = request.getQueryParams();</span><br><span class="line">Map&lt;String, String&gt; paramMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">params.entrySet()</span><br><span class="line">	.forEach(entry -&gt;</span><br><span class="line">		paramMap.put(</span><br><span class="line">			entry.getKey(), <span class="comment">// 将参数名写入Key</span></span><br><span class="line">			entry.getValue().stream().collect(Collectors.joining())) <span class="comment">// 参数值多行合并成一行写入value</span></span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
<p>大家可以看到，在处理参数值（<code>value</code>）的时候，值为<code>List&lt;String&gt;</code>数据结构，以上代码通过<code>entry.getValue().stream().collect(Collectors.joining()))</code>将其<code>List</code>先转化为<code>Stream</code>，再用流的<code>collection</code>方法，将其合并。这个<code>Collectors</code>还具有将<code>toSet/toList/groupingBy</code>等功能，大家可以自行研究，这里就是使用的是<code>joining</code>合并方法。</p>
<h3 id="使用Collection的forEach方法遍历Map"><a href="#使用Collection的forEach方法遍历Map" class="headerlink" title="使用Collection的forEach方法遍历Map"></a>使用<code>Collection</code>的<code>forEach</code>方法遍历<code>Map</code></h3><p>修改后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">params.forEach((key, value) -&gt; paramMap.put(key, String.join(<span class="string">&quot; &quot;</span>, value)));</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>map</tag>
        <tag>Stream流</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 操作Jenkins</title>
    <url>/blog/posts/d05062ae/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamVua2lucy5pby9kb2MvYm9vay91c2luZy9yZW1vdGUtYWNjZXNzLWFwaS8=">Jenkins-WIKI</span></p>
<p>参考文章: <span class="exturl" data-url="aHR0cDovL3d3dy5teWRscS5jbHViL2FydGljbGUvMjMv">利用 Java 操作 Jenkins API 实现对 Jenkins 的控制详解</span></p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jenkins</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8内置四大函数式接口</title>
    <url>/blog/posts/1da18d70/</url>
    <content><![CDATA[<h1 id="Java8内置函数式接口"><a href="#Java8内置函数式接口" class="headerlink" title="Java8内置函数式接口"></a><code>Java8</code>内置函数式接口</h1><h2 id="函数式接口有什么特点"><a href="#函数式接口有什么特点" class="headerlink" title="函数式接口有什么特点?"></a>函数式接口有什么特点?</h2><p>函数式接口只有一个方法，可以用注解<code>@FunctionalInterface</code>表示，当加上这个注解之后就给这个接口加上了条件，一旦接口中出现多个方法就会出现问题。</p>
<h2 id="核心内置函数有哪些？"><a href="#核心内置函数有哪些？" class="headerlink" title="核心内置函数有哪些？"></a>核心内置函数有哪些？</h2><table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer</td>
<td>T</td>
<td>void</td>
<td>对类型T参数操作，无返回结果，包含方法 void accept(T t)</td>
</tr>
<tr>
<td>Supplier</td>
<td>无</td>
<td>T</td>
<td>返回T类型参数，方法时 T get()</td>
</tr>
<tr>
<td>Function</td>
<td>T</td>
<td>R</td>
<td>对类型T参数操作，返回R类型参数，包含方法 R apply（T t）</td>
</tr>
<tr>
<td>Predicate</td>
<td>T</td>
<td>boolean</td>
<td>断言型接口，对类型T进行条件筛选操作，返回boolean，包含方法 boolean test（T t）</td>
</tr>
</tbody></table>
<h2 id="四大核心函数式接口"><a href="#四大核心函数式接口" class="headerlink" title="四大核心函数式接口"></a>四大核心函数式接口</h2><span id="more"></span>

<h3 id="1-Cousumer-lt-T-gt-消费型接口"><a href="#1-Cousumer-lt-T-gt-消费型接口" class="headerlink" title="1. Cousumer&lt;T&gt; 消费型接口"></a>1. <code>Cousumer&lt;T&gt; </code>消费型接口</h3><blockquote>
<p><code>void accept(T t)</code>;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Consumer&lt;T&gt; 消费型接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shooping</span><span class="params">(<span class="keyword">double</span> money, Consumer&lt;Double&gt; consumer)</span></span>&#123;</span><br><span class="line">    consumer.accept(money);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    shooping(<span class="number">100</span>, money -&gt; System.out.println(<span class="string">&quot;消费金额￥:&quot;</span>+money));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Supplier-lt-T-gt-供给型接口"><a href="#2-Supplier-lt-T-gt-供给型接口" class="headerlink" title="2. Supplier&lt;T&gt; 供给型接口"></a>2. <code>Supplier&lt;T&gt;</code> 供给型接口</h3><blockquote>
<p><code>T get()</code>;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Supplier&lt;T&gt; 供给型接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">random</span><span class="params">(Supplier&lt;Integer&gt; supplier)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = random(() -&gt; (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Function-lt-T-R-gt-函数式接口"><a href="#3-Function-lt-T-R-gt-函数式接口" class="headerlink" title="3. Function&lt;T, R&gt; 函数式接口"></a>3. <code>Function&lt;T, R&gt;</code> 函数式接口</h3><blockquote>
<p><code>R apply(T t)</code>;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Function&lt;T, R&gt; 函数式接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">str</span><span class="params">(String str, Function&lt;String, String&gt; function)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> function.apply(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    str(<span class="string">&quot;Hello World!&quot;</span>, (str) -&gt; str.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Predicate-lt-T-gt-断言型接口"><a href="#4-Predicate-lt-T-gt-断言型接口" class="headerlink" title="4. Predicate&lt;T&gt; 断言型接口"></a>4. <code>Predicate&lt;T&gt;</code> 断言型接口</h3><blockquote>
<p><code>booolean test(T t)</code>;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Predicate&lt;T&gt; 断言型接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">filter</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer number : list) &#123;</span><br><span class="line">        list1.add(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    List&lt;Integer&gt; filterList = filter(list, item -&gt; item &gt; <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (Integer number: filterList) &#123;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>函数式接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习线路图</title>
    <url>/blog/posts/96eb888f/</url>
    <content><![CDATA[<p>图片可能很长。。。</p>
<span id="more"></span>


<img data-src="/blog/posts/96eb888f/2022-02-13-22-17-38.png" class="">

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之assert关键字</title>
    <url>/blog/posts/c3733521/</url>
    <content><![CDATA[<h1 id="Java之assert关键字"><a href="#Java之assert关键字" class="headerlink" title="Java之assert关键字"></a><code>Java</code>之<code>assert</code>关键字</h1><p>在<code>Java</code>中，<code>assert</code>关键字是从<code>JAVA SE 1.4</code> 引入的，为了避免和老版本的<code>Java</code>代码中使用了<code>assert</code>关键字导致错误，<code>Java</code>在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都 将忽略！），如果要开启断言检查，则需要用开关<code>-enableassertions</code>或<code>-ea</code>来开启。</p>
<p><code>assert</code>关键字语法很简单，有两种用法：</p>
<span id="more"></span>

<ol>
<li><p><code>assert</code> <code>&lt;boolean表达式&gt;</code></p>
<p> 如果<code>&lt;boolean表达式&gt;</code>为<code>true</code>，则程序继续执行。</p>
<p> 如果为<code>false</code>，则程序抛出<code>AssertionError</code>，并终止执行。</p>
</li>
<li><p><code>assert &lt;boolean表达式&gt;</code> : &lt;错误信息表达式&gt;</p>
<p> 如果<code>&lt;boolean表达式&gt;</code>为<code>true</code>，则程序继续执行。</p>
<p> 如果为<code>false</code>，则程序抛出<code>java.lang.AssertionError</code>，并输入&lt;错误信息表达式&gt;。</p>
</li>
</ol>
<h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//断言1结果为true，则继续往下执行</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">true</span>;</span><br><span class="line">    System. out.println(<span class="string">&quot;断言1没有问题，Go！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System. out.println(<span class="string">&quot;\n-----------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//断言2结果为false,程序终止</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">false</span> : <span class="string">&quot;断言失败，此表达式的信息将会在抛出异常的时候输出！&quot;</span>;</span><br><span class="line">    System. out.println(<span class="string">&quot;断言2没有问题，Go！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于上述所说,在<code>IDEA</code>中需要手动开启 断言机制</p>
<p>开启方法:</p>
<img data-src="/blog/posts/c3733521/2022-02-13-22-04-43.png" class="">

<img data-src="/blog/posts/c3733521/2022-02-13-22-04-59.png" class="">

<img data-src="/blog/posts/c3733521/2022-02-13-22-05-23.png" class="">

<p>输入<code>-ea</code></p>
<img data-src="/blog/posts/c3733521/2022-02-13-22-05-35.png" class="">

<p>运行结果</p>
<img data-src="/blog/posts/c3733521/2022-02-13-22-05-42.png" class="">

<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p><code>assert</code>关键字用法简单，但是使用<code>assert</code>往往会让你陷入越来越深的陷阱中。应避免使用。笔者经过研究，总结了以下原因：</p>
<p>1、<code>assert</code>关键字需要在运行时候显式开启才能生效，否则你的断言就没有任何意义。而现在主流的<code>Java IDE</code>工具默认都没有开启<code>-ea</code>断言检查功能。这就意味着你如果使用<code>IDE</code>工具编码，调试运行时候会有一定的麻烦。并且，对于<code>Java Web</code>应用，程序代码都是部署在容器里面，你没法直接去控制程序的运行，如果一定要开启<code>-ea</code>的开关，则需要更改<code>Web</code>容器的运行配置参数。这对程序的移 植和部署都带来很大的不便。</p>
<p>2、用<code>assert</code>代替<code>if</code>是陷阱之二。<code>assert</code>的判断和<code>if</code>语句差不多，但两者的作用有着本质的区别：<code>assert</code>关键字本意上是为测试 调试程序时使用的，但如果不小心用<code>assert</code>来控制了程序的业务流程，那在测试调试结束后去掉<code>assert</code>关键字就意味着修改了程序的正常的逻辑。</p>
<p>3、<code>assert</code>断言失败将面临程序的退出。这在一个生产环境下的应用是绝不能容忍的。一般都是通过异常处理来解决程序中潜在的错误。但是使用断言就很危险，一旦失败系统就挂了。</p>
<h2 id="对assert的思考"><a href="#对assert的思考" class="headerlink" title="对assert的思考"></a>对<code>assert</code>的思考</h2><p><code>assert</code>既然是为了调试测试程序用，不在正式生产环境下用，那应该考虑更好的测试<code>JUint</code>来代替其做用，<code>JUint</code>相对<code>assert</code>关键的所提供的功能是有过之而无不及。当然完全可以通过<code>IDE debug</code>来进行调试测试。在此看来，<code>assert</code>的前途一片昏暗。</p>
<p>因此，应当避免在<code>Java</code>中使用<code>assert</code>关键字，除非哪一天<code>Java</code>默认支持开启<code>-ea</code>的开关，这时候可以考虑。对比一下，<code>assert</code>能给你带来多少好处，多少麻烦，这是我们选择是否使用的的原则。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Assert</tag>
      </tags>
  </entry>
  <entry>
    <title>Java获取一天时间的起始</title>
    <url>/blog/posts/49b96938/</url>
    <content><![CDATA[<p>如何获取一个指定日期的一天起始时间呢:<code>hutool</code>中有自带的方法:</p>
<span id="more"></span>

<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="keyword">group</span>: <span class="string">&#x27;cn.hutool&#x27;</span>, name: <span class="string">&#x27;hutool-all&#x27;</span>, version: <span class="string">&#x27;5.7.16&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="获取当天的开始时间"><a href="#获取当天的开始时间" class="headerlink" title="获取当天的开始时间"></a>获取当天的开始时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateUtil.beginOfDay(<span class="keyword">new</span> Date())</span><br></pre></td></tr></table></figure>
<h2 id="获取当天的结束时间"><a href="#获取当天的结束时间" class="headerlink" title="获取当天的结束时间"></a>获取当天的结束时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateUtil.endOfDay(<span class="keyword">new</span> Date())</span><br></pre></td></tr></table></figure>

<h2 id="在这里获取昨天的开始和结束时间需要结合Calendar和hutool一起使用"><a href="#在这里获取昨天的开始和结束时间需要结合Calendar和hutool一起使用" class="headerlink" title="在这里获取昨天的开始和结束时间需要结合Calendar和hutool一起使用"></a>在这里获取昨天的开始和结束时间需要结合<code>Calendar</code>和<code>hutool</code>一起使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat=<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如今天是 2021-12-16 16:55:45</span></span><br><span class="line"><span class="comment">//获取昨天开始的时间</span></span><br><span class="line">Date beginOfDay = DateUtil.beginOfDay(<span class="keyword">new</span> Date());</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">c.setTime(beginOfDay);</span><br><span class="line">c.add(Calendar.DAY_OF_MONTH,-<span class="number">1</span>);</span><br><span class="line">Date yesterBeginDay = c.getTime();</span><br><span class="line">String a = simpleDateFormat.format(yesterBeginDay);</span><br><span class="line">System.out.println(a);</span><br><span class="line"></span><br><span class="line">输出结果：<span class="number">2021</span>-<span class="number">12</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取昨天结束的时间</span></span><br><span class="line">Date endOfDay = DateUtil.endOfDay(<span class="keyword">new</span> Date());</span><br><span class="line">c.setTime(endOfDay);</span><br><span class="line">c.add(Calendar.DAY_OF_MONTH,-<span class="number">1</span>);</span><br><span class="line">Date yesterEndDay = c.getTime();</span><br><span class="line">String b = simpleDateFormat.format(yesterEndDay);</span><br><span class="line">System.out.println(b);</span><br><span class="line"></span><br><span class="line">输出结果：<span class="number">2021</span>-<span class="number">12</span>-<span class="number">15</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>calender</tag>
      </tags>
  </entry>
  <entry>
    <title>Java自带的好用的工具类</title>
    <url>/blog/posts/b246d3ce/</url>
    <content><![CDATA[<h1 id="Java自带的好用的工具类"><a href="#Java自带的好用的工具类" class="headerlink" title="Java自带的好用的工具类"></a><code>Java</code>自带的好用的工具类</h1><h2 id="List集合拼接成以逗号分隔的字符串"><a href="#List集合拼接成以逗号分隔的字符串" class="headerlink" title="List集合拼接成以逗号分隔的字符串"></a><code>List</code>集合拼接成以逗号分隔的字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如何把list集合拼接成以逗号分隔的字符串 a,b,c </span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);  </span><br><span class="line"><span class="comment">// 第一种方法，可以用stream流 </span></span><br><span class="line">String join = list.stream().collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));  </span><br><span class="line">System.out.println(join); <span class="comment">// 输出 a,b,c </span></span><br><span class="line"><span class="comment">// 第二种方法，其实String也有join方法可以实现这个功能 </span></span><br><span class="line">String join = String.join(<span class="string">&quot;,&quot;</span>, list);  </span><br><span class="line">System.out.println(join); <span class="comment">// 输出 a,b,c</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="比较两个字符串是否相等，忽略大小写"><a href="#比较两个字符串是否相等，忽略大小写" class="headerlink" title="比较两个字符串是否相等，忽略大小写"></a>比较两个字符串是否相等，忽略大小写</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (strA.equalsIgnoreCase(strB)) &#123;  </span><br><span class="line">  System.out.println(<span class="string">&quot;相等&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="比较两个对象是否相等"><a href="#比较两个对象是否相等" class="headerlink" title="比较两个对象是否相等"></a>比较两个对象是否相等</h2><p>当我们用 <code>equals</code> 比较两个对象是否相等的时候，还需要对左边的对象进行判空，不然可能会报空指针异常，我们可以用 <code>java.util</code> 包下 <code>Objects</code> 封装好的比较是否相等的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Objects.equals(strA, strB);</span><br><span class="line"><span class="comment">//源码是这样的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两个List取交集"><a href="#两个List取交集" class="headerlink" title="两个List取交集"></a>两个<code>List</code>取交集</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">list1.add(<span class="string">&quot;a&quot;</span>);  </span><br><span class="line">list1.add(<span class="string">&quot;b&quot;</span>);  </span><br><span class="line">list1.add(<span class="string">&quot;c&quot;</span>);  </span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">list2.add(<span class="string">&quot;a&quot;</span>);  </span><br><span class="line">list2.add(<span class="string">&quot;b&quot;</span>);  </span><br><span class="line">list2.add(<span class="string">&quot;d&quot;</span>);  </span><br><span class="line">list1.retainAll(list2);  </span><br><span class="line">System.out.println(list1);</span><br><span class="line"><span class="comment">// 输出[a, b]</span></span><br></pre></td></tr></table></figure>
<h1 id="使用apache-commons-工具类库"><a href="#使用apache-commons-工具类库" class="headerlink" title="使用apache commons 工具类库"></a>使用<code>apache commons</code> 工具类库</h1><h2 id="字符串判空"><a href="#字符串判空" class="headerlink" title="字符串判空"></a>字符串判空</h2><p>传参 <code>CharSequence</code> 类型是 <code>String、StringBuilder、StringBuffer</code> 的父类，都可以直接下面方法判空，以下是源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">final</span> CharSequence cs)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> cs == <span class="keyword">null</span> || cs.length() == <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNotEmpty</span><span class="params">(<span class="keyword">final</span> CharSequence cs)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> !isEmpty(cs);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 判空的时候，会去除字符串中的空白字符，比如空格、换行、制表符 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBlank</span><span class="params">(<span class="keyword">final</span> CharSequence cs)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> strLen = length(cs);  </span><br><span class="line">    <span class="keyword">if</span> (strLen == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!Character.isWhitespace(cs.charAt(i))) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNotBlank</span><span class="params">(<span class="keyword">final</span> CharSequence cs)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> !isBlank(cs);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="首字母转成大写"><a href="#首字母转成大写" class="headerlink" title="首字母转成大写"></a>首字母转成大写</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;yideng&quot;</span>;  </span><br><span class="line">String capitalize = StringUtils.capitalize(str);  </span><br><span class="line">System.out.println(capitalize); <span class="comment">// 输出Yideng</span></span><br></pre></td></tr></table></figure>
<h2 id="重复拼接字符串"><a href="#重复拼接字符串" class="headerlink" title="重复拼接字符串"></a>重复拼接字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = StringUtils.repeat(<span class="string">&quot;ab&quot;</span>, <span class="number">2</span>);  </span><br><span class="line">System.out.println(str); <span class="comment">// 输出abab</span></span><br></pre></td></tr></table></figure>
<h2 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Date类型转String类型 </span></span><br><span class="line">String date = DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);  </span><br><span class="line">System.out.println(date); <span class="comment">// 输出 2021-05-01 01:01:01 </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// String类型转Date类型 </span></span><br><span class="line">Date date = DateUtils.parseDate(<span class="string">&quot;2021-05-01 01:01:01&quot;</span>, <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 计算一个小时后的日期 </span></span><br><span class="line">Date date = DateUtils.addHours(<span class="keyword">new</span> Date(), <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="包装临时对象"><a href="#包装临时对象" class="headerlink" title="包装临时对象"></a>包装临时对象</h2><p>当一个方法需要返回两个及以上字段时，我们一般会封装成一个临时对象返回，现在有了 <code>Pair</code> 和 <code>Triple</code> 就不需要了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回两个字段 </span></span><br><span class="line">ImmutablePair&lt;Integer, String&gt; pair = ImmutablePair.of(<span class="number">1</span>, <span class="string">&quot;yideng&quot;</span>);  </span><br><span class="line">System.out.println(pair.getLeft() + <span class="string">&quot;,&quot;</span> + pair.getRight()); <span class="comment">// 输出 1,yideng </span></span><br><span class="line"><span class="comment">// 返回三个字段 </span></span><br><span class="line">ImmutableTriple&lt;Integer, String, Date&gt; triple = ImmutableTriple.of(<span class="number">1</span>, <span class="string">&quot;yideng&quot;</span>, <span class="keyword">new</span> Date());  </span><br><span class="line">System.out.println(triple.getLeft() + <span class="string">&quot;,&quot;</span> + triple.getMiddle() + <span class="string">&quot;,&quot;</span> + triple.getRight()); <span class="comment">// 输出 1,yideng,Wed Apr 07 23:30:00 CST 2021</span></span><br></pre></td></tr></table></figure>

<h1 id="commons-collections-集合工具类"><a href="#commons-collections-集合工具类" class="headerlink" title="commons-collections 集合工具类"></a><code>commons-collections</code> 集合工具类</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="集合判空"><a href="#集合判空" class="headerlink" title="集合判空"></a>集合判空</h2><p>封装了集合判空的方法，以下是源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">final</span> Collection&lt;?&gt; coll)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> coll == <span class="keyword">null</span> || coll.isEmpty();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNotEmpty</span><span class="params">(<span class="keyword">final</span> Collection&lt;?&gt; coll)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> !isEmpty(coll);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 两个集合取交集 </span></span><br><span class="line">Collection&lt;String&gt; collection = CollectionUtils.retainAll(listA, listB);  </span><br><span class="line"><span class="comment">// 两个集合取并集 </span></span><br><span class="line">Collection&lt;String&gt; collection = CollectionUtils.union(listA, listB);  </span><br><span class="line"><span class="comment">// 两个集合取差集 </span></span><br><span class="line">Collection&lt;String&gt; collection = CollectionUtils.subtract(listA, listB);</span><br></pre></td></tr></table></figure>
<h1 id="common-beanutils-操作对象"><a href="#common-beanutils-操作对象" class="headerlink" title="common-beanutils 操作对象"></a><code>common-beanutils</code> 操作对象</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Integer id;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line">User user = <span class="keyword">new</span> User();  </span><br><span class="line">BeanUtils.setProperty(user, <span class="string">&quot;id&quot;</span>, <span class="number">1</span>);  </span><br><span class="line">BeanUtils.setProperty(user, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;yideng&quot;</span>);  </span><br><span class="line">System.out.println(BeanUtils.getProperty(user, <span class="string">&quot;name&quot;</span>)); <span class="comment">// 输出 yideng </span></span><br><span class="line">System.out.println(user); <span class="comment">// 输出 &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;yideng&quot;&#125;</span></span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line"><span class="comment">//对象和 map 互转</span></span><br><span class="line">Map&lt;String, String&gt; map = BeanUtils.describe(user);  </span><br><span class="line">System.out.println(map); <span class="comment">// 输出 &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;yideng&quot;&#125; </span></span><br><span class="line"><span class="comment">// map转对象 </span></span><br><span class="line">User newUser = <span class="keyword">new</span> User();  </span><br><span class="line">BeanUtils.populate(newUser, map);  </span><br><span class="line">System.out.println(newUser); <span class="comment">// 输出 &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;yideng&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="commons-io-文件流处理"><a href="#commons-io-文件流处理" class="headerlink" title="commons-io 文件流处理"></a><code>commons-io</code> 文件流处理</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>文件处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;demo1.txt&quot;</span>);  </span><br><span class="line"><span class="comment">// 读取文件 </span></span><br><span class="line">List&lt;String&gt; lines = FileUtils.readLines(file, Charset.defaultCharset());  </span><br><span class="line"><span class="comment">// 写入文件 </span></span><br><span class="line">FileUtils.writeLines(<span class="keyword">new</span> File(<span class="string">&quot;demo2.txt&quot;</span>), lines);  </span><br><span class="line"><span class="comment">// 复制文件 </span></span><br><span class="line">FileUtils.copyFile(srcFile, destFile);</span><br><span class="line">```   </span><br><span class="line"># ``Google Guava`` 工具类库</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;  </span><br><span class="line">    &lt;version&gt;<span class="number">30.1</span><span class="number">.1</span>-jre&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList();  </span><br><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  </span><br><span class="line"><span class="comment">// 反转list </span></span><br><span class="line">List&lt;Integer&gt; reverse = Lists.reverse(list);  </span><br><span class="line">System.out.println(reverse); <span class="comment">// 输出 [3, 2, 1] </span></span><br><span class="line"><span class="comment">// list集合元素太多，可以分成若干个集合，每个集合10个元素 </span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; partition = Lists.partition(list, <span class="number">10</span>);  </span><br><span class="line">  </span><br><span class="line">Map&lt;String, String&gt; map = Maps.newHashMap();  </span><br><span class="line">Set&lt;String&gt; set = Sets.newHashSet();</span><br></pre></td></tr></table></figure>

<h2 id="Multimap-一个-key-可以映射多个-value-的-HashMap"><a href="#Multimap-一个-key-可以映射多个-value-的-HashMap" class="headerlink" title="Multimap 一个 key 可以映射多个 value 的 HashMap"></a><code>Multimap</code> 一个 <code>key</code> 可以映射多个 <code>value</code> 的 <code>HashMap</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Multimap&lt;String, Integer&gt; map = ArrayListMultimap.create();  </span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>, <span class="number">1</span>);  </span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>, <span class="number">2</span>);  </span><br><span class="line">Collection&lt;Integer&gt; values = map.get(<span class="string">&quot;key&quot;</span>);  </span><br><span class="line">System.out.println(map); <span class="comment">// 输出 &#123;&quot;key&quot;:[1,2]&#125; </span></span><br><span class="line"><span class="comment">// 还能返回你以前使用的臃肿的Map </span></span><br><span class="line">Map&lt;String, Collection&lt;Integer&gt;&gt; collectionMap = map.asMap();</span><br></pre></td></tr></table></figure>
<p>多省事，多简洁，省得你再创建 Map&lt;String, List&gt;</p>
<h2 id="BiMap-一种连-value-也不能重复的-HashMap"><a href="#BiMap-一种连-value-也不能重复的-HashMap" class="headerlink" title="BiMap 一种连 value 也不能重复的 HashMap"></a><code>BiMap</code> 一种连 <code>value</code> 也不能重复的 <code>HashMap</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiMap&lt;String, String&gt; biMap = HashBiMap.create();  </span><br><span class="line"><span class="comment">// 如果value重复，put方法会抛异常，除非用forcePut方法 </span></span><br><span class="line">biMap.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);  </span><br><span class="line">System.out.println(biMap); <span class="comment">// 输出 &#123;&quot;key&quot;:&quot;value&quot;&#125; </span></span><br><span class="line"><span class="comment">// 既然value不能重复，何不实现个翻转key/value的方法，已经有了 </span></span><br><span class="line">BiMap&lt;String, String&gt; inverse = biMap.inverse();  </span><br><span class="line">System.out.println(inverse); <span class="comment">// 输出 &#123;&quot;value&quot;:&quot;key&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>这其实是双向映射，在某些场景还是很实用的。</p>
<img data-src="/blog/posts/b246d3ce/2022-02-13-22-22-23.png" class="">

<h2 id="Table-一种有两个-key-的-HashMap"><a href="#Table-一种有两个-key-的-HashMap" class="headerlink" title="Table 一种有两个 key 的 HashMap"></a><code>Table</code> 一种有两个 <code>key</code> 的 <code>HashMap</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一批用户，同时按年龄和性别分组 </span></span><br><span class="line">Table&lt;Integer, String, String&gt; table = HashBasedTable.create();  </span><br><span class="line">table.put(<span class="number">18</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;yideng&quot;</span>);  </span><br><span class="line">table.put(<span class="number">18</span>, <span class="string">&quot;女&quot;</span>, <span class="string">&quot;Lily&quot;</span>);  </span><br><span class="line">System.out.println(table.get(<span class="number">18</span>, <span class="string">&quot;男&quot;</span>)); <span class="comment">// 输出 yideng </span></span><br><span class="line"><span class="comment">// 这其实是一个二维的Map，可以查看行数据 </span></span><br><span class="line">Map&lt;String, String&gt; row = table.row(<span class="number">18</span>);  </span><br><span class="line">System.out.println(row); <span class="comment">// 输出 &#123;&quot;男&quot;:&quot;yideng&quot;,&quot;女&quot;:&quot;Lily&quot;&#125; </span></span><br><span class="line"><span class="comment">// 查看列数据 </span></span><br><span class="line">Map&lt;Integer, String&gt; column = table.column(<span class="string">&quot;男&quot;</span>);  </span><br><span class="line">System.out.println(column); <span class="comment">// 输出 &#123;18:&quot;yideng&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Multiset-一种用来计数的-Set"><a href="#Multiset-一种用来计数的-Set" class="headerlink" title="Multiset 一种用来计数的 Set"></a><code>Multiset</code> 一种用来计数的 <code>Set</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multiset&lt;String&gt; multiset = HashMultiset.create();  </span><br><span class="line">multiset.add(<span class="string">&quot;apple&quot;</span>);  </span><br><span class="line">multiset.add(<span class="string">&quot;apple&quot;</span>);  </span><br><span class="line">multiset.add(<span class="string">&quot;orange&quot;</span>);  </span><br><span class="line">System.out.println(multiset.count(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// 输出 2 </span></span><br><span class="line"><span class="comment">// 查看去重的元素 </span></span><br><span class="line">Set&lt;String&gt; set = multiset.elementSet();  </span><br><span class="line">System.out.println(set); <span class="comment">// 输出 [&quot;orange&quot;,&quot;apple&quot;] </span></span><br><span class="line"><span class="comment">// 还能查看没有去重的元素 </span></span><br><span class="line">Iterator&lt;String&gt; iterator = multiset.iterator();  </span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">    System.out.println(iterator.next());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 还能手动设置某个元素出现的次数 </span></span><br><span class="line">multiset.setCount(<span class="string">&quot;apple&quot;</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>Java</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java通过URL下载资源</title>
    <url>/blog/posts/a54ed4b0/</url>
    <content><![CDATA[<p>关于如何通过下载<code>URL</code>下载网络资源，最近做了一些整理</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtZG93bmxvYWQtZmlsZQ==">参考文章</span></p>
<p>差不多以下的几个都是可以<code>work</code>的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadByUrl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DOWNLOAD_URL = <span class="string">&quot;https://archive.apache.org/dist/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILE_NAME = <span class="string">&quot;download_file/maven-3.5.4-bin.tar.gz&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">downloadByJavaIO</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> URL(DOWNLOAD_URL).openStream()))&#123;</span><br><span class="line">            FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(FILE_NAME);</span><br><span class="line">            <span class="keyword">byte</span>[] dataBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> bytesRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = in.read(dataBuffer,<span class="number">0</span>,<span class="number">1024</span>)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fileOutputStream.write(dataBuffer,<span class="number">0</span>,bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">downloadByJavaIOAndCopy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">new</span> URL(DOWNLOAD_URL).openStream();</span><br><span class="line">        Files.copy(in, Paths.get(FILE_NAME), StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">downloadByNIO</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(FILE_NAME))&#123;</span><br><span class="line">            ReadableByteChannel readableByteChannel = Channels.newChannel(<span class="keyword">new</span> URL(DOWNLOAD_URL).openStream());</span><br><span class="line">            <span class="comment">// get a file channel</span></span><br><span class="line">            ;</span><br><span class="line"><span class="comment">//            FileChannel fileChannel = fileOutputStream.getChannel();</span></span><br><span class="line">            fileOutputStream.getChannel()</span><br><span class="line">                    .transferFrom(readableByteChannel,<span class="number">0</span>,Long.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">downloadByCommonsIO</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileUtils.copyURLToFile(</span><br><span class="line">                <span class="keyword">new</span> URL(DOWNLOAD_URL)</span><br><span class="line">                ,<span class="keyword">new</span> File(FILE_NAME)</span><br><span class="line">                ,<span class="number">1000</span></span><br><span class="line">                ,<span class="number">2000</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java运行调用Shell脚本</title>
    <url>/blog/posts/8da68a98/</url>
    <content><![CDATA[<p>关于在<code>java</code>中如何去调用<code>shell</code>脚本，最近忙活了老半天</p>
<p>在<code>java</code>中有一个<code>ProcessBuilder</code>类,能够调用到<code>sh</code>命令，话不多说，贴上代码</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zipFileAction</span><span class="params">(String computationDir,String email)</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;###### start zip file , computation is &#123;&#125; ###### &quot;</span>, computationDir);</span><br><span class="line">    <span class="comment">// initShell</span></span><br><span class="line">    Process process = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder();</span><br><span class="line">        <span class="comment">//这里指的shell文件所在的目录</span></span><br><span class="line">        pb.directory(<span class="keyword">new</span> File(DirectoryUtil.getFileLocalAbsolutePathWithFileUrl(<span class="string">&quot;shell/action/&quot;</span>)));</span><br><span class="line">        <span class="comment">//权限</span></span><br><span class="line">        pb.command(<span class="string">&quot;chmod 777 &quot;</span> + shellProperties.getZipShellName());</span><br><span class="line">        <span class="comment">//此处的 ./ 不是指当前文件夹 ， 而是指运行的意思</span></span><br><span class="line">        pb.command(<span class="string">&quot;./&quot;</span>+shellProperties.getZipShellName() ,computationDir,shellProperties.getCompressedFileName());</span><br><span class="line">        <span class="comment">// 将错误输出流转移到标准输出流中,但使用Runtime不可以</span></span><br><span class="line">        pb.redirectErrorStream(<span class="keyword">true</span>);</span><br><span class="line">        process = pb.start();</span><br><span class="line">        <span class="comment">//将shell日志写入到文件中</span></span><br><span class="line">        writeToLocal(DirectoryUtil.getFileLocalAbsolutePathWithFileUrl(computationDir) + <span class="string">&quot;/zipLog.txt&quot;</span>,process.getInputStream());</span><br><span class="line"><span class="comment">//            String dataMsg = reader(process.getInputStream());</span></span><br><span class="line"><span class="comment">//            log.info(&quot;###### shell zip script data message is &#123;&#125; ###### &quot;,dataMsg);</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;###### run shell zip script is error , message is &#123;&#125;######&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> runningStatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runningStatus = process.waitFor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;###### run shell zip script occurs error, error is &#123;&#125; ######&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(runningStatus != <span class="number">0</span>) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;###### run shell zip script failed.###### &quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;###### run shell zip script success. ######&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 数据读取操作</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> input 输入流</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reader</span><span class="params">(InputStream input)</span> </span>&#123;</span><br><span class="line">    StringBuilder outDat = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">try</span> (InputStreamReader inputReader = <span class="keyword">new</span> InputStreamReader(input, StandardCharsets.UTF_8);</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(inputReader)) &#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            outDat.append(line);</span><br><span class="line">            outDat.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;exception is &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outDat.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将InputStream写入本地文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> destination 写入本地目录</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> input	输入流</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeToLocal</span><span class="params">(String destination, InputStream input)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    FileOutputStream downloadFile = <span class="keyword">new</span> FileOutputStream(destination);</span><br><span class="line">    <span class="keyword">while</span> ((index = input.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        downloadFile.write(bytes, <span class="number">0</span>, index);</span><br><span class="line">        downloadFile.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    downloadFile.close();</span><br><span class="line">    input.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins/CICD</title>
    <url>/blog/posts/171f1b7f/</url>
    <content><![CDATA[<p><a href="https://smile1231.github.io/posts/11faeb76/"><code>Docker</code>中安装<code>Jenkins</code></a></p>
<p><a href="https://www.cnblogs.com/yungyu16/p/12928802.html#%E6%93%8D%E4%BD%9C%E4%BB%BB%E5%8A%A1"><code>Java</code>操作<code>Jenkins</code>参考</a></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9pY29kZS5iZXN0L2kvODI4MDAwNDYwNDU0MDk=">参考文章</span></p>
<p>完成<code>jenkins</code>在docker中的启动安装对应的插件之后</p>
<p>由于我是使用的<code>docker</code>启动的<code>Jenkins</code>,所以需要在容器中装相应的环境：<code>jdk</code>,<code>maven</code>,<code>git</code>等等</p>
<p>进入容器内部:<code>docker exec -u root -it myJenkins10242 bash</code></p>
<h2 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装<code>vim</code></h2><blockquote>
<p>在这之前需要对<code>apt</code>进行一下升级 </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>

<p>安装指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/171f1b7f/2022-08-10-23-41-19.png" class="">

<h2 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装<code>jdk</code></h2><p>这里只讲解手动安装</p>
<p>查看架构，下载arm64版本的jdk，这里下载jdk11，<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhc2UvamRrMTEtYXJjaGl2ZS1kb3dubG9hZHMuaHRtbCNsaWNlbnNlLWxpZ2h0Ym94">jdk 11 aarch64_bin.tar.gz</span></p>
<img data-src="/blog/posts/171f1b7f/2022-08-10-22-18-27.png" class="">

<p>我这边将包放在了<code>docker</code>的挂载目录上</p>
<img data-src="/blog/posts/171f1b7f/2022-08-10-23-52-53.png" class="">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf jdk-11.0.15_linux-aarch64_bin.tar.gz</span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>
<p>在最后加上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/var/jenkins_home/install_package/jdk-11.0.15/</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure>

<p>最后：<code>source /etc/profile</code> 即可</p>
<img data-src="/blog/posts/171f1b7f/2022-08-11-00-02-07.png" class="">
<h2 id="安装maven"><a href="#安装maven" class="headerlink" title="安装maven"></a>安装<code>maven</code></h2><p>安装<code>maven</code>的方法也类似，下载版本为<span class="exturl" data-url="aHR0cHM6Ly9hcmNoaXZlLmFwYWNoZS5vcmcvZGlzdC9tYXZlbi9tYXZlbi0zLzMuNS40L2JpbmFyaWVzL2FwYWNoZS1tYXZlbi0zLjUuNC1iaW4udGFyLmd6">maven-3.5.4</span></p>
<p>依然放在了挂在目录中的<code>install_package</code>中</p>
<p>解压：<code>tar -zxvf apache-maven-3.5.4-bin.tar.gz</code></p>
<p>配置环境变量: <code>vim /etc/profile</code><br>加上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> MAVEN_HOME=/var/jenkins_home/install_package/apache-maven-3.5.4</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$MAVEN_HOME</span>/bin</span><br></pre></td></tr></table></figure>
<p>最后：<code>source /etc/profile</code> 即可</p>
<img data-src="/blog/posts/171f1b7f/2022-08-11-00-06-59.png" class="">

<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a><code>Git</code></h2><p>容器中自带了<code>git</code>，所以无需安装，但是需要查看路径: <code>which git</code>，路径为：<code>/usr/bin/git</code></p>
<img data-src="/blog/posts/171f1b7f/2022-08-11-00-10-10.png" class="">

<h2 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置<code>Jenkins</code></h2><p>打开<code>Global Tool Configuration</code>:</p>
<img data-src="/blog/posts/171f1b7f/2022-08-11-00-12-49.png" class="">

<p>这边是配置<code>maven</code>中的<code>settings</code>文件地址，我地址为：<code>/var/jenkins_home/install_package/apache-maven-3.5.4/conf/settings.xml</code></p>
<img data-src="/blog/posts/171f1b7f/2022-08-11-00-15-24.png" class="">


<p>分别配置上<code>jdk</code>,<code>git</code>,<code>maven</code>的本地目录,然后<code>Apply</code>和<code>Save</code>：</p>
<img data-src="/blog/posts/171f1b7f/2022-08-11-00-17-12.png" class="">

<img data-src="/blog/posts/171f1b7f/2022-08-11-00-17-47.png" class="">

<h2 id="安装plugin"><a href="#安装plugin" class="headerlink" title="安装plugin"></a>安装<code>plugin</code></h2><p>我们会发现新建一个<code>Item</code>是没有<code>Maven</code>项目的，需要安装一下对应的插件:<code>Maven Integration</code></p>
<img data-src="/blog/posts/171f1b7f/2022-08-11-00-20-56.png" class="">

<p>等待安装完成即可</p>
<h2 id="Maven项目部署测试"><a href="#Maven项目部署测试" class="headerlink" title="Maven项目部署测试"></a><code>Maven</code>项目部署测试</h2><h3 id="新建一个Maven，名字自取"><a href="#新建一个Maven，名字自取" class="headerlink" title="新建一个Maven，名字自取"></a>新建一个<code>Maven</code>，名字自取</h3><img data-src="/blog/posts/171f1b7f/2022-08-11-00-22-22.png" class="">

<h3 id="项目描述："><a href="#项目描述：" class="headerlink" title="项目描述："></a>项目描述：</h3><img data-src="/blog/posts/171f1b7f/2022-08-11-00-26-00.png" class="">

<h3 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置<code>github</code></h3><img data-src="/blog/posts/171f1b7f/2022-08-11-00-29-23.png" class="">

<blockquote>
<p>关于<code>GitHub</code>凭证配置</p>
</blockquote>
<p>配置地址： <code>https://github.com/settings/tokens</code></p>
<img data-src="/blog/posts/171f1b7f/2022-08-11-00-30-37.png" class="">

<img data-src="/blog/posts/171f1b7f/2022-08-11-00-31-02.png" class="">

<p>将生成的<code>token</code>记载到本地</p>
<img data-src="/blog/posts/171f1b7f/2022-08-11-00-31-43.png" class="">

<blockquote>
<p><code>Jenkins</code>添加凭据</p>
</blockquote>
<img data-src="/blog/posts/171f1b7f/2022-08-11-00-33-43.png" class="">

<h3 id="github访问超时时间"><a href="#github访问超时时间" class="headerlink" title="github访问超时时间"></a><code>github</code>访问超时时间</h3><p>检出超时时间：</p>
<img data-src="/blog/posts/171f1b7f/2022-08-11-00-34-52.png" class="">

<p><code>clone</code>超时时间：</p>
<img data-src="/blog/posts/171f1b7f/2022-08-11-00-36-01.png" class="">

<h3 id="Build阶段"><a href="#Build阶段" class="headerlink" title="Build阶段"></a><code>Build</code>阶段</h3><p><code>clean package -Dmaven.test.skip=true -Prd -U</code></p>
<img data-src="/blog/posts/171f1b7f/2022-08-11-00-39-04.png" class="">

<h3 id="配置构建项目后执行的Shell脚本"><a href="#配置构建项目后执行的Shell脚本" class="headerlink" title="配置构建项目后执行的Shell脚本"></a>配置构建项目后执行的<code>Shell</code>脚本</h3><img data-src="/blog/posts/171f1b7f/2022-08-11-00-42-20.png" class="">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#输入Maven打包后的项目名称</span></span><br><span class="line">app=xxx-0.0.1-SNAPSHOT</span><br><span class="line"><span class="comment">#项目移动的目的地址</span></span><br><span class="line">path=/usr/xxx</span><br><span class="line"><span class="built_in">echo</span> this is app : <span class="variable">$app</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#若项目已启动，杀死旧进程</span></span><br><span class="line">api_pid=`ps -ef | grep <span class="string">&quot;<span class="variable">$app</span>.jar&quot;</span> | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line"><span class="built_in">echo</span> api_pid = <span class="variable">$api_pid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$api_pid</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="built_in">kill</span> api</span><br><span class="line">        <span class="built_in">kill</span> -9 <span class="variable">$api_pid</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">echo</span> sleep 3s</span><br><span class="line">        sleep 1</span><br><span class="line">        <span class="built_in">echo</span> sleep 2s</span><br><span class="line">        sleep 1</span><br><span class="line">        <span class="built_in">echo</span> sleep 1s</span><br><span class="line">        sleep 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将jar包从jenkins工作空间中移动到指定路径下</span></span><br><span class="line">mv /root/.jenkins/workspace/项目名/target/<span class="variable">$app</span>.jar <span class="variable">$path</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$path</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#防止进程被杀死</span></span><br><span class="line">BUILD_ID=dontKillMe</span><br><span class="line"></span><br><span class="line"><span class="comment">#后台进程形式启动项目，日志文件为out.log</span></span><br><span class="line">nohup java -jar <span class="variable">$app</span>.jar &gt;&gt; out.log 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$app</span> start success</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<h2 id="Jenkins运行"><a href="#Jenkins运行" class="headerlink" title="Jenkins运行"></a><code>Jenkins</code>运行</h2><img data-src="/blog/posts/171f1b7f/2022-08-11-00-43-49.png" class="">

<img data-src="/blog/posts/171f1b7f/2022-08-11-00-45-15.png" class="">
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>Js中的some、find、findindex、includes、filter的使用</title>
    <url>/blog/posts/4aa00b9a/</url>
    <content><![CDATA[<h1 id="js中的some、find、findindex、includes、filter的使用"><a href="#js中的some、find、findindex、includes、filter的使用" class="headerlink" title="js中的some、find、findindex、includes、filter的使用"></a><code>js</code>中的<code>some、find、findindex、includes、filter</code>的使用</h1><blockquote>
<p>类似于<code>foreach</code>的方法<br>为什么把这类方法归到一起讲，因为我在使用的过程中发现其实这些方法的用法和参数其实都是一样的，底层应该都是和<code>foreach</code>差不多，差别只是在于返回的东西不一样，那么再来看看这些方法的差别以及用法。</p>
</blockquote>
<ul>
<li>语法<br><code>array.方法名(function(currentValue, index, arr),thisValue)</code></li>
</ul>
<span id="more"></span>

<ul>
<li>参数</li>
</ul>
<img data-src="/blog/posts/4aa00b9a/2022-02-14-22-33-00.png" class="">

<p>以上是这些方法共同的基本的语法以及参数</p>
<p>那么再来看看这些方法的不同点</p>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a><code>forEach()</code></h2><p><code>forEach()</code> 方法用于调用数组的每个元素，并将元素传递给回调函数。</p>
<p>注意: <code>forEach()</code> 对于空数组是不会执行回调函数的。</p>
<blockquote>
<p>也就是说 <code>forEach()</code> 这个方法是没有任何限制的，回调函数最终返回的值是完全由自己决定的，也就是说其实后面介绍到的所有的方法其实也都可以通过<code>forEach()</code>来实现相同的功能，只不过要自己写更多的代码量。<br><code>forEach()</code>可以通过<code>return</code>来提前退出循环，同时返回相应的值</p>
</blockquote>
<h2 id="map"><a href="#map" class="headerlink" title="map()"></a><code>map()</code></h2><p><code>map()</code> 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p>
<p><code>map()</code> 方法按照原始数组元素顺序依次处理元素。</p>
<ul>
<li><p>注意： <code>map()</code> 不会对空数组进行检测。</p>
</li>
<li><p>注意： <code>map()</code> 不会改变原始数组。</p>
</li>
</ul>
<blockquote>
<p><code>map</code>和<code>foreach</code>很像，差别就在于<code>map</code>所得到的所有符合条件的结果都会通过一个数组来返回。在我们需要将结果放到一个数组中的时候直接使用<code>map</code>就会更加的方便。</p>
</blockquote>
<blockquote>
<p>在<code>map()</code>中<code>return</code>无论如何都会返回一个数组，可以通过<code>return</code>来对原数组进行操作返回一个新数组</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;     <span class="comment">//[[true, true, true, true, true, true, true, true, true]]</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item*<span class="number">2</span>;     <span class="comment">//[2, 4, 6, 8, 10, 12, 14, 16, 18]</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<h2 id="some"><a href="#some" class="headerlink" title="some()"></a><code>some()</code></h2><p><code>some()</code> 方法用于检测数组中的元素是否满足指定条件（函数提供）。</p>
<p><code>some()</code> 方法会依次执行数组的每个元素：</p>
<p>如果有一个元素满足条件，则表达式返回<code>true</code> , 剩余的元素不会再执行检测。<br>如果没有满足条件的元素，则返回<code>false</code>。<br>注意： <code>some()</code> 不会对空数组进行检测。<br>注意： <code>some()</code> 不会改变原始数组。</p>
<p>也就是说<code>some</code>并不一定会遍历完数组中全部的元素，当遍历到由符合条件的元素时就会返回<code>true</code>并终止，否则返回<code>false</code>，所以也就可以通过利用此特性来对数组中特定一部分的元素进行操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.some(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 通过some可以对数组中符合要求的之前的元素进行操作</span></span><br><span class="line">            <span class="built_in">console</span>.log(item);</span><br><span class="line">            <span class="keyword">return</span> item &gt; <span class="number">5</span>;  <span class="comment">//可以通过return来设置返回值的条件</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取缓存是否收藏</span></span><br><span class="line"><span class="comment">// || 意思为强转为 数组格式</span></span><br><span class="line"><span class="keyword">let</span> collect = wx.getStorageSync(<span class="string">&quot;collect&quot;</span>)||[];</span><br><span class="line"><span class="comment">// 使用 some 遍历数组 判断 是否有id的值相等，只要有一个相等的 ， isCollect 都为true</span></span><br><span class="line"><span class="keyword">let</span> isCollect = collect.some(<span class="function"><span class="params">v</span>=&gt;</span>v.id === <span class="built_in">this</span>.data.courseDetails.id);</span><br></pre></td></tr></table></figure>
<p><strong>还有一个相对的方法叫做 <code>every()</code> ,条件时数组中所有的元素都满足条件。</strong></p>
<h2 id="find"><a href="#find" class="headerlink" title="``find()"></a>``find()</h2><p><code>find()</code> 方法返回通过测试（函数内判断）的数组的第一个元素的值。</p>
<p><code>find()</code> 方法为数组中的每个元素都调用一次函数执行：</p>
<ul>
<li>当数组中的元素在测试条件时返回 <code>true</code> 时, <code>find()</code> 返回符合条件的元素，之后的值不会再调用执行函数。</li>
<li>如果没有符合条件的元素返回 <code>undefined</code>  注意: <code>find()</code> 对于空数组，函数是不会执行的。</li>
</ul>
<p>注意: <code>find()</code> 并没有改变数组的原始值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过find也可以对数组中符合要求的之前的元素进行操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">    <span class="keyword">return</span> item&gt;<span class="number">5</span>;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h2 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a><code>findIndex()</code></h2><p><code>findIndex()</code> 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。</p>
<p><code>findIndex()</code> 方法为数组中的每个元素都调用一次函数执行：</p>
<ul>
<li><p>当数组中的元素在测试条件时返回 <code>true</code> 时, <code>findIndex()</code> 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。</p>
</li>
<li><p>如果没有符合条件的元素返回<code> -1</code></p>
<p>  注意: <code>findIndex()</code> 对于空数组，函数是不会执行的。</p>
</li>
</ul>
<p>注意: <code>findIndex()</code> 并没有改变数组的原始值。</p>
<blockquote>
<p>与<code>find</code>方法类似，区别只在于这个方法返回的时元素在数组中的索引。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">    <span class="keyword">return</span> item&gt;<span class="number">5</span>;          </span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// || 意思为强转为 数组格式</span></span><br><span class="line"><span class="keyword">let</span> collect = wx.getStorageSync(<span class="string">&quot;collect&quot;</span>)||[];</span><br><span class="line"><span class="comment">// 使用findIndex遍历, 返回 数组中和 目标id 相等的 索引</span></span><br><span class="line"><span class="keyword">let</span> index = collect.findIndex(<span class="function"><span class="params">v</span>=&gt;</span>v.id === <span class="built_in">this</span>.data.courseDetails.id) ;</span><br></pre></td></tr></table></figure>

<h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a><code>filter()</code></h2><p><code>filter()</code> 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p>
<p>注意： <code>filter()</code> 不会对空数组进行检测。</p>
<p>注意： <code>filter()</code> 不会改变原始数组。</p>
<blockquote>
<p>这个方法与<code>map</code>方法类似，<code>map</code>方法没有返回的条件，而这个方法可以直接通过<code>return</code>来设置过滤条件。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt;<span class="number">2</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a><code>includes()</code></h2><p>这个方法是<code>es6</code>中新增的一个方法，可以用来判断一个数组或者是字符串中是否包含某一元素，如果是返回 <code>true</code>，否则<code>false</code>。</p>
<p>语法:</p>
<ul>
<li><code>arr.includes(searchElement)</code></li>
<li><code>arr.includes(searchElement, fromIndex)</code></li>
</ul>
<p>参数:</p>
<ul>
<li><code>searchElement</code> 必须。需要查找的元素值。</li>
<li><code>fromIndex</code> 可选。从该索引处开始查找 <code>searchElement</code>。如果为负值，则按升序从 <code>array.length + fromIndex </code>的索引开始搜索。默认为<code> 0</code>。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">5</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter notebook使用</title>
    <url>/blog/posts/53fbbba3/</url>
    <content><![CDATA[<p><code>Jupyter</code>不乏为一个很好的编译工具，搭配上<code>Anoconda</code>简直是无敌了</p>
<h2 id="Jupyter常用快捷键："><a href="#Jupyter常用快捷键：" class="headerlink" title="Jupyter常用快捷键："></a><code>Jupyter</code>常用快捷键：</h2><h3 id="命令模式（按Esc键）："><a href="#命令模式（按Esc键）：" class="headerlink" title="命令模式（按Esc键）："></a>命令模式（按<code>Esc</code>键）：</h3><ol>
<li>Enter：转入编辑模式</li>
<li>Shift-Enter：运行本单元，选中下个单元</li>
<li>Ctrl-Enter：运行本单元</li>
<li>Alt-Enter：运行本单元，在其下插入新单元</li>
<li>Y：单元转入代码状态</li>
<li>M：单元转入markdown状态</li>
<li>R：单元转入raw状态</li>
<li>1：设定 1 级标题</li>
<li>2：设定 2 级标题</li>
<li>3：设定 3 级标题</li>
<li>4：设定 4 级标题</li>
<li>5：设定 5 级标题</li>
<li>6：设定 6 级标题</li>
<li>Up：选中上方单元</li>
<li>K：选中上方单元</li>
<li>Down：选中下方单元</li>
<li>J：选中下方单元</li>
<li>Shift-K：扩大选中上方单元</li>
<li>Shift-J：扩大选中下方单元</li>
<li>A：在上方插入新单元</li>
<li>B：在下方插入新单元</li>
<li>X：剪切选中的单元</li>
<li>C：复制选中的单元</li>
<li>Shift-V：粘贴到上方单元</li>
<li>V：粘贴到下方单元</li>
<li>Z：恢复删除的最后一个单元</li>
<li>D,D：删除选中的单元</li>
<li>Shift-M：合并选中的单元</li>
<li>Ctrl-S：文件存盘</li>
<li>S：文件存盘</li>
<li>L：转换行号</li>
<li>O：转换输出</li>
<li>Shift-O：转换输出滚动</li>
<li>Esc：关闭页面</li>
<li>Q：关闭页面</li>
<li>H：显示快捷键帮助</li>
<li>I,I：中断Notebook内核</li>
<li>0,0：重启Notebook内核</li>
<li>Shift：忽略</li>
<li>Shift-Space：向上滚动</li>
<li>Space：向下滚动</li>
</ol>
<h3 id="编辑模式："><a href="#编辑模式：" class="headerlink" title="编辑模式："></a>编辑模式：</h3><ol>
<li>Tab : 代码补全或缩进</li>
<li>Shift-Tab : 提示</li>
<li>Ctrl-] : 缩进</li>
<li>Ctrl-[ : 解除缩进</li>
<li>Ctrl-A : 全选</li>
<li>Ctrl-Z : 复原</li>
<li>Ctrl-Shift-Z : 再做</li>
<li>Ctrl-Y : 再做</li>
<li>Ctrl-Home : 跳到单元开头</li>
<li>Ctrl-Up : 跳到单元开头</li>
<li>Ctrl-End : 跳到单元末尾</li>
<li>Ctrl-Down : 跳到单元末尾</li>
<li>Ctrl-Left : 跳到左边一个字首</li>
<li>Ctrl-Right : 跳到右边一个字首</li>
<li>Ctrl-Backspace : 删除前面一个字</li>
<li>Ctrl-Delete : 删除后面一个字</li>
<li>Esc : 进入命令模式</li>
<li>Ctrl-M : 进入命令模式</li>
<li>Shift-Enter : 运行本单元，选中下一单元</li>
<li>Ctrl-Enter : 运行本单元</li>
<li>Alt-Enter : 运行本单元，在下面插入一单元</li>
<li>Ctrl-Shift– : 分割单元</li>
<li>Ctrl-Shift-Subtract : 分割单元</li>
<li>Ctrl-S : 文件存盘</li>
<li>Shift : 忽略</li>
<li>Up : 光标上移或转入上一单元</li>
<li>Down :光标下移或转入下一单元</li>
</ol>
<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p><code>jupyter notebook</code>每一个<code>cell</code>运行完后都会把这个<code>cell</code>中的变量保存到内存中，如果在一个<code>cell</code>中修改了之前的变量，再此运行这个<code>cell</code>的时候可能会导致一些问题产生。比如以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个cell中的代码</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个cell中的代码</span></span><br><span class="line">c = a/b</span><br><span class="line">b = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>因为第二个<code>cell</code>修改了<code>b</code>变量，此时在整个环境中<code>b</code>都是等于0的，所以以后再运行这个<code>cell</code>的时候，<code>a/b</code>这个就会出问题了。这时候可以使用<code>Kernel-&gt;Rstart&amp;Run All</code>来重新运行整个项目。</p>
<h2 id="Mac乱码解决"><a href="#Mac乱码解决" class="headerlink" title="Mac乱码解决"></a><code>Mac</code>乱码解决</h2><h3 id="步骤一-查看自己的字体中有哪种中文字体"><a href="#步骤一-查看自己的字体中有哪种中文字体" class="headerlink" title="步骤一 查看自己的字体中有哪种中文字体"></a>步骤一 查看自己的字体中有哪种中文字体</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">a=<span class="built_in">sorted</span>([f.name <span class="keyword">for</span> f <span class="keyword">in</span> matplotlib.font_manager.fontManager.ttflist])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">	<span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/53fbbba3/2022-07-17-22-46-35.png" class="">

<p>找到支持中文的字体</p>
<img data-src="/blog/posts/53fbbba3/2022-07-17-22-46-44.png" class="">

<h3 id="选择相应的字体"><a href="#选择相应的字体" class="headerlink" title="选择相应的字体"></a>选择相应的字体</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=<span class="string">&#x27;Heiti TC&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 负号正常显示</span></span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/53fbbba3/2022-07-17-22-46-51.png" class="">
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Jupyter</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode172_阶乘后的0</title>
    <url>/blog/posts/5d0c3fcc/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmFjdG9yaWFsLXRyYWlsaW5nLXplcm9lcy8=">题目链接</span></p>
<span id="more"></span>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定一个整数 n ，返回 n! 结果中尾随零的数量。</span><br><span class="line"></span><br><span class="line">提示 n! = n * (n - <span class="number">1</span>) * (n - <span class="number">2</span>) * ... * <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="number">3</span>! = <span class="number">6</span> ，不含尾随 <span class="number">0</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="number">5</span>! = <span class="number">120</span> ，有一个尾随 <span class="number">0</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= n &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode07_整数反转</title>
    <url>/blog/posts/4491edd3/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1pbnRlZ2VyLw==">题目链接</span></p>
<span id="more"></span>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">给你一个 <span class="number">32</span> 位的有符号整数 <span class="keyword">x</span> ，返回将 <span class="keyword">x</span> 中的数字部分反转后的结果。</span><br><span class="line"></span><br><span class="line">如果反转后整数超过 <span class="number">32</span> 位的有符号整数的范围 [−<span class="number">231</span><span class="punctuation">,</span>  <span class="number">231</span> − <span class="number">1</span>] ，就返回 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">假设环境不允许存储 <span class="number">64</span> 位整数（有符号或无符号）。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">x</span> <span class="operator">=</span> <span class="number">123</span></span><br><span class="line">输出：<span class="number">321</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">x</span> <span class="operator">=</span> <span class="number">-123</span></span><br><span class="line">输出：<span class="number">-321</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">x</span> <span class="operator">=</span> <span class="number">120</span></span><br><span class="line">输出：<span class="number">21</span></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="keyword">x</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">-231</span> &lt;<span class="operator">=</span> <span class="keyword">x</span> &lt;<span class="operator">=</span> <span class="number">231</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/blog/posts/d0edc1ed/</url>
    <content><![CDATA[<h2 id="Linux查看空间大小的命令"><a href="#Linux查看空间大小的命令" class="headerlink" title="Linux查看空间大小的命令"></a><code>Linux</code>查看空间大小的命令</h2><span id="more"></span>

<h3 id="df"><a href="#df" class="headerlink" title="df"></a><code>df</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">第一列：文件系统</span><br><span class="line">第二列：容量</span><br><span class="line">第三列：已用容量</span><br><span class="line">第四列：可用容量</span><br><span class="line">第五列：已用容量%</span><br><span class="line">第六列：挂载点</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/d0edc1ed/2022-06-29-22-09-03.png" class="">

<p>参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a: 显示所有文件系统信息，包括系统特有的 /proc、/sysfs 等文件系统；</span><br><span class="line">-m: 以 MB 为单位显示容量；</span><br><span class="line">-k: 以 KB 为单位显示容量，默认以 KB 为单位；</span><br><span class="line">-h: 使用人们习惯的 KB、MB 或 GB 等单位自行显示容量；</span><br><span class="line">-T: 显示该分区的文件系统名称；</span><br><span class="line">-i: 不用硬盘容量显示，而是以含有 inode 的数量来显示。</span><br><span class="line">--block-size=&lt;区块大小&gt;：以指定的区块大小来显示区块数目；</span><br><span class="line">-l或--<span class="built_in">local</span>：仅显示本地端的文件系统；</span><br><span class="line">--no-sync：在取得磁盘使用信息前，不要执行sync指令，此为预设值；</span><br><span class="line">-P或--portability：使用POSIX的输出格式；</span><br><span class="line">--sync：在取得磁盘使用信息前，先执行sync指令；</span><br><span class="line">-t&lt;文件系统类型&gt;或--<span class="built_in">type</span>=&lt;文件系统类型&gt;：仅显示指定文件系统类型的磁盘信息；</span><br><span class="line">-x&lt;文件系统类型&gt;或--exclude-type=&lt;文件系统类型&gt;：不要显示指定文件系统类型的磁盘信息；</span><br><span class="line">--<span class="built_in">help</span>：显示帮助；</span><br><span class="line">--version：显示版本信息。</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/d0edc1ed/2022-06-29-22-17-18.png" class="">

<h3 id="du"><a href="#du" class="headerlink" title="du"></a><code>du</code></h3><img data-src="/blog/posts/d0edc1ed/2022-06-29-22-20-51.png" class="">

<blockquote>
<p>如果只想查看当前目录占用空间的大小，不查看子目录或者子文件占用空间大小，那么<code>s</code>选项无疑很有帮助，如下：</p>
</blockquote>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">du -sh</span></span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/d0edc1ed/2022-06-29-22-23-40.png" class="">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -h --max-depth=0</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/d0edc1ed/2022-06-29-22-29-35.png" class="">

<h2 id="Mount文件挂载"><a href="#Mount文件挂载" class="headerlink" title="Mount文件挂载"></a><code>Mount</code>文件挂载</h2><blockquote>
<p>文件系统挂载</p>
</blockquote>
<p>硬件设备必须挂载之后才能使用，只不过，有些硬件设备（比如硬盘分区）在每次系统启动时会自动挂载，而有些（比如 U 盘、光盘）则需要手动进行挂载。</p>
<p>挂载指的是将硬件设备的文件系统和 <code>Linux</code> 系统中的文件系统，通过指定目录（作为挂载点）进行关联。而要将文件系统挂载到 <code>Linux</code> 系统上，就需要使用 <code>mount</code> 挂载命令。</p>
<blockquote>
<p><code>mount</code> 命令的常用格式有以下几种：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount [-l]</span><br><span class="line"><span class="comment"># 单纯使用 `mount` 命令，会显示出系统中已挂载的设备信息，使用 `-l` 选项，会额外显示出卷标名称（读者可自行运行，查看输出结果）；</span></span><br><span class="line"></span><br><span class="line">mount -a</span><br><span class="line"><span class="comment"># -a 选项的含义是自动检查 /etc/fstab 文件中有无疏漏被挂载的设备文件，如果有，则进行自动挂载操作。这里简单介绍一下 /etc/fstab 文件，此文件是自动挂载文件，系统开机时会主动读取 /etc/fstab 这个文件中的内容，根据该文件的配置，系统会自动挂载指定设备。</span></span><br><span class="line"></span><br><span class="line">mount [-t 系统类型] [-L 卷标名] [-o 特殊选项] [-n] 设备文件名 挂载点</span><br><span class="line"></span><br><span class="line"><span class="comment"># 各选项的含义分别是：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -t 系统类型：指定欲挂载的文件系统类型。Linux 常见的支持类型有 EXT2、EXT3、EXT4、iso9660（光盘格式）、vfat、reiserfs 等。如果不指定具体类型，挂载时 Linux 会自动检测。</span></span><br><span class="line"><span class="comment"># -L 卷标名：除了使用设备文件名（例如 /dev/hdc6）之外，还可以利用文件系统的卷标名称进行挂载。</span></span><br><span class="line"><span class="comment"># -n：在默认情况下，系统会将实际挂载的情况实时写入 /etc/mtab 文件中，但在某些场景下（例如单人维护模式），为了避免出现问题，会刻意不写入，此时就需要使用这个选项；</span></span><br><span class="line"><span class="comment"># -o 特殊选项：可以指定挂载的额外选项，比如读写权限、同步/异步等，如果不指定，则使用默认值（defaults）。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>mount 命令选项及功能</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rw/ro ：是否对挂载的文件系统拥有读写权限，rw 为默认值，表示拥有读写权限；ro 表示只读权限。</span><br><span class="line"></span><br><span class="line">async/sync ： 此文件系统是否使用同步写入（sync）或异步（async）的内存机制，默认为异步 async。</span><br><span class="line"></span><br><span class="line">dev/nodev ：是否允许从该文件系统的 block 文件中提取数据，为了保证数据安装，默认是 nodev。</span><br><span class="line"></span><br><span class="line">auto/noauto ：是否允许此文件系统被以 mount -a 的方式进行自动挂载，默认是 auto。</span><br><span class="line"></span><br><span class="line">suid/nosuid ：设定文件系统是否拥有 SetUID 和 SetGID 权限，默认是拥有。</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span>/noexec ：设定在文件系统中是否允许执行可执行文件，默认是允许。</span><br><span class="line"></span><br><span class="line">user/nouser ：设定此文件系统是否允许让普通用户使用 mount 执行实现挂载，默认是不允许（nouser），仅有 root 可以。</span><br><span class="line"></span><br><span class="line">defaults ：定义默认值，相当于 rw、suid、dev、<span class="built_in">exec</span>、auto、nouser、async 这 7 个选项。</span><br><span class="line"></span><br><span class="line">remount重新挂载已挂载的文件系统，一般用于指定修改特殊权限。</span><br></pre></td></tr></table></figure>


<h2 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/os-release</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/d0edc1ed/2022-06-30-10-12-30.png" class="">

<h3 id="查看内核版本"><a href="#查看内核版本" class="headerlink" title="查看内核版本"></a>查看内核版本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/version</span><br><span class="line">uname -a</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/d0edc1ed/2022-08-06-10-40-55.png" class="">

<h3 id="查看linux版本信息"><a href="#查看linux版本信息" class="headerlink" title="查看linux版本信息"></a>查看<code>linux</code>版本信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/d0edc1ed/2022-08-06-10-42-19.png" class="">

<h3 id="查看linux是64为还是32位"><a href="#查看linux是64为还是32位" class="headerlink" title="查看linux是64为还是32位"></a>查看<code>linux</code>是<code>64</code>为还是<code>32</code>位</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getconf LONG_BIT</span><br><span class="line">file /bin/ls</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/d0edc1ed/2022-08-06-10-43-41.png" class="">

<h3 id="直接查看系统的架构"><a href="#直接查看系统的架构" class="headerlink" title="直接查看系统的架构"></a>直接查看系统的架构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dpkg --print-architecture</span><br><span class="line">arch</span><br><span class="line">file /lib/systemd/systemd</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/d0edc1ed/2022-08-06-10-45-09.png" class="">


<h2 id="查看开放端口"><a href="#查看开放端口" class="headerlink" title="查看开放端口"></a>查看开放端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -lntu </span><br><span class="line">或者  ss -lntu</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看端口号</span><br><span class="line">netstat -ntlp //查看当前所有tcp端口·</span><br><span class="line">netstat -ntulp |grep 6666 //查看所有1935端口使用情况·</span><br><span class="line">CentOS默认开放的本地端口范围</span><br><span class="line">系统本地开放端口的范围：（默认30000多到60000多）</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/d0edc1ed/2022-06-30-10-13-53.png" class="">

<h2 id="检查端口是否打开"><a href="#检查端口是否打开" class="headerlink" title="检查端口是否打开"></a>检查端口是否打开</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -na | grep :9999</span><br><span class="line">ss -na | grep :9999</span><br></pre></td></tr></table></figure>
<p>输出必须保持空白，从而验证它当前未被使用，以便我们可以将端口规则手动添加到系统<code>iptables</code>防火墙。</p>
<h2 id="centos查看防火墙状态的方法"><a href="#centos查看防火墙状态的方法" class="headerlink" title="centos查看防火墙状态的方法"></a><code>centos</code>查看防火墙状态的方法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service iptables status <span class="comment">#查看iptables防火墙状态</span></span><br><span class="line">或</span><br><span class="line">systemctl status firewalld <span class="comment">#查看firewall防火墙服务状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#iptables防火墙</span></span><br><span class="line">service iptables start <span class="comment">#启动防火墙</span></span><br><span class="line">service iptables stop <span class="comment">#停止防火墙</span></span><br><span class="line">service iptables restart <span class="comment">#重启防火墙</span></span><br><span class="line"><span class="comment">#firewall防火墙</span></span><br><span class="line">service firewalld start <span class="comment"># 开启</span></span><br><span class="line">service firewalld stop <span class="comment"># 关闭 </span></span><br><span class="line">service firewalld restart <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure>

<h2 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要root权限</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"><span class="comment"># 命令含义：</span></span><br><span class="line">--zone <span class="comment">#作用域</span></span><br><span class="line">--add-port=6666/tcp <span class="comment">#添加端口，格式为：端口/通讯协议</span></span><br><span class="line">--permanent <span class="comment">#永久生效，没有此参数重启后失效</span></span><br></pre></td></tr></table></figure>

<h2 id="防火墙firewall"><a href="#防火墙firewall" class="headerlink" title="防火墙firewall"></a>防火墙<code>firewall</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启firewall</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否生效</span></span><br><span class="line">firewall-cmd --zone=public —query-port=8080/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止firewall</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止firewall开机启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure>

<h2 id="检测远程端口是否打开"><a href="#检测远程端口是否打开" class="headerlink" title="检测远程端口是否打开"></a>检测远程端口是否打开</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet 118.10.6.128 88</span><br><span class="line"><span class="comment"># 测试远程主机端口是否打开</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap ip -p port <span class="comment">#测试端口</span></span><br><span class="line">nmap ip </span><br><span class="line"><span class="comment"># 根据显示close/open确定端口是否打开</span></span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/d0edc1ed/2022-07-01-09-13-27.png" class="">

<h2 id="Linux生成-UUID"><a href="#Linux生成-UUID" class="headerlink" title="Linux生成 UUID"></a><code>Linux</code>生成 <code>UUID</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/kernel/random/uuid</span><br></pre></td></tr></table></figure>

<h2 id="查看正在运行的java线程"><a href="#查看正在运行的java线程" class="headerlink" title="查看正在运行的java线程"></a>查看正在运行的<code>java</code>线程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jps -l</span><br><span class="line"></span><br><span class="line"><span class="comment">## 杀死线程</span></span><br><span class="line"><span class="built_in">kill</span> -9 &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="linux-shell-缺少-ps-命令"><a href="#linux-shell-缺少-ps-命令" class="headerlink" title="linux shell 缺少 ps 命令"></a><code>linux shell</code> 缺少 <code>ps</code> 命令</h2><ol>
<li>缺少 <code>ps</code> 命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install -y procps</span><br><span class="line">yum install -y procps</span><br></pre></td></tr></table></figure></li>
<li>缺少 <code>pstree</code> 命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install -y psmisc</span><br><span class="line">yum install -y psmisc</span><br></pre></td></tr></table></figure></li>
<li>出现找不到包的问题：<img data-src="/blog/posts/d0edc1ed/2022-08-08-11-51-34.png" class="">
更新一下就可以了：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis之分页查询：MyBatis PageHelper</title>
    <url>/blog/posts/31dc52e1/</url>
    <content><![CDATA[<h1 id="MyBatis之分页查询：MyBatis-PageHelper"><a href="#MyBatis之分页查询：MyBatis-PageHelper" class="headerlink" title="MyBatis之分页查询：MyBatis PageHelper"></a><code>MyBatis</code>之分页查询：<code>MyBatis PageHelper</code></h1><h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MyBatis 分页插件: MyBatis PageHelper--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-添加配置"><a href="#2-添加配置" class="headerlink" title="2. 添加配置"></a>2. 添加配置</h2><span id="more"></span>

<p>在<code>application.properties</code>配置文件中添加<code>MyBatis PageHelper</code>的配置项</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PageHelper 分页插件配置</span></span><br><span class="line"><span class="meta">pagehelper.helperDialect</span>=<span class="string">mysql</span></span><br><span class="line"><span class="meta">pagehelper.reasonable</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">pagehelper.supportMethodsArguments</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">pagehelper.params</span>=<span class="string">count=countSql</span></span><br></pre></td></tr></table></figure>

<h2 id="3-分页查询"><a href="#3-分页查询" class="headerlink" title="3. 分页查询"></a>3. 分页查询</h2><p>通过 <code>MyBatis PageHelper</code> 进行分页查询实际上非常简单，只需在<code>service(或mapper)</code>方法执行查询前，调用一次 <code>PageHelper.startPage(pageNum,pageSize)</code> <code>来设置分页查询参数即可，其中pageNum</code> 为记录页数，<code>pageSize</code> 为单页记录数量。此时<code>service(或mapper)</code>方法的查询结果就是分页后的结果了。如果期望获得相关的分页信息，还可以将查询结果封装到<code>PageInfo</code>对象中，以获得总页数、总记录数、当前页数等相关分页信息</p>
<p>现在通过一个实际示例，来具体演示操作，这里我们提供了一个分页查询的<code>Controller</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageNum 记录页数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSize 单页记录数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/findPage&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findPage</span><span class="params">(<span class="meta">@RequestParam</span> <span class="keyword">int</span> pageNum, <span class="meta">@RequestParam</span> <span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置分页查询参数</span></span><br><span class="line">    PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">    List&lt;Student&gt; studentList = studentService.findList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Student student : studentList) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;element : &quot;</span> + student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装分页查询结果到 PageInfo 对象中以获取相关分页信息</span></span><br><span class="line">    PageInfo pageInfo = <span class="keyword">new</span> PageInfo( studentList );</span><br><span class="line">    System.out.println(<span class="string">&quot;总页数: &quot;</span> + pageInfo.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;总记录数: &quot;</span> + pageInfo.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前页数: &quot;</span> + pageInfo.getPageNum());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前页面记录数量: &quot;</span> + pageInfo.getSize());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pageInfo.getList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>service</code>方法中所调用的查询<code>SQL</code>如下所示，可以看到，<code>SQL</code>中无需使用<code>limit</code>语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;studentResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.aaron.springbootdemo.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findList&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentResultMap&quot;</span>&gt;</span>    </span><br><span class="line">    SELECT * FROM user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>NOTE:</code> </p>
</blockquote>
<p><code>PageHelper.startPage(pageNum,pageSize)</code> 只对其后的第一次<code>SQL</code>查询进行分页。故若需进行分页查询，必须每次在<code>service（或mapper）</code>方法执行<code>SQL</code>查询前调用<code>PageHelper.startPage(pageNum,pageSize) </code>方法</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Mybatis</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Mybatis</tag>
        <tag>分页查询</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning essays</title>
    <url>/blog/posts/1b930e38/</url>
    <content><![CDATA[<p>最近在看<code>数据挖掘</code>以及<code>ML</code>的课程</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmh3bC5jb29sL3B5dGhvbi8lRTYlOTUlQjAlRTYlOEQlQUUlRTYlOEMlOTYlRTYlOEUlOTgv">数据挖掘资料</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubnVtcHkub3JnLmNuL3JlZmVyZW5jZS8=">numpy reference</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zY2lraXQtbGVhcm4ub3JnL3N0YWJsZS9tb2R1bGVzL2NsYXNzZXMuaHRtbA==">Sklearn Reference</span></p>
<p><span class="exturl" data-url="aHR0cDovL3dlYmdyYXBodml6LmNvbS8=">WebGraph</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cua2FnZ2xlLmNvbS9kYXRhc2V0cy8=">Kaggle</span></p>
<h2 id="python中的head方法"><a href="#python中的head方法" class="headerlink" title="python中的head方法"></a><code>python</code>中的<code>head</code>方法</h2><p><code>head()</code>根据位置返回对象的前<code>n</code>行。 如果你的对象中包含正确的数据类型, 则对于快速测试很有用。 此方法用于返回数据帧或序列的前<code>n</code>行(默认值为<code>5</code>)。 <code>n：</code>它是指返回行数的整数值。</p>
<h2 id="pandas交叉表"><a href="#pandas交叉表" class="headerlink" title="pandas交叉表"></a><code>pandas</code>交叉表</h2><p>交叉表是由列和行组成的双向表。 它也被称为数据透视表或多维表。 其最大的优势是能够构造、汇总及显示大量数据。 交叉表还可用于确定行变量与列变量之间是否存在关系。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnRpYmNvLmNvbS9wdWIvc3BvdGZpcmVfd2ViX3BsYXllci82LjAuMC1ub3ZlbWJlci0yMDEzL3poLUNOL1dlYkhlbHAvR1VJRC0xRjY3QjJGMy0wNTZCLTQzMjQtQjJDQy0xNEQ3M0QzNzg2OTMuaHRtbA==">参考链接</span></p>
<h2 id="网格搜索（GridSearchCV）"><a href="#网格搜索（GridSearchCV）" class="headerlink" title="网格搜索（GridSearchCV）"></a>网格搜索（<code>GridSearchCV</code>）</h2><p><code>GridSearch和CV</code>，即网格搜索和交叉验证</p>
<p>网格搜索算法是一种通过遍历给定的参数组合来优化模型表现的方法</p>
<p>为何使用：超参数选择不恰当，就会出现欠拟合或者过拟合的问题</p>
<p>内容： 网格搜索，搜索的是参数，即在指定的参数范围内，按步长依次调整参数，利用调整的参数训练学习器，从所有的参数中找到在验证集上精度最高的参数，这其实是一个训练和比较的过程。</p>
<p><code>Grid Search</code>：一种调参手段；穷举搜索：在所有候选的参数选择中，通过循环遍历，尝试每一种可能性，表现最好的参数就是最终的结果</p>
<p>用法：网格搜索适用于三四个（或者更少）的超参数（当超参数的数量增长时，网格搜索的计算复杂度会呈现指数增长，这时候则使用随机搜索），用户列出一个较小的超参数值域，这些超参数至于的笛卡尔积（排列组合）为一组组超参数。网格搜索算法使用每组超参数训练模型并挑选验证集误差最小的超参数组合</p>
<p>缺点：遍历所有组合，比较耗时</p>
<h2 id="打印表头"><a href="#打印表头" class="headerlink" title="打印表头"></a>打印表头</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">titanic = pd.read_csv(<span class="string">&quot;./titanic/train.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(titanic.columns)</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/1b930e38/2022-07-29-13-01-44.png" class="">


<h2 id="pandas的inplace参数"><a href="#pandas的inplace参数" class="headerlink" title="pandas的inplace参数"></a><code>pandas</code>的<code>inplace</code>参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 关于`python`中的随机种子——`random_state`</span><br><span class="line"></span><br><span class="line">`random_state`是一个随机种子，是在任意带有随机性的类或函数里作为参数来控制随机模式。当`random_state`取某一个值时，也就确定了一种规则。</span><br><span class="line"></span><br><span class="line">`random_state`可以用于很多函数，一般用于以下三个地方：1、训练集测试集的划分 2、构建决策树 3、构建随机森林</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 查看数据类型</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"># type(a)   DataFrame数据类型</span><br><span class="line"></span><br><span class="line">df.dtypes  #查看各列数据类型</span><br><span class="line">df[A].dtypes  #查看A列数据类型</span><br><span class="line"></span><br><span class="line">df[A].astypes(int)#将A列数据类型转换为int</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>numpy</tag>
        <tag>pandas</tag>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title>MybatisPlus实现分页查询</title>
    <url>/blog/posts/2edf7887/</url>
    <content><![CDATA[<h1 id="MybatisPlus实现分页查询"><a href="#MybatisPlus实现分页查询" class="headerlink" title="MybatisPlus实现分页查询"></a><code>MybatisPlus</code>实现分页查询</h1><h2 id="分页区别"><a href="#分页区别" class="headerlink" title="分页区别"></a>分页区别</h2><p>分页查询每个人程序猿几乎都使用过，但是有部分同学不懂什么是物理分页和逻辑分页。</p>
<p>物理分页：相当于执行了<code>limit</code>分页语句，返回部分数据。物理分页只返回部分数据占用内存小，能够获取数据库最新的状态，实施性比较强，一般适用于数据量比较大，数据更新比较频繁的场景。</p>
<p>逻辑分页：一次性把全部的数据取出来，通过程序进行筛选数据。如果数据量大的情况下会消耗大量的内存，由于逻辑分页只需要读取数据库一次，不能获取数据库最新状态，实施性比较差，适用于数据量小，数据稳定的场合。</p>
<p>那么MP中的物理分页怎么实现呢？ 往下看往下看</p>
<span id="more"></span>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>需要新建一个<code>JavaConfig</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页插件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体分页实现"><a href="#具体分页实现" class="headerlink" title="具体分页实现"></a>具体分页实现</h2><p><code>MP</code>的<code>Wrapper</code>提供了两种分页查询的方式，源码如下：</p>
<img data-src="/blog/posts/2edf7887/2022-02-13-22-35-05.png" class="">

<p>可见两个分页方法参数都是一致的，只是返回参数略有不同，具体选择根据实际业务为准。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分页查询</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectByPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper();</span><br><span class="line">    wrapper.like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;雨&quot;</span>).lt(<span class="string">&quot;age&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IPage&lt;User&gt; userIPage = userMapper.selectPage(page, wrapper);</span></span><br><span class="line"></span><br><span class="line">    IPage&lt;Map&lt;String, Object&gt;&gt; mapIPage = userMapper.selectMapsPage(page, wrapper);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;总页数&quot;</span>+mapIPage.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;总记录数&quot;</span>+mapIPage.getTotal());</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; records = mapIPage.getRecords();</span><br><span class="line">    records.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上分页查询执行<code>sql</code>如下，先是查询了一次总记录数，然后在查询的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DEBUG<span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>  Preparing: <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> ? <span class="keyword">AND</span> age <span class="operator">&lt;</span> ? </span><br><span class="line">DEBUG<span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> Parameters: <span class="operator">%</span>雨<span class="operator">%</span>(String), <span class="number">40</span>(<span class="type">Integer</span>)</span><br><span class="line">TRACE<span class="operator">&lt;=</span><span class="operator">=</span>    Columns: <span class="built_in">COUNT</span>(<span class="number">1</span>)</span><br><span class="line">TRACE<span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: <span class="number">2</span></span><br><span class="line">DEBUG<span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>  Preparing: <span class="keyword">SELECT</span> id,name,age,email,manager_id,create_time <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> ? <span class="keyword">AND</span> age <span class="operator">&lt;</span> ? LIMIT ?,? </span><br><span class="line">DEBUG<span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> Parameters: <span class="operator">%</span>雨<span class="operator">%</span>(String), <span class="number">40</span>(<span class="type">Integer</span>), <span class="number">0</span>(Long), <span class="number">2</span>(Long)</span><br><span class="line">TRACE<span class="operator">&lt;=</span><span class="operator">=</span>    Columns: id, name, age, email, manager_id, create_time</span><br><span class="line">TRACE<span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: <span class="number">2</span>, 张雨琪, <span class="number">31</span>, zjq<span class="variable">@baomidou</span>.com, <span class="number">1088248166370832385</span>, <span class="number">2021</span><span class="number">-01</span><span class="number">-14</span> <span class="number">09</span>:<span class="number">15</span>:<span class="number">15</span></span><br><span class="line">TRACE<span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: <span class="number">3</span>, 刘红雨, <span class="number">31</span>, lhm<span class="variable">@baomidou</span>.com, <span class="number">1088248166370832385</span>, <span class="number">2021</span><span class="number">-01</span><span class="number">-14</span> <span class="number">09</span>:<span class="number">48</span>:<span class="number">16</span></span><br><span class="line">DEBUG<span class="operator">&lt;=</span><span class="operator">=</span>      Total: <span class="number">2</span></span><br><span class="line">总页数<span class="number">1</span></span><br><span class="line">总记录数<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>现在我们有需求只要查询数据即可， 不关心总记录数等，如果使用默认的方式就消耗不必要的性能。那么解决办法也是很简单的，只需要在创建<code>page</code>对象时传入第三个参数为<code>false</code>即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Page&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Java</category>
        <category>Mybatis</category>
        <category>SpringBoot</category>
        <category>分页查询</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Mybatis</tag>
        <tag>分页查询</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis使用Sql进行模糊查询</title>
    <url>/blog/posts/105c245f/</url>
    <content><![CDATA[<h1 id="Mybatis使用Sql进行模糊查询"><a href="#Mybatis使用Sql进行模糊查询" class="headerlink" title="Mybatis使用Sql进行模糊查询"></a><code>Mybatis</code>使用<code>Sql</code>进行模糊查询</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据名称模糊查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sc.domain.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span>&gt;</span></span><br><span class="line">    select * from user where username like #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>模糊查询的测试方法</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; users = userDao.findByName(<span class="string">&quot;%王%&quot;</span>);</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/105c245f/2022-02-13-22-29-15.png" class="">

<p>我们在配置文件中没有加入<code>%</code>来作为模糊查询的条件，所以在传入字符串实参时，就需要给定模糊查询的标<br>识%。配置文件中的<code>#&#123;username&#125;</code>也只是一个占位符，所以 <code>SQL</code> 语句显示为<code>“？”</code>。</p>
<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sc.domain.User&quot;</span>&gt;</span></span><br><span class="line"> select * from user where username like &#x27;%$&#123;value&#125;%&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在上面将原来的<code>#&#123;&#125;</code>占位符，改成了<code>&#123;value&#125;</code>。注意如果用模糊查询的这种写法，那么<code>$&#123;value&#125;</code>的写法就是固定的，不能写成其它名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行查询一个方法</span></span><br><span class="line">List&lt;User&gt; users = userDao.findByName(<span class="string">&quot;王&quot;</span>);</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/105c245f/2022-02-13-22-29-25.png" class="">

<p>可以发现，我们在程序代码中就不需要加入模糊查询的匹配符%了，这两种方式的实现效果是一样的，但执行<br>的语句是不一样的。</p>
<h2 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h2><p>说明：通过前两种写法，虽然可以解决模糊查询的问题，但是还是不好，因为通过<code>%</code>的方式会引发<code>sql</code>注入的问题，现在的期望是：既能够解决<code>sql</code>注入又能在配置文件中写<code>%</code>该如何实现呢，可以借助<code>mysql</code>的函数。</p>
<p>修改 <code>SQL</code> 语句的配置，配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sc.domain.User&quot;</span>&gt;</span></span><br><span class="line"> select * from user where username like concat(&#x27;%&#x27;,#&#123;username&#125;,&#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>*#&#123; &#125;</code>是预编译处理，<code>MyBatis</code>在处理<code>#&#123; &#125;</code>时，它会将<code>sql</code>中的<code>#&#123; &#125;</code>替换为<code>？</code>，然后调用<code>PreparedStatement</code>的<code>set</code>方法来赋值，传入字符串后，会在值两边加上单引号，使用占位符的方式提高效率，可以防止<code>sql</code>注入。<br><code>$&#123;&#125;:</code>表示拼接<code>sql</code>串，将接收到参数的内容不加任何修饰拼接在<code>sql</code>中，可能引发<code>sql</code>注入。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Mybatis</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Mybatis</tag>
        <tag>模糊查询</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis封装成Map结果</title>
    <url>/blog/posts/c112412d/</url>
    <content><![CDATA[<h1 id="Mybatis封装成Map结果"><a href="#Mybatis封装成Map结果" class="headerlink" title="Mybatis封装成Map结果"></a><code>Mybatis</code>封装成<code>Map</code>结果</h1><h2 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a><code>Dao</code>层</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapKey(&quot;cityCode&quot;)</span></span><br><span class="line"><span class="function">Map&lt;String,InvoiceSubjectRuleCity&gt; <span class="title">bulkSelectRuleCityByRuleIdList</span><span class="params">(<span class="meta">@Param(&quot;ruleIdList&quot;)</span> List&lt;Long&gt; ruleIdList)</span></span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;bulkSelectRuleCityByRuleIdList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span>/&gt;</span></span><br><span class="line">    from t_invoice_subject_rule_city</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">      rule_id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ruleIdList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;ruleId&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">           #&#123;ruleId&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>返回结果即为<code>Map</code>类型</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Mybatis</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis中#号和$号的区别</title>
    <url>/blog/posts/31d0fffb/</url>
    <content><![CDATA[<h1 id="Mybatis中-号和-号的区别"><a href="#Mybatis中-号和-号的区别" class="headerlink" title="Mybatis中#号和$号的区别"></a><code>Mybatis</code>中<code>#</code>号和<code>$</code>号的区别</h1><h2 id="默认会用引号将参数引起来"><a href="#默认会用引号将参数引起来" class="headerlink" title="#{} 默认会用引号将参数引起来"></a><code>#&#123;&#125;</code> 默认会用引号将参数引起来</h2><h2 id="单纯替代"><a href="#单纯替代" class="headerlink" title="${}单纯替代"></a><code>$&#123;&#125;</code>单纯替代</h2><p>示例：</p>
<span id="more"></span>

<p>之前的写法，<code>select * from product_tree_v pv where pv.product_code in(#&#123;product&#125;)</code></p>
<p>预编译出来的结果：<code>select * from product_tree_v pv where pv.product_code in ？</code>;</p>
<p><code>#&#123;&#125;</code>被当作一个占位符了，而参数前后也会被加上引号。</p>
<p>运行时的<code>sql</code>是：<code>select * from product_tree_v pv where pv.product_code in(&#39;‘p001&#39;,&#39;p002&#39;,&#39;p003&#39;&#39;)</code>;</p>
<p>所以无论如何都是查不到数据的。</p>
<p>换成<code>$&#123;&#125;</code>：<code>select * from product_tree_v pv where pv.product_code in($product&#125;)</code>;</p>
<p>预编译出来的结果 ：<code>select * from product_tree_v pv where pv.product_code in (‘p001&#39;,&#39;p002&#39;,&#39;p003&#39;)</code>;</p>
<p>这样就是纯粹的将参数传进去，没有做任何的转义操作。这才是我们真正想要的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>mybatis</code>作为<code>ORM</code>框架，从性能，系统维护性，实用性上来说，都是非常优秀的，</p>
<p>其所有的<code>sql</code>在执行前都会通过数据库驱动进行预编译，这样<code>DBMS</code>就可以不用编译直接接收参数运行，</p>
<p>而<code>#</code>和<code>$</code>号的区别在预编译后就能看出来了，<code>#&#123;&#125;</code>预编译完是占位符<code>?</code>，而<code>$&#123;&#125;</code>预编译完就是传进来的参数。</p>
<h2 id="的优点："><a href="#的优点：" class="headerlink" title="#{}的优点："></a><code>#&#123;&#125;</code>的优点：</h2><p>  使用<code>#&#123;&#125;</code>可以预防<code>sql</code>攻击，而<code>$&#123;&#125;</code>却不能</p>
<p>例如 <code>select * from $&#123;tablename&#125; </code>  如果传入的是 <code>product; drop product;</code></p>
<p>那么你的表数据就会被无声无息的干掉了。</p>
<p>使用<code>$&#123;&#125;</code>的场景：</p>
<ol>
<li><p>作为<code>in</code>条件时，</p>
</li>
<li><p>参数为<code>int</code>类型并且数据库中字段的类型是<code>number</code>，</p>
</li>
<li><p>表名</p>
</li>
<li><p><code>order by $&#123;&#125;</code>，排序字段</p>
</li>
</ol>
<p><code>--------------------------ps----------------------------</code></p>
<p><code>&lt;![CDATA[]]&gt;</code>的用法，在该符号内的语句，将不会被当成字符串来处理，而是直接当成<code>sql</code>语句，比如有大于，小于号，要执行一个存储过程都需要加上这个。</p>
]]></content>
      <categories>
        <category>Java面试</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis批量插入</title>
    <url>/blog/posts/cb74ceb6/</url>
    <content><![CDATA[<p>关于<code>Mybatia</code>实现插入<code>List</code>,每次一段时间就忘了，这次决定记载下来。</p>
<blockquote>
<p><code>Mapper层接口</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bulkInsertAppTable</span><span class="params">(List&lt;AppTable&gt; appTableList)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Xml实现</code></p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;bulkInsertAppTable&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">insert into app_table</span><br><span class="line">    (application_name,create_by)</span><br><span class="line">values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;appTableList&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">item</span>=<span class="string">&quot;appTable&quot;</span> <span class="attr">open</span>=<span class="string">&quot;&quot;</span> <span class="attr">close</span>=<span class="string">&quot;&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (</span><br><span class="line">            #&#123;appTable.applicationName,jdbcType=VARCHAR&#125;,</span><br><span class="line">            #&#123;appTable.createBy,jdbcType=VARCHAR&#125;</span><br><span class="line">        )</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx踩坑之解决前后端跨域</title>
    <url>/blog/posts/7874a051/</url>
    <content><![CDATA[<h2 id="nginx配置前端跨域"><a href="#nginx配置前端跨域" class="headerlink" title="nginx配置前端跨域"></a><code>nginx</code>配置前端跨域</h2><p>注意点： 如果使用<code>nginx</code>解决跨域在前端使用<code>axios</code>是不需要写后端全路径的，类似于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  原来我们需要写</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://localhost:9999/api&#x27;</span></span><br><span class="line"><span class="comment">// 现在改为</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;/api&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这边不改动</p>
<span id="more"></span>

<img data-src="/blog/posts/7874a051/2022-07-05-23-34-01.png" class="">

<p>因为如果使用了<code>Nginx</code>反向代理之后，部署服务器会有跨域的问题，如果仅仅只是后端处理，也不一定能行, 需要在配置文件中进行代理,<code>docker</code>中文件位置：</p>
<img data-src="/blog/posts/7874a051/2022-07-05-23-39-51.png" class="">

<img data-src="/blog/posts/7874a051/2022-07-05-23-40-29.png" class="">

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!--</span> <span class="string">解决跨域代理 --&gt;</span></span><br><span class="line"><span class="attr">location</span> <span class="string">/api/ &#123;</span></span><br><span class="line"><span class="attr">proxy_pass</span> <span class="string">http://58.198.178.163:9999/api/;</span></span><br><span class="line"><span class="attr">client_max_body_size</span> <span class="string">1024m;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="meta">&lt;!--</span> <span class="string">解决404 --&gt;</span></span><br><span class="line"><span class="attr">error_page</span>  <span class="string">404              index.html;</span></span><br></pre></td></tr></table></figure>

<p><strong>Tips：此处一定要注意的是，<code>proxy_pass</code> 所对应的地址一定要是真实<code>ip</code>，要不然就回报<code>502</code>错误，真的是个大坑，也是我自己的问题！！！</strong>： </p>
<h2 id="Nginx与Vue打包成镜像"><a href="#Nginx与Vue打包成镜像" class="headerlink" title="Nginx与Vue打包成镜像"></a><code>Nginx</code>与<code>Vue</code>打包成镜像</h2><blockquote>
<p><code>npm run build</code>打包,生成<code>dist</code>文件夹</p>
</blockquote>
<blockquote>
<p>在<code>dist</code>统计目录下，<code>vim Dockerfile</code>,在其中输入</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">COPY /dist /usr/share/nginx/html</span><br><span class="line"></span><br><span class="line">ENTRYPOINT nginx -g <span class="string">&quot;daemon off;&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>打包命令:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t &lt;image_name&gt; .</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看镜像 ： <code>docker images</code></p>
</blockquote>
<blockquote>
<p>运行： <code>docker run -d --name nginx_vue -p 8888:80 &lt;image_name&gt;</code></p>
</blockquote>
<blockquote>
<p>进入容器：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it nginx_vue /bin/bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>nginx</code>配置文件地址 <code>/etc/nginx/conf.d/default.conf</code></p>
</blockquote>
<h2 id="Nginx修改上传文件大小"><a href="#Nginx修改上传文件大小" class="headerlink" title="Nginx修改上传文件大小"></a><code>Nginx</code>修改上传文件大小</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">client_max_body_size</span>    <span class="string">1000m;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean的生命周期</title>
    <url>/blog/posts/89080a8e/</url>
    <content><![CDATA[<h1 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a><code>Spring Bean</code>的生命周期</h1><p>大致流程：</p>
<p>本文将从以下两方面去帮助理解 <code>Bean</code> 的生命周期：</p>
<span id="more"></span>

<ul>
<li>生命周期的概要流程：对 <code>Bean</code> 的生命周期进行概括，并且结合代码来理解；</li>
<li>扩展点的作用：详细介绍 <code>Bean</code> 生命周期中所涉及到的扩展点的作用。</li>
</ul>
<h2 id="生命周期的概要流程"><a href="#生命周期的概要流程" class="headerlink" title="生命周期的概要流程"></a>生命周期的概要流程</h2><p><code>Bean</code> 的生命周期概括起来就是 <code>4</code> 个阶段：</p>
<ul>
<li>实例化（<code>Instantiation</code>）</li>
<li>属性赋值（<code>Populate</code>）</li>
<li>初始化（<code>Initialization</code>）</li>
<li>销毁（<code>Destruction</code>）</li>
</ul>
<ul>
<li>实例化：第 <code>1</code> 步，实例化一个 <code>bean</code> 对象；</li>
<li>属性赋值：第 <code>2</code> 步，为 <code>bean</code> 设置相关属性和依赖；</li>
<li>初始化：第 <code>3~7</code> 步，步骤较多，其中第 <code>5、6</code> 步为初始化操作，第 <code>3、4</code> 步为在初始化前执行，第 <code>7</code> 步在初始化后执行，该阶段结束，才能被用户使用；</li>
<li>销毁：第 <code>8~10</code>步，第<code>8</code>步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第<code>9、10</code>步真正销毁 <code>bean</code> 时再执行相应的方法。</li>
</ul>
<p>下面我们结合代码来直观的看下，在 <code>doCreateBean()</code> 方法中能看到依次执行了这 <code>4</code> 个阶段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1. 实例化</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 属性赋值</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 3. 初始化</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 4. 销毁-注册回调接口</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于初始化包含了第 <code>3~7</code>步，较复杂，所以我们进到 <code>initializeBean()</code> 方法里具体看下其过程（注释的序号对应图中序号）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3. 检查 Aware 相关接口并设置相关依赖</span></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 4. BeanPostProcessor 前置处理</span></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 5. 若实现 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class="line">    <span class="comment">// 6. 若配置自定义的 init-method方法，则执行</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">            beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. BeanPostProceesor 后置处理</span></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br><span class="line">```java</span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3. 检查 Aware 相关接口并设置相关依赖</span></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 4. BeanPostProcessor 前置处理</span></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 5. 若实现 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class="line">    <span class="comment">// 6. 若配置自定义的 init-method方法，则执行</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">            beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. BeanPostProceesor 后置处理</span></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>invokInitMethods()</code> 方法中会检查 <code>InitializingBean</code> 接口和 <code>init-method</code> 方法，销毁的过程也与其类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DisposableBeanAdapter.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 9. 若实现 DisposableBean 接口，则执行 destory()方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    ((DisposableBean) <span class="keyword">this</span>.bean).destroy();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, <span class="keyword">this</span>.acc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ((DisposableBean) <span class="keyword">this</span>.bean).destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 10. 若配置自定义的 detory-method 方法，则执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Method methodToInvoke = determineDestroyMethod(<span class="keyword">this</span>.destroyMethodName);</span><br><span class="line">        <span class="keyword">if</span> (methodToInvoke != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>Spring</code> 的源码我们可以直观的看到其执行过程，而我们记忆其过程便可以从这 <code>4</code> 个阶段出发，实例化、属性赋值、初始化、销毁。其中细节较多的便是初始化，涉及了 <code>Aware、BeanPostProcessor、InitializingBean、init-method</code> 的概念。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psMXpsMnpsMy9hcnRpY2xlL2RldGFpbHMvMTA1MDQ0OTU0">拓展点讲解</span></p>
]]></content>
      <categories>
        <category>Java面试</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Speaking practice</title>
    <url>/blog/posts/9a088849/</url>
    <content><![CDATA[<blockquote>
<p>Speaking of which 说到这儿</p>
</blockquote>
<blockquote>
<p>we don’t see eye to eye 我们彼此看不顺眼</p>
</blockquote>
<blockquote>
<p>that’s how it is 原来如此</p>
</blockquote>
<blockquote>
<p>is this seat taken 我可以坐这儿吗</p>
</blockquote>
<blockquote>
<p>don’t flatter yourself 少臭美了</p>
</blockquote>
<blockquote>
<p>see you around 后会有期</p>
</blockquote>
<blockquote>
<p>keep your voice down 小声点</p>
</blockquote>
<blockquote>
<p>age before beauty 长者优先</p>
</blockquote>
<blockquote>
<p>with all due respect 恕我直言</p>
</blockquote>
<blockquote>
<p>go big or go home 要么吃鸡，要么成盒</p>
</blockquote>
<blockquote>
<p>time will tell 时间会证明一切</p>
</blockquote>
<blockquote>
<p>catch you later 回头见</p>
</blockquote>
<blockquote>
<p>are you serious 你是认真的吗</p>
</blockquote>
<blockquote>
<p>i don’t buy it 我才不信呢</p>
</blockquote>
<blockquote>
<p>it’s an honor to meet you 很荣幸见到你</p>
</blockquote>
<blockquote>
<p>you look so handsome 你好帅呀</p>
</blockquote>
<blockquote>
<p>i got you back 我挺你</p>
</blockquote>
<blockquote>
<p>don’t push your luck 别得寸进尺</p>
</blockquote>
<blockquote>
<p>it’s my day off 今天是我的休息日</p>
</blockquote>
<blockquote>
<p>how is everything 一切还好吗</p>
</blockquote>
<blockquote>
<p>i couldn’t agree more 再同意不过了</p>
</blockquote>
<blockquote>
<p>it’s only a matter of time 这只是时间问题而已</p>
</blockquote>
<blockquote>
<p>i told you so 我告诉过你了</p>
</blockquote>
<blockquote>
<p>the clock is ticking 时间不等人</p>
</blockquote>
<blockquote>
<p>anthor day anthor dollar 且过且得</p>
</blockquote>
<blockquote>
<p>night night 晚安</p>
</blockquote>
<blockquote>
<p>textbook 真他喵的典型的</p>
</blockquote>
<blockquote>
<p>it’s no big deal 没什么大不了的</p>
</blockquote>
<blockquote>
<p>get over yourself 别自作多情 </p>
</blockquote>
<blockquote>
<p>go with the flow 顺其自然</p>
</blockquote>
<blockquote>
<p>have nothing to fear 无所畏惧</p>
</blockquote>
<blockquote>
<p>there’s no turning back 没有退路了</p>
</blockquote>
<blockquote>
<p>all set 一切就绪</p>
</blockquote>
<blockquote>
<p>no more bullshit 少废话</p>
</blockquote>
<blockquote>
<p>you’re on your own 你得靠你自己了</p>
</blockquote>
<blockquote>
<p>the chosen one 天选之子</p>
</blockquote>
<blockquote>
<p>hear me out 听我说完</p>
</blockquote>
<blockquote>
<p>got a second 有空吗</p>
</blockquote>
<blockquote>
<p>do me a favor 帮个忙</p>
</blockquote>
<blockquote>
<p>life sucks 生活糟透了</p>
</blockquote>
<blockquote>
<p>same old 老样子</p>
</blockquote>
<blockquote>
<p>you’re a peach 你真好</p>
</blockquote>
<blockquote>
<p>cut to the chase 快说重点</p>
</blockquote>
<blockquote>
<p>keep a low profile 保持低调</p>
</blockquote>
<blockquote>
<p>just kiffing 开个玩笑</p>
</blockquote>
<blockquote>
<p>you know the drill 你知道该怎么做</p>
</blockquote>
<blockquote>
<p>ashes to ashes, dust to dust 尘归尘，土归土</p>
</blockquote>
<blockquote>
<p>I’m on a diet 我在减肥</p>
</blockquote>
<blockquote>
<p>don’t be childish 别孩子气了</p>
</blockquote>
<blockquote>
<p>people change 人是会变的  </p>
</blockquote>
<blockquote>
<p>my hands are tried 我无能为力了</p>
</blockquote>
<blockquote>
<p>finders keepers losers weepers 谁捡归谁，谁丢倒霉</p>
</blockquote>
<blockquote>
<p>humer me 给个面子</p>
</blockquote>
<blockquote>
<p>that’s a good sign 这是个好兆头</p>
</blockquote>
<blockquote>
<p>think outside the box 突破常规</p>
</blockquote>
]]></content>
      <categories>
        <category>Spoken English</category>
      </categories>
      <tags>
        <tag>Spoken English</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 获取服务IP地址和端口号</title>
    <url>/blog/posts/67f40b37/</url>
    <content><![CDATA[<blockquote>
<p><code>IP</code>地址</p>
</blockquote>
<p><code>IP</code>地址非常简单, 直接上代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String result = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">    LOGGER.error(<span class="string">&quot;获取IP失败&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<blockquote>
<p>端口号</p>
</blockquote>
<p>获取端口号有四种方式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- `<span class="meta">@Value</span>`注解</span><br><span class="line">- `<span class="meta">@LocalServerPort</span>`注解</span><br><span class="line">- `Environment`</span><br><span class="line"></span><br><span class="line">我们将`<span class="meta">@Value</span>和<span class="meta">@LocalServerPort</span>`放在一起, 其实`<span class="meta">@LocalServerPort</span>`等价于`<span class="meta">@Value(&quot;$&#123;local.server.port&#125;&quot;)</span>`:</span><br><span class="line">```java</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line"><span class="keyword">int</span> serverPort;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LocalServerPort</span></span><br><span class="line"><span class="keyword">int</span> localServerPort</span><br></pre></td></tr></table></figure>
<p>这里要特别注意, 如果没有在配置文件中配置<code>local.server.port, @LocalServerPort</code>会为<code>null</code><br><code>Environment</code>本质和上述方法类似, 用它来读取配置属性:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">Environment environment;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> environment.getProperty(<span class="string">&quot;server.port&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTY2OTIwMTQwNDYxOTY1MzIw">参考链接</span></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot中如何优雅的使用多线程</title>
    <url>/blog/posts/eec4b728/</url>
    <content><![CDATA[<h1 id="SpringBoot中如何优雅的使用多线程"><a href="#SpringBoot中如何优雅的使用多线程" class="headerlink" title="SpringBoot中如何优雅的使用多线程"></a><code>SpringBoot</code>中如何优雅的使用多线程</h1><p>在 <code>SpringBoot</code> 应用中，经常会遇到在一个接口中，同时做事情1，事情2，事情3，如果同步执行的话，则本次接口时间取决于事情1 2 3执行时间之和；如果三件事同时执行，则本次接口时间取决于事情1 2 3执行时间最长的那个，合理使用多线程，可以大大缩短接口时间。那么在 <code>SpringBoot</code> 应用中如何优雅的使用多线程呢？</p>
<p><code>Don&#39;t bb, show me code.</code></p>
<h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a><strong>快速使用</strong></h2><span id="more"></span>

<p><code>SpringBoot</code>应用中需要添加<code>@EnableAsync</code>注解，来开启异步调用，一般还会配置一个线程池，异步的方法交给特定的线程池完成，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;doSomethingExecutor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">doSomethingExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        <span class="comment">// 核心线程数：线程池创建时候初始化的线程数</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 最大线程数：线程池最大的线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 缓冲队列：用来缓冲执行任务的队列</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 允许线程的空闲时间60秒：当超过了核心线程之外的线程在空闲时间到达之后会被销毁</span></span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        <span class="comment">// 线程池名的前缀：设置好了之后可以方便我们定位处理任务所在的线程池</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;do-something-&quot;</span>);</span><br><span class="line">        <span class="comment">// 缓冲队列满了之后的拒绝策略：由调用线程处理（一般是主线程）</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的方式非常简单，在需要异步的方法上加<code>@Async</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/open/something&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">something</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            asyncService.doSomething(<span class="string">&quot;index = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        lon</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定使用beanname为doSomethingExecutor的线程池</span></span><br><span class="line">    <span class="meta">@Async(&quot;doSomethingExecutor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;do something, message=&#123;&#125;&quot;</span>, message);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;do something error: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问：<code>127.0.0.1:8080/open/something</code>，日志如下</p>
<img data-src="/blog/posts/eec4b728/2022-02-16-21-01-21.png" class="">

<p>由此可见已经达到异步执行的效果了，并且使用到了咱们配置的线程池。</p>
<h2 id="获取异步方法返回值"><a href="#获取异步方法返回值" class="headerlink" title="获取异步方法返回值"></a><strong>获取异步方法返回值</strong></h2><p>当异步方法有返回值时，如何获取异步方法执行的返回结果呢？这时需要异步调用的方法带有返回<code>CompletableFuture</code>。</p>
<p><code>CompletableFuture</code>是对<code>Feature</code>的增强，<code>Feature</code>只能处理简单的异步任务，而<code>CompletableFuture</code>可以将多个异步任务进行复杂的组合。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;异步 有返回值&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/open/somethings&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">somethings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; createOrder = asyncService.doSomething1(<span class="string">&quot;create order&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; reduceAccount = asyncService.doSomething2(<span class="string">&quot;reduce account&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; saveLog = asyncService.doSomething3(<span class="string">&quot;save log&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待所有任务都执行完</span></span><br><span class="line">        CompletableFuture.allOf(createOrder, reduceAccount, saveLog).join();</span><br><span class="line">        <span class="comment">// 获取每个任务的返回结果</span></span><br><span class="line">        String result = createOrder.get() + reduceAccount.get() + saveLog.get();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;doSomethingExecutor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">doSomething1</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;do something1: &#123;&#125;&quot;</span>, message);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">&quot;do something1: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;doSomethingExecutor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">doSomething2</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;do something2: &#123;&#125;&quot;</span>, message);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">&quot;; do something2: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;doSomethingExecutor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">doSomething3</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;do something3: &#123;&#125;&quot;</span>, message);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">&quot;; do something3: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台上日志：</p>
<img data-src="/blog/posts/eec4b728/2022-02-16-21-01-47.png" class="">

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><p><code>@Async</code>注解会在以下几个场景失效，也就是说明明使用了<code>@Async</code>注解，但就没有走多线程。</p>
<ul>
<li>异步方法使用<code>static</code>关键词修饰；</li>
<li>异步类不是一个<code>Spring</code>容器的<code>bean</code>（一般使用注解<code>@Component</code>和<code>@Service</code>，并且能被<code>Spring</code>扫描到）；</li>
<li><code>SpringBoot</code>应用中没有添加<code>@EnableAsync</code>注解；</li>
<li>在同一个类中，一个方法调用另外一个有<code>@Async</code>注解的方法，注解不会生效。原因是<code>@Async</code>注解的方法，是在代理类中执行的。</li>
</ul>
<p>需要注意的是： 异步方法使用注解<code>@Async</code>的返回值只能为<code>void</code>或者<code>Future</code>及其子类，当返回结果为其他类型时，方法还是会异步执行，但是返回值都是<code>null</code>，部分源码如下：</p>
<p><code>AsyncExecutionInterceptor</code>-<code>#invoke</code></p>
<img data-src="/blog/posts/eec4b728/2022-02-16-21-01-58.png" class="">

<p>通过上边几个示例，<code>@Async</code>实际还是通过<code>Future</code>或<code>CompletableFuture</code>来异步执行的，<code>Spring</code>又封装了一下，让我们使用的更方便。</p>
]]></content>
      <categories>
        <category>Java面试</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 接口添加统一前缀</title>
    <url>/blog/posts/80a06b6b/</url>
    <content><![CDATA[<p>为<code>SpringBoot</code>添加统一的接口路径前缀，例如<code>/api/1.0</code>这样。</p>
<p>写一个<code>Springboot</code>配置类即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jinMao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> WebMvcConfig.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2022-08-20  00:14:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.addPathPrefix(<span class="string">&quot;/api/1.0&quot;</span>, c -&gt; c.isAnnotationPresent(RestController.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/80a06b6b/2022-08-21-21-52-28.png" class="">

<p>会自动带上前缀：</p>
<img data-src="/blog/posts/80a06b6b/2022-08-21-21-52-48.png" class="">

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot中常见的几种解决跨域的方式</title>
    <url>/blog/posts/a3dfcd98/</url>
    <content><![CDATA[<h1 id="SpringBoot中常见的几种解决跨域的方式"><a href="#SpringBoot中常见的几种解决跨域的方式" class="headerlink" title="SpringBoot中常见的几种解决跨域的方式"></a><code>SpringBoot</code>中常见的几种解决跨域的方式</h1><h2 id="一、为什么会出现跨域问题"><a href="#一、为什么会出现跨域问题" class="headerlink" title="一、为什么会出现跨域问题"></a>一、为什么会出现跨域问题</h2><p>出于浏览器的同源策略限制。同源策略（<code>Sameoriginpolicy</code>）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说<code>Web</code>是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>
<p>同源策略会阻止一个域的<code>javascript</code>脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（<code>protocol</code>），主机（<code>host</code>）和端口号（<code>port</code>）</p>
<span id="more"></span>

<h2 id="二、什么是跨域"><a href="#二、什么是跨域" class="headerlink" title="二、什么是跨域"></a>二、什么是跨域</h2><p>当一个请求<code>url</code>的协议、域名、端口三者之间任意一个与当前页面<code>url</code>不同即为跨域</p>
<h2 id="三、非同源限制"><a href="#三、非同源限制" class="headerlink" title="三、非同源限制"></a>三、非同源限制</h2><p>【1】无法读取非同源网页的 <code>Cookie</code>、<code>LocalStorage</code> 和 <code>IndexedDB</code></p>
<p>【2】无法接触非同源网页的 <code>DOM</code></p>
<p>【3】无法向非同源地址发送 <code>AJAX</code> 请求</p>
<h2 id="四、java-后端-实现-CORS-跨域请求的方式"><a href="#四、java-后端-实现-CORS-跨域请求的方式" class="headerlink" title="四、java 后端 实现 CORS 跨域请求的方式"></a>四、<code>java</code> 后端 实现 <code>CORS</code> 跨域请求的方式</h2><p>对于 <code>CORS</code>的跨域请求，主要有以下几种方式可供选择：</p>
<ul>
<li>返回新的<code>CorsFilter</code></li>
<li>重写 <code>WebMvcConfigurer</code></li>
<li>使用注解 <code>@CrossOrigin</code></li>
<li>手动设置响应头 (<code>HttpServletResponse</code>)</li>
<li>自定<code>web filter</code> 实现跨域</li>
</ul>
<p>注意:</p>
<ul>
<li><code>CorFilter / WebMvConfigurer / @CrossOrigin</code> 需要 <code>SpringMVC 4.2</code>以上版本才支持，对应<code>springBoot 1.3</code>版本以上</li>
<li>上面前两种方式属于全局 <code>CORS</code> 配置，后两种属于局部 <code>CORS</code>配置。如果使用了局部跨域是会覆盖全局跨域的规则，所以可以通过 <code>@CrossOrigin</code> 注解来进行细粒度更高的跨域资源控制。</li>
<li>其实无论哪种方案，最终目的都是修改响应头，向响应头中添加浏览器所要求的数据，进而实现跨域</li>
</ul>
<h2 id="1-返回新的-CorsFilter-全局跨域"><a href="#1-返回新的-CorsFilter-全局跨域" class="headerlink" title="1.返回新的 CorsFilter(全局跨域)"></a>1.返回新的 <code>CorsFilter</code>(全局跨域)</h2><p>在任意配置类，返回一个 新的 <code>CorsFIlter Bean</code> ，并添加映射路径和具体的<code>CORS</code>配置路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalCorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 添加 CORS配置信息</span></span><br><span class="line">        CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        <span class="comment">//放行哪些原始域</span></span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//是否发送 Cookie</span></span><br><span class="line">        config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//放行哪些请求方式</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//放行哪些原始请求头部信息</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//暴露哪些头部信息</span></span><br><span class="line">        config.addExposedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 添加映射路径</span></span><br><span class="line">        UrlBasedCorsConfigurationSource corsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        corsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,config);</span><br><span class="line">        <span class="comment">//3. 返回新的CorsFilter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(corsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-重写-WebMvcConfigurer-全局跨域"><a href="#2-重写-WebMvcConfigurer-全局跨域" class="headerlink" title="2. 重写 WebMvcConfigurer(全局跨域)"></a>2. 重写 <code>WebMvcConfigurer</code>(全局跨域)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">//是否发送Cookie</span></span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">//放行哪些原始域</span></span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>&#125;)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .exposedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-使用注解-局部跨域"><a href="#3-使用注解-局部跨域" class="headerlink" title="3. 使用注解 (局部跨域)"></a>3. 使用注解 (局部跨域)</h2><p>在控制器(类上)上使用注解 <code>@CrossOrigin:</code>，表示该类的所有方法允许跨域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@CrossOrigin(origins = &quot;*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法上使用注解 <code>@CrossOrigin</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@CrossOrigin(origins = &quot;*&quot;)</span></span><br><span class="line">     <span class="comment">//@CrossOrigin(value = &quot;http://localhost:8081&quot;) //指定具体ip允许跨域</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-手动设置响应头-局部跨域"><a href="#4-手动设置响应头-局部跨域" class="headerlink" title="4. 手动设置响应头(局部跨域)"></a>4. 手动设置响应头(局部跨域)</h2><p>使用 <code>HttpServletResponse</code> 对象添加响应头<code>(Access-Control-Allow-Origin)</code>来授权原始域，这里 <code>Origin</code>的值也可以设置为<code> “*”</code>,表示全部放行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    response.addHeader(<span class="string">&quot;Access-Allow-Control-Origin&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-使用自定义filter实现跨域"><a href="#5-使用自定义filter实现跨域" class="headerlink" title="5. 使用自定义filter实现跨域"></a>5. 使用自定义<code>filter</code>实现跨域</h2><p>首先编写一个过滤器，可以起名字为<code>MyCorsFilter.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mesnac.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCorsFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">    response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;POST, GET, OPTIONS, DELETE&quot;</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Access-Control-Max-Age&quot;</span>, <span class="string">&quot;3600&quot;</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;x-requested-with,content-type&quot;</span>);</span><br><span class="line">    chain.doFilter(req, res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>web.xml</code>中配置这个过滤器，使其生效</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 跨域访问 START--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CorsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.mesnac.aop.MyCorsFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CorsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 跨域访问 END  --&gt;</span></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot如何优雅的发邮件</title>
    <url>/blog/posts/ac1ae082/</url>
    <content><![CDATA[<p>这里演示使用<code>163</code>邮箱发邮件</p>
<h2 id="注册163，并打开配置"><a href="#注册163，并打开配置" class="headerlink" title="注册163，并打开配置"></a>注册<code>163</code>，并打开配置</h2><p>记得保存授权吗</p>
<img data-src="/blog/posts/ac1ae082/2022-07-06-21-58-05.png" class="">

<span id="more"></span>

<h2 id="增加maven以来"><a href="#增加maven以来" class="headerlink" title="增加maven以来"></a>增加<code>maven</code>以来</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- send email --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="yaml文件配置"><a href="#yaml文件配置" class="headerlink" title="yaml文件配置"></a><code>yaml</code>文件配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.163.com</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">********</span> <span class="comment">#登陆账号</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">********</span> <span class="comment">#登陆密码（或授权码），开启上面配置时会有</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">from:</span> <span class="string">JinMaoToRich@163.com</span> <span class="comment">#邮件发信人（即真实邮箱）</span></span><br></pre></td></tr></table></figure>

<h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a><code>Java</code>代码</h2><p>实体类代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendEmailRecord</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 主键</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 邮件发送人</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> String from;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 邮件接受人</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> String to;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 邮件主题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> String subject;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 邮件内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> String text;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 抄送</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> String cc;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 密送</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> String bcc;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 0 - ok , 1 - fail</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> Byte status;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 报错信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> String error;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 发送时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> Date sendDate;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算文件夹路径</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> String computationDirectory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 邮件附件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@JsonIgnore</span></span><br><span class="line"><span class="keyword">private</span> List&lt;File&gt; fileList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>发送邮件代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMailService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSenderImpl mailSender;<span class="comment">//注入邮件工具类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SendEmailRecordDao sendEmailRecordDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ShellProperties shellProperties;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMailWithAttach</span><span class="params">(SendEmailRecord sendEmailInfo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start to send email to &#123;&#125;&quot;</span>,sendEmailInfo.getTo());</span><br><span class="line">        MimeMessageHelper messageHelper = <span class="keyword">new</span> MimeMessageHelper(mailSender.createMimeMessage(), <span class="keyword">true</span>);<span class="comment">//true表示支持复杂类型</span></span><br><span class="line">        sendEmailInfo.setFrom(getMailSendFrom());<span class="comment">//邮件发信人从配置项读取</span></span><br><span class="line">        messageHelper.setFrom(sendEmailInfo.getFrom());<span class="comment">//邮件发信人</span></span><br><span class="line">        messageHelper.setTo(sendEmailInfo.getTo().split(<span class="string">&quot;,&quot;</span>));<span class="comment">//邮件收信人</span></span><br><span class="line">        messageHelper.setSubject(sendEmailInfo.getSubject());<span class="comment">//邮件主题</span></span><br><span class="line">        messageHelper.setText(sendEmailInfo.getText());<span class="comment">//邮件内容</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(sendEmailInfo.getCc())) &#123;<span class="comment">//抄送</span></span><br><span class="line">            messageHelper.setCc(sendEmailInfo.getCc().split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(sendEmailInfo.getBcc())) &#123;<span class="comment">//密送</span></span><br><span class="line">            messageHelper.setCc(sendEmailInfo.getBcc().split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (CollUtil.isNotEmpty(sendEmailInfo.getFileList())) &#123;<span class="comment">//添加邮件附件</span></span><br><span class="line">            <span class="keyword">for</span> (File file : sendEmailInfo.getFileList()) &#123;</span><br><span class="line">                messageHelper.addAttachment(file.getName(),file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mailSender.send(messageHelper.getMimeMessage());<span class="comment">//正式发送邮件</span></span><br><span class="line">        sendEmailInfo.setStatus(SendMailStatusEnum.OK.getCode());</span><br><span class="line">        log.info(<span class="string">&quot;Send Email Success ：&#123;&#125;-&gt;&#123;&#125;&quot;</span>, sendEmailInfo.getFrom(), sendEmailInfo.getTo());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;send Email failed , error is &#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line">        sendEmailInfo.setStatus(SendMailStatusEnum.FAILED.getCode());</span><br><span class="line">        sendEmailInfo.setError(e.getMessage());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        saveMail(sendEmailInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存邮件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveMail</span><span class="params">(SendEmailRecord emailInfo)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;start save send email record to database.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(emailInfo.getTo(),shellProperties.getAlarmEmail()))&#123;</span><br><span class="line">        log.info(<span class="string">&quot;this is alarm email , email info is &#123;&#125;&quot;</span>,emailInfo);</span><br><span class="line">        emailInfo.setStatus(SendMailStatusEnum.FAILED.getCode());</span><br><span class="line">    &#125;</span><br><span class="line">    sendEmailRecordDao.insertSelective(emailInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取邮件发信人</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMailSendFrom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mailSender.getJavaMailProperties().getProperty(<span class="string">&quot;from&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <tags>
        <tag>SrpingBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot文件上传下载</title>
    <url>/blog/posts/20ac1950/</url>
    <content><![CDATA[<blockquote>
<p>文件上传与下载</p>
</blockquote>
<ol>
<li><code>Spring Boot</code>默认单个文件上传大小是<code>1MB</code>,默认多个文件上传总大小是<code>10MB</code></li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="comment">#配置单个上传文件的大小的限制</span></span><br><span class="line">    <span class="attr">multipart:</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">20MB</span></span><br><span class="line">    <span class="comment">#配置在一次请求中上传文件的总容量的限制</span></span><br><span class="line">      <span class="attr">max-request-size:</span> <span class="string">50MB</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(MultipartFile file)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//生成文件在服务器端存放的名字</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//扩展名</span></span><br><span class="line">            String fileSuffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            String fileName = System.currentTimeMillis() + <span class="string">&quot;.&quot;</span> +fileSuffix;</span><br><span class="line">            <span class="comment">//获取项目路径</span></span><br><span class="line">            System.out.println(System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line"></span><br><span class="line">            File files = <span class="keyword">new</span> File(<span class="string">&quot;/Users/jinmao/Documents/IDEASpace/springboot01/src/&quot;</span> + fileName);</span><br><span class="line">            <span class="comment">//上传</span></span><br><span class="line">            <span class="comment">// if(!files.exists()) files.mkdirs();</span></span><br><span class="line">            <span class="comment">// file.transferTo(files);</span></span><br><span class="line">            Files.copy(file.getInputStream(),files.toPath());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;上传失败&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;上传成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//多文件上传</span></span><br><span class="line">     <span class="meta">@PostMapping(&quot;/batch&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleFileUpload</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        List&lt;MultipartFile&gt; files = ((MultipartHttpServletRequest) request).getFiles(<span class="string">&quot;file&quot;</span>);</span><br><span class="line">        MultipartFile file = <span class="keyword">null</span>;</span><br><span class="line">        BufferedOutputStream stream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.size(); ++i) &#123;</span><br><span class="line">            file = files.get(i);</span><br><span class="line">            String filePath = <span class="string">&quot;/Users/dalaoyang/Downloads/&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!file.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = file.getBytes();</span><br><span class="line">                    stream = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                            <span class="keyword">new</span> File(filePath + file.getOriginalFilename())));<span class="comment">//设置文件路径及名字</span></span><br><span class="line">                    stream.write(bytes);<span class="comment">// 写入</span></span><br><span class="line">                    stream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    stream = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;第 &quot;</span> + i + <span class="string">&quot; 个文件上传失败 ==&gt; &quot;</span></span><br><span class="line">                            + e.getMessage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;第 &quot;</span> + i</span><br><span class="line">                        + <span class="string">&quot; 个文件上传失败因为文件为空&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;上传成功&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件下载</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/download&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">downloadFile</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        String fileName = <span class="string">&quot;dalaoyang.jpeg&quot;</span>;<span class="comment">// 文件名</span></span><br><span class="line">        <span class="keyword">if</span> (fileName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置文件路径</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/dalaoyang/Documents/dalaoyang.jpeg&quot;</span>);</span><br><span class="line">            <span class="comment">//File file = new File(realPath , fileName);</span></span><br><span class="line">            <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">                response.setContentType(<span class="string">&quot;application/force-download&quot;</span>);<span class="comment">// 设置强制下载不打开</span></span><br><span class="line">                response.addHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;fileName=&quot;</span> + fileName);<span class="comment">// 设置文件名</span></span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">                BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">                    bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">                    OutputStream os = response.getOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> i = bis.read(buffer);</span><br><span class="line">                    <span class="keyword">while</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">                        os.write(buffer, <span class="number">0</span>, i);</span><br><span class="line">                        i = bis.read(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;下载成功&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (bis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            bis.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            fis.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;下载失败&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




<h2 id="关于文件上传的理解"><a href="#关于文件上传的理解" class="headerlink" title="关于文件上传的理解"></a>关于文件上传的理解</h2><p>以前是这样认为的，就像代码中所展示的那样</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">swiper-item</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/Users/jinmao/Documents/Vscode/Space/StudyPlatform/images/swiper/1.png&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;widthFix&quot;</span> <span class="attr">lazy-load</span>=<span class="string">&quot;false&quot;</span> <span class="attr">binderror</span>=<span class="string">&quot;&quot;</span> <span class="attr">bindload</span>=<span class="string">&quot;&quot;</span>&gt;</span>  <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>image</code>标签只要<code>src</code>是静态的文件目录，感觉就是可以的，然后这就犯了一个很严重的错误，他是无法被解析的，必须是后端项目所带有的资源</p>
<p>类似于一个服务端，一个客户端去访问他的资源，这个资源是服务端所带有的，并不是服务器上有的，只要是有他的全限定类名就<code>ok</code>的</p>
<p>所以任何资源都要通过后端去获取，后端所带有的，所以这个代码有很严重的错误，也是一个关于文件上传的大误区</p>
<img data-src="/blog/posts/20ac1950/2022-02-16-21-04-44.png" class="">

<img data-src="/blog/posts/20ac1950/2022-02-16-21-04-53.png" class="">

<p>就可以显示出来了</p>
<p><strong>续：</strong></p>
<p>后来我又发现了新的问题，就是需要重启项目之后才能访问到相应的资源</p>
<h3 id="配置访问虚拟路径"><a href="#配置访问虚拟路径" class="headerlink" title="配置访问虚拟路径"></a>配置访问虚拟路径</h3><p>文件实际是存在 路径下面，但是当访问<code>http://ip:port/upload/xxx.jpg</code> 时，虚拟路径会映射到 <code>file://Users/path/xxx.jpg</code> 的路径中访问文件。也是对服务器文件的一种保护措施吧.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        String path = System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/src/main/resources/upload/&quot;</span>;</span><br><span class="line">        <span class="comment">//registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;);</span></span><br><span class="line">        <span class="comment">//linux服务器文件目录</span></span><br><span class="line">        <span class="comment">//配置磁盘映射 , pathPattern  访问路径                                        磁盘映射路径，不然不能够访问</span></span><br><span class="line">                                        <span class="comment">//这是因为对服务器的保护措施导致的，服务器不能对外部暴露真实的资源路径，需要配置虚拟路径映射访问。</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/upload/**&quot;</span>).addResourceLocations(<span class="string">&quot;file:&quot;</span>+path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java面试</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot+Vue二进制文件传输</title>
    <url>/blog/posts/a1926332/</url>
    <content><![CDATA[<p>最近用到了<code>springboot</code>项目返回二进制流，话不多说，代码贴上:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;/file/&#123;fileName&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;FileSystemResource&gt; <span class="title">getFile</span><span class="params">(<span class="meta">@PathVariable(&quot;fileName&quot;)</span> String fileName)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">	File file = <span class="keyword">new</span> File(filePath, fileName);</span><br><span class="line">	<span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">		<span class="keyword">return</span> export(file);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(file);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;FileSystemResource&gt; <span class="title">export</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">	headers.add(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache, no-store, must-revalidate&quot;</span>);</span><br><span class="line">	headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=&quot;</span> + file.getName());</span><br><span class="line">	headers.add(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">	headers.add(<span class="string">&quot;Expires&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">	headers.add(<span class="string">&quot;Last-Modified&quot;</span>, <span class="keyword">new</span> Date().toString());</span><br><span class="line">	headers.add(<span class="string">&quot;ETag&quot;</span>, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">	<span class="keyword">return</span> ResponseEntity.ok()</span><br><span class="line">                        .headers(headers)</span><br><span class="line">                        .contentLength(file.length())</span><br><span class="line">                        .contentType(MediaType.parseMediaType(<span class="string">&quot;application/octet-stream&quot;</span>))</span><br><span class="line">                        .body(<span class="keyword">new</span> FileSystemResource(file));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>前端<code>Vue</code>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">downloadXLSXFile() &#123;</span><br><span class="line">	<span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">	that.axios</span><br><span class="line">	.post(</span><br><span class="line">		<span class="string">&quot;/download/XLSXExampleFile&quot;</span>,</span><br><span class="line">		&#123; fileId: <span class="number">123</span> &#125;, <span class="comment">//入参</span></span><br><span class="line">		&#123; responseType: <span class="string">&quot;blob&quot;</span> &#125; <span class="comment">// 设置responseType对象格式为 blob:</span></span><br><span class="line">	)</span><br><span class="line">	.then((res) =&gt; &#123;</span><br><span class="line">		let blob = <span class="keyword">new</span> Blob([res.data], &#123;</span><br><span class="line">		type: <span class="string">&quot;application/octet-stream&quot;</span>,</span><br><span class="line">		&#125;); <span class="comment">// 获取请求返回的response对象中的blob 设置文件类型</span></span><br><span class="line"></span><br><span class="line">		let url = window.URL.createObjectURL(blob); <span class="comment">// 创建一个临时的url指向blob对象</span></span><br><span class="line">		let a = document.createElement(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		a.href = url;</span><br><span class="line">		a.download = <span class="string">&quot;text.xslx&quot;</span>; <span class="comment">//下载的文件名</span></span><br><span class="line">		a.click();</span><br><span class="line">		window.URL.revokeObjectURL(url); <span class="comment">//释放blob对象</span></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同时贴一个<code>Springboot</code>接受前端`Vue``对象参数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/business&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubmitController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SubmitService submitService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/submit&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultVO <span class="title">submitAction</span><span class="params">(<span class="meta">@RequestBody</span> UploadFileSubmitEntity uploadFileSubmitEntity)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;start submitAction ...&quot;</span>);</span><br><span class="line">        log.info(uploadFileSubmitEntity.toString());</span><br><span class="line">        <span class="keyword">return</span> submitService.submitAction(uploadFileSubmitEntity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadFileSubmitEntity</span> </span>&#123;</span><br><span class="line">    <span class="comment">//gz 文件列表</span></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;GZFileList&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;UploadRes&gt; GZFileList;</span><br><span class="line">    <span class="comment">//xlsx 文件列表</span></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;XLSXFileList&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;UploadRes&gt; XLSXFileList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前端:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">var</span> param = &#123;</span><br><span class="line">	<span class="string">&quot;GZFileList&quot;</span>: <span class="built_in">this</span>.GZFileList,</span><br><span class="line">	<span class="string">&quot;XLSXFileList&quot;</span>: <span class="built_in">this</span>.XLSXFileList,</span><br><span class="line">&#125;;</span><br><span class="line">that.axios(&#123;</span><br><span class="line">	<span class="attr">method</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">	<span class="attr">url</span>: <span class="string">&quot;/business/submit&quot;</span>,</span><br><span class="line">	<span class="attr">data</span>: <span class="built_in">JSON</span>.stringify(param),</span><br><span class="line">	<span class="attr">headers</span>: &#123;</span><br><span class="line">		<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json;charset=UTF-8&quot;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(res.data.code == <span class="number">200</span>)&#123;</span><br><span class="line">		that.$message.success(<span class="string">&quot;submit successfully! , Plz wait for some time .&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>











]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot工程项目.gitignore配置</title>
    <url>/blog/posts/ba003691/</url>
    <content><![CDATA[<img data-src="/blog/posts/ba003691/2022-06-30-08-58-34.png" class="">

<span id="more"></span>

<p><code>SpringBoot</code>根目录下创建<code>.gitignore</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**</span><br><span class="line">!**/src/<span class="built_in">test</span>/**</span><br><span class="line"></span><br><span class="line"><span class="comment">### STS ###</span></span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line">.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### IntelliJ IDEA ###</span></span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line">.mvn</span><br><span class="line">mvnw*</span><br><span class="line">HELP.md</span><br><span class="line"></span><br><span class="line"><span class="comment">### NetBeans ###</span></span><br><span class="line">/nbproject/private/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment">### VS Code ###</span></span><br><span class="line">.vscode/</span><br><span class="line"></span><br><span class="line"><span class="comment">### generated files ###</span></span><br><span class="line">bin/</span><br><span class="line">gen/</span><br><span class="line"></span><br><span class="line"><span class="comment">### MAC ###</span></span><br><span class="line">.DS_Store</span><br><span class="line"></span><br><span class="line"><span class="comment">### Other ###</span></span><br><span class="line">logs/</span><br><span class="line"><span class="built_in">log</span></span><br><span class="line">temp/</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring手动回滚事务</title>
    <url>/blog/posts/4ca5bfdf/</url>
    <content><![CDATA[<p>转载<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbXlpdG5ld3MvcC8xMzM3MDg5OS5odG1s">https://www.cnblogs.com/myitnews/p/13370899.html</span></p>
<p>这边是讲解如何手动回滚事务</p>
<span id="more"></span>
<h1 id="一、手动回滚事务"><a href="#一、手动回滚事务" class="headerlink" title="一、手动回滚事务"></a>一、手动回滚事务</h1><p>有时我们需要捕获一些错误信息，又需要进行事务回滚，这时我们就需要用到<code>Spring</code>提供的事务切面支持类<code>TransactionAspectSupport</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEntity</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        userDao.saveUser();</span><br><span class="line">        studentDao.saveStudent();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常了=====&quot;</span> + e);</span><br><span class="line">        <span class="comment">//手动强制回滚事务，这里一定要第一时间处理</span></span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手动回滚事务一定要加上<code>@Transactional</code>，不然会报以下错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.transaction.NoTransactionException: No transaction aspect-managed TransactionStatus in scope</span><br></pre></td></tr></table></figure>
<p>想想也是，不开启事务，何来手动回滚，所以<code>@Transactional</code>必不可少。</p>
<h1 id="二、回滚部分异常"><a href="#二、回滚部分异常" class="headerlink" title="二、回滚部分异常"></a>二、回滚部分异常</h1><p>使用<code>Object savePoint = TransactionAspectSupport.currentTransactionStatus().createSavepoint()</code>; 设置回滚点。<br>使用<code>TransactionAspectSupport.currentTransactionStatus().rollbackToSavepoint(savePoint)</code>; 回滚到<code>savePoint</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEntity</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Object savePoint = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        userDao.saveUser();</span><br><span class="line">        <span class="comment">//设置回滚点</span></span><br><span class="line">        savePoint = TransactionAspectSupport.currentTransactionStatus().createSavepoint();</span><br><span class="line">        studentDao.saveStudent(); <span class="comment">//执行成功</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>/<span class="number">0</span>; <span class="comment">//这里因为除数0会报异常,进入catch块</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常了=====&quot;</span> + e);</span><br><span class="line">        <span class="comment">//手工回滚异常</span></span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().rollbackToSavepoint(savePoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、DataSourceTransactionManager"><a href="#三、DataSourceTransactionManager" class="headerlink" title="三、DataSourceTransactionManager"></a>三、<code>DataSourceTransactionManager</code></h1><p><code>spring</code> 开启事务以及手动提交事务，可以在服务类上加上两个注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DataSourceTransactionManager dataSourceTransactionManager;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">TransactionDefinition transactionDefinition;</span><br></pre></td></tr></table></figure>
<ul>
<li>手动开启事务<br>  <code>TransactionStatus transactionStatus = dataSourceTransactionManager.getTransaction(transactionDefinition);</code></li>
<li>手动提交事务<br>  <code>dataSourceTransactionManager.commit(transactionStatus);//提交</code></li>
<li>手动回滚事务<br>  <code>dataSourceTransactionManager.rollback(transactionStatus);</code>//最好是放在<code>catch</code> 里面,防止程序异常而事务一直卡在哪里未提交</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>TS配置Webpack</title>
    <url>/blog/posts/ddb0d187/</url>
    <content><![CDATA[<h1 id="Ts配置Webpack笔记"><a href="#Ts配置Webpack笔记" class="headerlink" title="Ts配置Webpack笔记"></a>Ts配置Webpack笔记</h1><h2 id="安装-Node-js-淘宝镜像加速器（cnpm）"><a href="#安装-Node-js-淘宝镜像加速器（cnpm）" class="headerlink" title="安装 Node.js 淘宝镜像加速器（cnpm）"></a>安装 Node.js 淘宝镜像加速器（cnpm）</h2><p>==首先电脑是已经要满足安装了Node.js才可以==</p>
<p>由于不是很专业的前端,然后又学习了一些简单的<code>npm</code>指令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm -v          #显示版本，检查npm 是否正确安装。</span><br><span class="line"> </span><br><span class="line">$ npm install express   #安装express模块</span><br><span class="line"> </span><br><span class="line">$ npm install -g express  #全局安装express模块</span><br><span class="line"> </span><br><span class="line">$ npm list         #列出已安装模块</span><br><span class="line"> </span><br><span class="line">$ npm show express     #显示模块详情</span><br><span class="line"> </span><br><span class="line">$ npm update        #升级当前目录下的项目的所有模块</span><br><span class="line"> </span><br><span class="line">$ npm update express    #升级当前目录下的项目的指定模块</span><br><span class="line"> </span><br><span class="line">$ npm update -g express  #升级全局安装的express模块</span><br><span class="line"> </span><br><span class="line">$ npm uninstall express  #删除指定的模块</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<blockquote>
<p>因为配置了 cnpm 下载速度会快很多</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -g 就是全局安装 (Node Package Manager)</span><br><span class="line">npm install cnpm -g</span><br><span class="line"></span><br><span class="line"># 若安装失败，则将源npm源换成淘宝镜像</span><br><span class="line"># 因为npm安装插件是从国外服务器下载，受网络影响大</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"># 然后再执行</span><br><span class="line">npm install cnpm -g</span><br></pre></td></tr></table></figure>
<p><strong>安装的位置:<code>C:\Users\Administrator\AppData\Roaming\npm</code></strong></p>
<p>然后就可以使用 <code>cnpm</code>啦</p>
<h2 id="Ts中配置WebPack"><a href="#Ts中配置WebPack" class="headerlink" title="Ts中配置WebPack"></a>Ts中配置WebPack</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 会在目录下面生成一个 package.json 文件</span><br><span class="line">PS G:\VCCode\space\typescript+Vue3\03_webpack_ts&gt; npm init -y</span><br><span class="line">//Wrote to G:\VCCode\space\typescript+Vue3\03_webpack_ts\package.json:</span><br><span class="line">//&#123;</span><br><span class="line">// &quot;name&quot;: &quot;03_webpack_ts&quot;,</span><br><span class="line">//  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">//  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">//  &quot;scripts&quot;: &#123;</span><br><span class="line">//    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">//  &#125;,</span><br><span class="line">//  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">//  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//会在目录下生成一个 tsconfig.json 文件</span><br><span class="line">PS G:\VCCode\space\typescript+Vue3\03_webpack_ts&gt; tsc --init</span><br><span class="line">// message TS6071: Successfully created a tsconfig.json file.</span><br></pre></td></tr></table></figure>
<h3 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//安装Ts包</span><br><span class="line">PS G:\VCCode\space\typescript+Vue3\03_webpack_ts&gt; cnpm install -D typescript</span><br><span class="line">// webPack-cli 是对内容进行编译使用的(安装特定版本是为了兼容问题)</span><br><span class="line">// webpack-dev-server 是用来启用开发服务器的 </span><br><span class="line">PS G:\VCCode\space\typescript+Vue3\03_webpack_ts&gt;  cnpm install -D webpack@4.41.5 webpack-cli@3.3.10 webpack-dev-server@3.10.2</span><br><span class="line">//  html-webpack-plugin  是用来打包 html 文件的 </span><br><span class="line">// clean-webpack-plugin  是用来清除之前打包的js文件之类的</span><br><span class="line">//  ts-loader  针对 Ts文件进行编译处理的</span><br><span class="line">//  cross-env 涉及跨编译台的命令</span><br><span class="line">PS G:\VCCode\space\typescript+Vue3\03_webpack_ts&gt; cnpm install -D html-webpack-plugin clean-webpack-plugin ts-loader cross-env</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于 - S , -D , -g 参数的说明</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install module_name -S    即    npm install module_name –save    写入dependencies</span><br><span class="line">npm install module_name -D    即    npm install module_name –save-dev 写入devDependencies</span><br><span class="line">npm install module_name -g 	全局安装(命令行使用)</span><br><span class="line">npm install module_name 		本地安装(将安装包放在 ./node_modules 下)</span><br></pre></td></tr></table></figure>
<h3 id="测试案例素材文件以及配置"><a href="#测试案例素材文件以及配置" class="headerlink" title="测试案例素材文件以及配置"></a>测试案例素材文件以及配置</h3><h4 id="入口-src-main-ts"><a href="#入口-src-main-ts" class="headerlink" title="入口:src/main.ts"></a><strong>入口:src/main.ts</strong></h4><p><code>src</code>目录主要用来放置源码</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import &#x27;./01_helloworld&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&#x27;Hello Webpack TS!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="index页面-public-index-html"><a href="#index页面-public-index-html" class="headerlink" title="index页面: public/index.html"></a>index页面: public/index.html</h4><p><code>public</code>目录主要用来放置静态<code>html</code>文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack &amp; TS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&lt;/html</span><br></pre></td></tr></table></figure>
<h4 id="build-webpack-config-js"><a href="#build-webpack-config-js" class="headerlink" title="build/webpack.config.js"></a>build/webpack.config.js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isProd = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> <span class="comment">// 是否生产环境</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.resolve(__dirname, <span class="string">&#x27;..&#x27;</span>, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 是生产环境还是开发环境</span></span><br><span class="line">  <span class="attr">mode</span>: isProd ? <span class="string">&#x27;production&#x27;</span> : <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="comment">//主入口目录</span></span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&#x27;./src/main.ts&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">//打包后的内容输出目录</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="comment">//放在dist 目录下</span></span><br><span class="line">    <span class="attr">path</span>: resolve(<span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="comment">//以上面的 app 文件为开头</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].[contenthash:8].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">        <span class="comment">//使用 ts-loader 包 对 src 下的ts以及tsx文件进行编译操作</span></span><br><span class="line">        use: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">include</span>: [resolve(<span class="string">&#x27;src&#x27;</span>)]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="comment">//会把 dist 下的 之前打包的 js清除掉</span></span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">//此处针对 当前public 下的 html 进行打包</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./public/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">      <span class="comment">//对扩展名进行处理的 , 比如说 引入.ts文件不需要写拓展名</span></span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">//使用sourceMap ,将来代码哪一行出现了错误 将会出现提示</span></span><br><span class="line">  <span class="attr">devtool</span>: isProd ? <span class="string">&#x27;cheap-module-source-map&#x27;</span> : <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动项目之后进行的一些配置</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>, <span class="comment">// 主机名</span></span><br><span class="line">    <span class="attr">stats</span>: <span class="string">&#x27;errors-only&#x27;</span>, <span class="comment">// 打包日志输出输出错误信息</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">8081</span>,</span><br><span class="line">    <span class="comment">//浏览器中自动打开</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置打包命令"><a href="#配置打包命令" class="headerlink" title="配置打包命令"></a>配置打包命令</h3><p>在生成的<code>package.json</code>文件中,替换掉<code>test</code>标签:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">//cross-env 的作用是跨平台 </span></span><br><span class="line">    <span class="comment">//因为有些指令只能够在 linux 中被识别 </span></span><br><span class="line">    <span class="comment">// dev 开发环境</span></span><br><span class="line">    <span class="comment">// bulid 生产环境 </span></span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development webpack-dev-server --config build/webpack.config.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h3 id="运行与打包"><a href="#运行与打包" class="headerlink" title="运行与打包"></a>运行与打包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//运行</span><br><span class="line">npm run dev</span><br><span class="line">//打包</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<h4 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果:"></a>运行效果:</h4>




<h4 id="打包效果"><a href="#打包效果" class="headerlink" title="打包效果"></a>打包效果</h4>

<p>已经生成了<code>dist</code>目录以及相应的文件</p>


<h2 id="主要需要注意的就是-webpack-包之类的-版本问题就okk了"><a href="#主要需要注意的就是-webpack-包之类的-版本问题就okk了" class="headerlink" title="主要需要注意的就是 webpack 包之类的 版本问题就okk了"></a>主要需要注意的就是 <code>webpack</code> 包之类的 版本问题就okk了</h2>]]></content>
      <categories>
        <category>前端</category>
        <category>TypeScript</category>
        <category>WebPack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>TypeScript</tag>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot优雅的实现重试</title>
    <url>/blog/posts/49a9ac1a/</url>
    <content><![CDATA[<p><code>guava-retrying</code> 包有一个重试工具，这便是重试示例代码，同时，参考文章有 <span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNzUyMDg2">https://cloud.tencent.com/developer/article/1752086</span></p>
<p>引入<code>maven</code>包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.rholder<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava-retrying<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>封装为工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryUtil</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">RetryUtil</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Retryer&lt;Boolean&gt; retryer = RetryerBuilder.&lt;Boolean&gt;newBuilder()</span><br><span class="line">        <span class="comment">//重试条件</span></span><br><span class="line">        .retryIfResult(aBoolean -&gt; Objects.equals(aBoolean,<span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">//等待策略，此处为120秒重试一次</span></span><br><span class="line">        .withWaitStrategy(WaitStrategies.fixedWait(<span class="number">150</span>, TimeUnit.SECONDS))</span><br><span class="line">        <span class="comment">//停止策略，此处只重试10次</span></span><br><span class="line">        .withStopStrategy(StopStrategies.stopAfterAttempt(<span class="number">10</span>))</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">测试</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">context</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, RetryException </span>&#123;</span><br><span class="line">        AtomicInteger j = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        RetryUtil.retryer.call(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;start &#123;&#125; calculate&quot;</span>,j.get());</span><br><span class="line">           <span class="keyword">int</span> i = j.get();</span><br><span class="line">           <span class="keyword">if</span> (i &lt; <span class="number">8</span>)&#123;</span><br><span class="line">               j.getAndIncrement();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/49a9ac1a/2022-07-05-23-14-13.png" class="">






]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>The learning of Jenkins Grammer</title>
    <url>/blog/posts/273d98ce/</url>
    <content><![CDATA[<p>Recently , i use jenkinsFile to realize some function </p>
<h2 id="处理JSON"><a href="#处理JSON" class="headerlink" title="处理JSON"></a>处理<code>JSON</code></h2><h2 id="压缩方法"><a href="#压缩方法" class="headerlink" title="压缩方法"></a>压缩方法</h2><p>可能是自带的方法</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">zip <span class="attr">zipFile:</span> <span class="string">&#x27;&lt;zipFileName&gt;&#x27;</span>, <span class="attr">archive:</span> <span class="literal">true</span>, <span class="attr">glob:</span> <span class="string">&#x27;&lt;file_path&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example： zip zipFile: &#x27;upload.zip&#x27;, archive: true, glob: &#x27;/binary/&#x27;</span></span><br></pre></td></tr></table></figure>


<h2 id="JSON操作"><a href="#JSON操作" class="headerlink" title="JSON操作"></a><code>JSON</code>操作</h2><blockquote>
<p>读取：从文件中读取  <code>JSON</code> 字符串，并直接解析为对象</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从文件中读取</span></span><br><span class="line"><span class="keyword">def</span> dataObject = readJSON <span class="attr">file:</span> <span class="string">&#x27;message2.json&#x27;</span></span><br><span class="line">echo <span class="string">&quot;color: $&#123;dataObject.attachments[0].color&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从文本中读取</span></span><br><span class="line"><span class="keyword">def</span> dataObject = readJSON <span class="attr">text:</span> <span class="string">&#x27;message2.json&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>写入文件</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存：将对象直接写入文件，无需先转化为 JSON 字符串</span></span><br><span class="line"><span class="comment">// Building json from code and write it to file</span></span><br><span class="line">writeJSON(<span class="attr">file:</span> <span class="string">&#x27;message1.json&#x27;</span>, <span class="attr">json:</span> dataObject)</span><br></pre></td></tr></table></figure>


<h2 id="groovy获取shell执行结果和执行状态码"><a href="#groovy获取shell执行结果和执行状态码" class="headerlink" title="groovy获取shell执行结果和执行状态码"></a>groovy获取shell执行结果和执行状态码</h2><blockquote>
<p>获取执行结果</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">result = sh(<span class="attr">script:</span> <span class="string">&quot;shell command&quot;</span>, <span class="attr">returnStdout:</span> <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>获取执行状态码（0或者非0）</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">excuteCode = sh(<span class="attr">script:</span> <span class="string">&quot;shell command&quot;</span>, <span class="attr">returnStatus:</span> <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Jenkins声明式Pipeline中单引号和双引号的区别"><a href="#Jenkins声明式Pipeline中单引号和双引号的区别" class="headerlink" title="Jenkins声明式Pipeline中单引号和双引号的区别"></a><code>Jenkins</code>声明式<code>Pipeline</code>中单引号和双引号的区别</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NzE5MzkyL2FydGljbGUvZGV0YWlscy8xMjE0NzI4OTQ=">原文地址</span></p>
<ol>
<li><p>如果使用三个单引号，那么其中的字符，除了<code>&#39;\&#39;</code>会被解析为转义字符外，其他都会被原封不动地传递给<code>P</code>owershell`，不作任何解析</p>
</li>
<li><p>如果使用三个双引号，则绝大部分字符也会被原封不动地传递给<code>Powershel</code>l，但如下三个字符除外：</p>
<p> ① <code>&#39;$&#39;</code>（美元字符）<code>：</code>用于引用<code>Jenkinsfile</code>中的环境变量。</p>
<p> ② <code>&#39;\&#39;</code>（反斜杠字符）<code>：</code>用于转义。</p>
<p> ③ <code>&#39; &quot; &#39;</code>（双引号字符）：本身无特殊含义，但是三个双引号之间不允许出现非转义的双引号字符，否则将导致语法错误。</p>
</li>
</ol>
<p>如果确实需要使用上述三个字符本身，而不是使用其特殊含义，则必须在前面加上<code>&#39;\&#39;</code>字符进行转义，即：<code>&#39;\$&#39;</code>、<code>&#39;\\&#39;</code>、<code>&#39;\&quot;&#39;</code>。</p>
<blockquote>
<p>总结<code>：</code></p>
</blockquote>
<p>三单引号的优点是，语法简洁，不存在过多转义；缺点是，无法引用<code>Jenkins</code>中的环境变量。而三双引号的优缺点与此正好相反。</p>
<p>个人对于使用三双引号的建议是：仅在必须声明和引用<code>Powershell</code>变量（而非<code>Jenkins</code>环境变量）时，才使用三单引号或三双引号。其他时候，每一条命令都应拆分，并以<code>powershell</code>开头。这样做的好处是便于调试（尤其是使用<code>Blue Ocean</code>调试时）。在这一前提下，如果需要在三引号中引用<code>Jenkins</code>环境变量，则必须使用三双引号；否则，使用三单引号表达更为简洁。</p>
<h2 id="jenkins-pipeline中获取shell命令的标准输出或者状态"><a href="#jenkins-pipeline中获取shell命令的标准输出或者状态" class="headerlink" title="jenkins pipeline中获取shell命令的标准输出或者状态"></a><code>jenkins pipeline</code>中获取<code>shell</code>命令的标准输出或者状态</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取标准输出</span></span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line">result = sh <span class="attr">returnStdout:</span> <span class="literal">true</span> ,<span class="attr">script:</span> <span class="string">&quot;&lt;shell command&gt;&quot;</span></span><br><span class="line">result = result.trim()</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">result = sh(<span class="attr">script:</span> <span class="string">&quot;&lt;shell command&gt;&quot;</span>, <span class="attr">returnStdout:</span> <span class="literal">true</span>).trim()</span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line">sh <span class="string">&quot;&lt;shell command&gt; &gt; commandResult&quot;</span></span><br><span class="line">result = readFile(<span class="string">&#x27;commandResult&#x27;</span>).trim()</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取执行状态</span></span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line">result = sh <span class="attr">returnStatus:</span> <span class="literal">true</span> ,<span class="attr">script:</span> <span class="string">&quot;&lt;shell command&gt;&quot;</span></span><br><span class="line">result = result.trim()</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">result = sh(<span class="attr">script:</span> <span class="string">&quot;&lt;shell command&gt;&quot;</span>, <span class="attr">returnStatus:</span> <span class="literal">true</span>).trim()</span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line">sh <span class="string">&#x27;&lt;shell command&gt;; echo $? &gt; status&#x27;</span></span><br><span class="line"><span class="keyword">def</span> r = readFile(<span class="string">&#x27;status&#x27;</span>).trim()</span><br><span class="line"></span><br><span class="line"><span class="comment">//无需返回值，仅执行shell命令</span></span><br><span class="line"><span class="comment">//最简单的方式</span></span><br><span class="line">sh <span class="string">&#x27;&lt;shell command&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<blockquote>
<p>工作中需要获取<code>shell </code>命令的执行状态，返回0或者非0<br><code>groovy</code>语句写法为：</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> exitValue = sh(<span class="attr">script:</span> <span class="string">&quot;grep -i &#x27;xxx&#x27; /etc/myfolder&quot;</span>, <span class="attr">returnStatus:</span> <span class="literal">true</span>)</span><br><span class="line">echo <span class="string">&quot;return exitValue :$&#123;exitValue&#125;&quot;</span></span><br><span class="line"><span class="keyword">if</span>(exitValue != <span class="number">0</span>)&#123;</span><br><span class="line">    执行操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>grep</code>命令执行没有报错，正常情况下<code>exitValue</code>为<code>0</code>，报错则为非<code>0</code></p>
<p>需要注意的是当命令中存在重定向的时候，会出现返回状态异常，因为我们要返回状态，删除重定向（<code>&amp;&gt;/dev/null</code>）即可，比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> exitValue = sh(<span class="attr">script:</span> <span class="string">&quot;grep -i &#x27;xxx&#x27; /etc/myfolder &amp;&gt;/dev/null&quot;</span>, <span class="attr">returnStatus:</span> <span class="literal">true</span>)</span><br><span class="line">xxx不存在，正常逻辑是返回非<span class="number">0</span>，但是实际中返回的是<span class="number">0</span> 。可以理解为先执行命令然后赋值操作，类似下面的动作：（个人理解）</span><br><span class="line">sh <span class="string">&quot;ls -l &gt; commandResult&quot;</span></span><br><span class="line">result = readFile(<span class="string">&#x27;commandResult&#x27;</span>).trim()</span><br></pre></td></tr></table></figure>

<p><code>groovy</code>中存在另外一种解析<code>shell</code>脚本的方法，在<code>jenkins pipeline</code>中会使用会报异常,<code>jenkins</code>相关资料中也没有看到此种用法，应该是不支持</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">groovy<span class="selector-class">.lang</span><span class="selector-class">.MissingPropertyException</span>: No such property: rhel <span class="keyword">for</span> class: groovy<span class="selector-class">.lang</span>.Binding</span><br></pre></td></tr></table></figure>
<p>写法为：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> command = <span class="string">&quot;git log&quot;</span></span><br><span class="line"><span class="keyword">def</span> proc = command.execute()</span><br><span class="line">proc.waitFor()</span><br><span class="line"><span class="keyword">def</span> status = proc.exitValue()</span><br></pre></td></tr></table></figure>

<h2 id="pipleline讲解"><a href="#pipleline讲解" class="headerlink" title="pipleline讲解"></a><code>pipleline</code>讲解</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">  agent &#123;</span><br><span class="line">    /**</span><br><span class="line">    * agent none ，这样可以在具体的stages中定义</span><br><span class="line">agent：指定流水线的执行位置，流水线中的每个阶段都必须在某个地方（物理机，虚拟机或 Docker 容器）执行，agent 部分即指定具体在哪里执行。</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    *说明某项目要在jdk8的环境中创建</span><br><span class="line">    *实际上agent &#123; label <span class="string">&#x27;jdk8&#x27;</span> &#125;是 agent &#123; node &#123; label <span class="string">&#x27;jdk8&#x27;</span> &#125; &#125; 的简写。 </span><br><span class="line">    */</span><br><span class="line">    label <span class="string">&#x27;jdk8&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  /*</span><br><span class="line">  environment指令指定一系列键值对，这些对值将被定义为所有步骤的环境变量或阶段特定步骤</span><br><span class="line"></span><br><span class="line">environment&#123;…&#125;, 大括号里面写一些键值对，也就是定义一些变量并赋值，这些变量就是环境变量。环境变量的作用范围，取决你environment&#123;…&#125;所写的位置，你可以写在顶层环境变量，让所有的stage下的step共享这些变量，也可以单独定义在某一个stage下，只能供这个stage去调用变量，其他的stage不能共享这些变量。一般来说，我们基本上上定义全局环境变量，如果是局部环境变量，我们直接用def关键字声明就可以，没必要放environment&#123;…&#125;里面。</span><br><span class="line">*/</span><br><span class="line">  environment&#123;</span><br><span class="line">    project = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    staticname = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    appname= <span class="string">&#x27;&#x27;</span></span><br><span class="line">    version=<span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">//  需要配置jdk环境，那这个里面的jdk环境与agent label有啥区别</span><br><span class="line">tools&#123;</span><br><span class="line">   jdk <span class="string">&#x27;jdk1.8.0_121&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">// 定义阶段，可以设置并行和串行，默认情况就是串行的，默认的如下举例</span><br><span class="line">/**</span><br><span class="line">* stage(<span class="string">&#x27;Parallel Stage&#x27;</span>) &#123;</span><br><span class="line">*           failFast <span class="literal">true</span></span><br><span class="line">*            parallel &#123;</span><br><span class="line">*                stage(<span class="string">&#x27;并行一&#x27;</span>) &#123;</span><br><span class="line">*                    steps &#123;</span><br><span class="line">*                        <span class="built_in">echo</span> <span class="string">&quot;并行一&quot;</span></span><br><span class="line">*                    &#125;</span><br><span class="line">*                stage(<span class="string">&#x27;并行2&#x27;</span>) &#123;</span><br><span class="line">*                    steps &#123;</span><br><span class="line">*                        <span class="built_in">echo</span> <span class="string">&quot;并行2&quot;</span></span><br><span class="line">*                    &#125;</span><br><span class="line">*            &#125;</span><br><span class="line">*&#125;</span><br><span class="line"></span><br><span class="line">**/</span><br><span class="line">  stages &#123;</span><br><span class="line">     stage (<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">         steps &#123;</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&#x27;build&#x27;</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>The Basic knowledge of Anaconda</title>
    <url>/blog/posts/378107f2/</url>
    <content><![CDATA[<h1 id="Anaconda基本学习"><a href="#Anaconda基本学习" class="headerlink" title="Anaconda基本学习"></a><code>Anaconda</code>基本学习</h1><p><code>conda</code>中想要安装的包，可以在这个网站搜索查询： <span class="exturl" data-url="aHR0cHM6Ly9hbmFjb25kYS5vcmcvc2VhcmNoP3E9ZmFzdHEtam9pbg==">https://anaconda.org/search?q=fastq-join</span></p>
<blockquote>
<p> 官网下载  <span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tLz90PWh0dHBzOi8vd3d3LmFuYWNvbmRhLmNvbS9kb3dubG9hZC8=">链接</span></p>
</blockquote>
<p>此处不多说</p>
<blockquote>
<p>环境变量的配置(windows)</p>
</blockquote>
<p>需要注意的是,<code>AnaConda</code>需要配置三个路径的环境变量</p>
<span id="more"></span>

<img data-src="/blog/posts/378107f2/2022-05-23-16-19-09.png" class="">

<p>根据自己的安装目录为准</p>
<p>此时在<code>windows</code>中的<code>cmd</code>中输入<code>conda</code>命令</p>
<img data-src="/blog/posts/378107f2/2022-05-23-16-19-17.png" class="">

<p>说明安装完毕,就可以投入使用了</p>
<h2 id="Conda的基本指令"><a href="#Conda的基本指令" class="headerlink" title="Conda的基本指令"></a><code>Conda</code>的基本指令</h2><h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 升级conda</span></span><br><span class="line">conda update conda</span><br><span class="line">conda update anaconda</span><br><span class="line">conda update anaconda-navigator    <span class="comment">#update最新版本的anaconda-navigator</span></span><br><span class="line">conda update xxx   <span class="comment">#更新xxx文件包</span></span><br><span class="line"></span><br><span class="line">conda --version <span class="comment">#获取版本号</span></span><br><span class="line"></span><br><span class="line">conda update --<span class="built_in">help</span></span><br><span class="line">conda remove --<span class="built_in">help</span>  <span class="comment">#查看某一命令的帮助，如update命令及remove命令</span></span><br><span class="line"></span><br><span class="line">conda env -h <span class="comment"># 查看环境管理的全部命令帮助</span></span><br><span class="line"></span><br><span class="line">conda create --name your_env_name <span class="comment">#创建环境 --name可以省略为-n</span></span><br><span class="line"></span><br><span class="line">conda create --n your_env_name python=<span class="number">3.7</span><span class="comment">#创建制定python版本的环境</span></span><br><span class="line"></span><br><span class="line">conda create --name your_env_name numpy scipy<span class="comment">#创建包含某些包的环境</span></span><br><span class="line"></span><br><span class="line">conda info --envs</span><br><span class="line">conda env <span class="built_in">list</span>  <span class="comment">#列举当前所有环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进入某个环境</span></span><br><span class="line">activate your_env_name</span><br><span class="line"></span><br><span class="line"><span class="comment">#退出当前环境</span></span><br><span class="line">deactivate </span><br><span class="line"></span><br><span class="line"><span class="comment">#复制某个环境</span></span><br><span class="line">conda create --name new_env_name --clone old_env_name </span><br><span class="line"></span><br><span class="line"><span class="comment">#删除某个环境</span></span><br><span class="line">conda remove --name your_env_name --<span class="built_in">all</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="分享环境"><a href="#分享环境" class="headerlink" title="分享环境"></a>分享环境</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果你想把你当前的环境配置与别人分享，这样ta可以快速建立一个与你一模一样的环境（同一个版本的python及各种包）来共同开发/进行新的实验。一个分享环境的快速方法就是给ta一个你的环境的.yml文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#首先通过activate target_env要分享的环境target_env，然后输入下面的命令会在当前工作目录下生成一个environment.yml文件，</span></span><br><span class="line"></span><br><span class="line">conda env export &gt; environment.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">#小伙伴拿到environment.yml文件后，将该文件放在工作目录下，可以通过以下命令从该文件创建环境</span></span><br><span class="line"></span><br><span class="line">conda env create -f environment.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>yml</code>是这样的</p>
<img data-src="/blog/posts/378107f2/2022-05-23-16-19-29.png" class="">

<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>列举当前活跃环境下的所有包</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure>
<p>列举一个非当前活跃环境下的所有包</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">conda list -n your_env_name</span><br></pre></td></tr></table></figure>
<p>为指定环境安装某个包</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">conda install -n env_name package_name</span><br></pre></td></tr></table></figure>

<h1 id="搭载VsCode使用junpyter"><a href="#搭载VsCode使用junpyter" class="headerlink" title="搭载VsCode使用junpyter"></a>搭载<code>VsCode</code>使用<code>junpyter</code></h1><p>安装<code>VsCode</code>插件</p>
<img data-src="/blog/posts/378107f2/2022-05-23-16-19-42.png" class="">

<p>这个时候就具备使用<code>Jupyter</code>的条件了,因为<code>Python</code>插件内部也安装了<code>Jupyter</code>插件,此时<code>Ctrl+Shift+P</code>弹出</p>
<img data-src="/blog/posts/378107f2/2022-05-23-16-19-49.png" class="">

<p>新建一个<code>Jupyter</code>就可以使用了</p>
<img data-src="/blog/posts/378107f2/2022-05-23-16-19-55.png" class="">

<p>如果报错,一般重启一下VSCode就能够使用,喜欢使用主要是因为<code>Jupyter</code>可以一行一行的执行,嘻嘻</p>
]]></content>
      <categories>
        <category>master</category>
      </categories>
      <tags>
        <tag>master</tag>
      </tags>
  </entry>
  <entry>
    <title>UML:类图关系总结</title>
    <url>/blog/posts/f610585/</url>
    <content><![CDATA[<h1 id="UML-类图关系总结"><a href="#UML-类图关系总结" class="headerlink" title="UML:类图关系总结"></a><code>UML</code>:类图关系总结</h1><p>UML类图几种关系的总结，泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖<br>在UML类图中，常见的有以下几种关系: <code>泛化（Generalization）</code>, <code>实现（Realization）</code>，<code>关联（Association)</code>，<code>聚合（Aggregation）</code>，<code>组合(Composition)</code>，<code>依赖(Dependency)</code></p>
<span id="more"></span>

<h2 id="1-泛化（Generalization）"><a href="#1-泛化（Generalization）" class="headerlink" title="1. 泛化（Generalization）"></a>1. 泛化（<code>Generalization</code>）</h2><ul>
<li>【泛化关系】：是一种<strong>继承</strong>关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。</li>
<li>【箭头指向】：带三角箭头的实线，箭头指向父类.  <img data-src="/blog/posts/f610585/2022-02-13-23-24-28.png" class=""></li>
</ul>
<h2 id="2-实现（Realization）"><a href="#2-实现（Realization）" class="headerlink" title="2.实现（Realization）"></a>2.实现（<code>Realization</code>）</h2><p>【实现关系】：在这里插入图片描述是一种类与接口的关系，表示类是接口所有特征和行为的实现.</p>
<p>【箭头指向】：带三角箭头的虚线，箭头指向接口</p>
<img data-src="/blog/posts/f610585/2022-02-13-23-24-40.png" class="">


<h2 id="3-关联（Association"><a href="#3-关联（Association" class="headerlink" title="3.关联（Association)"></a>3.关联（<code>Association</code>)</h2><p>【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</p>
<p>【代码体现】：成员变量</p>
<p>【箭头及指向】：带普通箭头的实心线，指向被拥有者</p>
  <img data-src="/blog/posts/f610585/2022-02-13-23-24-49.png" class="">

<h2 id="4-聚合（Aggregation）"><a href="#4-聚合（Aggregation）" class="headerlink" title="4.聚合（Aggregation）"></a>4.聚合（<code>Aggregation</code>）</h2><p>【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。<br>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。<br>【代码体现】：成员变量<br>【箭头及指向】：带空心菱形的实心线，菱形指向整体</p>
<img data-src="/blog/posts/f610585/2022-02-13-23-24-59.png" class="">
<h2 id="5-组合-Composition"><a href="#5-组合-Composition" class="headerlink" title="5.组合(Composition)"></a>5.组合(<code>Composition</code>)</h2><p>【组合关系】：是<strong>整体与部分</strong>的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。<br>组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。<br>【代码体现】：成员变量</p>
<p>【箭头及指向】：带实心菱形的实线，菱形指向整体</p>
<img data-src="/blog/posts/f610585/2022-02-13-23-25-08.png" class="">

<h2 id="6-依赖-Dependency"><a href="#6-依赖-Dependency" class="headerlink" title="6. 依赖(Dependency)"></a>6. 依赖(<code>Dependency</code>)</h2><p> 只要在类中用到了对方，他们之间就存在依赖关系</p>
<img data-src="/blog/posts/f610585/2022-02-13-23-25-20.png" class="">


<img data-src="/blog/posts/f610585/2022-02-13-23-25-27.png" class="">


]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中安装卸载Mysql数据库</title>
    <url>/blog/posts/31f95091/</url>
    <content><![CDATA[<h1 id="Ubuntu中安装卸载Mysql数据库"><a href="#Ubuntu中安装卸载Mysql数据库" class="headerlink" title="Ubuntu中安装卸载Mysql数据库"></a><code>Ubuntu</code>中安装卸载<code>Mysql</code>数据库</h1><blockquote>
<p>启动<code>Mysql</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关闭<code>Mysql</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysql stop</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<blockquote>
<p>重启<code>Mysql</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/mysql restart</span><br></pre></td></tr></table></figure>

<h2 id="Mysql卸载"><a href="#Mysql卸载" class="headerlink" title="Mysql卸载"></a><code>Mysql</code>卸载</h2><ol>
<li>先卸载 <code>mysql-common</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove mysql-common</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>再卸载(因为我的<code>Mysql</code>是<code>8.0</code>)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get autoremove --purge mysql-server-8.0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>再用<code>dpkg --list|grep mysql</code>查看，还剩什么就卸载什么</p>
</li>
<li><p>最后清除残留数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -l |grep ^rc|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> |sudo xargs dpkg -P </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Mysql安装"><a href="#Mysql安装" class="headerlink" title="Mysql安装"></a><code>Mysql</code>安装</h2><h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><ol>
<li>更新软件库<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></li>
<li>安装<code>Mysql</code>服务<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install mysql-server(这步就已经安装mysql-client)</span><br></pre></td></tr></table></figure></li>
<li>安装依赖<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   sudo apt install libmysqlclient-dev</span><br><span class="line">   ```      </span><br><span class="line"></span><br><span class="line"><span class="comment">### 二、检查状态</span></span><br><span class="line">```bash</span><br><span class="line">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure>
如果出现“无此命令”，输入命令<code>sudo apt install netstat</code></li>
</ol>
<img data-src="/blog/posts/31f95091/2022-02-13-23-21-16.png" class="">

<h3 id="三、设置Root密码"><a href="#三、设置Root密码" class="headerlink" title="三、设置Root密码"></a>三、设置<code>Root</code>密码</h3><p>1、进入<code>root</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure>
<p>2、进入<code>mysql</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql</span><br></pre></td></tr></table></figure>
<p>3、配置数据库<code>root</code>权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update mysql.user <span class="keyword">set</span> authentication_string<span class="operator">=</span>PASSWORD(<span class="string">&#x27;123456&#x27;</span>), plugin<span class="operator">=</span><span class="string">&#x27;mysql_native_password&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/31f95091/2022-02-13-23-21-34.png" class="">

<p>如果显示密码过于简单则需要重新设置密码强度</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;validate_password%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/31f95091/2022-02-13-23-21-46.png" class="">

<blockquote>
<p>密码的长度是由<code>validate_password.length</code>决定的,但是可以通过以下命令修改</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password.length<span class="operator">=</span><span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>validate_password.policy</code>决定密码的验证策略,默认等级为<code>MEDIUM</code>(中等),可通过以下命令修改为<code>LOW</code>(低)</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password.policy<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/31f95091/2022-02-13-23-21-56.png" class="">

<h3 id="四、配置远程连接"><a href="#四、配置远程连接" class="headerlink" title="四、配置远程连接"></a>四、配置远程连接</h3><p>查看目前是否支持远程连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>,host <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/31f95091/2022-02-13-23-22-07.png" class="">

<p>目前只支持本地连接</p>
<blockquote>
<p>更新域属性，<code>&#39;%&#39;</code>表示允许外部访问：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> host<span class="operator">=</span><span class="string">&#x27;%&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span> <span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行以上语句之后再执行：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再执行授权语句：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure>
<p><code>FLUSH PRIVILEGES;</code> 命令本质上的作用是：</p>
<p>将当前<code>user</code>和<code>privilige</code>表中的用户信息/权限设置从<code>mysql</code>库(<code>MySQL</code>数据库的内置库)中提取到内存里。</p>
<p><code>MySQL</code>用户数据和权限有修改后，希望在”不重启<code>MySQL</code>服务”的情况下直接生效，那么就需要执行这个命令。</p>
<p>通常是在修改<code>ROOT</code>帐号的设置后，怕重启后无法再登录进来，那么直接<code>flush</code>之后就可以看权限设置是否生效。</p>
<p>而不必冒太大风险。</p>
<h4 id="可能存在的其它问题"><a href="#可能存在的其它问题" class="headerlink" title="可能存在的其它问题"></a>可能存在的其它问题</h4><p>执行完之后，再用<code>Navicat</code>连接<code>mysql</code>，报错如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Client does <span class="keyword">not</span> support authentication protocol requested <span class="keyword">by</span> server；</span><br></pre></td></tr></table></figure>
<p>报错原因：</p>
<p><code>mysql8.0</code> 引入了新特性 <code>caching_sha2_password；</code>这种密码加密方式<code>Navicat 12</code>以下客户端不支持；</p>
<p><code>Navicat 12</code>以下客户端支持的是<code>mysql_native_password</code> 这种加密方式；</p>
<p>解决方案:</p>
<ol>
<li>用如下语句查看<code>MySQL</code>当前加密方式<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> host,<span class="keyword">user</span>,plugin <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/31f95091/2022-02-13-23-22-58.png" class=""></li>
</ol>
<p>一般第一行，<code>root</code>加密方式为<code>caching_sha2_password</code>。</p>
<p>2，使用命令将他修改成<code>mysql_native_password</code>加密模式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> plugin<span class="operator">=</span><span class="string">&#x27;mysql_native_password&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>再次连接的时候，就成功了。</p>
<h4 id="如果还连接不上"><a href="#如果还连接不上" class="headerlink" title="如果还连接不上"></a>如果还连接不上</h4><p>通过以上操作后，依然无法连接上，问题可能出在了防火墙上。</p>
<p>1，<code>MySQL</code>部署在实体服务器上解决方案如下：<br>a.开放<code>MySQL</code>的端口号，默认端口号是<code>3306</code>。<br>b.直接关闭防火墙（慎重操作，不建议。当然测试玩的话就随意了。。。。）</p>
<p>2，<code>MySQL</code>部署在云计算机上的方案如下：<br>a.以阿里云为例，找到实例，设置安全组，开放端口号即可。</p>
<h3 id="关于开放端口"><a href="#关于开放端口" class="headerlink" title="关于开放端口"></a>关于开放端口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#防火墙开放3306端口</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 3306 -j ACCEPT</span><br><span class="line"><span class="comment">#修改MySQL监听</span></span><br><span class="line">vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"><span class="comment">##注释掉bind-address = 127.0.0.1</span></span><br><span class="line"><span class="comment">#重启动MySQL</span></span><br><span class="line">sudo /etc/init.d/mysql restart</span><br><span class="line"><span class="comment">#开放MySQL用户远程访问权限</span></span><br><span class="line">grant all privileges on *.* to <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">flush privileges;​</span><br></pre></td></tr></table></figure>

<p>大功告成</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Cli介绍以及使用</title>
    <url>/blog/posts/8408ed11/</url>
    <content><![CDATA[<h1 id="Vue-Cli介绍以及使用"><a href="#Vue-Cli介绍以及使用" class="headerlink" title="Vue-Cli介绍以及使用"></a><code>Vue-Cli</code>介绍以及使用</h1><p><code>vue-cli</code> 官方提供的一个脚手架,用于快速生成一个 <code>vue</code> 的项目模板;<br> 预先定义好的目录结构及基础代码，就好比咱们在创建 <code>Maven</code> 项目时可以选择创建一个骨架项目，这个骨架项目就是脚手架,我们的开发更加的快速;<br>主要的功能:</p>
<ul>
<li> 统一的目录结构</li>
<li> 本地调试</li>
<li> 热部署</li>
<li> 单元测试</li>
<li> 集成打包上线</li>
</ul>
<span id="more"></span>

<blockquote>
<p>需要的环境</p>
</blockquote>
<p><code>Node.js</code> : <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9kb3dubG9hZC8=">http://nodejs.cn/download/</span><br>安装就无脑下一步就好,安装在自己的环境目录下</p>
<p>Git : <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb3dubG9hZHM=">https://git-scm.com/downloads</span><br>镜像:<span class="exturl" data-url="aHR0cHM6Ly9ucG0udGFvYmFvLm9yZy9taXJyb3JzL2dpdC1mb3Itd2luZG93cy8=">https://npm.taobao.org/mirrors/git-for-windows/</span></p>
<p>确认<code>nodejs</code>安装成功:<br><code>cmd</code> 下输入 <code>node -v</code>,查看是否能够正确打印出版本号即可!<br><code>cmd</code> 下输入 <code>npm -v</code>,查看是否能够正确打印出版本号即可!<br>这个<code>npm</code>,就是一个软件包管理工具,就和<code>linux</code>下的<code>apt</code>软件安装差不多!<br>安装 <code>Node.js</code> 淘宝镜像加速器（<code>cnpm</code>）<br>这样子的话,下载会快很多~<br>在命令台输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -g 就是全局安装</span><br><span class="line">npm install cnpm -g</span><br><span class="line"># 或使用如下语句解决 npm 速度慢的问题</span><br><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>安装的位置:<code>C:\Users\Administrator\AppData\Roaming\npm</code></p>


<h2 id="安装-vue-cli"><a href="#安装-vue-cli" class="headerlink" title="安装 vue-cli"></a>安装 <code>vue-cli</code></h2><p>以下皆为狂神版本,但感觉有点问题</p>
<hr>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在命令台输入</span></span><br><span class="line">cnpm install vue-cli -g</span><br><span class="line"><span class="comment">#查看是否安装成功</span></span><br><span class="line">vue list</span><br></pre></td></tr></table></figure>
## 第一个 ``vue-cli`` 应用程序

<p>创建一个<code>Vue</code>项目,我们随便建立一个空的文件夹在电脑上<br>创建一个基于 <code>webpack</code> 模板的 <code>vue</code>应用程序</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这里的 myvue 是项目名称，可以根据自己的需求起名</span></span><br><span class="line">vue init webpack myvue</span><br></pre></td></tr></table></figure>
<p>一路都选择<code>no</code>即可;<br>初始化并运行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> myvue</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
<hr>

<p><span class="exturl" data-url="aHR0cHM6Ly9jbGkudnVlanMub3JnL3poL2d1aWRlL2NyZWF0aW5nLWEtcHJvamVjdC5odG1sI3Z1ZS1jcmVhdGU=">官网方法使用Vue-Cli创建项目链接</span></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3>

<blockquote>
<p>可以使用下列任一命令安装这个新的包：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure>

<p>安装之后，你就可以在命令行中访问 <code>vue</code> 命令。你可以通过简单运行 <code>vue</code>，看看是否展示出了一份所有可用命令的帮助信息，来验证它是否安装成功。</p>
<p>你还可以用这个命令来检查其版本是否正确：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue --version</span><br></pre></td></tr></table></figure>

<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>如需升级全局的 <code>Vue CLI</code> 包，请运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm update -g @vue/cli</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">yarn global upgrade --latest @vue/cli</span><br></pre></td></tr></table></figure>

<h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h3><p>上面列出来的命令是用于升级全局的 <code>Vue CLI</code>。如需升级项目中的 <code>Vue CLI</code> 相关模块（以 <code>@vue/cli-plugin-</code> 或 <code>vue-cli-plugin-</code> 开头），请在项目目录下运行 <code>vue upgrade：</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">用法： upgrade [options] [plugin-name]</span><br><span class="line"></span><br><span class="line">（试用）升级 Vue CLI 服务及插件</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -t, --to &lt;version&gt;    升级 &lt;plugin-name&gt; 到指定的版本</span><br><span class="line">  -f, --from &lt;version&gt;  跳过本地版本检测，默认插件是从此处指定的版本升级上来</span><br><span class="line">  -r, --registry &lt;url&gt;  使用指定的 registry 地址安装依赖</span><br><span class="line">  --all                 升级所有的插件</span><br><span class="line">  --next                检查插件新版本时，包括 alpha/beta/rc 版本在内</span><br><span class="line">  -h, --<span class="built_in">help</span>            输出帮助内容</span><br></pre></td></tr></table></figure>
<h3 id="官网使用-Vue-Cli-创建项目"><a href="#官网使用-Vue-Cli-创建项目" class="headerlink" title="官网使用``Vue-Cli`创建项目"></a>官网使用``Vue-Cli`创建项目</h3><blockquote>
<p><strong>vue create</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vue create hello-world</span><br></pre></td></tr></table></figure>

<blockquote>
<p>警告:<br>如果你在 Windows 上通过 minTTY 使用 Git Bash，交互提示符并不工作。你必须通过 winpty vue.cmd create hello-world 启动这个命令。不过，如果你仍想使用 vue create hello-world，则可以通过在 ~/.bashrc 文件中添加以下行来为命令添加别名。 alias vue=’winpty vue.cmd’ 你需要重新启动 Git Bash 终端会话以使更新后的 bashrc 文件生效。</p>
</blockquote>
<blockquote>
<p>你会被提示选取一个 preset。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。</p>
</blockquote>


<blockquote>
<p>这个默认的设置非常适合快速创建一个新项目的原型，而手动设置则提供了更多的选项，它们是面向生产的项目更加需要的。</p>
</blockquote>
<p>一路<code>enter</code>:</p>





<p>项目就算是创建完成了</p>
<blockquote>
<p><code>vue create</code> 命令有一些可选项，你可以通过运行以下命令进行探索：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vue create --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">用法：create [options] &lt;app-name&gt;</span><br><span class="line">创建一个由 `vue-cli-service` 提供支持的新项目</span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">  -p, --preset &lt;presetName&gt;       忽略提示符并使用已保存的或远程的预设选项</span><br><span class="line">  -d, --default                   忽略提示符并使用默认预设选项</span><br><span class="line">  -i, --inlinePreset &lt;json&gt;       忽略提示符并使用内联的 JSON 字符串预设选项</span><br><span class="line">  -m, --packageManager &lt;<span class="built_in">command</span>&gt;  在安装依赖时使用指定的 npm 客户端</span><br><span class="line">  -r, --registry &lt;url&gt;            在安装依赖时使用指定的 npm registry</span><br><span class="line">  -g, --git [message]             强制 / 跳过 git 初始化，并可选的指定初始化提交信息</span><br><span class="line">  -n, --no-git                    跳过 git 初始化</span><br><span class="line">  -f, --force                     覆写目标目录可能存在的配置</span><br><span class="line">  -c, --<span class="built_in">clone</span>                     使用 git <span class="built_in">clone</span> 获取远程预设选项</span><br><span class="line">  -x, --proxy                     使用指定的代理创建项目</span><br><span class="line">  -b, --bare                      创建项目时省略默认组件中的新手指导信息</span><br><span class="line">  -h, --<span class="built_in">help</span>                      输出使用帮助信息</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>使用图形化界面</strong></p>
</blockquote>
<p>你也可以通过 <code>vue ui</code> 命令以图形化界面创建和管理项目：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure>
<p>上述命令会打开一个浏览器窗口，并以图形化界面将你引导至项目创建的流程。</p>


<blockquote>
<p><strong>拉取 2.x 模板 (旧版本)</strong></p>
</blockquote>
<p><code>Vue CLI &gt;= 3</code> 和旧版使用了相同的 <code>vue</code> 命令，所以 <code>Vue CLI 2 (vue-cli)</code> 被覆盖了。如果你仍然需要使用旧版本的 <code>vue init</code> 功能，你可以全局安装一个桥接工具：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br><span class="line"><span class="comment"># `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同</span></span><br><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure>

<h3 id="CLI-服务"><a href="#CLI-服务" class="headerlink" title="CLI 服务"></a>CLI 服务</h3><p>在一个 <code>Vue CLI</code> 项目中，<code>@vue/cli-service</code> 安装了一个名为 <code>vue-cli-service</code> 的命令。你可以在 <code>npm scripts</code> 中以 <code>vue-cli-service</code>、或者从终端中以 <code>./node_modules/.bin/vue-cli-service</code> 访问这个命令。</p>
<p>这是你使用默认 <code>preset</code> 的项目的 <code>package.json：</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;vue-cli-service lint&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过 <code>npm</code> 或 <code>Yarn</code> 调用这些 <code>script</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm run serve</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">yarn serve</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><code>vue-cli-service serve</code></strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">用法：vue-cli-service serve [options] [entry]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">  --open    在服务器启动时打开浏览器</span><br><span class="line">  --copy    在服务器启动时将 URL 复制到剪切版</span><br><span class="line">  --mode    指定环境模式 (默认值：development)</span><br><span class="line">  --host    指定 host (默认值：0.0.0.0)</span><br><span class="line">  --port    指定 port (默认值：8080)</span><br><span class="line">  --https   使用 https (默认值：<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p><code>vue-cli-service serve</code> 命令会启动一个开发服务器 (基于 <code>webpack-dev-server</code>) 并附带开箱即用的模块热重载 <code>(Hot-Module-Replacement)</code>。</p>
<p>除了通过命令行参数，你也可以使用 <code>vue.config.js</code> 里的 <code>devServer</code> 字段配置开发服务器。</p>
<p>命令行参数 <code>[entry]</code> 将被指定为唯一入口，而非额外的追加入口。尝试使用 <code>[entry]</code> 覆盖 <code>config.pages</code> 中的 <code>entry</code> 将可能引发错误</p>
<blockquote>
<p><strong><code>vue-cli-service build</code></strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">用法：vue-cli-service build [options] [entry|pattern]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">  --mode        指定环境模式 (默认值：production)</span><br><span class="line">  --dest        指定输出目录 (默认值：dist)</span><br><span class="line">  --modern      面向现代浏览器带自动回退地构建应用</span><br><span class="line">  --target      app | lib | wc | wc-async (默认值：app)</span><br><span class="line">  --name        库或 Web Components 模式下的名字 (默认值：package.json 中的 <span class="string">&quot;name&quot;</span> 字段或入口文件名)</span><br><span class="line">  --no-clean    在构建项目之前不清除目标目录</span><br><span class="line">  --report      生成 report.html 以帮助分析包内容</span><br><span class="line">  --report-json 生成 report.json 以帮助分析包内容</span><br><span class="line">  --watch       监听文件变化</span><br></pre></td></tr></table></figure>

<p><code>vue-cli-service build</code> 会在 <code>dist/</code> 目录产生一个可用于生产环境的包，带有 <code>JS/CSS/HTML</code> 的压缩，和为更好的缓存而做的自动的 <code>vendor chunk splitting</code>。它的 <code>chunk manifest</code> 会内联在 <code>HTML</code> 里。</p>
<p>这里还有一些有用的命令参数：</p>
<ul>
<li><code>--modern</code> 使用现代模式构建应用，为现代浏览器交付原生支持的 <code>ES2015</code> 代码，并生成一个兼容老浏览器的包用来自动回退。</li>
<li><code>--target</code> 允许你将项目中的任何组件以一个库或 <code>Web Components</code> 组件的方式进行构建。更多细节请查阅构建目标。</li>
<li><code>--report</code> 和 <code>--report-json</code> 会根据构建统计生成报告，它会帮助你分析包中包含的模块们的大小。</li>
</ul>
<blockquote>
<p><strong><code>vue-cli-service inspect</code></strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">用法：vue-cli-service inspect [options] [...paths]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">  --mode    指定环境模式 (默认值：development)</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>vue-cli-service inspect</code> 来审查一个 <code>Vue CLI</code> 项目的 <code>webpack config</code>。更多细节请查阅审查 <span class="exturl" data-url="aHR0cHM6Ly9jbGkudnVlanMub3JnL3poL2d1aWRlL3dlYnBhY2suaHRtbCMlRTUlQUUlQTElRTYlOUYlQTUlRTklQTElQjklRTclOUIlQUUlRTclOUElODQtd2VicGFjay1jb25maWc=">webpack config</span>。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode快捷键</title>
    <url>/blog/posts/d199d651/</url>
    <content><![CDATA[<h1 id="VsCode快捷键"><a href="#VsCode快捷键" class="headerlink" title="VsCode快捷键"></a><code>VsCode</code>快捷键</h1><ul>
<li><code>VS Code</code>中代码格式化<ul>
<li><code>Windows Shift + Alt + F</code></li>
<li>在<code>Mac</code>上<code>Shift + Option + F</code></li>
</ul>
</li>
<li>一行优化显示<ul>
<li><code>Alt + Z </code></li>
</ul>
</li>
</ul>
<h1 id="IDEA常用"><a href="#IDEA常用" class="headerlink" title="IDEA常用"></a><code>IDEA</code>常用</h1><ul>
<li><code>Ctrl + Z</code> 撤销 （必备）</li>
<li><code>Ctrl + Shift + Z</code> 恢复 （必备）<span id="more"></span></li>
<li><code>Ctrl + Y</code> 删除光标所在行 或 删除选中的行 （必备）</li>
<li><code>Ctrl + W</code> 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围（必备）</li>
<li><code>Ctrl + E</code> 显示最近打开的文件记录列表 （必备）</li>
<li><code>Ctrl + Q</code> 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</li>
<li><code>Ctrl + U</code> 前往当前光标所在的方法的父类的方法 / 接口定义 （必备）</li>
<li><code>Ctrl + H</code> 显示当前类的层次结构</li>
<li><code>Ctrl + F1</code> 在光标所在的错误代码处显示错误信息 （必备）</li>
<li><code>Ctrl + F3</code> 调转到所选中的词的下一个引用位置 （必备）</li>
<li><code>Ctrl + Alt + L</code> 格式化代码，可以对当前文件和整个包目录使用 （必备）</li>
<li><code>Ctrl + Alt + S</code> 打开 <code>IntelliJ IDEA</code> 系统设置 （必备）</li>
<li><code>Ctrl + Alt + Enter</code> 光标所在行上空出一行，光标定位到新行 （必备）</li>
<li><code>Alt + Shift + 前方向键</code> 移动光标所在行向上移动 （必备）</li>
<li><code>Ctrl + Shift + Alt + V </code>无格式黏贴 （必备)</li>
<li><code>F3</code> 在查找模式下，定位到下一个匹配处</li>
<li><code>F4</code> 编辑源 （必备）</li>
<li><code>Ctrl + Shift + F7</code> 高亮显示所有该选中文本，按 <code>Esc</code> 高亮消失 （必备）</li>
<li><code>Ctrl + Shift + Alt + U</code> 自动生成<code>UML</code>图,是真的方便. </li>
<li><code>Ctrl + Shift + Alt + J</code> 选中相同的</li>
</ul>
]]></content>
      <categories>
        <category>VSCODE</category>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>VSCODE</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode 如何Debug Shell</title>
    <url>/blog/posts/823298d2/</url>
    <content><![CDATA[<h2 id="1-下载Vscode插件-Bash-Debug"><a href="#1-下载Vscode插件-Bash-Debug" class="headerlink" title="1. 下载Vscode插件 Bash Debug"></a>1. 下载<code>Vscode</code>插件 <code>Bash Debug</code></h2><img data-src="/blog/posts/823298d2/2022-07-01-10-59-08.png" class="">

<span id="more"></span>

<h2 id="2-create-launch-json-file"><a href="#2-create-launch-json-file" class="headerlink" title="2. create launch.json file"></a>2. <code>create launch.json file</code></h2><p>选择<code>Bash Debug</code></p>
<img data-src="/blog/posts/823298d2/2022-07-01-11-04-35.png" class="">

<h2 id="3-添加配置"><a href="#3-添加配置" class="headerlink" title="3. 添加配置"></a>3. 添加配置</h2><img data-src="/blog/posts/823298d2/2022-07-01-11-06-45.png" class="">

<img data-src="/blog/posts/823298d2/2022-07-01-11-07-31.png" class="">

<p>使用下拉菜单选中刚刚我们添加的 <code>select script from list of sh files</code>，点击播放键运行。</p>
<p>选择想<code>debug</code>的脚本，然后开始</p>
<h2 id="4-查看变量名"><a href="#4-查看变量名" class="headerlink" title="4. 查看变量名"></a>4. 查看变量名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;变量名&#125;</span></span><br><span class="line"><span class="comment"># 格式来添加，要确认哪个就添加哪个。</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>VsCode</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3项目的创建</title>
    <url>/blog/posts/21d4b84b/</url>
    <content><![CDATA[<h1 id="Vue3项目的创建"><a href="#Vue3项目的创建" class="headerlink" title="Vue3项目的创建"></a>Vue3项目的创建</h1><p>==一般来说,创建Vue项目有两种方式==</p>
<h2 id="方法一-使用-vue-cli-创建"><a href="#方法一-使用-vue-cli-创建" class="headerlink" title="方法一:使用 vue-cli 创建"></a>方法一:使用 vue-cli 创建</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jbGkudnVlanMub3JnL3poL2d1aWRlL2NyZWF0aW5nLWEtcHJvamVjdC5odG1sI3Z1ZS1jcmVhdGU=">Vue文档</span></p>
<span id="more"></span>

<blockquote>
<p>进入一个空的文件目录创建</p>
</blockquote>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 安装或者升级</span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"></span><br><span class="line">## 保证 vue cli 版本在 4.5.0 以上</span><br><span class="line">vue --version</span><br><span class="line"></span><br><span class="line">## 创建项目</span><br><span class="line">vue create &lt;项目名&gt;</span><br><span class="line"></span><br><span class="line">## 进入项目 </span><br><span class="line">cd  &lt;项目名&gt;</span><br><span class="line"></span><br><span class="line">## 启动项目</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<p><strong>然后的步骤</strong></p>
<ul>
<li><code>Please pick a preset</code> - 选择 <code>Manually select features</code></li>
<li><code>Check the features needed for your project</code> - 选择上 <code>TypeScript</code> ，特别注意点空格是选择，点回车是下一步</li>
<li><code>Choose a version of Vue.js that you want to start the project with</code> - 选择 <code>3.x</code> (<code>Preview</code>)</li>
<li><code>Use class-style component syntax</code> - 直接回车</li>
<li><code>Use Babel alongside TypeScript</code> - 直接回车</li>
<li><code>Pick a linter / formatter config</code> - 直接回车</li>
<li><code>Use history mode for router?</code> - 直接回车</li>
<li><code>Pick a linter / formatter config</code> - 直接回车</li>
<li><code>Pick additional lint features</code> - 直接回车</li>
<li><code>Where do you prefer placing config for Babel, ESLint, etc.?</code> - 直接回车</li>
<li><code>Save this as a preset for future projects?</code> - 直接回车</li>
</ul>
<h2 id="方法二-使用-vite-创建"><a href="#方法二-使用-vite-创建" class="headerlink" title="方法二:使用 vite 创建"></a>方法二:使用 vite 创建</h2><p><span class="exturl" data-url="aHR0cHM6Ly92My5jbi52dWVqcy5vcmcvZ3VpZGUvaW5zdGFsbGF0aW9uLmh0bWw=">文档链接</span></p>
<ul>
<li><p><code>vite</code> 是一个由原生 ESM 驱动的 Web 开发构建工具。在开发环境下基于浏览器原生 ES imports 开发，</p>
</li>
<li><p>它做到了<strong>本地快速开发启动</strong>, 在生产环境下基于 <code>Rollup</code> 打包。</p>
<ul>
<li>快速的冷启动，不需要等待打包操作；</li>
<li>即时的热模块更新，替换性能和模块数量的解耦让更新飞起；</li>
<li>真正的按需编译，不再等待整个应用编译完成，这是一个巨大的改变。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line">cd &lt;project-name&gt;</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>


<h2 id="使用Vue-Cli工程各目录介绍"><a href="#使用Vue-Cli工程各目录介绍" class="headerlink" title="使用Vue-Cli工程各目录介绍"></a>使用Vue-Cli工程各目录介绍</h2><h2 id="Vue修改端口号"><a href="#Vue修改端口号" class="headerlink" title="Vue修改端口号"></a><code>Vue</code>修改端口号</h2><p><code>package.json</code>文件下修改 <code>–port</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">   <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve --port 9991&quot;</span>,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>vue.config.js</code>文件下添加 (如果没有就在根目录下创建文件)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="number">9991</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Web-based design and analysis tools for CRISPR base editing 文献阅读</title>
    <url>/blog/posts/4da9c93/</url>
    <content><![CDATA[<h2 id="Web-based-design-and-analysis-tools-for-CRISPR-base-editing"><a href="#Web-based-design-and-analysis-tools-for-CRISPR-base-editing" class="headerlink" title="Web-based design and analysis tools for CRISPR base editing"></a><code>Web-based design and analysis tools for CRISPR base editing</code></h2><span id="more"></span>


]]></content>
      <tags>
        <tag>生物信息</tag>
        <tag>基因编辑</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue实现Yaml验证组件</title>
    <url>/blog/posts/bd30a519/</url>
    <content><![CDATA[<p>最近用到了<code>Vue</code>页面使用<code>Yaml</code>编辑器，但是这样的组件也是从来没有接触过的，这边做个记载:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTgxMTM3L2FydGljbGUvZGV0YWlscy8xMDU0NDg3MTM=">原文</span></p>
<h2 id="安装必要依赖"><a href="#安装必要依赖" class="headerlink" title="安装必要依赖"></a>安装必要依赖</h2><ol>
<li><code>npm install codemirrir@5.61.1</code></li>
<li><code>npm installl js-yaml@4.1.0</code></li>
</ol>
<h2 id="创建对应的组件"><a href="#创建对应的组件" class="headerlink" title="创建对应的组件"></a>创建对应的组件</h2><p>路径为<code>@/components/YamlEditor/index.vue</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;yaml-editor&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">ref</span>=<span class="string">&quot;textarea&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> CodeMirror <span class="keyword">from</span> <span class="string">&#x27;codemirror&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> <span class="string">&#x27;codemirror/addon/lint/lint.css&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> <span class="string">&#x27;codemirror/lib/codemirror.css&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> <span class="string">&#x27;codemirror/theme/monokai.css&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> <span class="string">&#x27;codemirror/mode/yaml/yaml&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> <span class="string">&#x27;codemirror/addon/lint/lint&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> <span class="string">&#x27;codemirror/addon/lint/yaml-lint&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">window</span>.jsyaml = <span class="built_in">require</span>(<span class="string">&#x27;js-yaml&#x27;</span>) <span class="comment">// 引入js-yaml为codemirror提高语法检查核心支持</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&#x27;YamlEditor&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">// eslint-disable-next-line vue/require-prop-types</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">props</span>: [<span class="string">&#x27;value&#x27;</span>],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">yamlEditor</span>: <span class="literal">false</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">watch</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">value</span>(<span class="params">value</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> editorValue = <span class="built_in">this</span>.yamlEditor.getValue()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">if</span> (value !== editorValue) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.yamlEditor.setValue(<span class="built_in">this</span>.value)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">this</span>.yamlEditor = CodeMirror.fromTextArea(<span class="built_in">this</span>.$refs.textarea, &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">lineNumbers</span>: <span class="literal">true</span>, <span class="comment">// 显示行号</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">mode</span>: <span class="string">&#x27;text/x-yaml&#x27;</span>, <span class="comment">// 语法model</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">gutters</span>: [<span class="string">&#x27;CodeMirror-lint-markers&#x27;</span>],  <span class="comment">// 语法检查器</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">theme</span>: <span class="string">&#x27;monokai&#x27;</span>, <span class="comment">// 编辑器主题</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">lint</span>: <span class="literal">true</span> <span class="comment">// 开启语法检查</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">this</span>.yamlEditor.setValue(<span class="built_in">this</span>.value)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">this</span>.yamlEditor.on(<span class="string">&#x27;change&#x27;</span>, <span class="function">(<span class="params">cm</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;changed&#x27;</span>, cm.getValue())</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>, cm.getValue())</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">getValue</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">return</span> <span class="built_in">this</span>.yamlEditor.getValue()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="selector-class">.yaml-editor</span>&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">height</span>: <span class="number">100%</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">position</span>: relative;</span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="selector-class">.yaml-editor</span> &gt;&gt;&gt; <span class="selector-class">.CodeMirror</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">height</span>: auto;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">min-height</span>: <span class="number">300px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="selector-class">.yaml-editor</span> &gt;&gt;&gt; <span class="selector-class">.CodeMirror-scroll</span>&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">min-height</span>: <span class="number">300px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="selector-class">.yaml-editor</span> &gt;&gt;&gt; <span class="selector-class">.cm-s-rubyblue</span> <span class="selector-tag">span</span><span class="selector-class">.cm-string</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">color</span>: <span class="number">#F08047</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><code>codemirror</code>的核心配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.yamlEditor = CodeMirror.fromTextArea(<span class="built_in">this</span>.$refs.textarea, &#123;</span><br><span class="line">    <span class="attr">lineNumbers</span>: <span class="literal">true</span>, <span class="comment">// 显示行号</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;text/x-yaml&#x27;</span>, <span class="comment">// 语法model</span></span><br><span class="line">    <span class="attr">gutters</span>: [<span class="string">&#x27;CodeMirror-lint-markers&#x27;</span>],  <span class="comment">// 语法检查器</span></span><br><span class="line">    <span class="attr">theme</span>: <span class="string">&#x27;monokai&#x27;</span>, <span class="comment">// 编辑器主题</span></span><br><span class="line">    <span class="attr">lint</span>: <span class="literal">true</span> <span class="comment">// 开启语法检查</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里的配置只有几个简单的参数，更多的详细参数配置可以移步<span class="exturl" data-url="aHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9kb2MvbWFudWFsLmh0bWw=">官方文档</span>；如果想让编辑器支持其他语言，可以查看codemirror官方文档的<span class="exturl" data-url="aHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9tb2RlLw==">语法支持</span>，这里我个人比较倾向下载<code>codemirror</code>源码，可以看到对应语法<code>demo</code>源代码，使用不同的语法在本组件中<code>import</code>相应的依赖即可。</p>
<p>这边不同的主题: <span class="exturl" data-url="aHR0cHM6Ly9jb2RlbWlycm9yLm5ldC81L3RoZW1lLw==">theme</span></p>
<h2 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;editor-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">yaml-editor</span>  <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml">import YamlEditor from &#x27;@/components/YamlEditor/index.vue&#x27;;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml"></span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml">const yamlData = &quot;- hosts: all\n  become: yes\n  become_method: sudo\n  gather_facts: no\n\n  tasks:\n  - name: \&quot;install </span><span class="template-variable">&#123;&#123; <span class="name">package_name</span> &#125;&#125;</span><span class="xml">\&quot;\n    package:\n      name: \&quot;</span><span class="template-variable">&#123;&#123; <span class="name">package_name</span> &#125;&#125;</span><span class="xml">\&quot;\n      state: \&quot;</span><span class="template-variable">&#123;&#123; <span class="name">state</span> | default(<span class="name">&#x27;present&#x27;</span>) &#125;&#125;</span><span class="xml">\&quot;&quot;;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml"></span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml">export default &#123;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml">  name: &#x27;YamlEditorDemo&#x27;,</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml">  components: &#123; YamlEditor &#125;,</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml">  data() &#123;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml">    return &#123;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml">      value: yamlData,</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml">    &#125;;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml">  &#125;,</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml">&#125;;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="selector-class">.editor-container</span>&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">position</span>: relative;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">height</span>: <span class="number">100%</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<img data-src="/blog/posts/bd30a519/2022-08-21-22-50-44.png" class="">


]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下如何查看某个端口被谁占用</title>
    <url>/blog/posts/e694a882/</url>
    <content><![CDATA[<h2 id="查找所有运行的端口"><a href="#查找所有运行的端口" class="headerlink" title="查找所有运行的端口"></a>查找所有运行的端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="查看被占用端口对应的-PID"><a href="#查看被占用端口对应的-PID" class="headerlink" title="查看被占用端口对应的 PID"></a>查看被占用端口对应的 <code>PID</code></h2><p>输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -aon|findstr &quot;8081&quot;</span><br></pre></td></tr></table></figure>
<h2 id="查看指定-PID-的进程"><a href="#查看指定-PID-的进程" class="headerlink" title="查看指定 PID 的进程"></a>查看指定 <code>PID</code> 的进程</h2><p>继续输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tasklist|findstr &quot;9088&quot;</span><br></pre></td></tr></table></figure>

<h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><p>强制（<code>/F</code>参数）杀死 <code>pid</code> 为 9088 的所有进程包括子进程（<code>/T</code>参数）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">taskkill /T /F /PID 9088 </span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>flex布局</title>
    <url>/blog/posts/e43580c1/</url>
    <content><![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html"><code>Flex</code>布局学习</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>equals与==区别</title>
    <url>/blog/posts/f23f1351/</url>
    <content><![CDATA[<h1 id="equals与-区别"><a href="#equals与-区别" class="headerlink" title="equals与 ==区别"></a><code>equals</code>与 <code>==</code>区别</h1><p><code>Java</code>中数据类型分两种：</p>
<ol>
<li>基本类型：<code>long,int,byte,float,double</code></li>
<li>对象类型：<code>Long,Integer,Byte,Float,Double</code>其它一切<code>java</code>提供的，或者你自己创建的类。</li>
</ol>
<span id="more"></span>

<p>其中<code>Long</code>叫 <code>long</code>的包装类。<code>Integer、Byte</code>和<code>Float</code>也类似，一般包装类的名字首写是数值名的大写开头。</p>
<blockquote>
<p>什么是包装类？</p>
</blockquote>
<p>在<code>java</code>中有时候的运算必须是两个类对象之间进行的，不允许对象与数字之间进行运算。所以需要有一个对象，这个对象把数字进行了一下包装，这样这个对象就可以和另一个对象进行运算了。</p>
<p>比如我们可以定义一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Long</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Long</span> <span class="params">(<span class="keyword">int</span> i)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.i=i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这个<code>Long</code> 就是一个包装类，它包装了一个整数值，然后可以在里面写一些运算符重载的方法使它支持某些运算。这个时候可以赋值：</p>
<p><code>Long l = new Long(10);</code></p>
<p>现在变量 <code>l</code> 就是一个对象，不是一个数字。 </p>
<p><code>long</code>是原始数据类型,没有属性方法,只能进行数学运算，<code>Long</code>是<code>long</code>相对应的引用数据类型，它有方法和属性，一个没方法属性，一个有方法属性,这就是它们的区别。</p>
<h2 id="解读"><a href="#解读" class="headerlink" title="==解读"></a><code>==</code>解读</h2><p>对于基本类型和引用类型 <code>==</code> 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同；</li>
<li>引用类型：比较的是引用是否相同；</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String x = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">String y = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>代码解读：因为 <code>x</code> 和 <code>y</code> 指向的是同一个引用，所以 <code>== </code>也是 <code>true</code>，而 <code>new String()</code>方法则重写开辟了内存空间，所以 <code>== </code>结果为 <code>false</code>，而 <code>equals</code> 比较的一直是值，所以结果都为 <code>true</code>。</p>
<h2 id="equals-解读"><a href="#equals-解读" class="headerlink" title="equals 解读"></a><code>equals</code> 解读</h2><p><code>equals</code> 本质上就是 <code>==</code>，只不过<code> String</code> 和 <code>Integer</code> 等重写了 <code>equals</code> 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 <code>equals</code> 比较一个有相同值的对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat c1 = <span class="keyword">new</span> Cat(<span class="string">&quot;王磊&quot;</span>);</span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat(<span class="string">&quot;王磊&quot;</span>);</span><br><span class="line">System.out.println(c1.equals(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>输出结果出乎我们的意料，竟然是 <code>false？</code>这是怎么回事，看了 <code>equals </code>源码就知道了，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来 <code>equals</code> 本质上就是 ==。<br>那问题来了，两个相同值的<code>String</code>对象，为什么返回的是<code> true？</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>同样的，当我们进入 <code>String</code> 的 <code>equals</code> 方法，找到了答案，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来是 <code>String</code> 重写了 <code>Object</code> 的 <code>equals</code> 方法，把引用比较改成了值比较。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 <code>equals</code> 默认情况下是引用比较，只是很多类重写了 <code>equals</code> 方法，比如 <code>String、Integer</code> 等把它变成了值比较，所以一般情况下 <code>equals</code> 比较的是值是否相等。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo</span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting</span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub</span>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing</span></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server</span></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating</span></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment</span></p>
]]></content>
  </entry>
  <entry>
    <title>java判断日期周几</title>
    <url>/blog/posts/60a1e80e/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">String Date = <span class="string">&quot;2020-08-03&quot;</span>;  <span class="comment">//定义初始是周一</span></span><br><span class="line">Date testdate = sdf.parse(Date);</span><br><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line">cal.setTime(testdate); </span><br><span class="line"><span class="keyword">if</span>(cal.get(Calendar.DAY_OF_WEEK)==Calendar.MONDAY)&#123;</span><br><span class="line">    System.out.println(sdf.format(cal.getTime())+<span class="string">&quot;=========&quot;</span>+<span class="string">&quot;是周一=========&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//日期加一天</span></span><br><span class="line">cal.add(Calendar.DATE,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(cal.get(Calendar.DAY_OF_WEEK)==Calendar.TUESDAY) &#123;</span><br><span class="line">    System.out.println(sdf.format(cal.getTime())+<span class="string">&quot;=========&quot;</span>+<span class="string">&quot;是周二=========&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">cal.add(Calendar.DATE,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(cal.get(Calendar.DAY_OF_WEEK)==Calendar.WEDNESDAY)&#123;</span><br><span class="line">    System.out.println(sdf.format(cal.getTime())+<span class="string">&quot;=========&quot;</span>+<span class="string">&quot;是周三=========&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">cal.add(Calendar.DATE,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(cal.get(Calendar.DAY_OF_WEEK)==Calendar.THURSDAY)&#123;</span><br><span class="line">    System.out.println(sdf.format(cal.getTime())+<span class="string">&quot;=========&quot;</span>+<span class="string">&quot;是周四=========&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">cal.add(Calendar.DATE,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(cal.get(Calendar.DAY_OF_WEEK)==Calendar.FRIDAY)&#123;</span><br><span class="line">    System.out.println(sdf.format(cal.getTime())+<span class="string">&quot;=========&quot;</span>+<span class="string">&quot;是周五=========&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">cal.add(Calendar.DATE,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(cal.get(Calendar.DAY_OF_WEEK)==Calendar.SATURDAY)&#123;</span><br><span class="line">    System.out.println(sdf.format(cal.getTime())+<span class="string">&quot;=========&quot;</span>+<span class="string">&quot;是周六=========&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">cal.add(Calendar.DATE,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(cal.get(Calendar.DAY_OF_WEEK)==Calendar.SUNDAY)&#123;</span><br><span class="line">    System.out.println(sdf.format(cal.getTime())+<span class="string">&quot;=========&quot;</span>+<span class="string">&quot;是周日=========&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>日期</tag>
      </tags>
  </entry>
  <entry>
    <title>java stream中Collectors的用法</title>
    <url>/blog/posts/b1231c9f/</url>
    <content><![CDATA[<h1 id="java-stream中Collectors的用法"><a href="#java-stream中Collectors的用法" class="headerlink" title="java stream中Collectors的用法"></a><code>java stream</code>中<code>Collectors</code>的用法</h1><ul>
<li><a href="#java-stream%E4%B8%ADcollectors%E7%9A%84%E7%94%A8%E6%B3%95"><code>java stream</code>中<code>Collectors</code>的用法</a><ul>
<li><a href="#%E7%AE%80%E4%BB%8B"><span id="common">简介</span></a></li>
<li><a href="#collectorstolist"><span id="toList"><code>Collectors.toList()</code></span></a></li>
<li><a href="#collectorstoset"><span id="toSet"><code>Collectors.toSet()</code></span></a></li>
<li><a href="#collectorstocollection"><span id="toColl"><code>Collectors.toCollection()</code></span></a></li>
<li><a href="#collectorstomap"><span id="toMap"><code>Collectors.toMap()</code></span></a></li>
<li><a href="#collectorscollectingandthen"><span id="toCollAndThen"><code>Collectors.collectingAndThen()</code></span></a></li>
<li><a href="#collectorsjoining"><span id="join"><code>Collectors.joining()</code></span></a></li>
<li><a href="#collectorscounting"><span id="count"><code>Collectors.counting()</code></span></a></li>
<li><a href="#collectorssummarizingdoublelongint"><span id="sum"><code>Collectors.summarizingDouble/Long/Int()</code></span></a></li>
<li><a href="#collectorsaveragingdoublelongint"><span id="average"><code>Collectors.averagingDouble/Long/Int()</code></span></a></li>
<li><a href="#collectorssummingdoublelongint"><span id="summing"><code>Collectors.summingDouble/Long/Int()</code></span></a></li>
<li><a href="#collectorsmaxbyminby"><span id="max"><code>Collectors.maxBy()/minBy()</code></span></a></li>
<li><a href="#collectorsgroupingby"><span id="group"><code>Collectors.groupingBy()</code></span></a></li>
<li><a href="#collectorspartitioningby"><span id="par"><code>Collectors.partitioningBy()</code></span></a></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><span id="common">简介</span></h2><p>在<code>java stream</code>中，我们通常需要将处理后的<code>stream</code>转换成集合类，这个时候就需要用到<code>stream.collect</code>方法。<code>collect</code>方法需要传入一个<code>Collector</code>类型，要实现<code>Collector</code>还是很麻烦的，需要实现好几个接口。</p>
<p>于是<code>java</code>提供了更简单的<code>Collectors</code>工具类来方便我们构建<code>Collector</code>。</p>
<p>下面我们将会具体讲解<code>Collectors</code>的用法。</p>
<p>假如我们有这样两个<code>list：</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;mark&quot;</span>);</span><br><span class="line">List&lt;String&gt; duplicateList = Arrays.asList(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;mark&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面一个是无重复的<code>list</code>，一个是带重复数据的<code>list</code>。接下来的例子我们会用上面的两个<code>list</code>来讲解<code>Collectors</code>的用法。</p>
<h2 id="Collectors-toList"><a href="#Collectors-toList" class="headerlink" title="Collectors.toList()"></a><span id="toList"><code>Collectors.toList()</code></span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; listResult = list.stream().collect(Collectors.toList());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,listResult);</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/b1231c9f/2022-02-13-23-13-35.png" class="">

<p>将<code>stream</code>转换为<code>list</code>。这里转换的<code>list</code>是<code>ArrayList</code>，如果想要转换成特定的<code>list</code>，需要使用<code>toCollection</code>方法。</p>
<h2 id="Collectors-toSet"><a href="#Collectors-toSet" class="headerlink" title="Collectors.toSet()"></a><span id="toSet"><code>Collectors.toSet()</code></span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; setResult = list.stream().collect(Collectors.toSet());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,setResult);</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/b1231c9f/2022-02-13-23-13-55.png" class="">

<h2 id="Collectors-toCollection"><a href="#Collectors-toCollection" class="headerlink" title="Collectors.toCollection()"></a><span id="toColl"><code>Collectors.toCollection()</code></span></h2><p>上面的<code>toMap,toSet</code>转换出来的都是特定的类型，如果我们需要自定义，则可以使用<code>toCollection()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; custListResult = list.stream().collect(Collectors.toCollection(LinkedList::<span class="keyword">new</span>));</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,custListResult);</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/b1231c9f/2022-02-13-23-14-12.png" class="">

<h2 id="Collectors-toMap"><a href="#Collectors-toMap" class="headerlink" title="Collectors.toMap()"></a><span id="toMap"><code>Collectors.toMap()</code></span></h2><p><code>toMap</code>接收两个参数，第一个参数是<code>keyMapper</code>，第二个参数是<code>valueMapper</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; mapResult = list.stream()</span><br><span class="line">                .collect(Collectors.toMap(Function.identity(), String::length));</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,mapResult);</span><br></pre></td></tr></table></figure>
<p>如果<code>stream</code>中有重复的值，则转换会报<code>IllegalStateException</code>异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; duplicateMapResult = duplicateList.stream()</span><br><span class="line">                .collect(Collectors.toMap(Function.identity(), String::length));</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/b1231c9f/2022-02-13-23-14-26.png" class="">

<p>解决方案:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; duplicateMapResult2 = duplicateList.stream()</span><br><span class="line">                .collect(Collectors.toMap(Function.identity(), String::length, (item, identicalItem) -&gt; item));</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,duplicateMapResult2);</span><br></pre></td></tr></table></figure>
<p>在<code>toMap</code>中添加第三个参数<code>mergeFunction</code>，来解决冲突的问题。</p>
<img data-src="/blog/posts/b1231c9f/2022-02-13-23-14-53.png" class="">

<h2 id="Collectors-collectingAndThen"><a href="#Collectors-collectingAndThen" class="headerlink" title="Collectors.collectingAndThen()"></a><span id="toCollAndThen">Collectors.collectingAndThen()</span></h2><p><code>collectingAndThen</code>允许我们对生成的集合再做一次操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; collectAndThenResult = list.stream()</span><br><span class="line">                .collect(Collectors.collectingAndThen(Collectors.toList(), l -&gt; &#123;<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(l);&#125;));</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,collectAndThenResult);</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/b1231c9f/2022-02-13-23-15-04.png" class="">

<h2 id="Collectors-joining"><a href="#Collectors-joining" class="headerlink" title="Collectors.joining()"></a><span id="join"><code>Collectors.joining()</code></span></h2><p><code>Joining</code>用来连接<code>stream</code>中的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String joinResult = list.stream().collect(Collectors.joining());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,joinResult);</span><br><span class="line">        String joinResult1 = list.stream().collect(Collectors.joining(<span class="string">&quot; &quot;</span>));</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,joinResult1);</span><br><span class="line">        String joinResult2 = list.stream().collect(Collectors.joining(<span class="string">&quot; &quot;</span>, <span class="string">&quot;prefix&quot;</span>,<span class="string">&quot;suffix&quot;</span>));</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,joinResult2);</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/b1231c9f/2022-02-13-23-15-15.png" class="">

<p>可以不带参数，也可以带一个参数，也可以带三个参数，根据我们的需要进行选择。</p>
<h2 id="Collectors-counting"><a href="#Collectors-counting" class="headerlink" title="Collectors.counting()"></a><span id="count"><code>Collectors.counting()</code></span></h2><p><code>counting</code>主要用来统计<code>stream</code>中元素的个数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long countResult = list.stream().collect(Collectors.counting());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,countResult);</span><br></pre></td></tr></table></figure>


<img data-src="/blog/posts/b1231c9f/2022-02-13-23-15-42.png" class="">

<h2 id="Collectors-summarizingDouble-Long-Int"><a href="#Collectors-summarizingDouble-Long-Int" class="headerlink" title="Collectors.summarizingDouble/Long/Int()"></a><span id="sum"><code>Collectors.summarizingDouble/Long/Int()</code></span></h2><p><code>SummarizingDouble/Long/Int</code>为<code>stream</code>中的元素生成了统计信息，返回的结果是一个统计类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntSummaryStatistics intResult = list.stream()</span><br><span class="line">                .collect(Collectors.summarizingInt(String::length));</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,intResult);</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/b1231c9f/2022-02-13-23-16-28.png" class="">

<h2 id="Collectors-averagingDouble-Long-Int"><a href="#Collectors-averagingDouble-Long-Int" class="headerlink" title="Collectors.averagingDouble/Long/Int()"></a><span id="average"><code>Collectors.averagingDouble/Long/Int()</code></span></h2><p><code>averagingDouble/Long/Int()</code>对<code>stream</code>中的元素做平均：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double averageResult = list.stream().collect(Collectors.averagingInt(String::length));</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,averageResult);</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/b1231c9f/2022-02-13-23-16-42.png" class="">

<h2 id="Collectors-summingDouble-Long-Int"><a href="#Collectors-summingDouble-Long-Int" class="headerlink" title="Collectors.summingDouble/Long/Int()"></a><span id="summing"><code>Collectors.summingDouble/Long/Int()</code></span></h2><p><code>summingDouble/Long/Int()</code>对<code>stream</code>中的元素做<code>sum</code>操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double summingResult = list.stream().collect(Collectors.summingDouble(String::length));</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,summingResult);</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/b1231c9f/2022-02-13-23-17-11.png" class="">

<h2 id="Collectors-maxBy-minBy"><a href="#Collectors-maxBy-minBy" class="headerlink" title="Collectors.maxBy()/minBy()"></a><span id="max"><code>Collectors.maxBy()/minBy()</code></span></h2><p><code>maxBy()/minBy()</code>根据提供的<code>Comparator</code>，返回<code>stream</code>中的最大或者最小值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; maxByResult = list.stream().collect(Collectors.maxBy(Comparator.naturalOrder()));</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,maxByResult);</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/b1231c9f/2022-02-13-23-17-22.png" class="">

<h2 id="Collectors-groupingBy"><a href="#Collectors-groupingBy" class="headerlink" title="Collectors.groupingBy()"></a><span id="group"><code>Collectors.groupingBy()</code></span></h2><p><code>GroupingBy</code>根据某些属性进行分组，并返回一个<code>Map</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Set&lt;String&gt;&gt; groupByResult = list.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(String::length, Collectors.toSet()));</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,groupByResult);</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/b1231c9f/2022-02-13-23-17-31.png" class="">

<h2 id="Collectors-partitioningBy"><a href="#Collectors-partitioningBy" class="headerlink" title="Collectors.partitioningBy()"></a><span id="par"><code>Collectors.partitioningBy()</code></span></h2><p><code>PartitioningBy</code>是一个特别的<code>groupingBy，PartitioningBy</code>返回一个<code>Map</code>，这个<code>Map</code>是以<code>boolean</code>值为<code>key</code>，从而将<code>stream</code>分成两部分，一部分是匹配<code>PartitioningBy</code>条件的，一部分是不满足条件的：</p>
<img data-src="/blog/posts/b1231c9f/2022-02-13-23-17-39.png" class="">



]]></content>
      <categories>
        <category>Java</category>
        <category>Stream</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>git项目中统计每个人提交代码行数</title>
    <url>/blog/posts/2543b551/</url>
    <content><![CDATA[<p>发现一个很有趣的，统计<code>git</code>项目中每个人提交代码的行数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --format=&#x27;%aN&#x27; | sort -u | while read name; do echo -en &quot;作者： $name\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加行数: %s, 删除的行数: %s, 代码总行数: %s\n&quot;, add, subs, loc &#125;&#x27; -; done</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/2543b551/2022-08-16-21-34-50.png" class="">]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 获取当前日期及格式化</title>
    <url>/blog/posts/96e2d97b/</url>
    <content><![CDATA[<p><code>MYSQL</code> 获取当前日期及日期格式</p>
<ul>
<li>获取系统日期： <code>NOW()</code></li>
<li>格式化日期： <code>DATE_FORMAT(date, format)</code></li>
</ul>
<p>注： date：时间字段<br>format：日期格式</p>
<span id="more"></span>

<ul>
<li><p><code>select now();</code></p>
<p>  输出<code>2021-12-16 17:20:21</code></p>
</li>
<li><p><code>select date_format(now(),&#39;%Y-%m-%d&#39;);</code></p>
<p>  输出<code>2021-12-16</code></p>
</li>
</ul>
<p>根据<code>format</code>字符串格式化<code>date</code>值:<br>参数值 | 效果<br>—-|—<br><code>%S, %s</code> | 两位数字形式的秒（<code>00,01, ..., 59</code>）<br><code>%I, %i</code> | 两位数字形式的分（ <code>00,01, ..., 59</code>）<br><code>%H</code> | 两位数字形式的小时，<code>24</code> 小时（<code>00,01, ..., 23</code>）<br><code>%h</code> | 两位数字形式的小时，<code>12</code> 小时（<code>01,02, ..., 12</code>）<br><code>%k</code> | 数字形式的小时，<code>24</code> 小时（<code>0,1, ..., 23</code>）<br><code>%l</code> | 数字形式的小时，<code>12</code> 小时（<code>1, 2, ..., 12</code>）<br><code>%T</code> | <code>24</code> 小时的时间形式（<code>hh:mm:ss</code>）<br><code>%r</code> | <code>12</code> 小时的时间形式（<code>hh:mm:ss AM</code> 或<code>hh:mm:ss PM</code>）<br><code>%p</code> | <code>AM</code>或<code>PM</code><br><code>%W</code> | 一周中每一天的名称（<code>Sunday, Monday, ..., Saturday</code>）<br><code>%a</code> | 一周中每一天名称的缩写（<code>Sun, Mon, ..., Sat</code>）<br><code>%d</code> | 两位数字表示月中的天数（<code>00, 01,..., 31</code>）<br><code>%e</code> | 数字形式表示月中的天数（<code>1, 2， ..., 31</code>）<br><code>%D</code> | 英文后缀表示月中的天数（<code>1st, 2nd, 3rd,...</code>）<br><code>%w</code> | 以数字形式表示周中的天数（ <code>0 = Sunday, 1=Monday, ..., 6=Saturday</code>）<br><code>%j</code> | 以三位数字表示年中的天数（ <code>001, 002, ..., 366</code>）<br><code>%U</code> | 周（<code>0, 1, 52</code>），其中<code>Sunday</code> 为周中的第一天<br><code>%u</code> | 周（<code>0, 1, 52</code>），其中<code>Monday</code> 为周中的第一天<br><code>%M</code> | 月名（<code>January, February, ..., December</code>）<br><code>%b</code> | 缩写的月名（ <code>January, February,...., December</code>）<br><code>%m</code> | 两位数字表示的月份（<code>01, 02, ..., 12</code>）<br><code>%c</code> | 数字表示的月份（<code>1, 2, ...., 12</code>）<br><code>%Y</code> | 四位数字表示的年份<br><code>%y</code> | 两位数字表示的年份<br><code>%%</code> | 直接值<code>“%”</code></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>java中产生指定范围内的随机数</title>
    <url>/blog/posts/817eab42/</url>
    <content><![CDATA[<ol>
<li><p><code>Math.random()</code>方法返回一个<code>[0.0 , 1.0)</code>的伪随机<code>double</code>类型的随机数</p>
</li>
<li><p><code>[min,max]</code>范围内的数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>    num = min + (<span class="keyword">int</span>)(Math.random() * (max-min));</span><br><span class="line"><span class="keyword">double</span> num = min + (Math.random() * (max-min));</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li><p>用<code>nextInt</code>方法生成区间范围内的随机整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random rand=<span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> n1=rand.nextInt(<span class="number">100</span>);<span class="comment">//返回值在范围[0,100) 即[0,99]</span></span><br><span class="line">        <span class="keyword">int</span> n2=rand.nextInt(<span class="number">100</span>)+<span class="number">1</span>;<span class="comment">//[1,100]内的随机整数</span></span><br><span class="line">        <span class="keyword">int</span> n3=rand.nextInt(<span class="number">80</span>)+<span class="number">10</span>;<span class="comment">//[10,89]内的随机整数</span></span><br><span class="line">        <span class="keyword">int</span> n4=rand.nextInt(<span class="number">27</span>)+<span class="number">82</span>;<span class="comment">//[82,108]内的随机整数</span></span><br></pre></td></tr></table></figure>
<p>注意<code>rand.nextInt(n)</code>中的参数<code>n</code>代表的是生成随机整数的数量，与生成随机整数的范围无关。比如代码中的<code>n4</code>,整数取值为<code>[82,108]</code>,共<code>27</code>个数，加上后面的<code>82</code>表示区间最小值</p>
</li>
</ol>
<p>生成<code>[min,max]</code>范围内随机整数的通用公式为：**<code>n=rand.nextInt(max-min+1)+min。</code>**</p>
<p>原文链接：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzal9qZXJyeTUyMS9hcnRpY2xlL2RldGFpbHMvMTA5NzM1ODAx">https://blog.csdn.net/wsj_jerry521/article/details/109735801</span></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>mybatis中大于等于小于等于的写法</title>
    <url>/blog/posts/9aff665a/</url>
    <content><![CDATA[<h2 id="mybatis中大于等于小于等于的写法"><a href="#mybatis中大于等于小于等于的写法" class="headerlink" title="mybatis中大于等于小于等于的写法"></a><code>mybatis</code>中大于等于小于等于的写法</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">第一种写法（1）：</span><br><span class="line"></span><br><span class="line">原符号       &lt;        &lt;=      &gt;       &gt;=       &amp;        &#x27;        &quot;</span><br><span class="line">替换符号    <span class="symbol">&amp;lt;</span>    <span class="symbol">&amp;lt;</span>=   <span class="symbol">&amp;gt;</span>    <span class="symbol">&amp;gt;</span>=   <span class="symbol">&amp;amp;</span>   <span class="symbol">&amp;apos;</span>  <span class="symbol">&amp;quot;</span></span><br><span class="line">例如：sql如下：</span><br><span class="line">create_date_time <span class="symbol">&amp;gt;</span>= #&#123;startTime&#125; and  create_date_time <span class="symbol">&amp;lt;</span>= #&#123;endTime&#125;</span><br><span class="line"></span><br><span class="line">第二种写法（2）：</span><br><span class="line">大于等于</span><br><span class="line">&lt;![CDATA[ &gt;= ]]&gt;</span><br><span class="line">小于等于</span><br><span class="line">&lt;![CDATA[ &lt;= ]]&gt;</span><br><span class="line">例如：sql如下：</span><br><span class="line">create_date_time &lt;![CDATA[ &gt;= ]]&gt; #&#123;startTime&#125; and  create_date_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;endTime&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Mybtais</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql日期加减</title>
    <url>/blog/posts/388f5c14/</url>
    <content><![CDATA[<h1 id="日期的加减"><a href="#日期的加减" class="headerlink" title="日期的加减"></a>日期的加减</h1><p><code>date_add</code>和<code>date_sub</code><br>语法为：<code>date_add(date,interval expr type)、date_sub(date,interval expr type)</code><br>其中常用的type的类型有：<code>second、minute、hour、day、month、year</code>等</p>
<p><code>date_add</code>是对日期的增加，如果天数为负数时，则表示对日期减少，<br><code>date_sub</code>是对日期的减少，如果天数为负数时，则表示对日期增加<br>例如</p>
<span id="more"></span>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取日期 2020-04-07</span></span><br><span class="line">curdate()</span><br><span class="line"><span class="comment">-- 获取日期加时间 2020-04-07 23:10:30</span></span><br><span class="line">now()</span><br><span class="line"><span class="comment">-- 获取明天的日期 2020-04-08</span></span><br><span class="line">date_add(curdate(),<span class="type">interval</span> <span class="number">1</span> <span class="keyword">day</span>)</span><br><span class="line"><span class="comment">--或者</span></span><br><span class="line">date_sub(curdate(),<span class="type">interval</span> <span class="number">-1</span> <span class="keyword">day</span>)</span><br><span class="line"><span class="comment">-- 获取明年的日期 2021-04-07</span></span><br><span class="line">date_add(curdate(),<span class="type">interval</span> <span class="number">1</span> <span class="keyword">year</span>)</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line">date_sub(curdate(),<span class="type">interval</span> <span class="number">-1</span> <span class="keyword">year</span>)</span><br></pre></td></tr></table></figure>

<h1 id="日期的格式化"><a href="#日期的格式化" class="headerlink" title="日期的格式化"></a>日期的格式化</h1><h2 id="date-format"><a href="#date-format" class="headerlink" title="date_format"></a><code>date_format</code></h2><p>语法为：<code>date_format(date,format)，date</code> 参数是合法的日期。<code>format </code>规定日期/时间的输出格式。<br>常用的格式有：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%Y</td>
<td>年，4 位</td>
</tr>
<tr>
<td>%y</td>
<td>年，2 位</td>
</tr>
<tr>
<td>%m</td>
<td>月，数值(00-12)</td>
</tr>
<tr>
<td>%M</td>
<td>月名</td>
</tr>
<tr>
<td>%D</td>
<td>带有英文前缀的月中的天</td>
</tr>
<tr>
<td>%d</td>
<td>月的天，数值(00-31)</td>
</tr>
<tr>
<td>%H</td>
<td>小时 (00-23)</td>
</tr>
<tr>
<td>%h</td>
<td>小时 (01-12)</td>
</tr>
<tr>
<td>%i</td>
<td>分钟，数值(00-59)</td>
</tr>
<tr>
<td>%S</td>
<td>秒(00-59)</td>
</tr>
<tr>
<td>%s</td>
<td>秒(00-59)</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 格式化当前日期 2020-04-07 23:23:23</span></span><br><span class="line">date_format(now(),<span class="string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span> )</span><br></pre></td></tr></table></figure>
<h1 id="日期的差值"><a href="#日期的差值" class="headerlink" title="日期的差值"></a>日期的差值</h1><h2 id="datediff"><a href="#datediff" class="headerlink" title="datediff"></a><code>datediff</code></h2><p><code>DATEDIFF(date1，date2)</code> 返回起始时间 <code>date1</code> 和结束时间 <code>date2</code> 之间的天数（<code>date2-date1</code>，正负情况都存在）。<code>date1</code> 和<code> date2</code> 为日期或 <code>date-and-time </code>表达式，计算差值时只会计算日期的差值，单位为天。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 当前时间2020-04-08，差值为-2</span></span><br><span class="line"><span class="keyword">SELECT</span> DATEDIFF(NOW(),<span class="string">&#x27;2020-04-10&#x27;</span>) </span><br><span class="line"><span class="comment">-- 当前时间2020-04-08，差值为2</span></span><br><span class="line"><span class="keyword">SELECT</span> DATEDIFF(NOW(),<span class="string">&#x27;2020-04-06&#x27;</span>) </span><br></pre></td></tr></table></figure>

<h2 id="timestampdiff"><a href="#timestampdiff" class="headerlink" title="timestampdiff"></a><code>timestampdiff</code></h2><p>语法为：<code>TIMESTAMPDIFF(interval,datetime_expr1,datetime_expr2)。</code><br>返回日期或日期时间表达式<code>datetime_expr1 和datetime_expr2the </code>之间的整数差。其结果的单位由<code>interval</code> 参数给出。<br>常用的值有：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FRAC_SECOND。表示间隔是毫秒</span><br><span class="line"><span class="keyword">SECOND</span>。秒</span><br><span class="line"><span class="keyword">MINUTE</span>。分钟</span><br><span class="line"><span class="keyword">HOUR</span>。小时</span><br><span class="line"><span class="keyword">DAY</span>。天</span><br><span class="line">WEEK。星期</span><br><span class="line"><span class="keyword">MONTH</span>。月</span><br><span class="line">QUARTER。季度</span><br><span class="line"><span class="keyword">YEAR</span>。年</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- now()值为 2020-04-08 23:20:20</span></span><br><span class="line"><span class="keyword">SELECT</span> TIMESTAMPDIFF(<span class="keyword">DAY</span>,NOW(),<span class="string">&#x27;2020-04-10 23:23:23&#x27;</span>) </span><br><span class="line"><span class="comment">-- 结果为2，相差两天，取整数</span></span><br><span class="line"><span class="comment">-- 其他单位同理</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>java线程池与五种常用线程池策略使用与解析</title>
    <url>/blog/posts/1748805d/</url>
    <content><![CDATA[<h1 id="一-线程池"><a href="#一-线程池" class="headerlink" title="一.线程池"></a>一.线程池</h1><p>关于为什么要使用线程池久不赘述了，首先看一下<code>java</code>中作为线程池<code>Executor</code>底层实现类的<code>ThredPoolExecutor</code>的构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>其中各个参数含义如下：</p>
<ul>
<li><code>corePoolSize</code>- 池中所保存的线程数，包括空闲线程。需要注意的是在初创建线程池时线程不会立即启动，直到有任务提交才开始启动线程并逐渐时线程数目达到<code>corePoolSize</code>。若想一开始就创建所有核心线程需调用<code>prestartAllCoreThreads</code>方法。</li>
<li><code>maximumPoolSize</code>- 池中允许的最大线程数。需要注意的是当核心线程满且阻塞队列也满时才会判断当前线程数是否小于最大线程数，并决定是否创建新线程。</li>
<li><code>keepAliveTime</code> - 当线程数大于核心时，多于的空闲线程最多存活时间</li>
<li><code>unit</code> - <code>keepAliveTime</code> 参数的时间单位。</li>
<li><code>workQueue</code> - 当线程数目超过核心线程数时用于保存任务的队列。主要有3种类型的<code>BlockingQueue</code>可供选择：无界队列，有界队列和同步移交。将在下文中详细阐述。从参数中可以看到，此队列仅保存实现<code>Runnable</code>接口的任务。</li>
<li><code>threadFactory</code> - 执行程序创建新线程时使用的工厂。</li>
<li><code>handler</code> - 阻塞队列已满且线程数达到最大值时所采取的饱和策略。<code>java</code>默认提供了4种饱和策略的实现方式：中止、抛弃、抛弃最旧的、调用者运行。将在下文中详细阐述:</li>
</ul>
<h2 id="二-可选择的阻塞队列BlockingQueue详解"><a href="#二-可选择的阻塞队列BlockingQueue详解" class="headerlink" title="二.可选择的阻塞队列BlockingQueue详解"></a>二.可选择的阻塞队列<code>BlockingQueue</code>详解</h2><p>首先看一下新任务进入时线程池的执行策略：<br>如果运行的线程少于<code>corePoolSize</code>，则 <code>Executor</code>始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于<code>corePoolSize</code>，则任务根本不会存入<code>queue</code>中，而是直接运行）<br>如果运行的线程大于等于 <code>corePoolSize</code>，则 <code>Executor</code>始终首选将请求加入队列，而不添加新的线程。<br>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 <code>maximumPoolSize</code>，在这种情况下，任务将被拒绝。<br>主要有3种类型的<code>BlockingQueue</code>:</p>
<h2 id="2-1-无界队列"><a href="#2-1-无界队列" class="headerlink" title="2.1 无界队列"></a>2.1 无界队列</h2><p>队列大小无限制，常用的为无界的<code>LinkedBlockingQueue</code>，使用该队列做为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致<code>OOM</code>。最近工作中就遇到因为采用<code>LinkedBlockingQueue</code>作为阻塞队列，部分任务耗时<code>80s</code>＋且不停有新任务进来，导致<code>cpu</code>和内存飙升服务器挂掉。</p>
<h2 id="2-2-有界队列"><a href="#2-2-有界队列" class="headerlink" title="2.2 有界队列"></a>2.2 有界队列</h2><p>常用的有两类，一类是遵循<code>FIFO</code>原则的队列如<code>ArrayBlockingQueue</code>与有界的<code>LinkedBlockingQueue</code>，另一类是优先级队列如<code>PriorityBlockingQueue</code>。<code>PriorityBlockingQueue</code>中的优先级由任务的<code>Comparator</code>决定。<br>使用有界队列时队列大小需和线程池大小互相配合，线程池较小有界队列较大时可减少内存消耗，降低<code>cpu</code>使用率和上下文切换，但是可能会限制系统吞吐量。</p>
<h2 id="2-3-同步移交"><a href="#2-3-同步移交" class="headerlink" title="2.3 同步移交"></a>2.3 同步移交</h2><p>如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用<code>SynchronousQueue</code>作为等待队列。<code>SynchronousQueue</code>不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入<code>SynchronousQueue</code>中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。</p>
<h2 id="2-4-几种BlockingQueue的具体实现原理"><a href="#2-4-几种BlockingQueue的具体实现原理" class="headerlink" title="2.4 几种BlockingQueue的具体实现原理"></a>2.4 几种<code>BlockingQueue</code>的具体实现原理</h2><p>关于上述几种<code>BlockingQueue</code>的具体实现原理与分析将在下篇博文中详细阐述。</p>
<h1 id="三-可选择的饱和策略RejectedExecutionHandler详解"><a href="#三-可选择的饱和策略RejectedExecutionHandler详解" class="headerlink" title="三.可选择的饱和策略RejectedExecutionHandler详解"></a>三.可选择的饱和策略<code>RejectedExecutionHandler</code>详解</h1><p><code>JDK</code>主要提供了<code>4</code>种饱和策略供选择。<code>4</code>种策略都做为静态内部类在<code>ThreadPoolExcutor</code>中进行实现。</p>
<h2 id="3-1-AbortPolicy中止策略"><a href="#3-1-AbortPolicy中止策略" class="headerlink" title="3.1 AbortPolicy中止策略"></a>3.1 <code>AbortPolicy</code>中止策略</h2><p>该策略是默认饱和策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                                <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                                e.toString());</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>使用该策略时在饱和时会抛出<code>RejectedExecutionException（继承自RuntimeException）</code>，调用者可捕获该异常自行处理。</p>
<h2 id="3-2-DiscardPolicy抛弃策略"><a href="#3-2-DiscardPolicy抛弃策略" class="headerlink" title="3.2 DiscardPolicy抛弃策略"></a>3.2 <code>DiscardPolicy</code>抛弃策略</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>如代码所示，不做任何处理直接抛弃任务</p>
<h2 id="3-3-DiscardOldestPolicy抛弃旧任务策略"><a href="#3-3-DiscardOldestPolicy抛弃旧任务策略" class="headerlink" title="3.3 DiscardOldestPolicy抛弃旧任务策略"></a>3.3 DiscardOldestPolicy抛弃旧任务策略</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如代码，先将阻塞队列中的头元素出队抛弃，再尝试提交任务。如果此时阻塞队列使用<code>PriorityBlockingQueue</code>优先级队列，将会导致优先级最高的任务被抛弃，因此不建议将该种策略配合优先级队列使用。</p>
<h2 id="3-4-CallerRunsPolicy调用者运行"><a href="#3-4-CallerRunsPolicy调用者运行" class="headerlink" title="3.4 CallerRunsPolicy调用者运行"></a>3.4 <code>CallerRunsPolicy</code>调用者运行</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>既不抛弃任务也不抛出异常，直接运行任务的<code>run</code>方法，换言之将任务回退给调用者来直接运行。使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成。</p>
<h1 id="四-java提供的四种常用线程池解析"><a href="#四-java提供的四种常用线程池解析" class="headerlink" title="四.java提供的四种常用线程池解析"></a>四.<code>java</code>提供的四种常用线程池解析</h1><p>在<code>JDK</code>帮助文档中，有如此一段话：</p>
<p>强烈建议程序员使用较为方便的<code>Executors</code>工厂方法<code>Executors.newCachedThreadPool()</code>（无界线程池，可以进行自动线程回收）、<code>Executors.newFixedThreadPool(int)</code>（固定大小线程池）<code>Executors.newSingleThreadExecutor()</code>（单个后台线程）它们均为大多数使用场景预定义了设置。</p>
<p>详细介绍一下上述四种线程池。</p>
<h2 id="4-1-newCachedThreadPool"><a href="#4-1-newCachedThreadPool" class="headerlink" title="4.1 newCachedThreadPool"></a>4.1 <code>newCachedThreadPool</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>newCachedThreadPool</code>中如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>初看该构造函数时我有这样的疑惑：核心线程池为<code>0</code>，那按照前面所讲的线程池策略新任务来临时无法进入核心线程池，只能进入 <code>SynchronousQueue</code>中进行等待，而<code>SynchronousQueue</code>的大小为1，那岂不是第一个任务到达时只能等待在队列中，直到第二个任务到达发现无法进入队列才能创建第一个线程？<br>这个问题的答案在上面讲<code>SynchronousQueue</code>时其实已经给出了，要将一个元素放入<code>SynchronousQueue</code>中，必须有另一个线程正在等待接收这个元素。因此即便<code>SynchronousQueue</code>一开始为空且大小为<code>1</code>，第一个任务也无法放入其中，因为没有线程在等待从<code>SynchronousQueue</code>中取走元素。因此第一个任务到达时便会创建一个新线程执行该任务。<br>这里引申出一个小技巧：有时我们可能希望线程池在没有任务的情况下销毁所有的线程，既设置线程池核心大小为<code>0</code>，但又不想使用<code>SynchronousQueue</code>而是想使用有界的等待队列。显然，不进行任何特殊设置的话这样的用法会发生奇怪的行为：直到等待队列被填满才会有新线程被创建，任务才开始执行。这并不是我们希望看到的，此时可通过<code>allowCoreThreadTimeOut</code>使等待队列中的元素出队被调用执行</p>
<h2 id="4-2-newFixedThreadPool-创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。"><a href="#4-2-newFixedThreadPool-创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。" class="headerlink" title="4.2 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。"></a>4.2 <code>newFixedThreadPool</code> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>看代码一目了然了，使用固定大小的线程池并使用无限大的队列</p>
<h2 id="4-3-newScheduledThreadPool-创建一个定长线程池，支持定时及周期性任务执行。"><a href="#4-3-newScheduledThreadPool-创建一个定长线程池，支持定时及周期性任务执行。" class="headerlink" title="4.3 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。"></a>4.3 <code>newScheduledThreadPool</code> 创建一个定长线程池，支持定时及周期性任务执行。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在来看看<code>ScheduledThreadPoolExecutor（）</code>的构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>ScheduledThreadPoolExecutor</code>的父类即<code>ThreadPoolExecutor</code>，因此这里各参数含义和上面一样。值得关心的是<code>DelayedWorkQueue</code>这个阻塞对列，在上面没有介绍，它作为静态内部类就在<code>ScheduledThreadPoolExecutor</code>中进行了实现。具体分析讲会在后续博客中给出，在这里只进行简单说明：<code>DelayedWorkQueue</code>是一个无界队列，它能按一定的顺序对工作队列中的元素进行排列。因此这里设置的最大线程数 <code>Integer.MAX_VALUE</code>没有任何意义。</p>
<h2 id="4-4-newSingleThreadExecutor-创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序-FIFO-LIFO-优先级-执行。"><a href="#4-4-newSingleThreadExecutor-创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序-FIFO-LIFO-优先级-执行。" class="headerlink" title="4.4 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。"></a>4.4 <code>newSingleThreadExecutor</code> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(<code>FIFO, LIFO,</code> 优先级)执行。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先<code>new</code>了一个线程数目为<code>1</code>的<code>ScheduledThreadPoolExecutor</code>，再把该对象传入<code>DelegatedScheduledExecutorService</code>中，看看<code>DelegatedScheduledExecutorService</code>的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DelegatedScheduledExecutorService(ScheduledExecutorService executor) &#123;</span><br><span class="line">           <span class="keyword">super</span>(executor);</span><br><span class="line">           e = executor;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>在看看它的父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;</span><br></pre></td></tr></table></figure>

<p>其实就是使用装饰模式增强了<code>ScheduledExecutorService（1）</code>的功能，不仅确保只有一个线程顺序执行任务，也保证线程意外终止后会重新创建一个线程继续执行任务。具体实现原理会在后续博客中讲解。</p>
<h2 id="4-5-newWorkStealingPool创建一个拥有多个任务队列（以便减少连接数）的线程池。"><a href="#4-5-newWorkStealingPool创建一个拥有多个任务队列（以便减少连接数）的线程池。" class="headerlink" title="4.5 newWorkStealingPool创建一个拥有多个任务队列（以便减少连接数）的线程池。"></a>4.5 <code>newWorkStealingPool</code>创建一个拥有多个任务队列（以便减少连接数）的线程池。</h2><p>这是<code>jdk1.8</code>中新增加的一种线程池实现，先看一下它的无参实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">          ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">          <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的<code>ForkJoinPool</code>从<code>jdk1.7</code>开始引进，个人感觉类似于<code>mapreduce</code>的思想。这个线程池较为特殊</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>simple self introduction</title>
    <url>/blog/posts/96b6e8a1/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7a91826b2b0a9b27ff196bfffe12db2a132d17b5422eb492dc503a8829970c32">4d3ce43e3d54dd81fa11ccfc5fccf966b70ff89387f9c74ab3330b3e9bec0afa958ddaad2c9ed18f160b303111aa71c9c23d0814abd6978c56d55d8b72ea1eb07754a825a8e99a0cdabd8ec1dffc1bce1906de86e36b64c2070a971efec412e11cc27f4d4311514e3921822ac0a7b9f1d3774a9e013a062bd25692fb53520f6837e7de328656e4183b1c15a89ae81684153d47120615a7e83a93e915d711c148ff00012a966006eeb84d48c65e4b5cb21bf8edb80bae66cd7e781dea42eddcadcb6d7e403bc6a89f8f7febd90cf67e6bd1dd9efd639f4911330ddd9702ca6acf8306c46064cb8a1ef49bf9a8a496f055d027b39daabb720e274ab992f597395bdc75e6a93207e75623192cc61d02c476cdde4d74841b1b30f778354297f5a38fab369479adce08ae8c1990c2114bc96df6ca20eb6b65d6ef645496077ecd2bcf339aef72b227b32d4f05ee1071ee8a9e27eeb43f8a9d5eb4a6556e8bfad0e9080332f44fff83b9570049fb0fc8218be23eba1211fc71eee23b7cb1716867228295d1d632430a07f741a6d499cf5bc46393391de4ad65be7f9569779adfb14f58bf3ce0daaf26b923af6cb81661bc011b098aced2d0d98eadf4b99176ef0ba7b359bde0615bb924b9fb44389838368ed109315e8f9eba77fc58683b74ae089102e2e62824ee3aa98d4556a00137c85c997eef651c0d6123a95620bf9a51b2b88219b1bb36d08261ce3d2666e2ea45b86d7e4e4c95e1f4d92b4e853210e76e5a4b8397f4a896b9466b3a94bb6b03630ec09aa1a498b0874252d3e3055090d91cf7793f7854047cfdcf842b469cd4b5f668841e9af34fcc008ceb65344f9e78dbc95870717955f025aaf8f9990a2edf9f49fed4788d8334624c185e466842db4a02965a1b3ea75646651b6616339f7ab89242695e74fe631d1a2feb2af1552a73397374f6724cc015039ed735d6b3896208c0bd430b5132b5144253c64dd9bd6d75d567c05a797cc417d83b8fdfec6c7da6a919422a3ba0a190500fe01ca4276c415959a3014ec6306b1ebd9d759ead26498197f21aae318f9c142a59d0e3e436bae8c5b29242a84ceee62f4962f4b1b7557220938c9afc80c04f3a81c286ce490b99c4eae449f4938ac57c7a9ccca68adb949d85fa577d0a37dd0aa6128c5ee36ff68c21d8f79a2e0a4563f66187482246f9c1d868f410c00586d3f9278b18f8a222bfccb89e54424a30fa9b197dd48261c65f759afc0305a46fb21d895a8f449688d08929ffe1373730f017cfe5c1afec4f90f092f8aa0b6f41578f6dadeb36e4723fcdda58cae56e9ebc2749d7b596377392b114b72d03052afbca4e03510b4acef1dd9bba0ccc9736e98b091e910e944435298e884b9ca91ad26e9ca95f8f816b8f936411c4b9bf0055986a14cfc043a55370defa578ef385600a24c306debda101f66e914a26c257e189c6af056fb5e267a74ca42bcc6762c9f1f26a58f938accb889d408080a386512ed3769f0a0427dfd63fe4491adfb2f6955c839d37ee528d208ff3dd70fcd1aae8c083cd8a7322248caaab6dd5e3c85494e6bf1db3d6eef36ac1b04887084db949a8c166c95b1a91542eba0a4b142609bced9f2936a5877a0fe92e41d49006f773a6b6904a4f95ddac2c946e75ebbeedb224465ee6662363f1771124092697ac0eaaa61c430ea7bec670668ee616b5374b9cd86b9815bc2aa25b2bdc25353ec478267914251f0c84fed647ed74c205ec19c8f77cb1e6d8ff3696530d0cd820ecc7389b90280776f913383e15f0b460fdfe5179fb5aba88d41a89ed90970c1bad0ccdfe56bbed010796a7cc520fb87f68a33f3169e3ea262d93dc2fe1ff035642ba6fabe05961b3f414f44de0cce7d764f8953908202a091a2a1b557f446755fb19c3ffd9639c1daa26256bab0ae8a573d8ba55e2898da4d1bb94a0dfc869d34c5173ff5252e77afde652b8feecfadb89b72838c687de48c4abca82cb5472c6f147f167efbf959a73326a9eb35682244abfd67100a53ab37d8f2487338a71e6e31a7ebe6ab600916faba1517988c44ef59c90422be490ed23403cdc13b4a41fe401d110540612829a0af31fa12226a7c94a81380a247265f759c908a80f13a2a127ea38eae4258b3f667cd8c98672b454e8d6823549b4ca038e5ab220b9af7aba70f184b4e244f152236cc82f27cfa57635f5ddd02db4367078ab35360ac996bd6be2e2ce72748e2aee42b77573176d9704005a999ffeb4b881e102cdce1bfa2f483e20720d842d988e41766e6baeb0134b5ec3aee39e05f46dfae84b3fd4ff197160059cec95899558f772ca54e9141dffe086515be8a79461f677ed65e748643aa783a10d3c5e4efe532ebee815eecf25c4eefd4f0b3b500b036daf591b31a8beb867499c573360661cf7f35dfd324f57fd86817cd7f54892f8642939ddc0b65d0c25df08625d1b93871cba6bf7396a847a52eb6b5ffb66a6a2ee5813054d8014948dc5ac93f279f0fe9e58d367a87f3ba3772c1aa929ec6ca5cfef428c06bcd5062bff59db4c2a321ac3edcb16c3eaac06c6b961fa33bf4ccb6734c05ea4cebe97963878779dc46d6eb44a7a5c7f655aee52c49c64d593cb5b4477383a22a2d5a515686e0b5af4059699e1f2a7e90ca5e45cc071af2fc837485be378c825bb9bdac170e6bd5e36f22bccb88a9baa4d5e97af0c6e2bacbea61afde930a4859cc408aeb5ea27817ceaf7141f2e807359a98eec8375c5d9d122bf8b22c50b0794567bf4c9351321674296bea0401b18973839a5d2ab202a6283bb0323c27abf49e041c71727bbbe81e3f254d888df8d00fa9dc285840e29a62d0c833f694119a076c9a57bfc9ac8745848ce053e507545e862aa8befda3a989f79c50aee20616fd4076077432f387cf631d7a0e6989940ebb117870a8cb923845c32e11a882c50d679df03972dedf100d3c4a312442bc168599d0fc6e3dc344b445e22096446a3a5ed405b1c91449b144835bfd3b616ade9248c7d20e5b21fc1476f0e7f42124ce52ee62089fd130dc5fc9db81d31f4d5dac47125220a4a1f605412aaee39c1765a866bed773463389ea80acef105bc6c8801d2968899d0325a2f8b66c8b7fbcdff5570f6177dc6000374f36fc7a34394e5b32a1946c1daf75dc3ec42362d4eb90cb0f63cefa82e3e58842bdaf29904624528554785c37981f8612be06263b143be0da7d8156d4a13625da675a47fd98d54098930de7d268f8acb4563985905dbc300cf039e4c659eee0954b86e23fb38dd2efe0e2e2002a3bc3ce084b12861ecf8b0417352a05928ad731369612609cc3029777661a58dd8bf32abf8f38cc262ec89da239bd0f109be525a39aeb7a6c07e98bc2631e85f11b123870ae37731cb64435becece4004d1f0d787641146877e337f9cca3355cd40d59b50b8cfaa4fbbd87c53ffece3aa034c8538688208a3c76c284584ebed81fd3e5e4d4d5bc1a5f7fb07bc8c8b3c1fcd203df92cd4d454ba16bed90f408fda27e950ef1bd8461e45f8925f879af3092ac3c3c8b72a5e7ad82f249e62fc9c75924585028e21b423a621bc9f65b1d59fc39c2057fccd452e27c15271de08b6510eb3f7740d46e1e22bdc2165fab1b551e6831745329b246d01997f72433b344c9c46a5cf6bdd3192a388ff4aac3f204e5223b3093050acc2eae26653cb7030bcd1d8a8963c8d6eaca6592f94916407d2eeb7da876a5a7771b0f2953cd71dcec382ee4edc7fecd89c9130ae1ef8ebe32022971eab90dca6f7edbaf9dd6e1758685fb64510eedd6e6c2c11c72d80722f28b78bbc1603e8365874005ab1362b5513889b1c11332268c6a930fb8707cb8b28be4b04569076fa75d4c1f8768e5a9211ed9fac8922d43a3152e19e1f0861aba3368d55f2f60490e62f9746bd29f3287eefa958dc97d551cf7802442634afe49ecdbc45ff73493cafb4c6c3ba18d061dcb1fdf54236c24dee7723d288bd341978c803eb121b322a5493f34e0e84f90c25356f6769506d0988fef3f5cfe3deb5b2f92d5417dc69951e0f173cdf74b8be5ca9085dc41c133318b977a20485baa36c109f12519fc7e87c096467fb582a785db04ccb6a9383807935cfcb1f0f387e0ad46da12e3a6cad2f3ec528b9d4f5d18e0dd2a812cc43a44de14d36832226c25872d0e96a8f11dfbb95ee78c6483e5b15c773aea7838dc7e1b7aba35f4c6536d2f41ed74a004c5274f620755c6b734831cd7e427c72b1b5c1fb2ead09a1bd7f7bd511625e39bdb678e6aac0cc5faa45f56027c1580b29f4c627e99ead16f4c9df72ec173cd5febe520a40bc23176d62338d6e065d55ac9c5c5a68fb942687d305a81d8c7bf5ff7aa2fa4993787d404c5ea287085f980e42a6f1362099a2a46297b4fff183b8d51faf4510d2eab632a1d51736872c7112d8b018159af9222e3b06559226c16dccf055967ab93b4d6cc04b25133c63ce60c3f994052f10d835beb954c8b82fac98a23c820598cff1934a4ec2923cbdc4dc0bf84705d994898d12f77aad287c4b27ed5251822a69f714bbed4b9e9a7a17a5158fcc1b73b0b7cf8f8a78c2c65e70866936a2dbd2000982e1fe0b4efdab2dcbec418995eb83976f91a113ccee468fca6553e70dc78ae921f08e2708ddc4051d6ee0b5c5c9f4ff108</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/blog/lib/hbe.js"></script><link href="/blog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>SAP</category>
      </categories>
      <tags>
        <tag>SAP</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu20无法安装vmtools解决</title>
    <url>/blog/posts/6e65ed30/</url>
    <content><![CDATA[<p>使用<code>vmware</code>安装<code>Ubuntu 20 LTS</code> 后 <code>vmware tools</code>工具选项为灰色，不允许安装，也无法共享文件夹问题。</p>
<img data-src="/blog/posts/6e65ed30/2021-11-22-17-07-07.png" class="">

<span id="more"></span>

<p><code>lsb_release -a</code>查看当前<code>Ubutun</code>版本。</p>
<h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><ol>
<li>在<code>vmware</code>安装目录下找到<code>linux.iso</code>文件</li>
</ol>
<img data-src="/blog/posts/6e65ed30/2021-11-22-17-09-52.png" class="">

<ol start="2">
<li>使用光盘挂接方式挂接到当前虚拟机。</li>
</ol>
<img data-src="/blog/posts/6e65ed30/2021-11-22-17-30-17.png" class="">
<ol start="3">
<li>将会在虚拟机内看到一个<code>DVD</code>显示为<code>VMWare Tools</code>。</li>
</ol>
<img data-src="/blog/posts/6e65ed30/2021-11-22-17-30-49.png" class="">
<ol start="4">
<li>进入到目标目录下并进入终端<img data-src="/blog/posts/6e65ed30/2021-11-22-17-31-56.png" class="">
<img data-src="/blog/posts/6e65ed30/2021-11-22-17-32-26.png" class=""></li>
<li>进行解压 <code>tar -zxvf VMwareTools…tar.gz</code><br>在解压文件夹下<code>sudo ./vmware-install.pl</code></li>
</ol>
<p>7 都选择默认，一路回车安装完成。</p>
<p>8 最后在<code>mnt</code>文件夹下就会看到<code>hgfs</code>文件了，就可以实现和<code>Windows</code>文件共享了。</p>
<img data-src="/blog/posts/6e65ed30/2021-11-22-17-33-55.png" class="">




<h2 id="共享文件夹不存在解决办法"><a href="#共享文件夹不存在解决办法" class="headerlink" title="共享文件夹不存在解决办法"></a>共享文件夹不存在解决办法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vmhgfs-fuse .host:/ /mnt/hgfs/ -o allow_other -o uid=1000</span><br></pre></td></tr></table></figure>

<h2 id="使用apt无法定文软件版解决方案"><a href="#使用apt无法定文软件版解决方案" class="headerlink" title="使用apt无法定文软件版解决方案"></a>使用<code>apt</code>无法定文软件版解决方案</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#备份sources.list文件</span></span><br><span class="line">sudo cp  /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"><span class="comment">#打开sources.list文件</span></span><br><span class="line">sudo vim  /etc/apt/sources.list</span><br><span class="line"><span class="comment">#删除原内容，添加下列内容</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="comment">#保存 做完以上前期工作，正式安装yum</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install yum</span><br><span class="line"><span class="comment">#成功解决上楼报错</span></span><br></pre></td></tr></table></figure>
<h2 id="Ubuntu-20-04-提示“检测到系统程序出现问题”解决"><a href="#Ubuntu-20-04-提示“检测到系统程序出现问题”解决" class="headerlink" title="Ubuntu 20 04 提示“检测到系统程序出现问题”解决"></a><code>Ubuntu 20 04</code> 提示“检测到系统程序出现问题”解决</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/default/apport</span><br><span class="line"><span class="comment"># 将enabled=0</span></span><br><span class="line">enabled=0</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO</title>
    <url>/blog/posts/bd76a990/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTUyODQ4Njc1OTI0MDgyNzE4"> 参考链接 </span></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>spring中/和/*和/**的区别</title>
    <url>/blog/posts/59de1824/</url>
    <content><![CDATA[<h1 id="spring中-和-和-的区别"><a href="#spring中-和-和-的区别" class="headerlink" title="spring中/和/*和/**的区别"></a>spring中<code>/</code>和<code>/*</code>和<code>/**</code>的区别</h1><h2 id="和-区别"><a href="#和-区别" class="headerlink" title="/ 和 /*区别"></a><code>/</code> 和 <code>/*</code>区别</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">/ 拦截所有请求 包括静态资源和动态请求 但是不拦截jsp</span><br><span class="line">/* 拦截所有请求 包括静态资源和动态请求 也拦截jsp</span><br><span class="line">区别就在于<span class="regexp">/ 不拦截jsp /</span>*拦截jsp</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="和-区别-1"><a href="#和-区别-1" class="headerlink" title="/* 和 /** 区别"></a><code>/*</code> 和 <code>/**</code> 区别</h2><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">/<span class="strong">** 的意思是所有文件夹及里面的子文件夹</span></span><br><span class="line"><span class="strong">/*</span> 是所有文件夹，不含子文件夹</span><br></pre></td></tr></table></figure>
<h2 id="注意点案例"><a href="#注意点案例" class="headerlink" title="注意点案例"></a>注意点案例</h2><p>理解下面的案例有助于理解如何使用</p>
<p>场景：当我在客户端调用<code>URL</code>：<code>/user/list</code>然后返回<code>user.jsp</code>视图，</p>
<ul>
<li>当配置的是<code>/</code>：<code>DispathcherServlet</code>拿到这个请求然后返回对应的<code>controller</code>，然后依据<code>Dispather Type</code>为<code>Forward</code>类型转发到<code>user.jsp</code>视图，即就是请求<code>user.jsp</code>视图(<code>/user/user.jsp</code>)，此时<code>Dispather</code>没有拦截<code>/user/user.jsp</code>,因为此时你配置的是默认的<code>/</code>，就顺利的交给<code>ModleAndView</code>去处理显示了。</li>
<li>当配置的是<code>/*</code>：<code>DispathcherServlet</code>拿到这个请求然后返回对应的<code>controller</code>，然后通过<code>Dispather Type</code>通过<code>Forward</code>转发到<code>user.jsp</code>视图，即就是请求<code>user.jsp</code>视图(<code>/user/user.jsp</code>)，此时<code>Dispather</code>已经拦截<code>/user/user.jsp</code>，<code>Dispatcher</code>会把他当作<code>Controller</code>去匹配，没有匹配到就会报<code>404</code>错误。</li>
</ul>
<p>在springboot中建了一个过滤器，测试</p>




<p>当请求为<code>/user/login</code>的时候可以被拦截，当为<code>/page/login.html</code>页面的时候不拦截</p>



<p> 当请求为<code>/user/login</code>的时候可以被拦截，当为<code>/page/login.html</code>页面的时候也会被拦截</p>
<ul>
<li><p><code>/</code>不会拦截页面，只会拦截路径。</p>
</li>
<li><p><code>/*</code> 会路径和页面</p>
</li>
</ul>
<p><strong>结论：在配置视图的时候尽量用<code>/</code>这种方式。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java面试</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java面试</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/blog/posts/e8eb0481/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找（<code>binary search</code>），也称作折半查找（<code>half-interval search</code>），每次划分一半进行下一步搜索，所以时间复杂度无非就是<code>while</code>循环的次数！</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分查找 Java 实现 （升序数组）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Integer[] srcArray, <span class="keyword">int</span> des)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = srcArray.length - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> ((low &lt;= high) &amp;&amp; (low &lt;= srcArray.length - <span class="number">1</span>)</span><br><span class="line">            &amp;&amp; (high &lt;= srcArray.length - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// &gt;&gt; 右移符号 表示除以 2</span></span><br><span class="line">        <span class="keyword">int</span> middle = (high + low) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (des == srcArray[middle]) &#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        <span class="comment">// 如果要查找的值 小于最中间的值 就算选择 左边的区间</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (des &lt; srcArray[middle]) &#123;</span><br><span class="line">            high = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>比如：总共有<code>n</code>个元素，每次查找的区间大小就是<code>n，n/2，n/4，…，n/2^k</code>（接下来操作元素的剩余个数），其中<code>k</code>就是循环的次数。<br>由于<code>n/2^k</code>取整后<code>&gt;=1</code>，即令<code>n/2^k=1</code>，<br>可得<code>k=log2n</code>,（是以<code>2</code>为底，<code>n</code>的对数），所以时间复杂度可以表示<code>O()=O(log2n)</code></p>
<h2 id="二分查找的缺点"><a href="#二分查找的缺点" class="headerlink" title="二分查找的缺点"></a>二分查找的缺点</h2><p>虽然二分查找的效率高，但是要将表按关键字排序。而排序本身是一种很费时的运算。既使采用高效率的排序方法也要花费<code>O(nlgn)</code>的时间。</p>
<p>　　二分查找只适用顺序存储结构。为保持表的有序性，在顺序结构里插入和删除都必须移动大量的结点。因此，二分查找特别适用于那种一经建立就很少改动、而又经常需要查找的线性表。</p>
<p>　　对那些查找少而又经常需要改动的线性表，可采用链表作存储结构，进行顺序查找。链表上无法实现二分查找。</p>
]]></content>
      <categories>
        <category>Java面试</category>
        <category>二分查找</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历</title>
    <url>/blog/posts/b9b9f7e7/</url>
    <content><![CDATA[<h1 id="二叉树遍历（前序、中序、后序、层次遍历）"><a href="#二叉树遍历（前序、中序、后序、层次遍历）" class="headerlink" title="二叉树遍历（前序、中序、后序、层次遍历）"></a>二叉树遍历（前序、中序、后序、层次遍历）</h1><p>二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆了。所以，对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。</p>
<p>四种主要的遍历思想为：</p>
<span id="more"></span>

<p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p>
<p>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</p>
<p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p>
<p>层次遍历：只需按层次遍历即可</p>
<p>例如，求下面二叉树的各种遍历</p>
<img data-src="/blog/posts/b9b9f7e7/2022-02-17-22-57-21.png" class="">

<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">前序遍历：1 <span class="number"> 2 </span><span class="number"> 4 </span><span class="number"> 5 </span><span class="number"> 7 </span><span class="number"> 8 </span><span class="number"> 3 </span><span class="number"> 6 </span></span><br><span class="line"></span><br><span class="line">中序遍历：4 <span class="number"> 2 </span><span class="number"> 7 </span><span class="number"> 5 </span><span class="number"> 8 </span><span class="number"> 1 </span><span class="number"> 3 </span> 6</span><br><span class="line"></span><br><span class="line">后序遍历：4 <span class="number"> 7 </span><span class="number"> 8 </span><span class="number"> 5 </span><span class="number"> 2 </span><span class="number"> 6 </span><span class="number"> 3 </span> 1</span><br><span class="line"></span><br><span class="line">层次遍历：1 <span class="number"> 2 </span><span class="number"> 3 </span><span class="number"> 4 </span><span class="number"> 5 </span><span class="number"> 6 </span><span class="number"> 7 </span> 8</span><br></pre></td></tr></table></figure>
<h2 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1. 前序遍历"></a>1. 前序遍历</h2><ol>
<li><p>根据上文提到的遍历思路, <code>根结点 ---&gt; 左子树 ---&gt; 右子树</code>，很容易写出递归版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.print(root.val+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">		preOrderTraverse1(root.left);</span><br><span class="line">		preOrderTraverse1(root.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>现在讨论非递归的版本：</p>
<p> 根据前序遍历的顺序，优先访问根结点，然后在访问左子树和右子树。所以，对于任意结点<code>node</code>，第一部分即直接访问之，之后在判断左子树是否为空，不为空时即重复上面的步骤，直到其为空。若为空，则需要访问右子树。注意，在访问过左孩子之后，需要反过来访问其右孩子，所以，需要<strong>栈</strong>这种数据结构的支持。对于任意一个结点<code>node</code>，具体步骤如下：</p>
<p> a) 访问之，并把结点<code>node</code>入栈，当前结点置为左孩子；</p>
<p> b) 判断结点<code>node</code>是否为空，若为空，则取出栈顶结点并出栈，将右孩子置为当前结点；否则重复<code>a)</code> 步直到当前结点为空或者栈为空（可以发现栈中的结点就是为了访问右孩子才存储的）</p>
<p> 代码如下:</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	TreeNode pNode = root;</span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.print(pNode.val+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">			stack.push(pNode);</span><br><span class="line">			pNode = pNode.left;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">			TreeNode node = stack.pop();</span><br><span class="line">			pNode = node.right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h2><ol>
<li><p>根据上文提到的遍历思路：<code>左子树 ---&gt; 根结点 ---&gt; 右子树</code>，很容易写出递归版本：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">		inOrderTraverse1(root.left);</span><br><span class="line">		System.out.print(root.val+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">		inOrderTraverse1(root.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>非递归实现，有了上面前序的解释，中序也就比较简单了，相同的道理。只不过访问的顺序移到出栈时。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	TreeNode pNode = root;</span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">			stack.push(pNode);</span><br><span class="line">			pNode = pNode.left;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">			TreeNode node = stack.pop();</span><br><span class="line">			System.out.print(node.val+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">			pNode = node.right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-后续遍历"><a href="#3-后续遍历" class="headerlink" title="3. 后续遍历"></a>3. 后续遍历</h2></li>
<li><p>根据上文提到的遍历思路：<code>左子树 ---&gt; 右子树 ---&gt; 根结点</code>，很容易写出递归版本：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">		postOrderTraverse1(root.left);</span><br><span class="line">		postOrderTraverse1(root.right);</span><br><span class="line">		System.out.print(root.val+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-层次遍历"><a href="#4-层次遍历" class="headerlink" title="4. 层次遍历"></a>4. 层次遍历</h2><p>层次遍历的代码比较简单，只需要一个队列即可，先在队列中加入根结点。之后对于任意一个结点来说，在其出队列的时候，访问之。同时如果左孩子和右孩子有不为空的，入队列。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        System.out.print(node.val+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的深度优先遍历（DFS）与广度优先遍历（BFS）"><a href="#二叉树的深度优先遍历（DFS）与广度优先遍历（BFS）" class="headerlink" title="二叉树的深度优先遍历（DFS）与广度优先遍历（BFS）"></a>二叉树的深度优先遍历（<code>DFS</code>）与广度优先遍历（<code>BFS</code>）</h1><p>二叉树的深度优先遍历（<code>DFS</code>）与广度优先遍历（<code>BFS</code>）</p>
<ul>
<li><p><strong>深度优先遍历</strong>：从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点为止。</p>
</li>
<li><p><strong>广度优先遍历</strong>：从根节点出发，在横向遍历二叉树层段节点的基础上纵向遍历二叉树的层次。</p>
</li>
</ul>
<img data-src="/blog/posts/b9b9f7e7/2022-02-17-23-00-13.png" class="">


<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">DFS:</span>ABDECFG</span><br><span class="line"></span><br><span class="line"><span class="symbol">BFS:</span>ABCDEFG</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>DFS</code>实现：</p>
<p>  数据结构：栈</p>
<p>  父节点入栈，父节点出栈，先右子节点入栈，后左子节点入栈。递归遍历全部节点即可</p>
</li>
<li><p><code>BFS</code>实现：</p>
<p>  数据结构：队列</p>
<p>  父节点入队，父节点出队列，先左子节点入队，后右子节点入队。递归遍历全部节点即可</p>
</li>
</ul>
<img data-src="/blog/posts/b9b9f7e7/2022-02-17-23-00-38.png" class="">

<p>深度优先搜索的步骤为：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">（1）、首先节点<span class="number"> 1 </span>进栈，节点1在栈顶；</span><br><span class="line"></span><br><span class="line">（2）、然后节点1出栈，访问节点1，节点1的孩子节点3进栈，节点2进栈；</span><br><span class="line"></span><br><span class="line">（3）、节点2在栈顶，然后节点2出栈，访问节点2</span><br><span class="line"></span><br><span class="line">（4）、节点2的孩子节点5进栈，节点4进栈</span><br><span class="line"></span><br><span class="line">（5）、节点4在栈顶，节点4出栈，访问节点4，</span><br><span class="line"></span><br><span class="line">（6）、节点4左右孩子为空，然后节点5在栈顶，节点5出栈，访问节点5；</span><br><span class="line"></span><br><span class="line">（7）、节点5左右孩子为空，然后节点3在站顶，节点3出栈，访问节点3；</span><br><span class="line"></span><br><span class="line">（8）、节点3的孩子节点7进栈，节点6进栈</span><br><span class="line"></span><br><span class="line">（9）、节点6在栈顶，节点6出栈，访问节点6；</span><br><span class="line"></span><br><span class="line">（10）、节点6的孩子为空，这个时候节点7在栈顶，节点7出栈，访问节点7</span><br><span class="line"></span><br><span class="line">（11）、节点7的左右孩子为空，此时栈为空，遍历结束。</span><br></pre></td></tr></table></figure>
<p>广度优先遍历：广度优先遍历是连通图的一种遍历策略，因为它的思想是从一个顶点V0开始，辐射状地优先遍历其周围较广的区域故得名。</p>
<p>根据广度优先遍历的特点我们利用Java数据结构队列Queue来实现。</p>
<p>广度优先搜索的步骤为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">（1）、节点1进队，节点1出队，访问节点1</span><br><span class="line"></span><br><span class="line">（2）、节点1的孩子节点2进队，节点3进队。</span><br><span class="line"></span><br><span class="line">（3）、节点2出队，访问节点2，节点2的孩子节点4进队，节点5进队；</span><br><span class="line"></span><br><span class="line">（4）、节点3出队，访问节点3，节点3的孩子节点6进队，节点7进队；</span><br><span class="line"></span><br><span class="line">（5）、节点4出队，访问节点4，节点4没有孩子节点。</span><br><span class="line"></span><br><span class="line">（6）、节点5出队，访问节点5，节点5没有孩子节点。</span><br><span class="line"></span><br><span class="line">（7）、节点6出队，访问节点6，节点6没有孩子节点。</span><br><span class="line"></span><br><span class="line">（8）、节点7出队，访问节点7，节点7没有孩子节点，结束。</span><br></pre></td></tr></table></figure>

<h2 id="5-深度优先遍历"><a href="#5-深度优先遍历" class="headerlink" title="5. 深度优先遍历"></a>5. 深度优先遍历</h2><p>其实深度遍历就是上面的前序、中序和后序。但是为了保证与广度优先遍历相照应，也写在这。代码也比较好理解，其实就是前序遍历，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depthOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        System.out.print(node.val+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-广度优先遍历"><a href="#6-广度优先遍历" class="headerlink" title="6. 广度优先遍历"></a>6. 广度优先遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depthFirstSearch</span><span class="params">(TreeNode nodeHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nodeHead==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; myStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    myStack.add(nodeHead);</span><br><span class="line">    <span class="keyword">while</span>(!myStack.isEmpty()) &#123;</span><br><span class="line">        TreeNode node=myStack.pop();    <span class="comment">//弹出栈顶元素</span></span><br><span class="line">        System.out.print(node.data+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.rightNode!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            myStack.push(node.rightNode);    <span class="comment">//深度优先遍历，先遍历左边，后遍历右边,栈先进后出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.leftNode!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            myStack.push(node.leftNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java面试</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是CRISPR/Cas9</title>
    <url>/blog/posts/b7653deb/</url>
    <content><![CDATA[<h1 id="什么是CRISPR-Cas系统"><a href="#什么是CRISPR-Cas系统" class="headerlink" title="什么是CRISPR-Cas系统"></a>什么是<code>CRISPR-Cas</code>系统</h1><p><code>CRISPR-Cas</code>系统是原核生物的一种天然免疫系统。某些细菌在遭到病毒入侵后，能够把病毒基因的一小段存储到自身的 <code>DNA</code> 里一个称为 <code>CRISPR</code> 的存储空间。当再次遇到病毒入侵时，细菌能够根据存写的片段识别病毒，将病毒的<code>DNA</code>切断而使之失效。</p>
<span id="more"></span>

<img data-src="/blog/posts/b7653deb/2021-11-10-15-36-21.png" class="">



<p><code>CRISPR-Cas</code>系统包含<code>CRISPR</code>基因座和<code>Cas</code>基因（<code>CRISPR</code>关联基因）两部分。</p>
<img data-src="/blog/posts/b7653deb/2021-11-10-15-36-29.png" class="">


<ol>
<li><code>CRISPR</code>是原核生物基因组内的一段重复序列。<code>CRISPR</code>全称<code>Clustered Regularly Interspersed Short Palindromic Repeats</code>（成簇的规律性间隔的短回文重复序列）。分布在<code>40%</code>的已测序细菌和<code>90%</code>的已测序古细菌当中。 （注：生活在深海的火山口、陆地的热泉以及盐碱湖等极端环境中，有一些独特结构的细菌，称为古细菌）</li>
</ol>
<pre><code>&gt; `CRISPR`基因序列主要由前导序列`（leader）`、重复序列（`repeat`）和间隔序列（`spacer`）构成。
</code></pre>
<ul>
<li><p>①前导序列：富含<code>AT</code>碱基，位于<code>CRISPR</code>基因上游，被认为是<code>CRISPR</code>序列的启动子。</p>
</li>
<li><p>②重复序列：长度约<code>20–50 bp</code>碱基且包含<code>5–7 bp</code>回文序列，转录产物可以形成发卡结构，稳定<code>RNA</code>的整体二级结构。</p>
</li>
<li><p>③间隔序列：是被细菌俘获的外源<code>DNA</code>序列。这就相当于细菌免疫系统的“黑名单”，当这些外源遗传物质再次入侵时，<code>CRISPR/Cas</code>系统就会予以精确打击。</p>
</li>
</ul>
<ol start="2">
<li><p><code>Cas</code>基因位于<code>CRISPR</code>基因附近或分散于基因组其他地方，该基因编码的蛋白均可与<code>CRISPR</code>序列区域共同发生作用。因此，该基因被命名为<code>CRISPR</code>关联基因（<code>CRISPR associated，Cas</code>）。</p>
<p> <code>Cas</code>基因编码的<code>Cas</code>蛋白在防御过程中至关重要，目前已经发现了<code>Cas1-Cas10</code>等多种类型的<code>Cas</code>基因。</p>
</li>
</ol>
<p>依据<code>Cas</code>蛋白在细菌免疫防御过程中参与的角色，目前将<code>CRISPR-Cas</code>系统分为两大类。</p>
<p>第一大类：它们切割外源核酸的效应因子为多个<code>Cas</code>蛋白形成的复合物，包括<code>Ⅰ</code>型、<code>Ⅲ</code>型和<code>Ⅳ</code>型。</p>
<p>第二大类：它们的作用因子是比较单一的<code>Cas</code>蛋白，比如<code>Ⅱ</code>型的<code>Cas9</code>蛋白和<code>Ⅴ</code>型的<code>Cpf</code>蛋白。</p>
<img data-src="/blog/posts/b7653deb/2021-11-10-15-36-36.png" class="">

<p><font style="color:red;font-weight:bolder">目前，被最为广泛应用的<code>CRISPR</code>系统是<code>II</code>型<code>CRISPR-Cas</code>系统，也就是<code>CRISPR-Cas9</code>系统。</font></p>
<h1 id="CRISPR-Cas9的作用原理"><a href="#CRISPR-Cas9的作用原理" class="headerlink" title="CRISPR-Cas9的作用原理"></a><code>CRISPR-Cas9</code>的作用原理</h1><p>对于<code>CRISPR-Cas9</code>的作用机理可以分为三个阶段来理解。</p>
<h2 id="1、第一阶段：CRISPR-的高度可变的间隔区的获得（俘获外源DNA，登记“黑名单”）"><a href="#1、第一阶段：CRISPR-的高度可变的间隔区的获得（俘获外源DNA，登记“黑名单”）" class="headerlink" title="1、第一阶段：CRISPR 的高度可变的间隔区的获得（俘获外源DNA，登记“黑名单”）"></a>1、第一阶段：<code>CRISPR </code>的高度可变的间隔区的获得（俘获外源<code>DNA</code>，登记“黑名单”）</h2><p><code>CRISPR</code> 的高度可变的间隔区获得，其实就是指外来入侵的噬菌体或是质粒<code>DNA</code> 的一小段<code>DNA</code> 序列被整合到宿主菌的基因组，整合的位置位于<code>CRRSPR </code>的5’ 端的两个重复序列之间。因此，<code>CRISPR</code> 基因座中的间隔序列从5’ 到3’ 的排列也记录了外源遗传物质入侵的时间顺序。</p>
<p>新间隔序列的获得可能分为三步：</p>
<ol>
<li><p>第1步：<code>Cas1</code>和<code>Cas2</code>编码的蛋白将扫描入侵的<code>DNA</code>，并识别出<code>PAM</code>区域，然后将临近<code>PAM</code>的<code>DNA</code>序列作为候选的原型间隔序列。</p>
<ul>
<li>①<code>PAM</code>类似身份证，原型间隔序列类似身份证号码。</li>
<li>②<code>PAM</code>通常由<code>NGG</code>三个碱基构成（<code>N</code>为任意碱基）。</li>
<li>③<code>Cas1</code> 和<code>Cas2</code> 蛋白是负责新间隔序列获得的核心蛋白．另外研究发现<code>TypeⅡ CRISRP/ Cas</code> 系统中<code>Csn2</code> 蛋白对于新的间隔序列的获得也是必需的。</li>
</ul>
</li>
<li><p>第2步：<code>Cas1/2</code>蛋白复合物将原间隔序列从外源<code>DNA</code>中剪切下来，并在其他酶的协助下将原间隔序列插入临近<code>CRISPR</code>序列前导区的下游。</p>
</li>
<li><p>第3步：<code>DNA</code>会进行修复，将打开的双链缺口闭合。这样一来，一段新的间隔序列就被添加到了基因组的<code>CRISPR</code>序列之中。</p>
</li>
</ol>
<img data-src="/blog/posts/b7653deb/2021-11-10-15-36-53.png" class="">

<h2 id="2、第二阶段：CRIPSR-基因座的表达（包括转录和转录后的成熟加工）"><a href="#2、第二阶段：CRIPSR-基因座的表达（包括转录和转录后的成熟加工）" class="headerlink" title="2、第二阶段：CRIPSR 基因座的表达（包括转录和转录后的成熟加工）"></a>2、第二阶段：<code>CRIPSR</code> 基因座的表达（包括转录和转录后的成熟加工）</h2><p><code>CRISPR</code>序列在前导区的调控下转录产生<code>pre-crRNA</code>（<code>crRNA</code>的前体），同时与<code>pre-crRNA</code>序列互补的<code>tracrRNA</code>（反式激活<code>crRNA</code>）也被转录出来。<code>pre-crRNA</code>通过碱基互补配对与<code>tracrRNA</code>形成双链<code>RNA</code>并与<code>Cas9</code>编码的蛋白组装成一个复合体。它将根据入侵者的类型，选取对应的“身份证号码”（间隔序列<code>RNA</code>），并在核糖核酸酶Ⅲ（<code>RNaseⅢ</code>）的协助下对这段“身份证”进行剪切，最终形成一段短小的<code>crRNA</code>（包含单一种类的间隔序列<code>RNA</code>以及部分重复序列区）。</p>
<p><code>crRNA，Cas9</code>以及<code>tracrRNA</code>组成最终的复合物，为下一步剪切做好准备。</p>
<img data-src="/blog/posts/b7653deb/2021-11-10-15-36-58.png" class="">

<h2 id="3、第三阶段：CRISPR-Cas-系统活性的发挥（靶向干扰）"><a href="#3、第三阶段：CRISPR-Cas-系统活性的发挥（靶向干扰）" class="headerlink" title="3、第三阶段：CRISPR/Cas 系统活性的发挥（靶向干扰）"></a>3、第三阶段：<code>CRISPR/Cas</code> 系统活性的发挥（靶向干扰）</h2><p><code>crRNA，Cas9</code>以及<code>tracrRNA</code>组成最终的复合物就像是一枚制导导弹，可以对入侵者的DNA进行精确的打击。这个复合物将扫描整个外源<code>DNA</code>序列，并识别出与<code>crRNA</code>互补的原间隔序列。这时，复合物将定位到<code>PAM/</code>原间隔序列的区域，<code>DNA</code>双链将被解开，形成<code>R-Loop。crRNA</code>将与互补链杂交，而另一条链则保持游离状态。</p>
<p>随后，<code>Cas9</code>蛋白精确的平端切割位点位于<code>PAM</code>上游<code>3</code>个核苷酸位置，形成平末端产物。<code>Cas9</code>蛋白的<code>HNH</code>结构域负责切割与<code>crRNA</code>互补配对的那一条DNA链，而<code>RuvC</code>结构域负责切割另外一条非互补<code>DNA</code>链。最终在<code>Cas9</code>的作用下<code>DNA</code>双链断裂<code>（DSB）</code>，外源<code>DNA</code>的表达被沉默，入侵者被一举歼灭。</p>
<img data-src="/blog/posts/b7653deb/2021-11-10-15-37-03.png" class="">

<h1 id="CRISPR-Cas9基因编辑技术及应用"><a href="#CRISPR-Cas9基因编辑技术及应用" class="headerlink" title="CRISPR-Cas9基因编辑技术及应用"></a><code>CRISPR-Cas9</code>基因编辑技术及应用</h1><p><code>tracrRNA-crRNA</code>在被融合为单链向导<code>RNA（sgRNA）</code>时也可以发挥指导<code>Cas9</code>的作用。</p>
<p><code>CRISPR-Cas9</code>基因编辑技术就是通过人工设计的 <code>sgRNA（guide RNA）</code>来识别目的基因组序列，并引导 <code>Cas9</code> 蛋白酶进行有效切割<code>DNA</code>双链，形成双链断裂，损伤后修复会造成基因敲除或敲入等，最终达到对基因组<code>DNA</code> 进行修饰的目的。</p>
<p><code>CRISPR-Cas9</code>的广泛应用</p>
<h2 id="1-基因敲除（Knock-out）"><a href="#1-基因敲除（Knock-out）" class="headerlink" title="1.基因敲除（Knock-out）"></a>1.基因敲除<code>（Knock-out）</code></h2><p><code>Cas9</code>可以对靶基因组进行剪切，形成<code>DNA</code>的双链断裂。在通常情况下，细胞会采用高效的非同源末端连接方式（<code>NHEJ</code>）对断裂的<code>DNA</code>进行修复。但是，在修复过程中通常会发生碱基插入或缺失的错配现象，造成移码突变，（移码突变：是指<code>DNA</code>分子由于某位点碱基的缺失或插入，引起阅读框架变化，造成下游的一系列密码改变，使原来编码某种肽链的基因变成编码另一种完全不同的肽链序列。）使靶标基因失去功能，从而实现基因敲除。为了提高<code>CRISPR</code>系统的特异性，可将<code>Cas9</code>的一个结构域进行突变，形成只能对<code>DNA</code>单链进行切割造成<code>DNA</code>缺口的<code>Cas9 nickase</code>核酸酶。因此想要形成双链断裂的效果可以设计两条<code>sgRNA</code>序列，分别靶向<code>DNA</code>互补的两条链，这样两条<code>sgRNA</code>特异性的结合靶标序列，即可形成<code>DNA</code>断裂，并在修复过程中通过移码突变实现基因敲除</p>
<h2 id="2-基因敲入（Knock-in）"><a href="#2-基因敲入（Knock-in）" class="headerlink" title="2.基因敲入（Knock-in）"></a>2.基因敲入（<code>Knock-in</code>）</h2><p>当<code>DNA</code>双链断裂后，如果有<code>DNA</code>修复模板进入到细胞中，基因组断裂部分会依据修复模板进行同源重组修复（<code>HDR</code>），从而实现基因敲入。修复模板由需要导入的目标基因和靶序列上下游的同源性序列（同源臂）组成，同源臂的长度和位置由编辑序列的大小决定。<code>DNA</code>修复模板可以是线性/双链脱氧核苷酸链，也可以是双链<code>DNA</code>质粒。<code>HDR</code>修复模式在细胞中发生率较低，通常小于<code>10%</code>。为了增加基因敲入的成功率，目前有很多科学家致力于提高<code>HDR</code>效率，将编辑的细胞同步至<code>HDR</code>最活跃的细胞分裂时期，促进修复方式以<code>HDR</code>进行；或者利用化学方法抑制基因进行<code>NHEJ</code>，提高<code>HDR</code>的效率</p>
<h2 id="3-基因抑制、基因激活"><a href="#3-基因抑制、基因激活" class="headerlink" title="3.基因抑制、基因激活"></a>3.基因抑制、基因激活</h2><p><code>Cas9</code>的特点是能够自主结合和切割目的基因，通过点突变的方式使<code>Cas9</code>的两个结构域<code>RuvC-</code>和<code>HNH-</code>失去活性，形成的<code>dCas9</code>只能在<code>sgRNA</code>的介导下结合靶基因，而不具备剪切<code>DNA</code>的功能。因此，将<code>dCas9</code>结合到基因的转录起始位点，可以阻断转录的开始，从而抑制基因表达；将<code>dCas9</code>结合到基因的启动子区域也可以结合转录抑制/活化物，使下游靶基因转录受到抑制或激活。因此<code>dCas9</code>与<code>Cas9、Cas9 nickase</code>的不同之处在于，<code>dCas9</code>造成的激活或者抑制是可逆的，并不会对基因组<code>DNA</code>造成永久性的改变。</p>
<h2 id="4-多重编辑（Multiplex-Editing）"><a href="#4-多重编辑（Multiplex-Editing）" class="headerlink" title="4.多重编辑（Multiplex Editing）"></a>4.多重编辑<code>（Multiplex Editing）</code></h2><p>将多个<code>sgRNA</code>质粒转入到细胞中，可同时对多个基因进行编辑，具有基因组功能筛选作用。多重编辑的应用包括：使用双<code>Cas9nickases</code>提高基因敲除的准确率、大范围的基因组缺失及同时编辑不同的基因。通常情况下，一个质粒上可以构建<code>2～7</code>个不同的<code>sgRNA</code>进行多重<code>CRISPR</code>基因编辑。</p>
<h2 id="5-功能基因组筛选"><a href="#5-功能基因组筛选" class="headerlink" title="5.功能基因组筛选"></a>5.功能基因组筛选</h2><p>利用<code>CRISPR-Cas9</code>进行基因编辑可以产生大量的基因突变细胞，因此利用这些突变细胞可以确认表型的变化是否是由基因或者遗传因素导致的。基因组筛选的传统方法是<code>shRNA</code>技术，但是<code>shRNA</code>有其局限性：具有很高的脱靶效应以及无法抑制全部基因而形成假阴性的结果。<code>CRISRP-Cas9</code>系统的基因组筛选功能具有高特异性和不可逆性的优势，在基因组筛选中得到了广泛的应用。目前<code>CRISPR</code>的基因组筛选功能应用于筛选对表型有调节作用的相关基因，如对化疗药物或者毒素产生抑制的基因、影响肿瘤迁移的基因以及构建病毒筛选文库对潜在基因进行大范围筛选等。</p>
]]></content>
      <categories>
        <category>基因编辑</category>
      </categories>
      <tags>
        <tag>生物信息</tag>
        <tag>基因编辑</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>位，字节， 字符</title>
    <url>/blog/posts/166a1445/</url>
    <content><![CDATA[<h2 id="位，字节，-字符"><a href="#位，字节，-字符" class="headerlink" title="位，字节， 字符"></a>位，字节， 字符</h2><h3 id="1-位"><a href="#1-位" class="headerlink" title="1. 位"></a>1. 位</h3><pre><code> 数据存储的最小单位。每个二进制数字0或者1就是1个位,比特为 bit ，简称 b
 
</code></pre>
<span id="more"></span>

<h3 id="2-字节"><a href="#2-字节" class="headerlink" title="2. 字节"></a>2. 字节</h3><pre><code> 8个位构成一个字节；即：1 byte (字节)= 8 bit(位)；
 Byte(字节)，简称B。byte是基本数据类型，Byte是byte的包装类
</code></pre>
<p>     <code>1 KB</code> = <code>1024 B</code>(字节)；</p>
<p>     <code>1 MB</code> = <code>1024 KB</code>;  (<code>2^20 B</code>)</p>
<p>     <code>1 GB</code> = <code>1024 MB</code>;  (<code>2^20 KB</code>)</p>
<p>     <code>1 TB</code> = <code>1024 GB</code>;  (<code>2^30 KB</code>)</p>
<h3 id="3-字符"><a href="#3-字符" class="headerlink" title="3.字符"></a>3.字符</h3><p> <code>a、A、中、+、*、の......</code>均表示一个字符；</p>
<p> 字符(汉字和汉字标点符号都算字符)</p>
<pre><code> 一般 utf-8 编码下，一个汉字 字符 占用 3 个 字节；

 一般 gbk 编码下，一个汉字  字符  占用 2 个 字节；
</code></pre>
<h3 id="4-字符集"><a href="#4-字符集" class="headerlink" title="4.字符集"></a>4.字符集</h3><pre><code> 即各种各个字符的集合，也就是说哪些汉字，字母（A、b、c）和符号（空格、引号..）会被收入标准中；
</code></pre>
<h3 id="5-编码"><a href="#5-编码" class="headerlink" title="5.编码"></a>5.编码</h3><blockquote>
<p><code>ASCII</code>码：一个英文字母（不分大小写）占<code>一个字节</code>的空间，一个中文汉字占<code>两个字节</code>的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值<code>-128</code>，最大值<code>127</code>。如一个<code>ASCII</code>码就是<code>一个字节</code>,<code>0~127</code>(总共有<code>128</code>个<code>ASCII</code>码)。</p>
</blockquote>
<blockquote>
<p><code>UTF-8</code>编码：一个<code>英文字符</code>等于<code>一个字节</code>，一个<code>中文（含繁体）</code>等于<code>三个字节</code>。<code>中文标点</code>占<code>三个字节</code>，英文标点占<code>一个字节</code></p>
</blockquote>
<blockquote>
<p><code>Unicode</code>编码：一个<code>英文</code>等于<code>两个字节</code>，一个<code>中文</code>（含繁体）等于<code>两个字节</code>。<code>中文标点</code>占<code>两个字节</code>，<code>英文标点</code>占<code>两个字节</code></p>
</blockquote>
<h2 id="基本数据类型范围"><a href="#基本数据类型范围" class="headerlink" title="基本数据类型范围"></a>基本数据类型范围</h2><p>在<code>JAVA</code>中一共有八种基本数据类型，他们分别是：<code>byte、short、int、long、float、double、char、boolean</code></p>
<ul>
<li><code>byte</code>的取值范围为 <code>-128</code> ~ <code>127</code>, 占用<code>一个</code>字节(<code>-2^7</code> 到 <code>(2^7)-1</code> )</li>
<li><code>short</code> 的取值范围为 <code>-32768</code> ～ <code>32767</code>， 占用 <code>两个</code> 字节 (<code>-2^15</code> 到 <code>(2^31)-1</code>)</li>
<li><code>int</code> 的取值范围为 <code>-2147483648</code><del><code>2147483647</code>(<code>-2^31</code></del><code>(2^31)-1</code>) , 占用<code>四个个</code>字节</li>
<li><code>long</code>的取值范围为（<code>-9223372036854774808</code> ~ <code>9223372036854774807</code>）, 占用<code>8个字节</code>（<code>-2^63</code> 到 <code>(2^63)-1</code>）</li>
</ul>
<p>可以看到<code>byte</code>和<code>short</code>的取值范围比较小，而<code>long</code>的取值范围太大，占用的空间多，基本上<code>int</code>可以满足我们的日常的计算了，而且<code>int</code>也是使用的最多的整型类型了。 在通常情况下，如果<code>JAVA</code>中出现了一个整数数字比如<code>35</code>，那么这个数字就是<code>int</code>型的，如果我们希望它是<code>byte</code>型的，可以在数据后加上大写的 <code>B</code>：<code>35B</code>，表示它是<code>byte</code>型的. 同样的<code>35S</code>表示<code>short</code>型，<code>35L</code>表示<code>long</code>型的，表示<code>int</code>我们可以什么都不用加，但是如果要表示<code>long</code>型的，就一定要在数据后面加<code>“L”</code>。</p>
<p>浮点型 <code>float</code>和<code>double</code>是表示浮点型的数据类型，他们之间的区别在于他们的精确度不同</p>
<ul>
<li><code>float</code> <code>3.402823e+38 ~ 1.401298e-45</code>（<code>e+38</code>表示是乘以<code>10</code>的<code>38</code>次方，同样，<code>e-45</code>表示乘以<code>10</code>的负<code>45</code>次方）, 占用<code>4个字节 </code></li>
<li><code>double</code> <code>1.797693e+308 ~ 4.9000000e-324</code> 占用<code>8个字节</code> . <code>double</code>型比<code>float</code>型存储范围更大，精度更高，所以通常的浮点型的数据在不声明的情况下都是<code>double</code>型的，如果要表示一个数据是<code>float</code>型的，可以在数据后面加上<code>“F”</code>。 浮点型的数据是不能完全精确的，所以有的时候在计算的时候可能会在小数点最后几位出现浮动，这是正常的。</li>
<li><code>boolean</code>型（布尔型） 这个类型只有两个值，<code>true</code>和<code>false</code>（真和非真） <code>boolean t = true</code>； <code>boolean f = false；</code></li>
<li><code>char</code>型（文本型） 用于存放字符的数据类型，占用<code>2个字节</code>，采用<code>unicode</code>编码，它的前<code>128字节</code>编码与<code>ASCII</code>兼容 字符的存储范围在<code>\u0000~\uFFFF</code>，在定义字符型的数据时候要注意加<code>&#39; &#39;</code>，比如<code> &#39;1&#39;</code>表示字符<code>&#39;1&#39;</code>而不是数值<code>1</code><ul>
<li><code>char c = &#39; 1 &#39;</code>; 我们试着输出<code>c</code>看看，<code>System.out.println(c)</code>;</li>
<li>结果就是<code>1</code></li>
<li>而如果我们这样输出呢<code>System.out.println(c+0)</code>; 结果却变成了<code>49</code>。 如果我们这样定义<code>c</code>看看 <code>char c = &#39; \u0031 &#39;</code>;</li>
<li>输出的结果仍然是<code>1</code>，</li>
<li>这是因为字符<code>&#39;1&#39;</code>对应着unicode编码就是<code>\u0031</code>, <code>char c1 = &#39;h&#39;</code>,<code>c2 = &#39;e&#39;</code>,<code>c3=&#39;l&#39;</code>,<code>c4=&#39;l&#39;</code>,<code>c5 = &#39;o&#39;</code>;</li>
<li><code> System.out.print(c1);</code> <code>System.out.print(c2);</code> <code>System.out.print(c3);</code> <code>System.out.print(c4);</code> <code>Sytem.out.print(c5);</code></li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveTypeTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// byte  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：byte 二进制位数：&quot;</span> + Byte.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Byte&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最小值：Byte.MIN_VALUE=&quot;</span> + Byte.MIN_VALUE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：Byte.MAX_VALUE=&quot;</span> + Byte.MAX_VALUE);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// short  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：short 二进制位数：&quot;</span> + Short.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Short&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最小值：Short.MIN_VALUE=&quot;</span> + Short.MIN_VALUE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：Short.MAX_VALUE=&quot;</span> + Short.MAX_VALUE);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// int  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：int 二进制位数：&quot;</span> + Integer.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Integer&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最小值：Integer.MIN_VALUE=&quot;</span> + Integer.MIN_VALUE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：Integer.MAX_VALUE=&quot;</span> + Integer.MAX_VALUE);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// long  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：long 二进制位数：&quot;</span> + Long.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Long&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最小值：Long.MIN_VALUE=&quot;</span> + Long.MIN_VALUE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：Long.MAX_VALUE=&quot;</span> + Long.MAX_VALUE);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// float  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：float 二进制位数：&quot;</span> + Float.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Float&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最小值：Float.MIN_VALUE=&quot;</span> + Float.MIN_VALUE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：Float.MAX_VALUE=&quot;</span> + Float.MAX_VALUE);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// double  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：double 二进制位数：&quot;</span> + Double.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Double&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最小值：Double.MIN_VALUE=&quot;</span> + Double.MIN_VALUE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：Double.MAX_VALUE=&quot;</span> + Double.MAX_VALUE);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// char  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型：char 二进制位数：&quot;</span> + Character.SIZE);  </span><br><span class="line">        System.out.println(<span class="string">&quot;包装类：java.lang.Character&quot;</span>);  </span><br><span class="line">        <span class="comment">// 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;最小值：Character.MIN_VALUE=&quot;</span>  </span><br><span class="line">                + (<span class="keyword">int</span>) Character.MIN_VALUE);  </span><br><span class="line">        <span class="comment">// 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：Character.MAX_VALUE=&quot;</span>  </span><br><span class="line">                + (<span class="keyword">int</span>) Character.MAX_VALUE);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基本类型：<span class="keyword">byte</span> 二进制位数：<span class="number">8</span></span><br><span class="line">包装类：java.lang.Byte</span><br><span class="line">最小值：Byte.MIN_VALUE=-<span class="number">128</span></span><br><span class="line">最大值：Byte.MAX_VALUE=<span class="number">127</span></span><br><span class="line"></span><br><span class="line">基本类型：<span class="keyword">short</span> 二进制位数：<span class="number">16</span></span><br><span class="line">包装类：java.lang.Short</span><br><span class="line">最小值：Short.MIN_VALUE=-<span class="number">32768</span></span><br><span class="line">最大值：Short.MAX_VALUE=<span class="number">32767</span></span><br><span class="line"></span><br><span class="line">基本类型：<span class="keyword">int</span> 二进制位数：<span class="number">32</span></span><br><span class="line">包装类：java.lang.Integer</span><br><span class="line">最小值：Integer.MIN_VALUE=-<span class="number">2147483648</span></span><br><span class="line">最大值：Integer.MAX_VALUE=<span class="number">2147483647</span></span><br><span class="line"></span><br><span class="line">基本类型：<span class="keyword">long</span> 二进制位数：<span class="number">64</span></span><br><span class="line">包装类：java.lang.Long</span><br><span class="line">最小值：Long.MIN_VALUE=-<span class="number">9223372036854775808</span></span><br><span class="line">最大值：Long.MAX_VALUE=<span class="number">9223372036854775807</span></span><br><span class="line"></span><br><span class="line">基本类型：<span class="keyword">float</span> 二进制位数：<span class="number">32</span></span><br><span class="line">包装类：java.lang.Float</span><br><span class="line">最小值：Float.MIN_VALUE=<span class="number">1.4E-45</span></span><br><span class="line">最大值：Float.MAX_VALUE=<span class="number">3.4028235E38</span></span><br><span class="line"></span><br><span class="line">基本类型：<span class="keyword">double</span> 二进制位数：<span class="number">64</span></span><br><span class="line">包装类：java.lang.Double</span><br><span class="line">最小值：Double.MIN_VALUE=<span class="number">4.9E-324</span></span><br><span class="line">最大值：Double.MAX_VALUE=<span class="number">1.7976931348623157E308</span></span><br><span class="line"></span><br><span class="line">基本类型：<span class="keyword">char</span> 二进制位数：<span class="number">16</span></span><br><span class="line">包装类：java.lang.Character</span><br><span class="line">最小值：Character.MIN_VALUE=<span class="number">0</span></span><br><span class="line">最大值：Character.MAX_VALUE=<span class="number">65535</span></span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>Java</category>
        <category>操作系统</category>
        <category>Java面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java面试</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是MapReduce</title>
    <url>/blog/posts/737c98ca/</url>
    <content><![CDATA[<p><code>Hadoop</code>的各个组成部分</p>
<img data-src="/blog/posts/737c98ca/2021-11-22-11-27-10.png" class="">

<span id="more"></span>

<pre><code>归纳:
Hadoop组成
 
    Hadoop  HDFS：一个高可靠、高吞吐量的分布式文件系统，对海量数据的存储。
     Hadoop  MapReduce：一个分布式的资源调度和离线并行计算框架。
     Hadoop  Yarn：基于HDFS,用于作业调度和集群资源管理的框架。
</code></pre>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>使用EasyExcel读取excel文件为Java实体类</title>
    <url>/blog/posts/13370746/</url>
    <content><![CDATA[<p><a href="https://www.yuque.com/easyexcel/doc/read">附赠<code>EasyExcel</code>的官方文档</a></p>
<p>最近用到了需要使用<code>Excel</code>的<code>InputStream</code>流转化为Java实体类,然后再进行一些业务上的操作,这边稍加学习了之后也做了一些整理:</p>
<p>本次所用到的依赖:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.projectlombok:lombok:1.18.20&#x27;</span></span><br><span class="line">implementation <span class="keyword">group</span>: <span class="string">&#x27;cn.hutool&#x27;</span>, name: <span class="string">&#x27;hutool-all&#x27;</span>, version: <span class="string">&#x27;5.7.16&#x27;</span></span><br><span class="line">implementation(<span class="string">&#x27;com.alibaba:easyexcel:2.2.6&#x27;</span>)</span><br><span class="line">implementation <span class="string">&#x27;com.google.protobuf:protobuf-java:4.0.0-rc-2&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="首先需要建立一个和Excel相对应的实体类"><a href="#首先需要建立一个和Excel相对应的实体类" class="headerlink" title="首先需要建立一个和Excel相对应的实体类"></a>首先需要建立一个和<code>Excel</code>相对应的实体类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexOrNameData</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 强制读取第三个 这里不建议 index 和 name 同时用，要么一个对象只用index，要么一个对象只用name去匹配</span></span><br><span class="line"><span class="comment">     *  index 从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 2)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用名字去匹配，这里需要注意，如果名字重复，会导致只有一个字段读取到数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;字符串标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;日期标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>使用解析功能时需要使用到<code>easyExcel</code>提供给我们的一个监听器</p>
<img data-src="/blog/posts/13370746/2021-12-15-18-51-15.png" class="">

<p>所以我这边选择的是继承<code>AnalysisEventListener</code>类,是一个通用泛型类</p>
<p><strong>有个很重要的点<code>ExcelListener</code> 不能被<code>spring</code>管理，要每次读取<code>excel</code>都要<code>new</code>,然后里面用到<code>spring</code>可以构造方法传进去</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelListener</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来获取解析到的数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(T data, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(data));</span><br><span class="line">        dataList.add(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;所有数据解析完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getDataList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工具类泛化使用"><a href="#工具类泛化使用" class="headerlink" title="工具类泛化使用"></a>工具类泛化使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelUtil</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取excel InputStream流 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">readExcel</span><span class="params">(InputStream excelInputStream, Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        ExcelListener&lt;T&gt; excelListener = <span class="keyword">new</span> ExcelListener&lt;&gt;();</span><br><span class="line">        <span class="comment">//此处的read方法也支持`file`类型,这边使用的是inputStream流</span></span><br><span class="line">        ExcelReader excelReader = EasyExcel.read(excelInputStream, clazz, excelListener).build();</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtil.isNull(excelReader))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;ReadSheet&gt; readSheetList = excelReader.excelExecutor().sheetList();</span><br><span class="line">        <span class="keyword">for</span> (ReadSheet readSheet : readSheetList) &#123;</span><br><span class="line">            excelReader.read(readSheet);</span><br><span class="line">        &#125;</span><br><span class="line">        excelReader.finish();</span><br><span class="line">        <span class="keyword">return</span> Convert.toList(clazz,excelListener.getDataList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于第二个参数 <code>clazz</code>的原因,只要传入了相应的泛型类,就会返回相应类型的<code>List</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\Download\\test.xlsx&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            List&lt;IndexOrNameData&gt; driverBlackListExcels = ExcelUtil.readExcel(fileInputStream, IndexOrNameData.class);</span><br><span class="line">            System.out.println(driverBlackListExcels);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/13370746/2021-12-15-19-09-34.png" class="">


<h2 id="JavaList封装为Excel返回"><a href="#JavaList封装为Excel返回" class="headerlink" title="JavaList封装为Excel返回"></a><code>JavaList</code>封装为<code>Excel</code>返回</h2><p>上面已经介绍完如果读取上传的<code>Excel</code>文件,接下来需要介绍如何将<code>List</code>数据输出为<code>Excel</code>文件</p>
<p>一样需要建立一个和<code>Excel</code>对应的实体类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExcelPojo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;年龄&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;余额&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String money;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 忽略这个字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String ignore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边有一个注意点,就是<code>@ExcelProperty</code>是把你的<code>Excel</code>头换成了对应的值,但是存在于这个实体类中属性都会被解析出来放到输出的<code>Excel</code>文件中.</p>
<p>然后使用<code>EasyExcel</code>提供的方法来进行数据的写,一下是用例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEasyExcel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;download.tmpPath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tmp;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Context01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList&lt;TestExcelPojo&gt; pojoArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        TestExcelPojo pojo = <span class="keyword">new</span> TestExcelPojo(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;21&quot;</span>, <span class="string">&quot;100&quot;</span>);</span><br><span class="line">        pojoArrayList.add(pojo);</span><br><span class="line">        pojoArrayList.add(pojo);</span><br><span class="line">        pojoArrayList.add(pojo);</span><br><span class="line">        pojoArrayList.add(pojo);</span><br><span class="line">        pojoArrayList.add(pojo);</span><br><span class="line"></span><br><span class="line">        String fileName = tmp + File.separator + IdUtil.simpleUUID() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">        ExcelWriter excelWriter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            excelWriter = EasyExcel.write(fileName,TestExcelPojo.class).build();</span><br><span class="line">            WriteSheet writeSheet = EasyExcel.writerSheet(<span class="string">&quot;模板&quot;</span>).build();</span><br><span class="line">            excelWriter.write(pojoArrayList,writeSheet);</span><br><span class="line">            FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">            <span class="comment">//转化为二进制流</span></span><br><span class="line">            ByteString bytes = ByteString.readFrom(fileInputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (excelWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                excelWriter.finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/13370746/2021-12-16-15-33-13.png" class="">
]]></content>
      <categories>
        <category>Java</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo框架+next主题+githubPage搭建个人博客</title>
    <url>/blog/posts/3d071a12/</url>
    <content><![CDATA[<p>我自己的博客是采用了<code>hexo</code>+ <code>Next</code>主题搭建完成，并做了一些简单的配置，这边也将全面从0-&gt;1介绍</p>
<h1 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装<code>Node</code></h1><p><code>Node</code>的官网为 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL3poLWNuL2Rvd25sb2FkLw==">https://nodejs.org/zh-cn/download/</span>  </p>
<img data-src="/blog/posts/3d071a12/2021-11-13-00-33-44.png" class=""> 

<p>下载自己对应的版本即可，傻瓜式的下一步下一步之后，在终端控制台输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<img data-src="/blog/posts/3d071a12/2021-11-13-00-34-52.png" class="">

<p>说明安装成功，而在这个时候也会给你安装了<code>npm</code>环境，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/3d071a12/2021-11-13-00-36-59.png" class="">

<p>此时我们需要将原生的镜像源换为淘宝镜像源，这样能加快下载速度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置镜像源</span><br><span class="line">npm config set registry=https://registry.npm.taobao.org/</span><br><span class="line"># 查看镜像源</span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>

<p><code>Node</code>环境安装完毕</p>
<h1 id="安装Git并创建github-pages"><a href="#安装Git并创建github-pages" class="headerlink" title="安装Git并创建github pages"></a>安装<code>Git</code>并创建<code>github pages</code></h1><p>git安装地址 ： <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyLyVFOCVCNSVCNyVFNiVBRCVBNS0lRTUlQUUlODklRTglQTMlODUtR2l0">https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git</span></p>
<p><code>github</code>注册这边也不多赘述，不会的小伙伴可以自行百度</p>
<h2 id="创建github项目"><a href="#创建github项目" class="headerlink" title="创建github项目"></a>创建<code>github</code>项目</h2><h2 id="创建responsibility"><a href="#创建responsibility" class="headerlink" title="创建responsibility"></a>创建<code>responsibility</code></h2><img data-src="/blog/posts/3d071a12/2021-11-13-21-03-18.png" class="">

<img data-src="/blog/posts/3d071a12/2021-11-13-21-04-34.png" class="">

<p>这边我踩了个坑，命名格式好像必须是 <code>owner/owner.github.io</code></p>
<p>然后<code>responsibility</code>就创建好了</p>
<h2 id="生成token"><a href="#生成token" class="headerlink" title="生成token"></a>生成<code>token</code></h2><p>按照图片步骤创建<code>token</code></p>
<img data-src="/blog/posts/3d071a12/2021-11-13-21-10-03.png" class="">

<img data-src="/blog/posts/3d071a12/2021-11-13-21-10-54.png" class="">

<img data-src="/blog/posts/3d071a12/2021-11-13-21-33-00.png" class="">

<p>此时生成的<code>token</code>只会显示这一次，尽量复制保存到本地，据说这个<code>token</code>不开启<code>github Page</code>无法</p>
<h2 id="设置page"><a href="#设置page" class="headerlink" title="设置page"></a>设置<code>page</code></h2><img data-src="/blog/posts/3d071a12/2021-11-15-22-00-27.png" class="">
<p>点击<code>Settings</code>，向下拉到最后有个<code>GitHub Pages</code>，点击<code>Choose a theme</code>选择一个主题。然后等一会儿，此时点击图片中打码链接就是你的<code>GitHub Pages</code>地址了。应该是会跳出一个页面出来。</p>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装<code>Hexo</code></h1><p>选择一个合适的本地位置存在你的<code>Blog</code>源码，比如我就存放在<code>/Users/jinmao/Documents/Blog/blog_source/</code>处，然后输入全局安装<code>hexo</code>脚手架</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>安装完后输入验证是否安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/3d071a12/2021-11-15-23-18-45.png" class="">
<p>说明安装成功啦！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo 常用指令</span><br><span class="line"></span><br><span class="line">hexo init [folder]  //初始化本地文件夹为网站的根目录 - folder 为可选</span><br><span class="line"></span><br><span class="line">//hexo new 命令用于新建文章，&lt;title&gt;字段需要加双引号</span><br><span class="line">hexo n [layout] &lt;title&gt;</span><br><span class="line"></span><br><span class="line">hexo generate //命令用于生成静态文件，一般可以简写为 hexo g</span><br><span class="line">hexo d -g //指生成后再部署</span><br><span class="line"></span><br><span class="line">hexo server //命令用于启动本地服务器，一般可以简写为hexo s</span><br><span class="line">//-p 选项，指定服务器端口，默认为 4000</span><br><span class="line">//-i 选项，指定服务器 IP 地址，默认为 0.0.0.0</span><br><span class="line">//-s 选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视</span><br><span class="line"></span><br><span class="line">hexo clean //命令用于清理缓存文件，是一个比较常用的命令</span><br><span class="line"></span><br><span class="line">hexo deploy //命令用于部署网站，一般可以简写为 hexo d</span><br></pre></td></tr></table></figure>
<p>说明 ：运行服务器前需要安装 <code>hexo-server </code>插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-server --save</span><br></pre></td></tr></table></figure>

<p>使用<code>hexo -d</code>前需要修改<code>_config.yml</code>配置文件，下面以 <code>git</code> 为例进行说明</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;repository</span> <span class="string">url&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">自定义提交消息，默认为Site</span> <span class="attr">updated:</span> &#123;&#123; <span class="string">now(&#x27;YYYY-MM-DD</span> <span class="string">HH:mm:ss&#x27;)</span> &#125;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h1><p>创建一篇新文章,例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;写在最前面&quot;</span><br></pre></td></tr></table></figure>
<p>然后会在<code>source/_posts</code>下生成一个<code>markdown</code>文件，在这个文件中使用的是正常的<code>markdown</code>语法。<br>然后依次输入以下步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean //清理缓存</span><br><span class="line"></span><br><span class="line">hexo g //编译生成静态文件</span><br><span class="line"></span><br><span class="line">hexo s //启动本地服务器</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/3d071a12/2021-11-17-00-01-23.png" class="">

<p><code>command + 左键</code>就可以在浏览器中浏览效果了</p>
<h1 id="设置背景音乐"><a href="#设置背景音乐" class="headerlink" title="设置背景音乐"></a>设置背景音乐</h1><img data-src="/blog/posts/3d071a12/2021-11-21-22-39-25.png" class="">
<img data-src="/blog/posts/3d071a12/2021-11-21-22-39-51.png" class="">
<img data-src="/blog/posts/3d071a12/2021-11-21-22-40-14.png" class="">

<p>我们将音乐插件添加到侧边栏，效果类似于此<code>Blog</code><br>打开我们主题文件：<code>themes\next\layout\_macro\sidebar.swig找到sidebar-inner</code></p>
<img data-src="/blog/posts/3d071a12/2021-11-21-22-38-07.png" class="">
<p>就可以啦！</p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>使用npm时报python错误的解决方案</title>
    <url>/blog/posts/3eca6246/</url>
    <content><![CDATA[<p>由于本人是做后端的,最近有用到前端的一些东西,由于安装了<code>node</code>之后,<code>npm</code>是自带的,最近在,拉取前端的<code>web</code>项目之后,使用<code>npm install</code>之后,老是会报一个<code>node-sass</code>的错误,错误里面还夹杂了关于<code>python</code>的错误(也可能因为我之前安装了<code>anoconda</code>的原因,虽然卸载了,但还是报这样的错误)</p>
<img data-src="/blog/posts/3eca6246/2021-11-17-10-21-32.png" class="">

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><span id="more"></span>

<p>在网上找了很多解决方案,最后也是自己拼拼凑凑解决了,自己使用的<code>VSCODE</code>编译器,打开终端依次输入以下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g node-gyp</span><br><span class="line"></span><br><span class="line">npm install --global --production windows-build-tools</span><br><span class="line"></span><br><span class="line">npm install node-sass@latest //安装最新的node-sass</span><br></pre></td></tr></table></figure>

<p>然后应该就不会报错啦!</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JVM常用参数</title>
    <url>/blog/posts/a72f470b/</url>
    <content><![CDATA[<p>笔记链接： <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4NjMwMjQvYXJ0aWNsZS9kZXRhaWxzLzExNDY4NDQyOA==">大厂面试视频</span></p>
<h2 id="JVM的标配参数和X参数"><a href="#JVM的标配参数和X参数" class="headerlink" title="JVM的标配参数和X参数"></a><code>JVM</code>的标配参数和<code>X</code>参数</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvdG9vbHMvd2luZG93cy9qYXZhLmh0bWw=">官方文档</span></p>
<p><code>JVM</code>的参数类型：</p>
<span id="more"></span>

<blockquote>
<p>标配参数</p>
</blockquote>
<ul>
<li><code>-version java -version</code></li>
<li><code>-help</code></li>
</ul>
<blockquote>
<p><code>X</code>参数（了解）</p>
</blockquote>
<ul>
<li><code>-Xint</code>：解释执行</li>
<li><code>-Xcomp</code>：第一次使用就编译成本地代码</li>
<li><code>-Xmixed</code>：混合模式</li>
</ul>
<h2 id="VM的XX参数之布尔类型"><a href="#VM的XX参数之布尔类型" class="headerlink" title="VM的XX参数之布尔类型"></a><code>VM</code>的<code>XX</code>参数之布尔类型</h2><p>公式：<code>-XX:+</code> 或者 <code>-</code> 某个属性值（<code>+</code>表示开启，<code>-</code>表示关闭）</p>
<p>如何查看一个正在运行中的<code>java</code>程序，它的某个<code>jvm</code>参数是否开启？具体值是多少？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jps -l 查看一个正在运行中的java程序，得到Java程序号。</span><br><span class="line">jinfo -<span class="function">flag <span class="title">PrintGCDetails</span> <span class="params">(Java程序号 )</span>查看它的某个jvm参数（如PrintGCDetails ）是否开启。</span></span><br><span class="line"><span class="function">jinfo -<span class="title">flags</span> <span class="params">(Java程序号 )</span>查看它的所有jvm参数</span></span><br></pre></td></tr></table></figure>
<p>Case</p>
<blockquote>
<p>是否打印<code>GC</code>收集细节</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:-PrintGCDetails</span><br><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>
<blockquote>
<p>是否使用串行垃圾回收器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:-UseSerialGC</span><br><span class="line">-XX:+UserSerialGC</span><br></pre></td></tr></table></figure>

<h2 id="JVM的XX参数之设值类型"><a href="#JVM的XX参数之设值类型" class="headerlink" title="JVM的XX参数之设值类型"></a><code>JVM</code>的<code>XX</code>参数之设值类型</h2><p>公式：<code>-XX</code>:属性<code>key=</code>属性值<code>value</code></p>
<p>Case</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:MetaspaceSize=128m</span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">15</span></span><br></pre></td></tr></table></figure>
<h2 id="VM的XX参数之XmsXmx坑题"><a href="#VM的XX参数之XmsXmx坑题" class="headerlink" title="VM的XX参数之XmsXmx坑题"></a><code>VM</code>的<code>XX</code>参数之<code>XmsXmx</code>坑题</h2><p>两个经典参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms等价于-XX:InitialHeapSize，初始大小内存，默认物理内存<span class="number">1</span>/<span class="number">64</span></span><br><span class="line">-Xmx等价于-XX:MaxHeapSize，最大分配内存，默认为物理内存<span class="number">1</span>/<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="JVM盘点家底查看初始默认"><a href="#JVM盘点家底查看初始默认" class="headerlink" title="JVM盘点家底查看初始默认"></a><code>JVM</code>盘点家底查看初始默认</h2><blockquote>
<p>查看初始默认参数值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+PrintFlagsInitial</span><br></pre></td></tr></table></figure>

<p>公式：<code>java -XX:+PrintFlagsInitial</code></p>
<img data-src="/blog/posts/a72f470b/2022-03-13-15-29-37.png" class="">

<blockquote>
<p>查看修改更新参数值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+PrintFlagsFinal</span><br></pre></td></tr></table></figure>

<p>公式：<code>java -XX:+PrintFlagsFinal</code></p>
<img data-src="/blog/posts/a72f470b/2022-03-13-15-32-07.png" class="">

<p><strong><code>=</code>表示默认，<code>:=</code>表示修改过的。</strong></p>
<h2 id="JVM盘点家底查看修改变更值"><a href="#JVM盘点家底查看修改变更值" class="headerlink" title="JVM盘点家底查看修改变更值"></a><code>JVM</code>盘点家底查看修改变更值</h2><p><code>PrintFlagsFinal</code>举例，运行<code>java</code>命令的同时打印出参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -XX:MetaspaceSize=512m HelloWorld</span><br><span class="line"></span><br><span class="line">--------------</span><br><span class="line">...</span><br><span class="line">   size_t MetaspaceSize                            := <span class="number">536870912</span>                               &#123;pd product&#125; &#123;<span class="keyword">default</span>&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印命令行参数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(base) ➜  ~ java -XX:+PrintCommandLineFlags -version</span><br><span class="line"></span><br><span class="line">-XX:G1ConcRefinementThreads=<span class="number">8</span> -XX:GCDrainStackTargetSize=<span class="number">64</span> -XX:InitialHeapSize=<span class="number">268435456</span> -XX:MaxHeapSize=<span class="number">4294967296</span> -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=<span class="number">251658240</span> -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br><span class="line">java version <span class="string">&quot;11.0.10&quot;</span> <span class="number">2021</span>-<span class="number">01</span>-<span class="number">19</span> <span class="function">LTS</span></span><br><span class="line"><span class="function"><span class="title">Java</span><span class="params">(TM)</span> SE Runtime Environment 18.9 <span class="params">(build <span class="number">11.0</span><span class="number">.10</span>+<span class="number">8</span>-LTS-<span class="number">162</span>)</span></span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server VM 18.9 <span class="params">(build <span class="number">11.0</span><span class="number">.10</span>+<span class="number">8</span>-LTS-<span class="number">162</span>, mixed mode)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="堆内存初始大小快速复习"><a href="#堆内存初始大小快速复习" class="headerlink" title="堆内存初始大小快速复习"></a>堆内存初始大小快速复习</h2><p><code>JDK 1.8</code>之后将最初的永久代取消了，由元空间取代。</p>
<img data-src="/blog/posts/a72f470b/2022-03-13-15-48-45.png" class="">

<p>在<code>Java8</code>中，永久代已经被移除，被一个称为元空间的区域所取代。元空间的本质和永久代类似。</p>
<p>元空间(<code>Java8</code>)与永久代(<code>Java7</code>)之间最大的区别在于：永久带使用的<code>JVM</code>的堆内存，但是<code>Java8</code>以后的元空间<strong>并不在虚拟机中而是使用本机物理内存</strong>。</p>
<p>因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入<code>native memory</code>，字符串池和类的静态变量放入<code>java</code>堆中，这样可以加载多少类的元数据就不再由<code>MaxPermSize</code>控制，而由系统的实际可用空间来控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMMemorySizeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机中内存的总量</span></span><br><span class="line">        <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回Java虚拟机中试图使用的最大内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;TOTAL_MEMORY(-Xms): %d B, %.2f MB.&quot;</span>, totalMemory, totalMemory / <span class="number">1024.0</span> / <span class="number">1024</span>));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;MAX_MEMORY(-Xmx): %d B, %.2f MB.&quot;</span>, maxMemory, maxMemory / <span class="number">1024.0</span> / <span class="number">1024</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<img data-src="/blog/posts/a72f470b/2022-03-13-15-51-39.png" class="">

<h2 id="常用基础参数栈内存Xss讲解"><a href="#常用基础参数栈内存Xss讲解" class="headerlink" title="常用基础参数栈内存Xss讲解"></a>常用基础参数栈内存<code>Xss</code>讲解</h2><p>设置单个线程栈的大小，一般默认为<code>512k~1024K</code></p>
<p>等价于<code>-XX:ThreadStackSize</code></p>
<blockquote>
<p>-XX:ThreadStackSize=size<br>Sets the thread stack size (in bytes). Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, g or G to indicate gigabytes. The default value depends on virtual memory.<br>The following examples show how to set the thread stack size to 1024 KB in different units:<br>-XX:ThreadStackSize=1m<br>-XX:ThreadStackSize=1024k<br>-XX:ThreadStackSize=1048576<br>This option is equivalent to <code>-Xss</code>. <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvdG9vbHMvd2luZG93cy9qYXZhLmh0bWwjQkdCQ0lFRkM=">文档</span></p>
</blockquote>
<h2 id="常用基础参数元空间MetaspaceSize讲解"><a href="#常用基础参数元空间MetaspaceSize讲解" class="headerlink" title="常用基础参数元空间MetaspaceSize讲解"></a>常用基础参数元空间<code>MetaspaceSize</code>讲解</h2><ul>
<li><code>-Xmn</code>：设置年轻代大小</li>
<li><code>-XX:MetaspaceSize</code> 设置元空间大小</li>
</ul>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制</p>
<p>典型设置案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms128m -Xmx4096m -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails-XX:+UseSerialGC</span><br></pre></td></tr></table></figure>

<h2 id="常用基础参数PrintGCDetails回收前后对比讲解"><a href="#常用基础参数PrintGCDetails回收前后对比讲解" class="headerlink" title="常用基础参数PrintGCDetails回收前后对比讲解"></a>常用基础参数<code>PrintGCDetails</code>回收前后对比讲解</h2><p><code>-XX:+PrintGCDetails</code> 输出详细<code>GC</code>收集日志信息</p>
<p>设置参数 <code>-Xms10m -Xmx10m -XX:+PrintGCDetails</code> 运行以下程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintGCDetailsDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">		</span><br><span class="line">		TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 778K-&gt;480K(2560K)] 778K-&gt;608K(9728K), <span class="number">0.0029909</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 480K-&gt;480K(2560K)] 608K-&gt;616K(9728K), <span class="number">0.0007890</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 480K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 136K-&gt;518<span class="title">K</span><span class="params">(7168K)</span>] 616K-&gt;518<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 2644K-&gt;2644<span class="title">K</span><span class="params">(1056768K)</span>], 0.0058272 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 518K-&gt;518K(9728K), <span class="number">0.0002924</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 518K-&gt;506<span class="title">K</span><span class="params">(7168K)</span>] 518K-&gt;506<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 2644K-&gt;2644<span class="title">K</span><span class="params">(1056768K)</span>], 0.0056906 secs] [Times: user</span>=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.lun.jvm.PrintGCDetailsDemo.main(PrintGCDetailsDemo.java:<span class="number">9</span>)</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 61K [<span class="number">0x00000000ffd00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 2048K, <span class="number">3</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffd0f748</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  from space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line">  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 7168K, used 506K [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd00000</span>, <span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  object space 7168K, <span class="number">7</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff67ea58</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line"> Metaspace       used 2676K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 285<span class="title">K</span>, <span class="title">capacity</span> 386<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/a72f470b/2022-03-13-16-04-30.png" class="">

<img data-src="/blog/posts/a72f470b/2022-03-13-16-04-40.png" class="">

<h2 id="常用基础参数SurvivorRatio讲解"><a href="#常用基础参数SurvivorRatio讲解" class="headerlink" title="常用基础参数SurvivorRatio讲解"></a>常用基础参数<code>SurvivorRatio</code>讲解</h2><img data-src="/blog/posts/a72f470b/2022-03-13-16-05-01.png" class="">

<p>调节新生代中 <code>eden</code> 和 <code>S0、S1</code>的空间比例，默认为 <code>-XX:SuriviorRatio=8，Eden:S0:S1 = 8:1:1</code></p>
<p>假如设置成 <code>-XX:SurvivorRatio=4</code>，则为 <code>Eden:S0:S1 = 4:1:1</code></p>
<p><code>SurvivorRatio</code>值就是设置<code>eden</code>区的比例占多少，<code>S0</code>和<code>S1</code>相同。</p>
<h2 id="常用基础参数NewRatio讲解"><a href="#常用基础参数NewRatio讲解" class="headerlink" title="常用基础参数NewRatio讲解"></a>常用基础参数<code>NewRatio</code>讲解</h2><p>配置年轻代<code>new</code>和老年代<code>old</code> 在堆结构的占比</p>
<p>默认：<code>-XX:NewRatio=2</code> 新生代占<code>1</code>，老年代<code>2</code>，年轻代占整个堆的<code>1/3</code></p>
<p><code>-XX:NewRatio=4：</code>新生代占<code>1</code>，老年代占<code>4</code>，年轻代占整个堆的<code>1/5</code>，</p>
<p><code>NewRadio</code>值就是设置老年代的占比，剩下的<code>1</code>个新生代。</p>
<p>新生代特别小，会造成频繁的进行<code>GC</code>收集。</p>
<h2 id="常用基础参数MaxTenuringThreshold讲解"><a href="#常用基础参数MaxTenuringThreshold讲解" class="headerlink" title="常用基础参数MaxTenuringThreshold讲解"></a>常用基础参数<code>MaxTenuringThreshold</code>讲解</h2><p>晋升到老年代的对象年龄。</p>
<p><code>SurvivorTo和SurvivorFrom</code>互换，原<code>SurvivorTo</code>成为下一次<code>GC</code>时的<code>SurvivorFrom</code>区，部分对象会在<code>From</code>和<code>To</code>区域中复制来复制去，如此交换<code>15</code>次（由<code>JVM</code>参数<code>MaxTenuringThreshold</code>决定，这个参数默认为<code>15</code>），最终如果还是存活，就存入老年代。</p>
<p>这里就是调整这个次数的，默认是15，并且设置的值 在 <code>0~15</code>之间。</p>
<p><code>-XX:MaxTenuringThreshold=0</code>：设置垃圾最大年龄。如果设置为0的话，则年轻对象不经过<code>Survivor</code>区，直接进入老年代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大的值，则年轻代对象会在<code>Survivor</code>区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概念。</p>
]]></content>
      <tags>
        <tag>Java面试</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>使用vscode书写hexo博客粘贴图片解决方案</title>
    <url>/blog/posts/45934af9/</url>
    <content><![CDATA[<p>以前都是在<code>Vscode</code>中写一些<code>MarkDown</code>文档,然后上传到<code>GitHub</code>上做好目录供阅读使用:</p>
<img data-src="/blog/posts/45934af9/2021-11-17-14-35-44.png" class="">

<p>如今搭建好了<code>Blog</code>,图片粘贴也是必不可少的,翻阅大量网站资料,目前本人是采用的如下方式:</p>
<span id="more"></span>

<ul>
<li><p>修改<code>hexo</code>配置文件: <code>post_asset_folder: true</code>,开启之后,生成新的<code>post</code>时,会在<code>source/_posts/</code>下创建一个同名文件夹</p>
 <img data-src="/blog/posts/45934af9/2021-11-17-14-41-29.png" class=""></li>
<li><p>下载插件:<code>paste image</code> <img data-src="/blog/posts/45934af9/2021-11-17-14-47-25.png" class=""><br>这个插件用来在md文档中粘贴图片，默认会在文档的同级目录下新建一个图片文件，并在<code>md</code>中插入一行相对路径的图片代码。迎合上述<code>hexo</code>的新图片插入方式，可以在<code>vscode</code>的<code>user-settings</code>里新增两条配置:</p>
<img data-src="/blog/posts/45934af9/2021-11-17-14-49-06.png" class=""> 
<img data-src="/blog/posts/45934af9/2021-11-17-14-49-20.png" class=""> 
<img data-src="/blog/posts/45934af9/2021-11-17-14-49-44.png" class=""> 
<img data-src="/blog/posts/45934af9/2021-11-17-14-50-14.png" class="">
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;pasteImage.path&quot;</span>: <span class="string">&quot;$&#123;currentFileNameWithoutExt&#125;/&quot;</span>,</span><br><span class="line"><span class="string">&quot;pasteImage.insertPattern&quot;</span>: <span class="string">&quot;&#123;% asset_img $&#123;imageFileName&#125; %&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样以来，粘贴的图片就会保存到md文档的同名文件夹下，文档中将插入<code>hexo asset</code>语法的代码。然后再复制或者剪切之后的图片,使用快捷键.(<code>windows</code>是<code>ctrl+Alt+V</code>,<code>Mac</code>是<code>Command+option+V</code>),但是<code>hexo clean -&gt; hexo g -&gt; hexo s</code>之后图片就可以正常显示了</p>
<img data-src="/blog/posts/45934af9/2021-11-17-15-16-19.png" class=""></li>
<li><p>(以下的步骤需要修改到<code>markdown</code>源码,慎重考虑),由于重新新建一个文件夹的特殊性,所以需要略微修改</p>
<ul>
<li>下载预览插件: <code>Markdown Preview Enhanced</code><img data-src="/blog/posts/45934af9/2021-11-17-15-01-16.png" class=""></li>
<li>现在就要利用这个功能来解决一个问题：<code>vscode</code>内无法预览代码的图片。<code>ctrl+shift+P</code>输入<code>Markdown Preview Enhanced: Extend Parser</code>调出插件的<code>parse.js</code>文件，修改其中的<code>onWillParseMarkdown</code>方法：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> <span class="attr">onWillParseMarkdown</span>: <span class="function"><span class="keyword">function</span>(<span class="params">markdown</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">     <span class="comment">//markdown参数打印出来是整个文件的内容</span></span><br><span class="line">     <span class="keyword">var</span> a = markdown.split(<span class="string">&quot;\n&quot;</span>);<span class="comment">//通过下面第一张图片内容通过换行符进行切割</span></span><br><span class="line">     <span class="keyword">var</span> b = a[<span class="number">1</span>].substring(<span class="number">6</span>); <span class="comment">//获取到title行字符,然后再去除空格即可获得图片的路径</span></span><br><span class="line">     markdown = markdown.replace(</span><br><span class="line">       <span class="comment">//以下为代码，注释是因为markdown语法会渲染出错，但是是正确代码</span></span><br><span class="line">     <span class="comment">//  /\&#123;%\s*asset_img\s*(.*)\s*%\&#125;/g,</span></span><br><span class="line">      <span class="comment">// (whole, content) =&gt; (&#x27;{% asset_img &#x27;+content+&#x27;)&#x27;  %}</span></span><br><span class="line">     )</span><br><span class="line">     <span class="keyword">return</span> resolve(markdown)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/45934af9/2021-11-17-18-00-53.png" class="">
尝试过后,图片的预览功能就能实现啦.</li>
</ul>
 <img data-src="/blog/posts/45934af9/2021-11-17-18-03-07.png" class=""></li>
</ul>
<p>参考链接(图片重写预览功能有错误,本文已经修正):<span class="exturl" data-url="aHR0cHM6Ly9saW5iZWkudG9wL3ZzY29kZSVFNyVCQyU5NiVFNSU4NiU5OW1kLw==">https://linbei.top/vscode%E7%BC%96%E5%86%99md/</span></p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Exception的处理细节</title>
    <url>/blog/posts/405fde88/</url>
    <content><![CDATA[<h1 id="关于Exception的处理细节"><a href="#关于Exception的处理细节" class="headerlink" title="关于Exception的处理细节"></a>关于<code>Exception</code>的处理细节</h1><h2 id="背景1"><a href="#背景1" class="headerlink" title="背景1"></a>背景1</h2><p><strong>万事先讲背景,在写需求时,需要有一个场景也是第一次遇到. 调用某第三方接口,除了返回正常值时,都是会报出异常,然后需要将异常在当前层处理一部分,然后再抛到外层处理剩余部分,可能描述有点抽象,给出一点代码</strong></p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            divideNum(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;此处是除零异常(外部)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">divideNum</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer res  =  <span class="number">10</span> / i;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ArithmeticException) System.out.println(<span class="string">&quot;此处是除零异常(内部)&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果截图:</p>
<img data-src="/blog/posts/405fde88/2022-02-12-20-23-54.png" class="">


<p>可以看出使用了 <code>throw</code> 依然可以将本层的异常抛出,的确也是平时很少会接触到的</p>
<h2 id="背景2"><a href="#背景2" class="headerlink" title="背景2"></a>背景2</h2><blockquote>
<p>关于异常处理,然后又遇到了另一个场景,一个方法报了某个异常,那么他是否还会继续往下走呢?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            divideNum(<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;这边是异常之后的方法11...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;此处是异常(外部)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;这边是异常之后的方法22...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">divideNum</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer res  =  <span class="number">10</span> / i;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ArithmeticException) System.out.println(<span class="string">&quot;此处是除零异常(内部)&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/405fde88/2022-02-12-20-24-29.png" class="">


<p>可观察到,```try``内部的代码将不会往下执行,但是外部的代码以及方法会继续执行,</p>
<blockquote>
<p>那么,新的问题来了,如何也停止外部的方法执行呢,其实这个很简单</p>
</blockquote>
<img data-src="/blog/posts/405fde88/2022-02-12-20-24-40.png" class="">

<img data-src="/blog/posts/405fde88/2022-02-12-20-24-47.png" class="">

<p>可以看到加了<code>return</code>关键字时,就直接将整个方法返回出去了</p>
<h3 id="常用应用"><a href="#常用应用" class="headerlink" title="常用应用"></a>常用应用</h3><blockquote>
<p>在这次开发需求中,其实也发现了一些新的世界,分享一下</p>
</blockquote>
<blockquote>
<p>在异常处理时,我是在一个<code>for</code>循环内部进行异常的捕捉并处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            divideNumNoParam();</span><br><span class="line">            System.out.println(<span class="string">&quot;这边是异常之后的方法11...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;此处是异常(外部)&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;这边是异常之后的方法22...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">divideNumNoParam</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">2</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="number">10</span> / i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除0错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行截图:</p>
<img data-src="/blog/posts/405fde88/2022-02-12-20-24-58.png" class="">

<p><strong>可以看到,报异常之后,将会推出<code>for</code>循环体,但是跳出子程序之后,程序依然会往下走</strong></p>
<blockquote>
<p>但是我们如果再内部中将异常丢出</p>
</blockquote>
<img data-src="/blog/posts/405fde88/2022-02-12-20-25-07.png" class="">

<p>结果截图:</p>
<img data-src="/blog/posts/405fde88/2022-02-12-20-25-17.png" class="">

<p><strong>外部捕捉到的异常之后将不会再继续运行下去</strong></p>
<h4 id="小结论"><a href="#小结论" class="headerlink" title="小结论"></a>小结论</h4><p>我们可以看出在<code>Java</code>程序中,如果当前程序报错之后,将会直接跳出,跳出当前子集程序,如果没有父类了,将会抛给虚拟机.</p>
<blockquote>
<p>那问题来了,那我们在<code>for</code>循环过程中,如何继续运行<code>for</code>循环体呢?</p>
</blockquote>
<h4 id="1-try内部使用for"><a href="#1-try内部使用for" class="headerlink" title="1. try内部使用for"></a>1. <code>try</code>内部使用<code>for</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;外部错误&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">2</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="number">10</span> / i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除0错误&quot;</span>);</span><br><span class="line">            <span class="comment">//continue  可加可不加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果截图:</p>
<img data-src="/blog/posts/405fde88/2022-02-12-20-25-28.png" class="">

<p>如果将<code>try</code>放在了<code>for</code>循环内部,则捕捉之后将可以继续运行</p>
<h4 id="2-使用Stream流"><a href="#2-使用Stream流" class="headerlink" title="2. 使用Stream流"></a>2. 使用<code>Stream</code>流</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">userStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(-<span class="number">2</span>);</span><br><span class="line">        list.add(-<span class="number">1</span>);</span><br><span class="line">        list.add(-<span class="number">0</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        AtomicInteger i = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        list.stream()</span><br><span class="line">                .forEach(m -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="number">10</span>/m);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;报错了&quot;</span>);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果截图:</p>
<img data-src="/blog/posts/405fde88/2022-02-12-20-25-35.png" class="">

<p>可以知道<code>Stream</code>流报了异常之后还会回继续运行循环体</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Linux排查问题命令</title>
    <url>/blog/posts/56be7cc9/</url>
    <content><![CDATA[<h2 id="Linux命令之top"><a href="#Linux命令之top" class="headerlink" title="Linux命令之top"></a><code>Linux</code>命令之<code>top</code></h2><blockquote>
<p>top - 整机性能查看</p>
</blockquote>
<span id="more"></span>

<img data-src="/blog/posts/56be7cc9/2022-03-13-22-54-06.png" class="">

<img data-src="/blog/posts/56be7cc9/2022-03-13-22-58-37.png" class="">

<p>主要看<code>load average, CPU, MEN</code>三部分</p>
<ul>
<li><code>load average</code>表示系统负载，即任务队列的平均长度。 三个数值分别为 <code>1</code>分钟、<code>5</code>分钟、<code>15</code>分钟前到现在的平均值。</li>
<li><code>load average</code>: 如果这个数除以逻辑<code>CPU</code>的数量，结果高于<code>5</code>的时候就表明系统在超负荷运转了。</li>
</ul>
<p><a href="https://yjclsx.blog.csdn.net/article/details/81508455"><code>Linux</code>中<code>top</code>命令参数详解</a></p>
<blockquote>
<p>uptime - 系统性能命令的精简版</p>
</blockquote>
<img data-src="/blog/posts/56be7cc9/2022-03-13-23-00-56.png" class="">

<h2 id="Linux之cpu查看vmstat-mac中为vm-stat"><a href="#Linux之cpu查看vmstat-mac中为vm-stat" class="headerlink" title="Linux之cpu查看vmstat (mac中为vm_stat)"></a><code>Linux</code>之<code>cpu</code>查看<code>vmstat</code> (<code>mac</code>中为<code>vm_stat</code>)</h2><img data-src="/blog/posts/56be7cc9/2022-03-13-23-05-38.png" class="">

<ul>
<li><code>procs</code><ul>
<li><code>r</code>：运行和等待的<code>CPU</code>时间片的进程数，原则上<code>1</code>核的<code>CPU</code>的运行队列不要超过<code>2</code>，整个系统的运行队列不超过总核数的2倍，否则代表系统压力过大，我们看蘑菇博客测试服务器，能发现都超过了<code>2</code>，说明现在压力过大</li>
<li><code>b</code>：等待资源的进程数，比如正在等待磁盘<code>I/O</code>、网络<code>I/O</code>等</li>
</ul>
</li>
<li><code>cpu</code><br>  <code>us</code>：用户进程消耗<code>CPU</code>时间百分比，<code>us</code>值高，用户进程消耗<code>CPU</code>时间多，如果长期大于<code>50%</code>，优化程序<br>  <code>sy</code>：内核进程消耗的CPU时间百分比<br>  <code>us + sy </code>参考值为<code>80%</code>，如果<code>us + sy</code> 大于<code>80%</code>，说明可能存在<code>CPU</code>不足，从上面的图片可以看出，<code>us + sy</code>还没有超过百分80，因此说明蘑菇博客的<code>CPU</code>消耗不是很高<br>  <code>id</code>：处于空闲的<code>CPU</code>百分比<br>  <code>wa</code>：系统等待<code>IO</code>的<code>CPU</code>时间百分比<br>  <code>st</code>：来自于一个虚拟机偷取的<code>CPU</code>时间比</li>
</ul>
<h2 id="Linux之cpu查看pidstat（Mac中没有）"><a href="#Linux之cpu查看pidstat（Mac中没有）" class="headerlink" title="Linux之cpu查看pidstat（Mac中没有）"></a><code>Linux</code>之<code>cpu</code>查看<code>pidstat</code>（<code>Mac</code>中没有）</h2><p>查看看所有<code>cpu</code>核信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mpstat -P ALL 2</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/56be7cc9/2022-03-13-23-10-51.png" class="">


<p>每个进程使用<code>cpu</code>的用量分解信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pidstat -u 1 -p 进程编号</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/56be7cc9/2022-03-13-23-11-14.png" class="">



<h2 id="Linux之内存查看free和pidstat（Mac中没有）"><a href="#Linux之内存查看free和pidstat（Mac中没有）" class="headerlink" title="Linux之内存查看free和pidstat（Mac中没有）"></a><code>Linux</code>之内存查看<code>free</code>和<code>pidstat</code>（<code>Mac</code>中没有）</h2><p>应用程序可用内存数</p>
<p>经验值</p>
<p>应用程序可用内存l系统物理内存&gt;<code>70%</code>内存充足</p>
<p>应用程序可用内存/系统物理内存&lt;<code>20%</code>内存不足，需要增加内存</p>
<p><code>20%</code>&lt;应用程序可用内存/系统物理内存&lt;<code>70%</code>内存基本够用</p>
<p><code>m/g</code>：兆/吉</p>
<img data-src="/blog/posts/56be7cc9/2022-03-13-23-12-13.png" class="">

<p>查看额外</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pidstat -p 进程号 -r 采样间隔秒数</span><br></pre></td></tr></table></figure>

<h2 id="Linux之硬盘查看df"><a href="#Linux之硬盘查看df" class="headerlink" title="Linux之硬盘查看df"></a><code>Linux</code>之硬盘查看<code>df</code></h2><p>查看磁盘剩余空间数</p>
<img data-src="/blog/posts/56be7cc9/2022-03-13-23-13-22.png" class="">

<h2 id="Linux之磁盘IO查看iostat和pidstat"><a href="#Linux之磁盘IO查看iostat和pidstat" class="headerlink" title="Linux之磁盘IO查看iostat和pidstat"></a><code>Linux</code>之磁盘<code>IO</code>查看<code>iostat</code>和<code>pidstat</code></h2><p>磁盘<code>I/O</code>性能评估<br><code>mac</code>:</p>
<img data-src="/blog/posts/56be7cc9/2022-03-13-23-16-06.png" class="">

<p><code>linux</code>:</p>
<img data-src="/blog/posts/56be7cc9/2022-03-13-23-16-54.png" class="">

<p>磁盘块设备分布</p>
<ul>
<li><code>rkB/s</code>每秒读取数据量<code>kB;wkB/s</code>每秒写入数据量<code>kB</code>;</li>
<li><code>svctm lO</code>请求的平均服务时间，单位毫秒;</li>
<li><code>await l/O</code>请求的平均等待时间，单位毫秒;值越小，性能越好;</li>
<li><code>util</code>一秒中有百分几的时间用于<code>I/O</code>操作。接近<code>100%</code>时，表示磁盘带宽跑满，需要优化程序或者增加磁盘;</li>
<li><code>rkB/s、wkB/s</code>根据系统应用不同会有不同的值，但有规律遵循:长期、超大数据读写，肯定不正常，需要优化程序读取。</li>
<li><code>svctm</code>的值与<code>await</code>的值很接近，表示几乎没有IO等待，磁盘性能好。</li>
<li>如果<code>await</code>的值远高于<code>svctm</code>的值，则表示<code>IO</code>队列等待太长，需要优化程序或更换更快磁盘。</li>
</ul>
<h2 id="Linux之网络IO查看ifstat"><a href="#Linux之网络IO查看ifstat" class="headerlink" title="Linux之网络IO查看ifstat"></a><code>Linux</code>之网络<code>IO</code>查看<code>ifstat</code></h2><p>默认本地没有，下载<code>ifstat</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://gael.roualland.free.fr/lifstat/ifstat-1.1.tar.gz</span><br><span class="line">tar -xzvf ifstat-1.1.tar.gz</span><br><span class="line">cd ifstat-1.1</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>查看网络<code>IO</code></p>
<p>各个网卡的<code>in、out</code></p>
<p>观察网络负载情况程序</p>
<p>网络读写是否正常</p>
<ul>
<li>程序网络<code>I/O</code>优化</li>
<li>增加网络<code>I/O</code>带宽</li>
</ul>
<img data-src="/blog/posts/56be7cc9/2022-03-13-23-19-52.png" class="">

<h2 id="Linux查看物理CPU个数、核数、逻辑CPU个数"><a href="#Linux查看物理CPU个数、核数、逻辑CPU个数" class="headerlink" title="Linux查看物理CPU个数、核数、逻辑CPU个数"></a><code>Linux</code>查看物理<code>CPU</code>个数、核数、逻辑<code>CPU</code>个数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 总核数 = 物理CPU个数 X 每颗物理CPU的核数 </span></span><br><span class="line"><span class="comment"># 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看物理CPU个数</span></span><br><span class="line">cat /proc/cpuinfo| grep <span class="string">&quot;physical id&quot;</span>| sort| uniq| wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个物理CPU中core的个数(即核数)</span></span><br><span class="line">cat /proc/cpuinfo| grep <span class="string">&quot;cpu cores&quot;</span>| uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看逻辑CPU的个数 , 这是我们关心的,涉及到线程池大小</span></span><br><span class="line">cat /proc/cpuinfo| grep <span class="string">&quot;processor&quot;</span>| wc -l</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看服务器信息指令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看CPU信息（型号）</span></span><br><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看内存信息</span></span><br><span class="line">cat /proc/meminfo</span><br><span class="line"></span><br><span class="line"><span class="comment">#如何查看Linux 内核</span></span><br><span class="line">uname -a</span><br><span class="line">cat /proc/version</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看机器型号（机器硬件型号）</span></span><br><span class="line">dmidecode | grep <span class="string">&quot;Product Name&quot;</span></span><br><span class="line">dmidecode</span><br><span class="line"></span><br><span class="line"><span class="comment">#如何查看linux 系统版本</span></span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">lsb_release -a</span><br><span class="line">cat  /etc/issue</span><br><span class="line"> </span><br><span class="line"><span class="comment">#如何查看linux系统和CPU型号，类型和大小</span></span><br><span class="line">cat /proc/cpuinfo</span><br><span class="line"></span><br><span class="line"><span class="comment">#如何查看linux 系统内存大小的信息，可以查看总内存，剩余内存，可使用内存等信息  </span></span><br><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure>



<h2 id="CPU占用过高的定位分析思路"><a href="#CPU占用过高的定位分析思路" class="headerlink" title="CPU占用过高的定位分析思路"></a><code>CPU</code>占用过高的定位分析思路</h2><p>结合<code>Linux</code>和<code>JDK</code>命令一块分析</p>
<p>案例步骤</p>
<ul>
<li>先用<code>top</code>命令找出<code>CPU</code>占比最高的</li>
</ul>
<img data-src="/blog/posts/56be7cc9/2022-03-13-23-20-27.png" class="">

<ul>
<li><p><code>ps -ef</code>或者<code>jps</code>进一步定位，得知是一个怎么样的一个后台程序作搞屎棍</p>
<img data-src="/blog/posts/56be7cc9/2022-03-13-23-24-51.png" class=""></li>
<li><p>定位到具体线程或者代码</p>
<ul>
<li><code>ps -mp</code> 进程 <code>-o THREAD,tid,time</code></li>
<li><code>-m</code> 显示所有的线程</li>
<li><code>-p pid</code>进程使用<code>cpu</code>的时间</li>
<li><code>-o</code> 该参数后是用户自定义格式</li>
</ul>
</li>
</ul>
<img data-src="/blog/posts/56be7cc9/2022-03-13-23-25-31.png" class="">

<ul>
<li>将需要的线程<code>ID</code>转换为<code>16</code>进制格式（英文小写格式），命令<code>printf %x 172 </code>将<code>172</code>转换为十六进制</li>
<li><code>jstack 进程ID | grep tid</code>（<code>16</code>进制线程<code>ID</code>小写英文）<code>-A60</code></li>
</ul>
<blockquote>
<p>ps - process status<br>-A Display information about other users’ processes, including those without controlling terminals.<br>-e Identical to -A.<br>-f Display the uid, pid, parent pid, recent CPU usage, process start time, controlling tty, elapsed CPU usage, and the associated command. If the -u option is also used, display the user name rather then the numeric uid. When -o or -O is used to add to the display following -f, the command field is not truncated as severely as it is in other formats.<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6dWZlbmcvYXJ0aWNsZS9kZXRhaWxzLzgzNTM3Mjc1">ps -ef中的e、f是什么含义</span></p>
</blockquote>
<p>对于<code>JDK</code>自带的<code>JVM</code>监控和性能分析工具用过哪些?一般你是怎么用的?<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4NjMwMjQvYXJ0aWNsZS9kZXRhaWxzLzEwNjY1MTA2OA==">link</span></p>
<h2 id="GitHub骚操作之awesome搜索"><a href="#GitHub骚操作之awesome搜索" class="headerlink" title="GitHub骚操作之awesome搜索"></a><code>GitHub</code>骚操作之<code>awesome</code>搜索</h2><ul>
<li>公式：<code>awesome</code> 关键字：<code>awesome</code>系列，一般用来收集学习、工具、书籍类相关的项目</li>
<li>搜索优秀的<code>redis</code>相关的项目，包括框架，教程等 <code>awesome redis</code><h2 id="GitHub骚操作之-L数字"><a href="#GitHub骚操作之-L数字" class="headerlink" title="GitHub骚操作之#L数字"></a><code>GitHub</code>骚操作之<code>#L</code>数字</h2>一行：地址后面紧跟 <code>#L10</code><br><code>https://github.com/abc/abc/pom.xml#L13</code><br>多行：地址后面紧跟 <code>#Lx - #Ln</code><br><code>https://github.com/moxi624/abc/abc/pom.xml#L13-L30</code><h2 id="GitHub骚操作之T搜索"><a href="#GitHub骚操作之T搜索" class="headerlink" title="GitHub骚操作之T搜索"></a><code>GitHub</code>骚操作之<code>T</code>搜索</h2></li>
</ul>
<img data-src="/blog/posts/56be7cc9/2022-03-13-23-31-47.png" class="">]]></content>
      <tags>
        <tag>Java面试</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Try-With-Source的使用以及注意点</title>
    <url>/blog/posts/91c18f7c/</url>
    <content><![CDATA[<h1 id="关于-Try-With-Source-的使用以及注意点"><a href="#关于-Try-With-Source-的使用以及注意点" class="headerlink" title="关于 Try-With-Source 的使用以及注意点"></a>关于 <code>Try-With-Source</code> 的使用以及注意点</h1><h2 id="在JDK-1-7-之前-资源需要手动关闭"><a href="#在JDK-1-7-之前-资源需要手动关闭" class="headerlink" title="在JDK 1.7 之前 , 资源需要手动关闭"></a>在<code>JDK 1.7 </code>之前 , 资源需要手动关闭</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Charset charset = Charset.forName(<span class="string">&quot;US-ASCII&quot;</span>);</span><br><span class="line">String s = ...;</span><br><span class="line">BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> writer = Files.newBufferedWriter(file, charset);</span><br><span class="line"> writer.write(s, <span class="number">0</span>, s.length());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line"> System.err.format(<span class="string">&quot;IOException: %s%n&quot;</span>, x);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (writer != <span class="keyword">null</span>) writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>JDK 7</code> 之前，你一定要牢记在 <code>finally</code> 中执行 <code>close</code> 以释放资源</p>
<h2 id="JDK-7-中的-try-with-resources-介绍"><a href="#JDK-7-中的-try-with-resources-介绍" class="headerlink" title="JDK 7 中的 try-with-resources 介绍"></a><code>JDK 7</code> 中的 <code>try-with-resources</code> 介绍</h2><p><code>try-with-resources</code> 是 <code>JDK 7</code> 中一个新的异常处理机制，它能够很容易地关闭在 <code>try-catch</code> 语句块中使用的资源。所谓的资源<code>（resource）</code>是指在程序完成后，必须关闭的对象。<code>try-with-resources </code>语句确保了每个资源在语句结束时关闭。所有实现了 <code>java.lang.AutoCloseable </code>接口（其中，它包括实现了 <code>java.io.Closeable</code> 的所有对象），可以使用作为资源。</p>
<p>例如，我们自定义一个资源类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(Resource res = <span class="keyword">new</span> Resource()) &#123;</span><br><span class="line">    res.doSome();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;resource is closed&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> something</span><br><span class="line">resource is closed</span><br></pre></td></tr></table></figure>

<p>可以看到，资源终止被自动关闭了。</p>
<p>再来看一个例子，是同时关闭多个资源的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(ResourceSome some = <span class="keyword">new</span> ResourceSome();</span><br><span class="line">    ResourceOther other = <span class="keyword">new</span> ResourceOther()) &#123;</span><br><span class="line">        some.doSome();</span><br><span class="line">        other.doOther();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceSome</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;some resource is closed&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceOther</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doOther</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;do other things&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;other resource is closed&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终输出为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">do</span> other things</span><br><span class="line">other resource is closed</span><br><span class="line">some resource is closed</span><br></pre></td></tr></table></figure>

<h2 id="try-with-resources-在-JDK-9-中的改进"><a href="#try-with-resources-在-JDK-9-中的改进" class="headerlink" title="try-with-resources 在 JDK 9 中的改进"></a><code>try-with-resources</code> 在 <code>JDK 9</code> 中的改进</h2><p>作为 <code>Milling Project Coin</code> 的一部分, <code>try-with-resources</code> 声明在 <code>JDK 9</code> 已得到改进。如果你已经有一个资源是 <code>final</code> 或等效于 <code>final</code> 变量,您可以在 <code>try-with-resources</code> 语句中使用该变量，而无需在 <code>try-with-resources</code> 语句中声明一个新变量。</p>
<p>例如,给定资源的声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A final resource final Resource resource1 = new Resource(&quot;resource1&quot;);</span></span><br><span class="line"><span class="comment">// An effectively final resource</span></span><br><span class="line">Resource resource2 = <span class="keyword">new</span> Resource(<span class="string">&quot;resource2&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>老方法编写代码来管理这些资源是类似的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Original try-with-resources statement from JDK 7 or 8 </span></span><br><span class="line"><span class="keyword">try</span> (Resource r1 = resource1;Resource r2 = resource2) &#123;</span><br><span class="line"> <span class="comment">// Use of resource1 and resource 2 through r1 and r2.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而新方法可以是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// New and improved try-with-resources statement in JDK 9 </span></span><br><span class="line"><span class="keyword">try</span> (resource1;resource2) &#123;</span><br><span class="line"> <span class="comment">// Use of resource1 and resource 2.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><p>类似于<code>java.io.InputStream、java.sql.Connection</code> 等都是可以使用该语法实现自动关闭,是因为他实现了<code>AutoCloseable</code>接口</p>
<img data-src="/blog/posts/91c18f7c/2022-02-13-21-33-56.png" class=""> 

<img data-src="/blog/posts/91c18f7c/2022-02-13-21-34-06.png" class="">

<p>所以限制点就在于这个</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于YAML中List存放Map</title>
    <url>/blog/posts/e18abc1d/</url>
    <content><![CDATA[<h1 id="关于YAML中List存放Map"><a href="#关于YAML中List存放Map" class="headerlink" title="关于YAML中List存放Map"></a>关于<code>YAML</code>中<code>List</code>存放<code>Map</code></h1><h2 id="YAML如何书写"><a href="#YAML如何书写" class="headerlink" title="YAML如何书写"></a><code>YAML</code>如何书写</h2><blockquote>
<p><code>YAML</code>语法</p>
</blockquote>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">大小写敏感</span><br><span class="line">使用缩进表示层级关系</span><br><span class="line">缩进时不允许使用<span class="literal">Tab</span>键，只允许使用空格。</span><br><span class="line">缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</span><br></pre></td></tr></table></figure>
<blockquote>
<p>支持的数据结构</p>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">对象：键值对的集合，又称为映射（<span class="keyword">mapping</span>）/ 哈希（hashes） / 字典（<span class="keyword">dictionary</span>）</span><br><span class="line">数组：一组按次序排列的值，又称为序列（<span class="keyword">sequence</span>） / 列表（list）</span><br><span class="line">基本类型：单个的、不可再分的值</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<blockquote>
<p>基本语法</p>
</blockquote>
<ul>
<li><code>k:</code>(空格)<code>v：</code>表示一对键值对</li>
<li><code>v:</code>包含上面举的数据</li>
<li><code>k;string</code>类型</li>
</ul>
<blockquote>
<p><code>value</code>的使用说明</p>
</blockquote>
<ul>
<li><p>基本类型：数字，字符串，布尔</p>
<ul>
<li><code>k: v：</code>字面直接来写；</li>
<li>字符串默认不用加上单引号或者双引号；</li>
</ul>
</li>
<li><p><code>&quot;&quot;</code>：双引号:不会转义字符串里面的特殊字符；</p>
<ul>
<li>特殊字符会作为本身想表示的意思；</li>
<li>如 ：<code>name: &quot;zhangsan \n lisi&quot;：</code>输出；<code>zhangsan</code> 换行 <code>lisi</code></li>
</ul>
</li>
<li><p><code>&#39;&#39;</code>：单引号:转义特殊字符</p>
<ul>
<li>特殊字符终只是一个普通的字符串数据 ，</li>
<li>如： <code>name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi </code></li>
</ul>
</li>
</ul>
<blockquote>
<p>对象、Map（属性和值）（键值对）：</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"> <span class="attr">k:</span> <span class="string">v：在下一行来写对象的属性和值的关系；注意缩进对象还是k:</span> <span class="string">v的方式</span></span><br><span class="line"></span><br><span class="line"><span class="attr">friends:</span> </span><br><span class="line"> 	<span class="attr">lastName:</span> <span class="string">zhangsan</span>          </span><br><span class="line"> 	<span class="attr">age:</span> <span class="number">20</span></span><br><span class="line"> <span class="comment">## 行内写法：friends: &#123;lastName: zhangsan,age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组（<code>List、Set</code>）：</p>
</blockquote>
<p>用- 值表示数组中的一个元素</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"> <span class="attr">pets:</span>  </span><br><span class="line">	<span class="string">‐</span> <span class="string">cat</span>  </span><br><span class="line">	<span class="string">‐</span> <span class="string">dog</span>  </span><br><span class="line">	<span class="string">‐</span> <span class="string">pig</span></span><br><span class="line"><span class="comment"># 行内写法 pets: [cat,dog,pig]</span></span><br></pre></td></tr></table></figure>

<h2 id="yml的使用"><a href="#yml的使用" class="headerlink" title="yml的使用"></a><code>yml</code>的使用</h2><ul>
<li><p>简单类型使用 <code>@Value</code></p>
</li>
<li><p>复杂类型使用 ：<code>@ConfigurationProperties</code></p>
<ol>
<li>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用<code>@Value；</code> </li>
<li>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用<code>@ConﬁgurationProperties；</code></li>
</ol>
</li>
</ul>
<p><code>yml</code>文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">test:</span> <span class="string">小猪</span></span><br><span class="line">  <span class="comment">#list&lt;map&gt;</span></span><br><span class="line">  <span class="attr">testList:</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">小王</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">12</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">小李</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">13</span></span><br><span class="line">  <span class="comment"># map&lt;String,String&gt;</span></span><br><span class="line">  <span class="attr">testMap:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">小朱</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">14</span></span><br><span class="line"><span class="attr">testname:</span> <span class="string">小明</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-Value"><a href="#使用-Value" class="headerlink" title="使用@Value"></a>使用<code>@Value</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* value 的使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTest</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 直接赋值</span></span><br><span class="line"></span><br><span class="line">     <span class="meta">@Value(&quot;小李&quot;)</span></span><br><span class="line">     <span class="keyword">private</span>  String name;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Value(&quot;1&quot;)</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//读取配置文件的信息</span></span><br><span class="line">     <span class="meta">@Value(&quot;$&#123;spring.testMap.name&#125;&quot;)</span></span><br><span class="line">     <span class="keyword">private</span> String name2;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Value(&quot;$&#123;spring.test&#125;&quot;)</span></span><br><span class="line">     <span class="keyword">private</span> String name1;</span><br><span class="line">     <span class="comment">//报错</span></span><br><span class="line">     <span class="comment">//@Value(&quot;$&#123;spring.testMap&#125;&quot;)</span></span><br><span class="line">     <span class="keyword">private</span> Map&lt;String,String&gt; map;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//使用SpEL</span></span><br><span class="line">     <span class="meta">@Value(&quot;#&#123;1+1&#125;&quot;)</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行测试<code>Test</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ValueTest valueTest;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test111</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(valueTest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ValueTest&#123;name=&#x27;小李&#x27;, num=1, name2=&#x27;小朱&#x27;, name1=&#x27;小猪&#x27;, map=null, num1=2&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-ConfigurationProperties"><a href="#使用-ConfigurationProperties" class="headerlink" title="使用@ConfigurationProperties"></a>使用<code>@ConfigurationProperties</code></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>         </span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>              					</span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐configuration‐processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>              </span><br><span class="line">     <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>              </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfigurationProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Map&gt; testList;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; testMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestConfigurationProperties testConfigurationProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(testConfigurationProperties.getTestMap());</span><br><span class="line">        System.out.println(testConfigurationProperties.getTestList());</span><br><span class="line">        System.out.println(testConfigurationProperties.getName());</span><br><span class="line">        System.out.println(testConfigurationProperties.getTest());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//&#123;name=小朱, age=14&#125;</span></span><br><span class="line"><span class="comment">//[&#123;name=小王, age=12&#125;, &#123;name=小李, age=13&#125;]</span></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//小猪</span></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Yaml</tag>
      </tags>
  </entry>
  <entry>
    <title>关于hexo使用shoka主题注意点</title>
    <url>/blog/posts/66edb7d2/</url>
    <content><![CDATA[<p>最近发现了一个特比好看的主题，叫 <code>shaoka</code> , <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">github 地址</span> , 效果图不出意外的话应该就是我现在使用的这个<code>theme</code>了，同时博主也很贴心了贴了一些简单的<a href="https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/dependents/"><code>wiki</code>文档</a>, <span class="exturl" data-url="aHR0cHM6Ly93d3cucmV2ZXJzZXNhY2xlLmNvbS9IZXhvLVNob2thJUU0JUI4JUJCJUU5JUEyJTk4JUU1JThBJTlGJUU4JTgzJUJEJUU0JUJCJThCJUU3JUJCJThEJUU4JUExJUE1JUU1JTg1JTg1JUU3JTgyJUI5Lw==">补充功能介绍点</span></p>
<p>可能我这个主题还是会有一点问题，目前有的大坑的话就是关于界面搜索功能的失效，参照上面的补充功能介绍点注册一个<a href="https://www.algolia.com/"><code>algolia</code></a>.</p>
<p>需要注意的是，在<code>root</code>的<code>_config.yml</code>文件中需要输入一些配置信息,由于我之前<code>appId</code>一直写的是<code>applicaitonId</code>, 因为有些博客是这个，可能是老版本吧。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">algolia:</span></span><br><span class="line">   <span class="attr">appId:</span> <span class="string">&quot;Application ID对应码&quot;</span></span><br><span class="line">   <span class="attr">apiKey:</span> <span class="string">&quot;API Keys页面的All API Keys中刚刚新建的API key的对应码&quot;</span></span><br><span class="line">   <span class="attr">adminApiKey:</span> <span class="string">&quot;Admin API Key对应码&quot;</span></span><br><span class="line">   <span class="attr">chunkSize:</span> <span class="number">5000</span></span><br><span class="line">   <span class="attr">indexName:</span> <span class="string">&quot;你填写的Indices部分&quot;</span></span><br><span class="line">   <span class="attr">fields:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">title</span> <span class="comment">#必须配置</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">path</span> <span class="comment">#必须配置</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">categories</span> <span class="comment">#推荐配置</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">content:strip:truncate,0,4000</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">gallery</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">photos</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">tags</span></span><br></pre></td></tr></table></figure>

<p>在<code>theme</code>的<code>_config.yml</code>文件中,加入或者修改以下配置,目前版本的<code>search</code>如果不配置，会报一个<code>hits</code>的错误</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Algolia Search</span></span><br><span class="line"><span class="comment"># For more information: https://www.algolia.com</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Something</span> </span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">&quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot;</span> <span class="comment"># if there are no result</span></span><br><span class="line">    <span class="attr">hits_stats:</span> <span class="string">&quot;$&#123;hits&#125; results found in $&#123;time&#125; ms&quot;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于mysql中对Json类型字段进行筛选查询</title>
    <url>/blog/posts/377b6f7d/</url>
    <content><![CDATA[<p>最近用到了对<code>Mysql</code>中对<code>JSON</code>类型的字符串进行筛选,这边做个简单的总结:</p>
<p>添加筛查条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> JSON_EXTRACT(JSON_String,<span class="string">&#x27;$.json字段名&#x27;</span>) <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> ...</span><br></pre></td></tr></table></figure>

<p><code>JSON</code>筛查加更新</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update table_name <span class="keyword">set</span> JSON_String <span class="operator">=</span> json_replace(JSON_String, <span class="string">&#x27;$.json字段名&#x27;</span>, <span class="string">&#x27;jinmao&#x27;</span>)</span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">in</span> (?,?)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>关于junit测试类防止事务回滚</title>
    <url>/blog/posts/b536fa7f/</url>
    <content><![CDATA[<blockquote>
<p>背景<br>昨晚在做一个<code>Junit</code>测试时，使用了事务来测试某个业务，但是意外发现，在``SpringBoot<code>测试中会自定帮你回滚掉</code>CUD`操作，下面是自己做的简单测试:</p>
</blockquote>
<span id="more"></span>

<img data-src="/blog/posts/b536fa7f/2022-02-12-16-03-00.png" class="">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">context02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LambdaUpdateWrapper&lt;Student&gt; updateWrapper = <span class="keyword">new</span> LambdaUpdateWrapper&lt;&gt;();</span><br><span class="line">        updateWrapper.eq(Student::getName,<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">                .set(Student::getName,<span class="string">&quot;张三改&quot;</span>);</span><br><span class="line"></span><br><span class="line">        studentDao.update(Student.builder().build(), updateWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这边做了一个简单的更新操作，然后进行操作时</p>
<img data-src="/blog/posts/b536fa7f/2022-02-12-16-22-47.png" class="">

<p>此时观察数据库的确也没有被更新掉</p>
<p>只需要在测试方法上添加<code>@Rollback(false)</code>，我们试一试</p>
<img data-src="/blog/posts/b536fa7f/2022-02-12-16-39-25.png" class="">

<p>运行结果</p>
<img data-src="/blog/posts/b536fa7f/2022-02-12-18-43-01.png" class="">

<p>也算是一个小坑嘛，哈哈！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>junit</tag>
      </tags>
  </entry>
  <entry>
    <title>关于事务提交中踩坑</title>
    <url>/blog/posts/69c17d37/</url>
    <content><![CDATA[<p>今天在处理一个问题时始终都没有头绪，主要场景是自己的方法中最后需要调用别人的方法进行回调，但是又同时处在一个大事务中，主要我做了以下场景来模拟</p>
<span id="more"></span>

<p>数据库表结构：</p>
<img data-src="/blog/posts/69c17d37/2022-02-10-23-42-40.png" class="">

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentMapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="meta">@Rollback(false)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">context01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询张三</span></span><br><span class="line">        LambdaUpdateWrapper&lt;Student&gt; updateWrapper0 = <span class="keyword">new</span> LambdaUpdateWrapper&lt;&gt;();</span><br><span class="line">        updateWrapper0.eq(Student::getName,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = studentDao.selectList(updateWrapper0);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对张三进行修改为张三改</span></span><br><span class="line">        LambdaUpdateWrapper&lt;Student&gt; updateWrapper = <span class="keyword">new</span> LambdaUpdateWrapper&lt;&gt;();</span><br><span class="line">        updateWrapper.eq(Student::getName,<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">                .set(Student::getName,<span class="string">&quot;张三改&quot;</span>);</span><br><span class="line"></span><br><span class="line">        studentDao.update(Student.builder().build(), updateWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再度查询张三</span></span><br><span class="line">        LambdaUpdateWrapper&lt;Student&gt; updateWrapper1 = <span class="keyword">new</span> LambdaUpdateWrapper&lt;&gt;();</span><br><span class="line">        updateWrapper1.eq(Student::getName,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        List&lt;Student&gt; students1 = studentDao.selectList(updateWrapper1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试查询修改后的张三改</span></span><br><span class="line">        LambdaUpdateWrapper&lt;Student&gt; updateWrapper2 = <span class="keyword">new</span> LambdaUpdateWrapper&lt;&gt;();</span><br><span class="line">        updateWrapper2.eq(Student::getName,<span class="string">&quot;张三改&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students2 = studentDao.selectList(updateWrapper2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>debug</code>结果：</p>
<img data-src="/blog/posts/69c17d37/2022-02-10-23-47-46.png" class="">

<img data-src="/blog/posts/69c17d37/2022-02-10-23-47-01.png" class="">

<p><strong>我们可以得到虽然事务没有提交但是同一会话查询时依然是修改后的值，但是此时如果为多线程下，别的线程将不会读取到提交事物之前的结果，这就是数据库的隔离性问题</strong>，此时事务没有提交，数据库结果未改变</p>
<img data-src="/blog/posts/69c17d37/2022-02-10-23-50-42.png" class="">

<p>当然，只有当程序正常运行结束之后，事务才会提交，数据库才会改变：</p>
<img data-src="/blog/posts/69c17d37/2022-02-10-23-51-07.png" class="">
]]></content>
      <categories>
        <category>Java</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mysql事务</tag>
      </tags>
  </entry>
  <entry>
    <title>关于在IDEA中回滚Git版本</title>
    <url>/blog/posts/424eebf1/</url>
    <content><![CDATA[<p>今天在项目中使用<code>Git</code>想撤销已<code>Commit</code>但是没有<code>Push</code>的版本</p>
<p>一不小心点了<code>Drop</code>,导致代码全部丢失,瞬间人就没了,于是在紧急中我决定寻找救济方案</p>
<span id="more"></span>

<br/>


<p>首先执行<code>git reflog</code>查看本地记录,记录都是从最新的翻页显示到历史的,</p>
<img data-src="/blog/posts/424eebf1/2022-02-12-20-17-28.png" class="">

<p>退出浏览是在英文状态下按<code>Q</code>键</p>
<p>找到想回退的那一行操作,最前面是<code>HASH</code>值</p>
<p>然后在 <code>Terminal</code>中输入</p>
<p><code>git reset --hard (hashValue)</code></p>
<img data-src="/blog/posts/424eebf1/2022-02-12-20-18-14.png" class="">

<p>就可以了</p>
<p>吓死我了</p>
<p>同时如果在<code>IDEA</code>中想撤销上一次<code>Commit</code>,</p>
<img data-src="/blog/posts/424eebf1/2022-02-12-20-18-47.png" class="">

<p>在输入框中输入<code>HEAD~1</code>即可撤销上一次<code>Commit</code></p>
<img data-src="/blog/posts/424eebf1/2022-02-12-20-19-05.png" class="">



<p>有惊无险!!!</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/blog/posts/14e6f1eb/</url>
    <content><![CDATA[<h2 id="冒泡排序（稳定）"><a href="#冒泡排序（稳定）" class="headerlink" title="冒泡排序（稳定）"></a>冒泡排序（稳定）</h2><h3 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h3><p>冒泡排序（<code>Bubble Sort</code>）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<span id="more"></span>
<h3 id="2、算法描述"><a href="#2、算法描述" class="headerlink" title="2、算法描述"></a>2、算法描述</h3><p>冒泡排序算法的运作如下：</p>
<p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>③. 针对所有的元素重复以上的步骤，除了最后一个。<br>④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</p>
<h3 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><p>冒泡排序需要两个嵌套的循环. 其中, 外层循环移动游标; 内层循环遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length; i &gt; <span class="number">0</span>; i--) &#123;      <span class="comment">//外层循环移动游标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i &amp;&amp; (j+<span class="number">1</span>) &lt; i; j++)&#123;    <span class="comment">//内层循环遍历游标及之后(或之前)的元素</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                System.out.println(<span class="string">&quot;Sorting: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv">链接</span></p>
]]></content>
      <categories>
        <category>Java面试</category>
        <category>冒泡排序</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>算法</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title>写在最前面</title>
    <url>/blog/posts/bf4d20ae/</url>
    <content><![CDATA[<p><font style="font-weight:bloder;color:#03ecfc;font-size:32px">大家好，我叫金茂，大家都喜欢叫我茂茂，在2021年的十一月我在知道了<code>github Page</code>之后就开始着手搭建自己的<code>blog</code>耗时半个月左右，也算是跌跌撞撞有了雏形，我是一名<code>Java</code>工程师会写那么一丢丢的前端啦，因为之前自己的博客是采用了<code>MarkDown</code>的格式发布在<code>github</code>上，准备近期把所有的资料都慢慢挪过来，以后都会在这个上面更新自己的想法，如果有错误，希望大家多多评论指出，非原创我也会标明出处，一起加油吧！！！</font></p>
<img data-src="/blog/posts/bf4d20ae/2021-12-16-16-43-54.png" class="">


]]></content>
  </entry>
  <entry>
    <title>关于设置git以及npm代理</title>
    <url>/blog/posts/afe5178f/</url>
    <content><![CDATA[<p> 我们在平时使用<code>git</code>或者<code>npm</code>等进行拉取项目或者安装一些需要科学上网的包时，就会报一些<code>connection timeout</code>的错误，这篇博客做了一些简单的汇总</p>
<h2 id="关于git设置代理和取消代理"><a href="#关于git设置代理和取消代理" class="headerlink" title="关于git设置代理和取消代理"></a>关于<code>git</code>设置代理和取消代理</h2><span id="more"></span>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line">//https</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br><span class="line">//使用socks5代理的 例如ss，ssr 1080是windows下ss的默认代理端口,mac下不同，或者有自定义的，根据自己的改</span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line">//只对github.com使用代理，其他仓库不走代理</span><br><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:10808</span><br><span class="line">git config --global https.https://github.com.proxy socks5://127.0.0.1:10808</span><br><span class="line">//取消github代理</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.https://github.com.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.https://github.com.proxy</span><br><span class="line"></span><br><span class="line">//查看代理</span><br><span class="line">git config --global --get http.proxy</span><br><span class="line">git config --global --get https.proxy</span><br><span class="line"></span><br><span class="line">//取消全局代理</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>

<h2 id="关于npm的设置代理和取消代理"><a href="#关于npm的设置代理和取消代理" class="headerlink" title="关于npm的设置代理和取消代理"></a>关于<code>npm</code>的设置代理和取消代理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set proxy socks5://127.0.0.1:10808</span><br><span class="line">npm config set https-proxy socks5://127.0.0.1:10808</span><br><span class="line"></span><br><span class="line"># npm设置镜像源</span><br><span class="line">npm config set registry=http://registry.npmjs.org</span><br><span class="line"></span><br><span class="line"># 查看镜像源</span><br><span class="line">npm config get registry</span><br><span class="line"></span><br><span class="line"># 淘宝镜像源 https://registry.npm.taobao.org/</span><br><span class="line"></span><br><span class="line"># 取消代理</span><br><span class="line">npm config delete proxy</span><br><span class="line">npm config delete https-proxy</span><br></pre></td></tr></table></figure>

<h2 id="关于git修改推送仓库地址"><a href="#关于git修改推送仓库地址" class="headerlink" title="关于git修改推送仓库地址"></a>关于<code>git</code>修改推送仓库地址</h2><blockquote>
<p>查看远程仓库地址</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p>方法有三种：</p>
<p>修改命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url origin [url]</span><br></pre></td></tr></table></figure>
<p>先删后加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin [url]</span><br></pre></td></tr></table></figure>

<h2 id="git统计项目代码行数"><a href="#git统计项目代码行数" class="headerlink" title="git统计项目代码行数"></a><code>git</code>统计项目代码行数</h2><blockquote>
<p>显示项目的所有文件列表及行数（已删除的文件显示为空）<br>最后一行会显示项目代码的总行数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git ls-files | xargs wc -l</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只统计项目代码的总行数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git ls-files | xargs cat | wc -l</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只查看项目文件列表</p>
</blockquote>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">ls</span>-<span class="keyword">files</span></span><br></pre></td></tr></table></figure>

<p><a href="https://ipaddress.com/website/github.com">查看<code>Ip</code> link click</a></p>
<h2 id="git-更改user-信息"><a href="#git-更改user-信息" class="headerlink" title="git 更改user 信息"></a>git 更改user 信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;your_email@example.com&quot;</span><br><span class="line"></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line">git config --global credential.helper cache</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<!-- https://github.com/microsoft/terminal -->
]]></content>
      <tags>
        <tag>git,npm,node</tag>
      </tags>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/blog/posts/7474c898/</url>
    <content><![CDATA[<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将原问题划分成<code>n</code>个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解</p>
<h2 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h2><p>“分而治之”，大问题能够拆成相似的小问题，记住这些小问题需要具有相似性。而后将小问题的每个解合成为大问题的解。所以说大问题如何拆，小问题如何合并才是这个算法最主要的一个思想。实际上很多算法如贪心算法，动态规划等等都是要求把大问题拆成小问题。而分治算法的重要一点就是要适用于能够重新把小问题的解合并为大问题的解。</p>
<span id="more"></span>

<h2 id="使用分治算法的前提条件"><a href="#使用分治算法的前提条件" class="headerlink" title="使用分治算法的前提条件"></a>使用分治算法的前提条件</h2><ul>
<li>原问题与分解成的小问题具有相同的模式；</li>
<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，<strong>这一点是分治算法跟动态规划的明显区别；</strong></li>
<li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li>
<li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了</li>
</ul>
<h2 id="每一次递归都会涉及三个操作"><a href="#每一次递归都会涉及三个操作" class="headerlink" title="每一次递归都会涉及三个操作"></a>每一次递归都会涉及三个操作</h2><ul>
<li><strong>分解</strong>：将原问题分解成一系列子问题；</li>
<li><strong>解决</strong>：递归地求解各个子问题，若子问题足够小，则直接求解；</li>
<li><strong>合并</strong>：将子问题的结果合并成原问题</li>
</ul>
<h2 id="分治法适用条件"><a href="#分治法适用条件" class="headerlink" title="分治法适用条件"></a>分治法适用条件</h2><ol>
<li><p>该问题的规模缩小到一定程度就可以很容易解决；</p>
</li>
<li><p>该问题可以分解为若干个规模较小的相同问题，这里注意是最优子结构性质；</p>
</li>
<li><p>利用该问题分解出的子问题的解可以合并为该问题的解；</p>
</li>
<li><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共子问题；</p>
</li>
</ol>
<p>　　<strong>对于很多算法而言，第一条往往是必要的，因为数据量一旦大起来，问题往往复杂度上升的特别快。这里就需要将这个大问题分解为小问题。小问题处理起来更加方便。第二、三条的才是分治思想的核心，因为很多时候我们会采用递归的方式进行解决，所以在大问题分解为小问题的时候需要保证小问题之间的相同性。单单分解为小问题之后还不能算完成，必须要能够将小问题的解合并为这个问题的最终解才能算真正用到了分治的思想。最后一条也是最关键的，各个子问题之间必须要保证独立性，即不互相影响。如果相互之间有影响，这时候我们采用的是动态规划就更加好一点。</strong></p>
<h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><p>其实算法的思想不用讲太多，能够化为几句话是最好的，下面就举几个例子来看看分治算法：</p>
<blockquote>
<p>例题一：二分查找，给定一个按照升序排好的数组<code>array</code>，要在这个数组中找出一个特定的元素<code>x</code>；<br>当我们遇到一个问题，完全可以在心里问自己下面四个问题：</p>
</blockquote>
<p>　　1、当前问题能不能切分？</p>
<p>　　答：能切分，因为数组按照升序来排列。所以当x大于某个元素array[mid]时，x一定在array[mid]的右边。以此再来切分。每次切一半</p>
<p>　　2、分解出来的子问题相同吗？</p>
<p>　　答：相同，每个子问题的数据集都是父问题的1/2倍。并且每次只比较子问题的中间的数据</p>
<p>　　3、子问题的解能合并为父问题的解吗？</p>
<p>　　答：不需要合并，子问题的解即为父问题的解。</p>
<p>　　4、子问题之间相互独立吗？</p>
<p>　　答：独立，子问题只是判断，不需要和父问题有很强的关联性（这里可以参考一下动态规划算法，就能理解子问题之间怎么判断是独立的）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分治算法只是一种思想，不是一个具体的套路，只能说在碰见具体问题时我们能够从这个思路去思考，切分问题？合并问题？子问题之间影响关联大不大？这些都是具体问题具体考虑。还有很多很多题目是用了分治算法。也可以多刷刷题</p>
<h2 id="循环赛日常表"><a href="#循环赛日常表" class="headerlink" title="循环赛日常表"></a>循环赛日常表</h2><p>设有<code>n=2^k</code>个运动员，要进行网球循环赛。现在要设计一个满足以下要求的比赛日程表</p>
<p>（1）每个选手必须与其他<code>n-1</code>个选手各赛一场</p>
<p>（2）每个选手一天只能赛一次</p>
<p>（3）循环赛一共进行<code>n-1</code>天</p>
<p>将比赛日程表设计成<code>n</code>行<code>n</code>列，表中除了第一列，其他<code>n-1</code>列才是我们要的，数组下标行列都从<code>0</code>开始，第i行j列代表第<code>（i+1）</code>位选手在第j天的对手：</p>
<img data-src="/blog/posts/7474c898/2022-02-17-23-08-53.png" class="">

<p>以8个选手为例子</p>
<img data-src="/blog/posts/7474c898/2022-02-17-23-09-01.png" class="">

<p>①我们先初始化第一行各个数为<code>1~8</code>（<code>2~8</code>为：第<code>1</code>天 — 第<code>7</code>天）；</p>
<p>②因为是递归，那么要填8x8的左下角和右下角，分别需要知道它的右上角和左上角</p>
<p>③而<code>8x8</code>的盒子它的左上角是一个<code>4x4</code>的盒子，要填<code>4x4</code>的左下角和右下角，也分别需要知道它的右上角和左上角</p>
<p>④现在递归到<code>4x4</code>的盒子的左上角，是一个<code>2x2</code>的盒子，它不需要递归了，直接沿对角线填左下角和右下角的数字，也就是上面的图②</p>
<p>⑤可以看到，经过上面的②③步，我们左上角4x4的盒子，它的·右上角和左上角已经知道了，那就可以沿对角线填它的左下角和右下角了，所以出现了图④</p>
<p>⑥其他的依次类推</p>
<p>通俗易懂地讲，就是<strong>如果你想填一个大的，你得先得出它左上角和右上角两个盒子 ， 再沿对角线分别抄到右下角和左下角。 而为了得出它左上角和右上角，就需要递归了</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SportsSchedule</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleTable</span><span class="params">(<span class="keyword">int</span>[][] table, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            table[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 填充左上区域矩阵</span></span><br><span class="line"><span class="comment">            n值的变化：8  4  2  1</span></span><br><span class="line"><span class="comment">            m值的变化：4  2  1  1  */</span></span><br><span class="line">            <span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">            scheduleTable(table, m);</span><br><span class="line">            <span class="comment">//填充右上区域矩阵</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &lt; n; j++) &#123;</span><br><span class="line">                    table[i][j] = table[i][j - m] + m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//填充左下区域矩阵</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                    table[i][j] = table[i - m][j] + m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//填充右下区域矩阵</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &lt; n; j++) &#123;</span><br><span class="line">                    table[i][j] = table[i - m][j - m];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">        SportsSchedule schedule = <span class="keyword">new</span> SportsSchedule();</span><br><span class="line">        schedule.scheduleTable(table, n);</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//打印二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                System.out.print(table[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                c++;<span class="comment">//每打印一个数，c++</span></span><br><span class="line">                <span class="keyword">if</span> (c % n == <span class="number">0</span>) &#123;<span class="comment">//说明打印一行了</span></span><br><span class="line">                    System.out.println();<span class="comment">//换行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="L型骨牌棋盘覆盖"><a href="#L型骨牌棋盘覆盖" class="headerlink" title="L型骨牌棋盘覆盖"></a><code>L</code>型骨牌棋盘覆盖</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在一个<code>2^k×2^k </code>个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格（特殊点），且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何<code>2</code>个<code>L</code>型骨牌不得重叠覆盖。</p>
<img data-src="/blog/posts/7474c898/2022-02-17-23-09-17.png" class="">

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>分析 </p>
</blockquote>
<p>当<code>k&gt;0</code>时，将<code>2^k×2^k</code> 棋盘分割为<code>4</code>个<code>2^k-1×2^k-1</code> 子棋盘<code>(a)</code>所示。特殊方格必位于<code>4</code>个较小子棋盘之一中，其余<code>3</code>个子棋盘中无特殊方格。为了将这<code>3</code>个无特殊方格的子棋盘转化为特殊棋盘，可以用一个<code>L</code>型骨牌覆盖这<code>3</code>个较小棋盘的会合处，如 <code>(b)</code>所示，从而将原问题转化为<code>4</code>个较小规模的棋盘覆盖问题。递归地使用这种分割，直至棋盘简化为棋盘<code>1×1</code>。</p>
<img data-src="/blog/posts/7474c898/2022-02-17-23-09-30.png" class="">

<blockquote>
<p>实现：</p>
</blockquote>
<p>每次都对分割后的四个小方块进行判断，判断特殊方格是否在里面。这里的判断的方法是每次先记录下整个大方块的左上角方格的行列坐标，然后再与特殊方格坐标进行比较，就可以知道特殊方格是否在该块中。如果特殊方块在里面，这直接递归下去求即可，如果不在，这根据分割的四个方块的不同位置，把右下角、左下角、右上角或者左上角的方格标记为特殊方块，然后继续递归。在递归函数里，还要有一个变量subSize来记录边的方格数，每次对方块进行划分时，边的方格数都会减半，这个变量是为了方便判断特殊方格的位置。</p>
<blockquote>
<p> 覆盖步骤如图：</p>
</blockquote>
<img data-src="/blog/posts/7474c898/2022-02-17-23-09-51.png" class="">

<blockquote>
<p> 代码实现:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessBoradProblem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] board;<span class="comment">//棋盘</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> specialRow;<span class="comment">//特殊点行下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> specialCol;<span class="comment">//特殊点列下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//矩阵大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type = <span class="number">0</span>;<span class="comment">//骨牌类型，1,2,3,4  因为是用数字表示的，所以用int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessBoradProblem</span><span class="params">(<span class="keyword">int</span> specialRow, <span class="keyword">int</span> specialCol, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.specialRow = specialRow;</span><br><span class="line">        <span class="keyword">this</span>.specialCol = specialCol;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        board = <span class="keyword">new</span> <span class="keyword">int</span>[size][size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> specialRow 特殊点的行下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> specialCol 特殊点的列下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leftRow    分割成4个后每个矩阵的左边的起点行下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leftCol    分割成4个后每个矩阵的左边起点列下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size       矩阵的宽或者高</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//相对于四个方格中右上的方格，左边起点的leftRow不一定是0了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ChessBoard</span><span class="params">(<span class="keyword">int</span> specialRow, <span class="keyword">int</span> specialCol, <span class="keyword">int</span> leftRow, <span class="keyword">int</span> leftCol, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> subSize = size / <span class="number">2</span>;</span><br><span class="line">        type = type % <span class="number">4</span> + <span class="number">1</span>;<span class="comment">//不断+1，超过4就取模</span></span><br><span class="line">        <span class="keyword">int</span> n = type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//假设特殊点在左上角，然后行和列都小于一半</span></span><br><span class="line">        <span class="keyword">if</span> (specialRow &lt; leftRow + subSize &amp;&amp; specialCol &lt; leftCol + subSize) &#123;</span><br><span class="line">            ChessBoard(specialRow, specialCol, leftRow, leftCol, subSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不在左上角，左上角矩阵的右下角就是特殊点</span></span><br><span class="line">            board[leftRow + subSize - <span class="number">1</span>][leftCol + subSize - <span class="number">1</span>] = n;</span><br><span class="line">            ChessBoard(leftRow + subSize - <span class="number">1</span>, leftRow + subSize - <span class="number">1</span>, leftRow, leftCol, subSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//特殊点在右上方，行小于一半，列大于一半</span></span><br><span class="line">        <span class="keyword">if</span> (specialRow &lt; leftRow + subSize &amp;&amp; specialCol &gt;= leftCol + subSize) &#123;</span><br><span class="line">            ChessBoard(specialRow, specialCol, leftRow, leftCol + subSize, subSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            board[leftRow + subSize - <span class="number">1</span>][leftCol + subSize] = n;</span><br><span class="line">            ChessBoard(leftRow + subSize - <span class="number">1</span>, leftCol + subSize, leftRow, leftCol + subSize, subSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//特殊点在左下方</span></span><br><span class="line">        <span class="keyword">if</span> (specialRow &gt;= leftRow + subSize &amp;&amp; specialCol &lt; leftCol + subSize) &#123;</span><br><span class="line">            ChessBoard(specialRow, specialCol, leftRow + subSize, leftCol, subSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            board[leftRow + subSize][leftCol + subSize - <span class="number">1</span>] = n;</span><br><span class="line">            ChessBoard(leftRow + subSize, leftCol + subSize - <span class="number">1</span>, leftRow + subSize, leftCol, subSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//特殊点在右下方</span></span><br><span class="line">        <span class="keyword">if</span> (specialRow &gt;= leftRow + subSize &amp;&amp; specialCol &gt;= leftCol + subSize) &#123;</span><br><span class="line">            ChessBoard(specialRow, specialCol, leftRow + subSize, leftCol + subSize, subSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            board[leftRow + subSize][leftCol + subSize] = n;</span><br><span class="line">            ChessBoard(leftRow + subSize, leftCol + subSize, leftRow + subSize, leftCol + subSize, subSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printBoard</span><span class="params">(<span class="keyword">int</span> specialRow, <span class="keyword">int</span> specialCol, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        ChessBoard(specialRow, specialCol, <span class="number">0</span>, <span class="number">0</span>, size);</span><br><span class="line">        printResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                System.out.print(board[i][j] + <span class="string">&quot; &quot;</span>);<span class="comment">//注意：print</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;<span class="comment">//矩阵大小</span></span><br><span class="line">        <span class="comment">//选取特殊点</span></span><br><span class="line">        <span class="keyword">int</span> specialRow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> specialCol = <span class="number">1</span>;</span><br><span class="line">        ChessBoradProblem boradProblem = <span class="keyword">new</span> ChessBoradProblem(specialRow, specialCol, N);</span><br><span class="line">        boradProblem.printBoard(specialRow, specialCol, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java面试</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/blog/posts/c2a5fdc5/</url>
    <content><![CDATA[<h2 id="堆排序（不稳定）"><a href="#堆排序（不稳定）" class="headerlink" title="堆排序（不稳定）"></a>堆排序（不稳定）</h2><p>个人感觉堆排序还是挺难的，虽然会有演示动画<br><span class="exturl" data-url="aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAvIyVFNSU5QiU5QiVFMyU4MCU4MSVFNSVBMCU4NiVFNiU4RSU5MiVFNSVCQSU4RiVFRiVCQyU4OEhlYXAtU29ydCVFRiVCQyU4OQ==">链接</span></p>
<p>但是从代码层面就没有那么好的通俗</p>
<span id="more"></span>

<p>堆的含义就是：完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。</p>
<h3 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h3><p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p>
<h3 id="2、算法描述"><a href="#2、算法描述" class="headerlink" title="2、算法描述"></a>2、算法描述</h3><p>①. 先将初始序列<code>K[1..n]</code>建成一个大顶堆, 那么此时第一个元素<code>K1</code>最大, 此堆为初始的无序区.<br>②. 再将关键字最大的记录<code>K1</code> (即堆顶, 第一个元素)和无序区的最后一个记录 <code>Kn</code> 交换, 由此得到新的无序区<code>K[1..n−1]</code>和有序区<code>K[n]</code>, 且满足<code>K[1..n−1].keys⩽K[n].key</code><br>③. 交换<code>K1</code> 和 <code>Kn</code> 后, 堆顶可能违反堆性质, 因此需将<code>K[1..n−1]</code>调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</p>
<h3 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p>
<p>总结起来就是定义了以下几种操作：</p>
<ul>
<li>最大堆调整（<code>Max_Heapify</code>）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（<code>Build_Max_Heap</code>）：将堆所有数据重新排序</li>
<li>堆排序（<code>HeapSort</code>）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ul>
<p>对于堆节点的访问：</p>
<ul>
<li>父节点i的左子节点在位置：<code>(2*i+1);</code></li>
<li>父节点i的右子节点在位置：<code>(2*i+2);</code></li>
<li>子节点i的父节点在位置：<code>floor((i-1)/2);</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        max_heapify(arr, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = arr[<span class="number">0</span>];      <span class="comment">//堆顶元素(第一个元素)与Kn交换</span></span><br><span class="line">        arr[<span class="number">0</span>] = arr[i-<span class="number">1</span>];</span><br><span class="line">        arr[i-<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span> || arr.length &lt; limit) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIdx = limit / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; parentIdx &gt;= <span class="number">0</span>; parentIdx--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(parentIdx * <span class="number">2</span> &gt;= limit)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = parentIdx * <span class="number">2</span>;       <span class="comment">//左子节点位置</span></span><br><span class="line">        <span class="keyword">int</span> right = (left + <span class="number">1</span>) &gt;= limit ? left : (left + <span class="number">1</span>);    <span class="comment">//右子节点位置，如果没有右节点，默认为左节点位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxChildId = arr[left] &gt;= arr[right] ? left : right;</span><br><span class="line">        <span class="keyword">if</span>(arr[maxChildId] &gt; arr[parentIdx])&#123;   <span class="comment">//交换父节点与左右子节点中的最大值</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[parentIdx];</span><br><span class="line">            arr[parentIdx] = arr[maxChildId];</span><br><span class="line">            arr[maxChildId] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Max_Heapify: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips: 由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列. 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv">链接</span></p>
]]></content>
      <categories>
        <category>Java面试</category>
        <category>堆排序</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>算法</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/blog/posts/a80d0031/</url>
    <content><![CDATA[<h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h2 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h2><p>动态规划的大致思路是把一个复杂的问题转化成一个分阶段逐步递推的过程，从简单的初始状态一步一步递推，最终得到复杂问题的最优解。</p>
<blockquote>
<p>基本思想与策略编辑:</p>
</blockquote>
<p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中</p>
<span id="more"></span>

<ol>
<li><p><font color="red"><strong>拆分问题</strong></font>:根据问题的可能性把问题划分成通过递推或者递归一步一步实现。关键就是这个步骤,动态规划有一类问题就是从后往前推到,有时候我们很容易知道 : 如果只有一种情况时,最佳的选择应该怎么做.然后根据这个最佳选择往前一步推导,得到前一步的最佳选择</p>
</li>
<li><p><font color="blue">定义问题状态和状态之间的关系：</font>用一种量化的形式表现出来,类似于高中学的推导公式,因为这种式子很容易用程序写出来,也可以说对程序比较亲和(也就是最后所说的状态转移方程式)</p>
</li>
<li><p>动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，<font color="white">前一子问题的解，为后一子问题的求解提供了有用的信息。</font>在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
</li>
</ol>
<p><strong>我的理解是</strong>：比如我们找到最优解,我们应该讲最优解保存下来,为了往前推导时能够使用前一步的最优解,在这个过程中难免有一些相比于最优解差的解,此时我们应该放弃,只保存最优解,</p>
<p>这样我们每一次都把最优解保存了下来,大大降低了时间复杂度。</p>
<hr/>

<p>动态规划解决问题的过程分为两步：</p>
<ol>
<li><p>寻找状态转移方程式</p>
</li>
<li><p>利用状态转移方程式自底向上求解问题</p>
</li>
</ol>
<h2 id="动态规划原理"><a href="#动态规划原理" class="headerlink" title="动态规划原理"></a>动态规划原理</h2><ul>
<li>使用条件：可分为多个相关子问题，子问题的解被重复使用</li>
<li><code>Optimal substructure（优化子结构）</code>：<ul>
<li> 一个问题的优化解包含了子问题的优化解</li>
<li> 缩小子问题集合，只需那些优化问题中包含的子问题，降低实现复杂性</li>
<li> 我们可以自下而上的</li>
</ul>
</li>
<li><code>Subteties（重叠子问题）</code>：在问题的求解过程中，很多子问题的解将被多次使用。</li>
<li><strong>动态规划算法的设计步骤：</strong><ul>
<li>分析优化解的结构</li>
<li>递归地定义最优解的代价</li>
<li>自底向上地计算优化解的代价保存之，并获取构造最优解的信息</li>
<li>根据构造最优解的信息构造优化解</li>
</ul>
</li>
<li>动态规划特点：<ul>
<li>把原始问题划分成一系列子问题；</li>
<li>求解每个子问题仅一次，并将其结果保存在一个表中，以后用到时直接存取，不重复计算，节省计算时间</li>
<li>自底向上地计算。</li>
<li>整体问题最优解取决于子问题的最优解（状态转移方程）（将子问题称为状态，最终状态的求解归结为其他状态的求解</li>
</ul>
</li>
</ul>
<h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><h3 id="最长公共子序列（longest-common-subsequence-LCS）"><a href="#最长公共子序列（longest-common-subsequence-LCS）" class="headerlink" title="最长公共子序列（longest-common-subsequence, LCS）"></a>最长公共子序列（<code>longest-common-subsequence, LCS</code>）</h3><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/"><code>LeetCode</code></a></p>
<img data-src="/blog/posts/a80d0031/2022-02-17-23-18-58.png" class="">

<p>(1) 子序列：一个序列<code>X ＝ x1x2...xn</code>,中任意删除若干项，剩余的序列叫做<code>A</code>的一个子序列。也可以认为是从序列<code>A</code>按原顺序保留任意若干项得到的序列。<br>      例如：对序列 <code>1,3,5,4,2,6,8,7</code>来说，序列<code>3,4,8,7</code> 是它的一个子序列。对于一个长度为<code>n</code>的序列，它一共有<code>2^n</code> 个子序列，有<code>(2^n – 1)</code>个非空子序列。在这里需要提醒大家，子序列不是子集，它和原始序列的元素顺序是相关的。</p>
<p>(2) 公共子序列：如果序列<code>Z</code>既是序列<code>X</code>的子序列，同时也是序列Y的子序列，则称它为序列<code>X</code>和序列<code>Y</code>的公共子序列。空序列是任何两个序列的公共子序列。</p>
<p>(3) 最长公共子序列：<code>X</code>和<code>Y</code>的公共子序列中长度最长的（包含元素最多的）叫做<code>X</code>和<code>Y</code>的最长公共子序列。</p>
<p>这个问题如果用穷举法时间，最终求出最长公共子序列时，时间复杂度是<code>Ο（2mn）</code>，是指数级别的复杂度，对于长序列是不适用的。因此我们使用动态规划法来求解。</p>
<h3 id="刻画最长公共子序列问题的最优子结构"><a href="#刻画最长公共子序列问题的最优子结构" class="headerlink" title="刻画最长公共子序列问题的最优子结构"></a>刻画最长公共子序列问题的最优子结构</h3><p>设<code>X=x1x2…xm</code>和<code>Y=y1y2…yn</code>是两个序列，<code>Z=z1z2…zk</code>是这两个序列的一个最长公共子序列。</p>
<ol>
<li><p>如果<code>xm=yn</code>，那么<code>zk=xm=yn</code>，且<code>Zk-1</code>是<code>Xm-1</code>，<code>Yn-1</code>的一个最长公共子序列；</p>
</li>
<li><p>如果<code>xm≠yn</code>，那么<code>zk≠xm</code>，意味着<code>Z</code>是<code>Xm-1</code>，<code>Y</code>的一个最长公共子序列；</p>
</li>
<li><p>如果<code>xm≠yn</code>，那么<code>zk≠yn</code>，意味着<code>Z</code>是<code>X</code>，<code>Yn-1</code>的一个最长公共子序列。</p>
</li>
</ol>
<p>从上面三种情况可以看出，两个序列的<code>LCS</code>包含两个序列的前缀的<code>LCS</code>。因此，<code>LCS</code>问题具有最优子结构特征。</p>
<h3 id="递归的定义最优质"><a href="#递归的定义最优质" class="headerlink" title="递归的定义最优质"></a>递归的定义最优质</h3><p>从最优子结构可以看出，如果<code>xm=yn</code>，那么我们应该求解<code>Xm-1</code>，<code>Yn-1</code>的一个<code>LCS</code>，并且将<code>xm=yn</code>加入到这个<code>LCS</code>的末尾，这样得到的一个新的<code>LCS</code>就是所求。</p>
<p>如果<code>xm≠yn</code>，我们需要求解两个子问题，分别求<code>Xm-1</code>，<code>Y</code>的一个<code>LCS</code>和<code>X</code>，<code>Yn-1</code>的一个<code>LCS</code>。两个<code>LCS</code>中较长者就是<code>X</code>和<code>Y</code>的一个<code>LCS</code>。</p>
<p>可以看出<code>LCS</code>问题具有重叠子问题性质。为了求<code>X</code>和<code>Y</code>的一个<code>LCS</code>，我们需要分别求出<code>Xm-1</code>，<code>Y</code>的一个<code>LCS</code>和<code>X</code>，<code>Yn-1</code>的一个<code>LCS</code>，这几个字问题又包含了求出<code>Xm-1</code>，<code>Yn-1</code>的一个<code>LCS</code>的子子问题。（有点绕了。。。晕没晕。。。。）</p>
<p>根据上面的分析，我们可以得出下面的公式；</p>
<img data-src="/blog/posts/a80d0031/2022-02-17-23-19-37.png" class="">

<h3 id="计算最优的解"><a href="#计算最优的解" class="headerlink" title="计算最优的解"></a>计算最优的解</h3><p> 根据上面的，我们很容易就可以写出递归计算<code>LCS</code>问题的程序，通过这个程序我们可以求出各个子问题的<code>LCS</code>的值，此外，为了求解最优解本身，我们好需要一个表<code>dp，dp[i，j]</code>记录使<code>C[i，j]</code>取值的最优子结构。</p>
<h3 id="数组的填表过程"><a href="#数组的填表过程" class="headerlink" title="数组的填表过程"></a>数组的填表过程</h3><img data-src="/blog/posts/a80d0031/2022-02-17-23-19-46.png" class="">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LCS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLCS</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">int</span> m = B.length();</span><br><span class="line">        <span class="comment">//返回一个字符数组，该字符数组中存放了当前字符串中的所有字符</span></span><br><span class="line">        <span class="comment">//返回的是字符数组char[]a</span></span><br><span class="line">        <span class="keyword">char</span>[] a = A.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] b = B.toCharArray();</span><br><span class="line">        <span class="comment">//创建一个二维矩阵，用来推到公共子序列</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//如果找到第一列其中一个字符等于第一行第一个字符</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">//找到第一列与第一行b[0]的相等的值，把其变成1</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//并将其后面的字符都变成1</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    dp[j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">//如果找到第一列其中一个字符等于第一行第一个字符</span></span><br><span class="line">            <span class="keyword">if</span> (b[i] == a[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">//则把第一列后面的字符都变成1</span></span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                    dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从1开始是因为横向和纵向下标为0的都遍历过了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="comment">//横向和纵向有相等的值</span></span><br><span class="line">                <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">                    <span class="comment">//当前位置左边的值+1</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//取当前位置（左边的值，上边的值）的最大值</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                System.out.print(dp[i][j] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LCS lcs = <span class="keyword">new</span> LCS();</span><br><span class="line">        <span class="keyword">int</span> findLCS = lcs.findLCS(<span class="string">&quot;android&quot;</span>, <span class="string">&quot;random&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;最长子序列长度：&quot;</span> + findLCS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>Java面试</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程分批处理方案</title>
    <url>/blog/posts/2dc35ee/</url>
    <content><![CDATA[<p>最近开发一个新的需求,虽然磕磕碰碰需求写完了,但是问题也随之而来:可能查询的数据会有上千万之多,所以可能会用到分批去查询处理,所以也就聚集了一些办法:</p>
<span id="more"></span>

<p>首先,分批处理必然会去遍历一个拥有某些前置条件的<code>List</code>,一般都会去遍历这个拥有全数据的<code>List</code>,所以分批处理的逻辑也从该<code>List</code>开始</p>
<h2 id="1-List分组实现"><a href="#1-List分组实现" class="headerlink" title="1. List分组实现"></a>1. <code>List</code>分组实现</h2><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>21.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在工具包的 <code>Lists</code>报下有一个<code>partition</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;List&lt;T&gt;&gt; partition(List&lt;T&gt; list, <span class="keyword">int</span> size) &#123;</span><br><span class="line">    checkNotNull(list);</span><br><span class="line">    checkArgument(size &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess)</span><br><span class="line">        ? <span class="keyword">new</span> RandomAccessPartition&lt;T&gt;(list, size)</span><br><span class="line">        : <span class="keyword">new</span> Partition&lt;T&gt;(list, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************/</span></span><br><span class="line">List&lt;List&lt;String&gt;&gt; partition = Lists.partition(list, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>该<code>partition</code>中就是分组后的数据</p>
<h2 id="2-多线程实现分批"><a href="#2-多线程实现分批" class="headerlink" title="2. 多线程实现分批"></a>2. 多线程实现分批</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture[] completableFuture = partition.stream()</span><br><span class="line">        .map(m -&gt; CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            Map&lt;String, DriverSettlement&gt; driverSettlementMap = m.stream()</span><br><span class="line">                    .map(driversMap::get).collect(Collectors.toMap(DriverSettlement::getDriverId, t -&gt; t));</span><br><span class="line">            <span class="comment">//业务实现</span></span><br><span class="line">        &#125;, ExecutorUtil.getExcelExecutor())).toArray(CompletableFuture[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="comment">//所有线程执行完毕,否则处于阻塞状态</span></span><br><span class="line">CompletableFuture.allOf(completableFuture).join();</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExecutorUtil</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor excelExecutor =</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>,</span><br><span class="line">                    <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">10000</span>),</span><br><span class="line">                    <span class="keyword">new</span> NamedThreadFactory(<span class="string">&quot;pay-verify-thread-%d&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolExecutor <span class="title">getExcelExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> excelExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>所有子线程都需要完成后再执行主线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture.allOf().join()</span><br></pre></td></tr></table></figure></li>
<li><p>其中任何一个子线程完成后就执行主线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ComPletableFuture.anyOf()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>线程池线程数量参考:</p>
<img data-src="/blog/posts/2dc35ee/2021-11-30-11-11-11.png" class="">

]]></content>
  </entry>
  <entry>
    <title>在Javadoc注释中引用方法</title>
    <url>/blog/posts/d6d1be75/</url>
    <content><![CDATA[<p>最近用到如何在注释中<code>link</code>到另一个类</p>
<ol>
<li><code>@link</code>标签<br><code>Javadoc</code> 提供了<code>@link</code>内联标记来引用Java 类中的成员。我们可以认为<code>@link</code>标签类似于 <code>HTML</code> 中的锚标签，用于通过超链接将一个页面链接到另一个页面。</li>
</ol>
<p>让我们看看使用<code>@link</code>标记引用 <code>Javadoc</code> 注释中的方法的语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> path_to_member label&#125;</span><br></pre></td></tr></table></figure>

<p>与锚标签类似，<code>path_to_member</code>是目的地，标签是显示文本。</p>
<p>标签是可选的，但<code>path_to_member</code>是引用方法所必需的。但是，始终使用标签名称来避免复杂的参考链接是一种很好的做法。<code>path_to_member</code>的语法 根据我们引用的方法是否驻留在同一个类中而有所不同。</p>
<p>需要注意的是，大括号<code>&#123;</code>和<code>@link</code>之间不能有空格。如果它们之间有空格，<code>Javadoc </code>工具将无法正确生成引用。但是， <code>path_to_member、label</code>和右大括号之间没有空间限制。</p>
<span id="more"></span>

<ol start="2">
<li>引用同一个类中的方法<br>引用方法的最简单方法是在同一个类中：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> #methodName() LabelName&#125;</span><br></pre></td></tr></table></figure>
假设我们正在记录一个方法，并且我们想从同一个类中引用另一个方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Also, check the &#123;<span class="doctag">@link</span> #move() Move&#125; method for more movement details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在这种情况下，<code>walk()</code>方法引用同一类中的<code>move()</code>实例方法。</li>
</ol>
<p>如果被引用的方法有参数，当我们想要引用一个重载或参数化的方法时，我们必须相应地指定其参数的类型。</p>
<p>考虑以下引用重载方法的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check this &#123;<span class="doctag">@link</span> #move(String) Move&#125; method for direction-oriented movement.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String direction)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>move()</code>方法是指一种采用一个String参数的重载方法。</p>
<ol start="3">
<li>引用另一个类中的方法<br>要引用另一个类中的方法，我们将使用类名，后跟标签，然后是方法名：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> ClassName#methodName() LabelName&#125;</span><br></pre></td></tr></table></figure>
语法类似于引用同一类中的方法，除了在<code>#</code>符号之前提到类名。</li>
</ol>
<p>现在，让我们考虑在另一个类中引用方法的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Additionally, check this &#123;<span class="doctag">@link</span> Animal#run(String) Run&#125; method for direction based run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用的方法在同一个包中的<code>Animal</code>类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String direction)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想引用另一个包中的方法，我们有两个选择。一种方法是直接指定包以及类名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Also consider checking &#123;<span class="doctag">@link</span> com.baeldung.sealed.classes.Vehicle#Vehicle() Vehicle&#125; </span></span><br><span class="line"><span class="comment"> * constructor to initialize vehicle object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，已经使用完整的包名称提到了<code>Vehicle</code>类，以引用<code>Vehicle()</code>方法。</p>
<p>此外，我们可以导入包并单独提及类名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baeldung.sealed.records.Car;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Have a look at &#123;<span class="doctag">@link</span> Car#getNumberOfSeats() SeatsAvailability&#125; </span></span><br><span class="line"><span class="comment"> * method for checking the available seats needed for driving.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，驻留在另一个包中的<code>Car</code>类已被导入。所以，<code>@link</code>只需要包含类名和方法。</p>
<p>我们可以选择两种方式中的任何一种来引用不同包中的方法。如果是单次使用包，那么我们可以使用第一种方式，否则，如果有多个依赖项，我们应该选择第二种方式。</p>
<ol start="4">
<li><code>@linkplain</code>标签<br>我们已经在注释中看到了用于引用方法的<code>@link Javadoc</code> 标记。<code>Javadoc</code> 提供了另一个名为<code>@linkplain</code> 的标记，用于在注释中引用方法，类似于<code>@link</code>标记。主要区别在于，在生成文档时，<code>@link</code>以等宽格式文本生成标签值，而<code>@linkplain</code>以标准格式（如纯文本）生成它。</li>
</ol>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemRpdGVjdC5jb20vbWFpbi1hZHZhbmNlZC9qYXZhL2phdmEtbWV0aG9kLWluLWphdmFkb2MuaHRtbA=="> 原文章地址 </span></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何保证接口的幂等性</title>
    <url>/blog/posts/3b6bfba3/</url>
    <content><![CDATA[<h1 id="如何保证接口的幂等性"><a href="#如何保证接口的幂等性" class="headerlink" title="如何保证接口的幂等性"></a><strong>如何保证接口的幂等性</strong></h1><h2 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h2><p>幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。</p>
<span id="more"></span>

<h2 id="什么情况下需要幂等"><a href="#什么情况下需要幂等" class="headerlink" title="什么情况下需要幂等"></a>什么情况下需要幂等</h2><p>以<code>SQL</code>为例：</p>
<ul>
<li><p><code>SELECT col1 FROM tab1 WHER col2=2，</code>无论执行多少次都不会改变状态，是天然的幂等。</p>
</li>
<li><p><code>UPDATE tab1 SET col1=1 WHERE col2=2</code>，无论执行成功多少次状态都是一致的，因此也是幂等操作。</p>
</li>
<li><p><code>UPDATE tab1 SET col1=col1+1 WHERE col2=2</code>，每次执行的结果都会发生变化，这种不是幂等的。</p>
</li>
<li><p><code>insert into user(userid,name) values(1,&#39;a&#39;)</code> 如<code>userid</code>为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。<br>如<code>userid</code>不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。</p>
</li>
<li><p><code>delete from user where userid=1</code>，多次操作，结果一样，具备幂等性</p>
</li>
</ul>
<h2 id="如何保证幂等"><a href="#如何保证幂等" class="headerlink" title="如何保证幂等"></a>如何保证幂等</h2><ul>
<li><h3 id="token机制"><a href="#token机制" class="headerlink" title="token机制"></a><code>token</code>机制</h3><ol>
<li><p>服务端提供了发送<code>token</code>的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取<code>token</code>，服务器会把<code>token</code>保存到<code>redis</code>中。</p>
</li>
<li><p>然后调用业务接口请求时，把<code>token</code>携带过去，一般放在请求头部。</p>
</li>
<li><p>服务器判断<code>token</code>是否存在<code>redis</code>中，存在表示第一次请求，然后删除<code>token</code>,继续执行业务。</p>
</li>
<li><p>如果判断<code>token</code>不存在<code>redis</code>中，就表示是重复操作，直接返回重复标记给<code>client</code>，这样就保证了业务代码，不被重复执行。</p>
<h4 id="关键点-先删除token，还是后删除token。"><a href="#关键点-先删除token，还是后删除token。" class="headerlink" title="关键点 先删除token，还是后删除token。"></a><strong>关键点 先删除<code>token</code>，还是后删除<code>token</code>。</strong></h4><p>   后删除<code>token</code>：如果进行业务处理成功后，删除<code>redis</code>中的<code>token</code>失败了，这样就导致了有可能会发生重复请求，因为<code>token</code>没有被删除。这个问题其实是数据库和缓存<code>redis</code>数据不一致问题，后续会写文章进行讲解。</p>
<p>   先删除<code>token</code>：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但<code>token</code>已经删除掉了，服务端判断<code>token</code>不存在，认为是重复请求，就直接返回了，无法进行业务处理了。</p>
<p>   先删除<code>token</code>可以保证不会因为重复请求，业务数据出现问题。出现业务异常，可以让调用方配合处理一下，重新获取新的<code>token</code>，再次由业务调用方发起重试请求就<code>ok</code>了。</p>
<h4 id="token机制缺点"><a href="#token机制缺点" class="headerlink" title="token机制缺点"></a><code>token</code>机制缺点</h4><p>   业务请求每次请求，都会有额外的请求（一次获取<code>token</code>请求、判断<code>token</code>是否存在的业务）。其实真实的生产环境中，1万请求也许只会存在<code>10</code>个左右的请求会发生重试，为了这<code>10</code>个请求，我们让<code>9990</code>个请求都发生了额外的请求。</p>
</li>
</ol>
</li>
<li><h3 id="乐观锁机制"><a href="#乐观锁机制" class="headerlink" title="乐观锁机制"></a>乐观锁机制</h3><p>  这种方法适合在更新的场景中<code>update t_goods set count = count -1 , version = version + 1 where good_id=2 and version = 1</code><br>  根据<code>version</code>版本，也就是在操作库存前先获取当前商品的<code>version</code>版本号，然后操作的时候带上此<code>version</code>号。我们梳理下，我们第一次操作库存时，得到<code>version</code>为<code>1</code>，调用库存服务<code>version</code>变成了<code>2</code>；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的<code>version</code>还是<code>1</code>，再执行上面的<code>sql</code>语句时，就不会执行；因为<code>version</code>已经变为<code>2</code>了，<code>where</code>条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。<br>  乐观锁主要使用于处理读多写少的问题</p>
</li>
<li><h3 id="唯一主键"><a href="#唯一主键" class="headerlink" title="唯一主键"></a>唯一主键</h3><p>  这个机制是利用了数据库的主键唯一约束的特性，解决了在<code>insert</code>场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。</p>
<p>  如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</p>
</li>
<li><h3 id="防重表"><a href="#防重表" class="headerlink" title="防重表"></a>防重表</h3><p>  使用订单号<code>orderNo</code>做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</p>
</li>
<li><h3 id="唯一ID"><a href="#唯一ID" class="headerlink" title="唯一ID"></a>唯一<code>ID</code></h3><p>  调用接口时，生成一个唯一<code>id</code>，<code>redis</code>将数据保存到集合中（去重），存在即处理过。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java面试</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>幂等性</tag>
      </tags>
  </entry>
  <entry>
    <title>如何让自己的博客被Google以及百度收录</title>
    <url>/blog/posts/3c59e6c8/</url>
    <content><![CDATA[<p>参考文章： <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAzNzU1MDM2Mg==">https://segmentfault.com/a/1190000037550362</span></p>
<p>这篇文章讲的很详细</p>
<h2 id="Agenda"><a href="#Agenda" class="headerlink" title="Agenda"></a>Agenda</h2><p>突然奇想，我的博客能在<code>Google</code>或者百度上搜到吗，果不其然，是不能的，测试方法：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">site:</span><span class="params">&lt;域名&gt;</span></span><br></pre></td></tr></table></figure>
<p>例如我的：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">site</span>:smile<span class="number">1231</span>.github.io</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/3c59e6c8/2022-07-08-22-34-25.png" class="">


<p>百度还在申请中：</p>
<img data-src="/blog/posts/3c59e6c8/2022-07-08-22-36-33.png" class="">


<h2 id="百度申请"><a href="#百度申请" class="headerlink" title="百度申请"></a>百度申请</h2><p>我们需要登录<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnNlZ21lbnRmYXVsdC5jb20vP2VuYz1NMG9kZGFxWmwrQTc3RGVWNVpwNUZBPT0uNTg0SytxS29KRFVXcWQrWkhVTEhwYWgwZUZ6bXY5NGEvdjIrNVZYNWRVaz0=">百度搜索资源平台</span>， 只要是百度旗下的账号就可以， 登录成功之后在站点管理中点击<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnNlZ21lbnRmYXVsdC5jb20vP2VuYz15bndBbGYveVB2bitlSTVwQVIrOFRRPT0uRksvMVpnRWtBMHc1LzhDTmNXZ3NPbVc0djV5MHc5bStLd2t1bmJHTG93cUltby90bFA0cVN6UFpJakFxSmJRNQ==">添加网站</span>，输入域名，按照步骤走。</p>
<blockquote>
<p>输入网址</p>
</blockquote>
<img data-src="/blog/posts/3c59e6c8/2022-07-08-22-39-27.png" class="">

<blockquote>
<p>一些站点标签</p>
</blockquote>
<img data-src="/blog/posts/3c59e6c8/2022-07-08-22-41-13.png" class="">

<blockquote>
<p>需要验证所有权，所以这边我选择了文件验证，需要将<code>html</code>文件进行下载</p>
</blockquote>
<img data-src="/blog/posts/3c59e6c8/2022-07-08-22-41-04.png" class="">

<p>将<code>html</code>文件放在<code>theme</code>主题下的<code>source</code>文件夹中</p>
<img data-src="/blog/posts/3c59e6c8/2022-07-08-22-43-41.png" class="">

<blockquote>
<p><code>Google</code> 文件下载<br>这边可以同时将<a href="https://search.google.com/search-console/welcome"><code>Google</code>的<code>html</code>文件</a>也下载了</p>
</blockquote>
<img data-src="/blog/posts/3c59e6c8/2022-07-08-22-50-55.png" class="">

<p>点击下载放在同样的位置：</p>
<img data-src="/blog/posts/3c59e6c8/2022-07-08-22-53-06.png" class="">


<blockquote>
<p>依次执行<code>hexo clean</code> <code>hexo g</code> <code>hexo d</code>，需要等待部署完毕之后，访问 <code>https://&lt;域名&gt;/&lt;htmlFileName&gt;</code> ， 不报<code>404</code>就ok啦</p>
</blockquote>
<img data-src="/blog/posts/3c59e6c8/2022-07-08-22-56-26.png" class="">

<img data-src="/blog/posts/3c59e6c8/2022-07-08-22-57-11.png" class="">

<blockquote>
<p>点击验证完成即可</p>
</blockquote>
<img data-src="/blog/posts/3c59e6c8/2022-07-08-22-57-41.png" class="">

<h2 id="关于收录"><a href="#关于收录" class="headerlink" title="关于收录"></a>关于收录</h2><img data-src="/blog/posts/3c59e6c8/2022-07-08-23-01-54.png" class="">

<h3 id="使用sitemap方式推送"><a href="#使用sitemap方式推送" class="headerlink" title="使用sitemap方式推送"></a>使用<code>sitemap</code>方式推送</h3><blockquote>
<p><code>hexo</code>框架只需要在两个<code>sitemap</code>插件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save </span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>

<p>这两个插件是用来生成 <code>Sitemap</code>文件 的插件，而 <code>Sitemap</code>文件 是用来告诉搜索引擎我们的站点有哪些资源是可以抓取的。</p>
<p>安装完成后我们执行<code>hexo clean</code>&amp;&amp;<code>hexo g</code> 命令后我们会发现在<code>public</code> 目录下面会多了<code>baidusitemap.xml</code>和<code>sitemap.xml</code>文件。</p>
<blockquote>
<p>安装<code>hexo-abbrlink</code>,这个会自动生成一个永久博客链接且不重复，同时需要配置<code>root</code>目录下的<code>_config.</code></p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>hexo d</code>完成之后，可以访问 <code>https://&lt;域名&gt;/baidusitemap.xml</code></p>
</blockquote>
<img data-src="/blog/posts/3c59e6c8/2022-07-08-23-33-54.png" class="">

<p>回到百度提交<code>sitemap</code>界面，将<code>https://smile1231.github.io/baidusitemap.xml</code>填入然后提交即可，就会进入审核状态，需要耗时一段时间。</p>
<img data-src="/blog/posts/3c59e6c8/2022-07-08-23-36-16.png" class="">

<h3 id="Google提交sitemap"><a href="#Google提交sitemap" class="headerlink" title="Google提交sitemap"></a><code>Google</code>提交<code>sitemap</code></h3><p>由于之前的插件也会在<code>public</code>目录下生成一个<code>sitemap.xml</code>，同样的在<code>google</code>站点地图中提交即可</p>
<img data-src="/blog/posts/3c59e6c8/2022-07-08-23-38-49.png" class="">

<p><code>ex: sitemap.xml</code></p>
<p><code>google</code>收录会很快，估计几个小时即可！效果上图已经展示</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程笔记</title>
    <url>/blog/posts/12fecb94/</url>
    <content><![CDATA[<blockquote>
<p>线程的实现方式</p>
</blockquote>
<ol>
<li><p>继承Thread类</p>
</li>
<li><p>实现Runnable接口</p>
</li>
<li><p>使用Callable和Future</p>
</li>
</ol>
<span id="more"></span>

<blockquote>
<p>Thread 类中的<code>start()</code> 和 <code>run() </code>方法有什么区别?</p>
</blockquote>
<ol>
<li>start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</li>
<li>run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。</li>
</ol>
<blockquote>
<p>线程<code>RUNNABLE</code>状态</p>
</blockquote>
<p>线程对象通过start方法进入runnable状态，启动的线程不一定会立即得到执行，线程的运行与否要看cpu的调度，我们把这个中间状态叫可执行状态（RUNNABLE)。</p>
<blockquote>
<p>线程的<code>BLOCKED</code>状态</p>
</blockquote>
<p>线程正在等待获取锁。</p>
<p>进入<code>BLOCKED</code>状态，比如调用了<code>sleep</code>,或者<code>wait</code>方法<br>进行某个阻塞的<code>io</code>操作，比如因网络数据的读写进入<code>BLOCKED</code>状态<br>获取某个锁资源，从而加入到该锁的阻塞队列中而进入<code>BLOCKED</code>状态</p>
<blockquote>
<p>线程的<code>TERMINATED</code>状态</p>
</blockquote>
<p>`TERMINATED``是一个线程的最终状态，在该状态下线程不会再切换到其他任何状态了，代表整个生命周期都结束了。</p>
<p>下面几种情况会进入<code>TERMINATED</code>状态:</p>
<p>线程运行正常结束，结束生命周期<br>线程运行出错意外结束<br><code>JVM Crash</code> 导致所有的线程都结束</p>
<blockquote>
<p>如何知道代码段被哪个线程调用？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Thread.currentThread().getName());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>停止线程</p>
</blockquote>
<p><code>run</code>方法执行完成，自然终止。</p>
<p><code>stop()</code>方法，<code>suspend()</code>以及<code>resume()</code>都是过期作废方法，使用它们结果不可预期。</p>
<p>大多数停止一个线程的操作使用<code>Thread.interrupt()</code>等于说给线程打一个停止的标记, 此方法不回去终止一个正在运行的线程，需要加入一个判断才能可以完成线程的停止。</p>
<blockquote>
<p><code>interrupted</code> 和 <code>isInterrupted</code></p>
</blockquote>
<p><code>interrupted</code> : 判断当前线程是否已经中断,会清除状态。</p>
<p><code>isInterrupted</code> ：判断线程是否已经中断，不会清除状态。</p>
<blockquote>
<p><code>yield</code></p>
</blockquote>
<p>放弃当前cpu资源，将它让给其他的任务占用cpu执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得cpu时间片。</p>
<blockquote>
<p>线程的优先级</p>
</blockquote>
<p>在操作系统中，线程可以划分优先级，优先级较高的线程得到cpu资源比较多，也就是cpu有限执行优先级较高的线程对象中的任务，但是不能保证一定优先级高，就先执行。</p>
<p>Java的优先级分为1～10个等级，数字越大优先级越高，默认优先级大小为5。超出范围则抛出：<code>java.lang.IllegalArgumentException</code>。</p>
<blockquote>
<p>优先级继承特性</p>
</blockquote>
<p>线程的优先级具有继承性，比如<code>a</code>线程启动<code>b</code>线程，<code>b</code>线程与<code>a</code>优先级是一样的。</p>
<blockquote>
<p>线程种类</p>
</blockquote>
<p><code>Java</code>线程有两种，一种是用户线程，一种是守护线程。</p>
<blockquote>
<p>守护线程的特点</p>
</blockquote>
<p>守护线程是一个比较特殊的线程，主要被用做程序中后台调度以及支持性工作。当<code>Java</code>虚拟机中不存在非守护线程时，守护线程才会随着<code>JVM</code>一同结束工作。</p>
<blockquote>
<p><code>Java</code>中典型的守护线程</p>
</blockquote>
<p><code>GC</code>（垃圾回收器）</p>
<blockquote>
<p>如何设置守护线程<br><code>Thread.setDaemon(true)</code></p>
</blockquote>
<p><code>PS:Daemon</code>属性需要再启动线程之前设置，不能再启动后设置。</p>
<blockquote>
<p>join</p>
</blockquote>
<p>join是指把指定的线程加入到当前线程，比如join某个线程a,会让当前线程b进入等待,直到a的生命周期结束，此期间b线程是处于blocked状态。</p>
<blockquote>
<p>什么是synchronized?</p>
</blockquote>
<p>synchronized关键字可以时间一个简单的策略来防止线程干扰和内存一致性错误，如果一个对象是对多个线程可见的，那么对该对想的所有读写都将通过同步的方式来进行。</p>
<blockquote>
<p>synchronized包括哪两个jvm重要的指令？</p>
</blockquote>
<p>monitor enter 和 monitor exit</p>
<blockquote>
<p>synchronized关键字用法?</p>
</blockquote>
<p>可以用于对代码块或方法的修饰</p>
<blockquote>
<p>synchronized锁的是什么?</p>
</blockquote>
<p>普通同步方法 —————&gt; 锁的是当前实力对象。</p>
<p>静态同步方法—————&gt; 锁的是当前类的Class对象。</p>
<p>同步方法 块—————&gt; 锁的是synchonized括号里配置的对象。</p>
<blockquote>
<p>Java对象头</p>
</blockquote>
<p>synchronized用的锁是存在Java对象头里的。对象如果是数组类型，虚拟机用3个字宽(Word)存储对象头，如果对象是非数组类型，用2字宽存储对象头。</p>
<p>Tips:32位虚拟机中一个字宽等于4字节。</p>
<blockquote>
<p>volatile关键字</p>
</blockquote>
<p>volatile 是轻量级的synchronized,它在多处理器开发中保证了共享变量的“可见性“。</p>
<p>Java语言规范第3版对volatile定义如下，Java允许线程访问共享变量，为了保证共享变量能准确和一致的更新，线程应该确保排它锁单独获得这个变量。如果一个字段被声明为volatile,Java线程内存模型所有线程看到这个变量的值是一致的。</p>
<blockquote>
<p>重入锁 ReentrantLock</p>
</blockquote>
<p>支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。</p>
<blockquote>
<p>重进入是什么意思？</p>
</blockquote>
<p>重进入是指任意线程在获取到锁之后能够再次获锁而不被锁阻塞。</p>
<p>该特性主要解决以下两个问题：</p>
<ol>
<li><p>锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是则再次成功获取。</p>
</li>
<li><p>所得最终释放。线程重复n次是获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。</p>
</li>
</ol>
<blockquote>
<p>ReentrantLock默认锁？</p>
</blockquote>
<p>默认非公平锁</p>
<blockquote>
<p>公平锁和非公平锁的区别</p>
</blockquote>
<p>公平性与否针对获取锁来说的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是<code>FIFO</code>。</p>
<blockquote>
<p>读写锁</p>
</blockquote>
<p>读写锁允许同一时刻多个读线程访问，但是写线程和其他写线程均被阻塞。读写锁维护一个读锁一个写锁，读写分离，并发性得到了提升。<br><code>Java</code>中提供读写锁的实现类是<code>ReentrantReadWriteLock</code>。</p>
<blockquote>
<p>Java并发容器，你知道几个？</p>
</blockquote>
<p>ConcurrentHashMap、CopyOnWriteArrayList 、CopyOnWriteArraySet 、ConcurrentLinkedQueue、</p>
<p>ConcurrentLinkedDeque、ConcurrentSkipListMap、ConcurrentSkipListSet、ArrayBlockingQueue、</p>
<p>LinkedBlockingQueue、LinkedBlockingDeque、PriorityBlockingQueue、SynchronousQueue、</p>
<p>LinkedTransferQueue、DelayQueue</p>
<blockquote>
<p>Java里的阻塞的队列</p>
</blockquote>


<blockquote>
<p>工作窃取算法</p>
</blockquote>
<p>是指某个线程从其他队列里窃取任务来执行。当大任务被分割成小任务时，有的线程可能提前完成任务，此时闲着不如去帮其他没完成工作线程。此时可以去其他队列窃取任务，为了减少竞争，通常使用双端队列，被窃取的线程从头部拿，窃取的线程从尾部拿任务执行。</p>
<blockquote>
<p>创建线程池参数有哪些，作用？</p>
</blockquote>


<ol>
<li><p>corePoolSize:核心线程池大小，当提交一个任务时，线程池会创建一个线程来执行任务，即使其他空闲的核心线程能够执行新任务也会创建，等待需要执行的任务数大于线程核心大小就不会继续创建。</p>
</li>
<li><p>maximumPoolSize:线程池最大数，允许创建的最大线程数，如果队列满了，并且已经创建的线程数小于最大线程数，则会创建新的线程执行任务。如果是无界队列，这个参数基本没用。</p>
</li>
<li><p>keepAliveTime: 线程保持活动时间，线程池工作线程空闲后，保持存活的时间，所以如果任务很多，并且每个任务执行时间较短，可以调大时间，提高线程利用率。</p>
</li>
<li><p>unit: 线程保持活动时间单位，天（DAYS)、小时(HOURS)、分钟(MINUTES、毫秒MILLISECONDS)、微秒(MICROSECONDS)、纳秒(NANOSECONDS)</p>
</li>
<li><p>workQueue: 任务队列，保存等待执行的任务的阻塞队列。</p>
</li>
</ol>
<p>一般来说可以选择如下阻塞队列：</p>
<p><code>ArrayBlockingQueue</code>:基于数组的有界阻塞队列。</p>
<p><code>LinkedBlockingQueue</code>:基于链表的阻塞队列。</p>
<p><code>SynchronizedQueue</code>:一个不存储元素的阻塞队列。</p>
<p><code>PriorityBlockingQueue</code>:一个具有优先级的阻塞队列。</p>
<blockquote>
<p>向线程池提交任务</p>
</blockquote>
<p>可以使用<code>execute()</code>和<code>submit()</code> 两种方式提交任务。</p>
<p><code>execute()</code>:无返回值，所以无法判断任务是否被执行成功。</p>
<p><code>submit()</code>:用于提交需要有返回值的任务。线程池返回一个<code>future</code>类型的对象，通过这个<code>future</code>对象可以判断任务是否执行成功，并且可以通过<code>future的get()</code>来获取返回值，<code>get()</code>方法会阻塞当前线程知道任务完成。<code>get(long timeout,TimeUnit unit)</code>可以设置超市时间。</p>
<blockquote>
<p>关闭线程池</p>
</blockquote>
<p>可以通过shutdown()或shutdownNow()来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt来中断线程，所以无法响应终端的任务可以能永远无法停止。</p>
<p>shutdownNow首先将线程池状态设置成STOP,然后尝试停止所有的正在执行或者暂停的线程，并返回等待执行任务的列表。</p>
<p>shutdown只是将线程池的状态设置成shutdown状态，然后中断所有没有正在执行任务的线程。</p>
<p>只要调用两者之一，isShutdown就会返回true,当所有任务都已关闭，isTerminaed就会返回true。</p>
<p>一般来说调用shutdown方法来关闭线程池，如果任务不一定要执行完，可以直接调用shutdownNow方法。</p>
<blockquote>
<p>线程池如何合理设置</p>
</blockquote>
<p>配置线程池可以从以下几个方面考虑。</p>
<ul>
<li><p>任务是cpu密集型、IO密集型或者混合型</p>
</li>
<li><p>任务优先级，高中低。</p>
</li>
<li><p>任务时间执行长短。</p>
</li>
<li><p>任务依赖性：是否依赖其他系统资源。</p>
<ul>
<li><p>cpu密集型可以配置可能小的线程,比如 n + 1个线程。</p>
</li>
<li><p>io密集型可以配置较多的线程，如 2n个线程。</p>
</li>
<li><p>混合型可以拆成io密集型任务和cpu密集型任务，</p>
</li>
<li><p>如果两个任务执行时间相差大，否-&gt;分解后执行吞吐量将高于串行执行吞吐量。<br>否-&gt;没必要分解。</p>
</li>
<li><p>可以通过Runtime.getRuntime().availableProcessors()来获取cpu个数。</p>
</li>
<li><p>建议使用有界队列，增加系统的预警能力和稳定性。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>JDK 内置的拒绝策略</p>
</blockquote>
<ul>
<li><p>AbortPolicy 抛出异常。</p>
</li>
<li><p>DiscardPolicy 直接静悄悄的丢弃这个任务，不触发任何动作。这个策略基本不会使用</p>
</li>
<li><p>DiscardOldestPolicy 丢弃队列最前面（最旧）的任务，然后重新尝试执行任务（重复此过程）。</p>
</li>
<li><p>CallerRunsPolicy 由调用线程处理该任务 。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
        <category>Java面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java面试</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>宝儿的大腿小腿围</title>
    <url>/blog/posts/5a74c6a6/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="77c1a1c22967d6d4b5bfc7bb74bd5902c655a3c68fc668f71a37e284098d62fa">d8f882ae5b95f5a7d293d910bf962efe2c336ae2e7f37d338ffea9f00dacb4f7199c21dc2dd2e28c01696796ca01821dc6160933dcf938577aaad899fca684630f743df48d3d8d1da01b7fc03fa2f87410885a0f772858b7f9c0b7933cceb3f0bc4371a084b84b84536b1c789fce9c15ed16300c7ae95914a0caf9f336920b93022048dc26e2b31bd2ce4252bc06efbefe6b450016bda7392990f0b36578ec84e2e5e342e15f48244449ab89d8714599a62d37f6228b45affec9ae9d07dd6c1c1c5d8ef2e9e86b9081914c80879e4ac5d037807128b7f2fe8c75041312bf4bf89d5f66ef840590bd86c87a6e22337719db8df6c9d6751610f0a7d63e8f9a4106b813297dc848e0e65630cbf362e8afbe027d7faefab5f6bdfac40d20ad5332ef837753d34161633561049f50744309a129e0be16e307b9151961fdfcbda42220</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/blog/lib/hbe.js"></script><link href="/blog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>工作难点</title>
    <url>/blog/posts/d0966c4d/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="5705267f463bfd0e1fc5f2f0e51a4c51e3b56d061b83cf22dce936d43c94ffe3">36b0d245773c4ce2339eb0a7bae59cc6a1a0da7a63994ce87fcfd6dc56f5cfdd025812a3cd319540864e180afd2e9ebe871a0b745b7bf79e82be0e14676e20f517dfae138ec75f34eb7b29c9e844926ee6cb55db2fa8f22e4385a263049c14785a30e1957a77b9edb85d0b2eb91508cd69bfc47222bc35224ece462cee3789a0c8ea2f1467228818eda219a4eca396040d863c6952e7c5bf07499bde1694588f565d4937a38cea08f2b07255f37749e2e947b135c24a282735464cf6de718fad95a55350025e9bac22f3efedd83e0f076b11d76e693f6dd75ef37ff9be6f84e1a2a23a6242b7edc77127a9b5c03498dc3986d3edd636c5a418c0402d30fd88b33cbae9104d7f5b0717120245ebba1e530100f8e94df292c0a70db4316f67ea7980333ef42f4febaa6a79ce0fb02b00577b171554f5faeee84cb5a9223dd9e20f25f3bf5b698bae1b8c633a42c2b6f9c3691581309ce54b1b76404db80a80e9105af21714ced19e503b5824b1096d961d0939e8a89c27453aa30a3fc75eb7dcaddddd6641b7831dec907f957944de4af39d92aea1f414489e14bd4d0d81b52a01d4f1322163742e3d91cd2689bf90320cd1e18a4ed25770fdae29901b83c833feed609bd12aa9a624ed40ce84f2de57e10f5ce53c2c58e747cee3eb2205dfa7704c0fa59c8240d1bd396e5b6febbd4a1230b0849389554eac06e7b2e218e1846b6237ea2d0b9d6fb7e785fe466e7a9e30b6d2fa94efdf53c6cfa56e7691397bd3ca60c371b39fbf5aed80bab1dd72006e5e742fc3190a98aef06aa446bc785b7ed9609c2db75173ebbec6eb4cca0fb54cb49730629742b0c1b6eab7ff1f46a9ebd22b17067a2b2746b02fa22dc90baebf6856e5e9e19173b1bdff75a65d41ec63790177a22debcc2b543c12227afc36ae9224cdea0abd1d4257b785a45abe080b21987915ced09c63c4646c0b061e5e18f64aecddb0f27ceb8b59b23e1692ddf233fdec93cd71e50794cb4b6b74c3a5f644f7018c91b606b80da145638975ac9ed7f4a1bb429e2abc2eb12c4cc6ea48a88fef1d5051886ee21a37f53f1d8992f17e28555411fb751cbe5d596bd9d0ff56117761a444eaf5cfd620aa4e42974807814854d9d3321d15dd0abe6eb575b2034fb584d8c85b4c1118ac95fd21e5c83317389752909042864dbe5cafae2e876f3f40053584a9181c9671c38be4ba4ea722045d4c59c90a043fc87606fca04b0a9aea90b002b82242493e410da4df890b7772623fe27d5008ab54ca3a1613a1ae27e2314363615aa7f5070f657ae75076cf95e1483c49b25a78177639984c73a00e973208d2ab9f75337ad167c37a491530b597c5d018d2ed9ecf7c9bac1360830e3c9a03fa0220277ea5f723cbb9824759206d4be239df496dba4dce7bfeb87dabaa975ac9a98cc9c4caf5c1a69cca19db2d9c303ea4be20f46289e3540d0ed7ae7c223a1ebd730acd58a7766a31b058f2b309820264a69fb1bdc986346256fe0925fac4c6d17dcd9827c7dcc0cf8c07aa10ada8a82a00d81f117d0a2493bc698b6a20818a193dddbcdbdf0bb90864700ae950c273961f992a6cc2387f2631bd3fcab7c16577cef45994a1dd20b1681526cb7b0098a1b63a570a47b0a09e6f4c02e6e332b49314b574c5a46b87010c0f54804f7f7db8a76662fe6ded2b77a4f7f3522c271fb0d926e72b4829234efa2873e127b824870cccedb3a1f4f6a67cb5f9f74bb441c87fc8c8f0a79e54f215261da98def4b918f71532e33764952e30e47398d0cab69fadfaaef0c8c576ebb35ce3c0d5d8ae7f32e99d4aa93756e7185b29e1d01981625ee8babdf693593f21f25a01b0ea5f16a822b7d7b367f4a5b4f02f7b48afd75236efdef4efdbae90ca8775ea4c18bb25882bdf28f7d19226208ec87b8f097c66b1286f834898f192c879ce23fc93ba6eb804abf3597e1ec375994e6ab7245c9bafd38ff0221fa995132d76f9c711740d397d95bed948309e644dc1424571dd2ab58f4c9c476b10b22ee096a7033b1bfe2461acd294b0e8bb096e642d757707ecb78149aed205c837923c9d16ce880665353c9e612bbe02be2bfc822a91e1ab769bd38a83656d7a3e6220d41d49cab36e51375d89b003e3ac5a894346b760eaae01aefb2ccb26321565707901f4e0fabf0c50241034dba170e5180b4cb35d48495401625b393b3761e396e494a796d238f8e3ee87a8b0444eedc96301514c8fe0806f6250227b00eb9bb8fcf480162e043fd7e571e773ea8fd2c1d824c53f276c1c97b218adc1a7144c697bb768c447f03fac520199b9f132c0abe4d38cde3a8a4ecea09683828aa7deda37b62548e4bd0765993ec03a655e8e7ad42a0d8c7dd58d179dad9c4469ba0b86be75110e15423e0b07e91cd3f9b12c6e048450bc9b15335613b752ad26bdba7d76df9309b1c0b4f6d7671b0d40b81aea5d6d936e0a45b121ca57b9a7c3cffe87604e1523c0705dbf064217504463eeaedc95ef25130be6be5425520601912dbf7000a68b61163c5a0479c394fa2fc5517fcd91d72ccd735fe822348cd5753ad8a943fc072eb833cef1218ba370e1d465aa8611ef59ed0aae63c4a4f581f5b6757cbf56719a16afe8de07e67fdf126d2f69fb4acc39731b910b6f2e810b9c13d423cd7c15024d94c2ef199c3014d88c24eabb09e99f2c3f68ee4e8d328e012a71b49ef1a8c866ab10d497f56a50ddf6bd78026097145e43828c174aa180454439941010dec8b6eacc1bb9c4e1b10d9f67c041fa4318d6a33b4c54942cabfe1b1cdb3f30be5acda252da0c75372b1f028d221cfdf4d85d379470095a0e6405371f62f08b64c5b5adf1a6c57764f084f51f8622361df91d019d6cc3d3be8a46f73eaccaf08b4162b201627115afc1306b8c65cf111cb9ec40637f4dcfcda88f7922322f5bf2a1c3d46c161e3d146220db3c67d651ac81e1c5f5a67b0c88546215c7ed42762a59f24eb640ace95b0b473594e97c8192336b1fd8fdb6212951489a6a74220d42330a5e356b1bc22815da26681b192cf719f89b4ff93b55fc226b7f0a9a9b7b2523ba95d5b7b2d346aacb5ebc8cadb6c60ae9da7895295764e36e8b85326efd4fc586bba734ce6a2f30d26ca5789e93d74c9623d0deb0a606f802d45af9a0600a054cec465871f700f76e16fb64443d21760e3a2a09220f719291af93b76daa452f2306e055c1b89220da4e2c7c0cd8d810781deb80312ab7f3d87984bbf61bc15196d3d51fee35023bd44e9723dd10ee048c15046f35ab12a8a1b35909bcc260c8fb1fea4b72551e22469cce63d0ca1766b27571b3f7d7eeec134d719d8bb48d44263d1a497b566676a7dd15de451e06027a3d86eafb77dd0bb95632f41f7ef4c22b6cd5cda963db5988efbcd286fb87543466be97488be4281b2ada9ca6cd362c978d17e570f83f6a964394dcbf74d3d68a1c830a21a04d9467a0aa4dc0a054b5e0c8659979f6ea6bfd07d8fa7dcafbde9e32f36c04a269d89fe7e12d8231f069eeb6983949b9a28f44df5be885cef91c68de024898fedf948d5024fa1b23f324c019dd9a4f1449db7e44f2d5be514815ae3ced6b028e77bf1539bdd065b65a7fb6b0bd23757a23b3339d0287230f559f5b59aaf0e4928f6251f50a9982c87359ef390840db2ed7790ad9a5bf39aea9011a0375cb032a08da7e75e0d1c8f872f2185d0288c9dfda8b2746e5073c9068467b3a6bbf94cc82198e0b76ce22101edea9e3693fbfbdd09a2a89452a680c0e4065f41ef7be6187e1972280ca34cbf93149e3e397c012c0cbe3a3d55c66236a50a4b484b4b866e430c037f76683c20e1c4f2dd5a90a8712b16fde3ba9734633d7b8f243bc58789f90aaf79382bba55d55c5dfd5dcc665f28c5834577a9515370835825c97a6b896f0d4614bbe68d198fefdda743cadc18c143f2a6a843fff923ba185ebcaf47989adee99d8a47aa66f867bd84bb1460d6fb6062caad963910a0ad683a910fd2f7219414d7427118b5a157f4c68a4c632e97a8506a9ccfeb75b5fe4a8b43f1bf78f1e76140d8b012301eb73dba625a1c2d9ca70b3b7f377f99787b7f90b52a9c65d160364d25c97c4cc455f285652a3db4b0db1573fda664d9e1db1f7c8cef40f0f4233d700019b3893f5c3e21899d8d40a2e091a88a0d376d5284b4f806cc8a31e3c274e8e5f59fe24d94d9935cfdb09d1edbbfeab6e1205eee570a09b72da52a19fc47fa4ed731ab5703be0b56948e96cf2aa5fcac985b8895a9ad0332b5049057d659da17de2c2a727b3352d8c8e7ced4315f81b1a624676e487d9a2faf91ffb074fd95a605b4de302c663555c52a134354186dbb801de9d68712a683eae97b90be2af782726e2c0d35fe8159af8245df9b2219e94407a9814479126e9d59ef16646744f7dd3cedfb8eb09c29bddb006b41489ae93ede7aeb89a10a6a42d852df8d36163863fab94eb338373ab8881442c7a1e90ba344c4caf9851eb2450e536cf7d7f1b8c2d498d7b8e1ef5719d5dafba0664c1346a8da31406a1ac1f28207435ec28a9a7b75929faf2f5a94e555b0051d87cbc21901d6523f961219b243b1b9c7582a176bec2f767990d0f4df32c34cf4c640969b82e826a4ca79ae696cb22eec273d54806ea37c2ab154f2257d75257e85f3db67bf3e162fdbd890490753da9c1e6b88ffdc813094b36bbd1b6edff590d260fed8b75b58f23f8262457a68e7bbb76ddf6892ad8545a3748ddcd66b5cf4d6cd9c068d206f6bac6d9f8840eb8f71373b7f3e656b1b725bcc98e2df2504410a9b794adf3e700c50e4cf15cf1a76a31581b44024e3a4e4e05397101538c24a5f47bc8433b554e5ea8cde4ecf2ee67e513c9cae8645b034aa85fb36f78b0eb8eb03d578327da0f4033c060e9c9b680b2987a45cc9a339541638a9685fc205cf572c264daaa36521dc3e0a53ab38ec9501c9853b7e20934339b8df3823551f209c079b27a89d1cf16ecc9b09629d2ec9af7e5162128a9b5ae7c5c91acacdb1f459bae9b0e835d90e032abc2b04ac4f33664b3cd13da7b2dc930cc08564522cad257d4a92ce00f320b4580d6f4ab09eed87a6b461fd4484f18398500a8dfee84c7727d9d7462a6b3454980b68c5ee0af8f833f9c3cfa916b0c86b8e74e8959f5ba7570ad69d172fcf30abbf4b59fb28f8bd8ed69afc236fbf7b4a184f846a3d6b7cfeecc7168a2ec9407325a7bc405d23fec6273c63c12eed067da9e24609991738a1f7372674011ac29636192352648495ec3f25cc2b17185af9df2cdb7cd4f49cdd3337fa25176d6a51ac454c714fffc4d60f298950f02481fddbec2e975cd932a55b9d51f26233b65ba3c02ce01d4850589d250099540cf918a9ac840003d3f2d8ca5c09821c848320b2bbb6e0af86d8755158cf52476863bd7df4a4f086a0e33842441b465d771346fefff594d51397cd72388f9adecd04d78a8663ebb75389f735f51583f9f789c51d141504ba5361ab5fdfa29b7dedcbc46bf0ab529595f7b8e566a1b1cbb715d007a8439d065c6642813168dd3bd4b49f28923f73102f7dbd123380900ae0a109bcc8a787717e1e82f747ede7008cbb228e665ba4986ae610dd61aee8ec16f0b22b1ec37ae665231089fc6d31f9218d7b2f7e199e04748ec0f2c668e0ec413955eba576a9856a55afd06dc73200c04e44abce662bd2aebdccd0d8881d3e5a91880be01a5c5838b84615aa9de80dd5cf2bebc7dd95f6f757864302b2678728e0b2f9d615fe62e774eb409216e3bccb89922ae84d6671bf4b8fbb8d2eb980df07368c5ca57c30faa9d7b6ffea1fe34b982a1ab85a3c6fde6b62a626bc7836488c8dc33da8311f8a5cfcf302c4a536cbf27ea12efdbd7f66a54baef9b8741bfcda4ec3f54c352f6df31c600d9b6005869174a3427dbc3eec3c7a4a223a016d6c94e3aedf3228b56866502de719c714696e845e06565199739fd8df98036d871163d3bc3d986726ab8272ba951bd51bb7da45b3568d00a088a43256b77a8cac81854d42b8fb224c3abc8244d9b153afed89500266ecd8c5e49734aaf116a0d34b1d99294d9a477b7f2305bfff2227626f349dd2e4a490112c124721e7b78eaf3d721dc1ce5bedbb4e7a6f815fdc5a1408058079355fc3ed8f667cef0342899a9125ea5d07da789029892740e5b47409988a44207654d7a645dede5b52cce62cd6ad33b5dc06d2a17233e6cd46beea5d3f61c2feeb227300a393935aca16c097608ec38a0febddb9be6269d14adeb85c01b9d3bfa3c6850b40cf8828cf8d6b6326a20e80a4d1d7a57ae27f9d6103d8a6a3c57a3f665a5f194ee7634548573ede647c0ccc4ae4e48df350912b0a4189301024d858873fdafaa7ec46f8394cc10e59382a6aa322769de87e998bb86d607ef7d6cb9b142d1c0010737c648fa956e69a7f2fe41b01c65fbc7c4f4db01d8d771467df29bad1525a0067e719977a35d95099f178f04d57fb2b72134c379214b8c802ab7d15739cb966a0bba62460bdabad4b2349e152c0e8f2577118525a6b6c9d047e17f316358379e00a8620b39a3fc1466e8e5f627e9a7aed81c82cf0646dea589f15fa534d5e842af8d67dfac67d2298cd2d663ab9ef553dceb9fc5f21dcc000342750eb2aae911f0bda0e199f8dcdc5443f22da508fdb6c14056359205badac5f41079a24e6731c9fe3f743c0b026f7c558ba97e36db4f4bbf8f4dee0f04bf252af23a69f2a0b3737c02c7c5f59ddb7c52ecb356c19ac823a08ca85c98ed4d81e3146e8166ad777e64ec8531e4ba7ac94f0add7428eb240929f10232b2b3918d6f22f2b59504a34cf24f9352c9e61b55d3a1fad1322641721da4e319c3e41ff6e3f3587f0cd724080edba2ed1eaeda09fe3ddc8b8ccca9a873c24e69a0c5a5ed6dabc15b15900767f6e203ab100a03dca095a8ab226df0d26a04cccf7a68cfe85a226f87aeb52ee6594a99cbd939f21774ba9e3354a06f8e94ad959880b96277d4c61b8b7e0249cdaa4601fab230c2b5b65adb0708a80e8ca4b6f33688fb0f665b5726ac5adedd175997243ba226c0c4c46457eb0f8b1ed4515e242899428fb3c525dc7d098a188bfc8afa549970f6a7fb0389766f2cd2c05010d57a70d7f9133d65126662287c170b824d3c2dfc3cbe386afb347dcfee630947a3dc8a575cdcfe748633f371a2abf35b0f4528623c0ad9d56ef7f146ee535dac1c9e78db7e0e4672bd4d9fa3f498c645fd0f9d588178cf4ed53308ec87ccc358a6d98aac67922201bfde70350ee61e7921e39258750df1666ccfdd8501661c1faa107b8595132e78de64d413c77f464a7f202ddf184fc020391fb05dc2bfabfc523e3c67da067c675ce5c210deb8f7b35a30a2d51e223a059ea12e5a939ecf4eda740baf3a5945a59b36c2d14fa09abed4412309de061552f950d89f63a5727f4977b07b59c85e875e5ef615a92e05b392ebd509b4516fc7e41d1bfc0d06596ea86ad84d50fe8773b31db6c3bf61294a3caa99d538c608a959f1b83968cbd4e7cc1c598e998f985c1ca1c316ec6e5f0587bf13a6c7b229eca7745ef19ab6d2697e9250792d0cf4614a9fa22bea72a63c6e981ef0641506fbc1905c9d5ca23d46e7356ffc3215d618e778d2fc4bbcbe2697247f8672f9b12b196f16c8482d7889517a9c02840ab66ec4c74bb2b273f9fe8151b71b44b249dae9b86cb4141775eacd9e62712478f2158b5285795c40c50726e068fc0725b6beb2387ca5bda06e432649b50e5cd683bc3b6dd6c8a64233122f72a1486537ff28c86e1a59a75d31a69c6d5b92eea76a46db070debd55dcad137870fb1020b44e417972782037a1fe36261b13299495f75f22f268484944aab69e57b45d58f249abd05e83a6e6266f42f3b83e03f3eb8ede158a96462fdd1f8abcc12a19889974286c2df6a379bd52d2c5eafe45aa510bc68937d77b960121f7c71ec0d8f84c2f5777d2fcf98df6cfa81cdb50230219b9df11640977364461b9a75f0e491545e2dedd043f715ce9b9dabc0b2f4b90bc5267c7f50da62efc69deacf609053917343ee1e953b4c404aed20cdc71afebe08fba8d9dd86d1456d011ee5dfe47b6261839b8f7c0ec70e6248dd933ce539e97330eefc56c50c8e14a2a97cd93c553f65e67f9175108391bb19c18d35cf7b3981be617672e21bd02daee5800d7dc99b07fe9bc9e160fe2e1e25f11ef3deca9b4e9762648b89d6edc880d36b48b65934197e1ef525f5b5608c4a04af69709fd8a9a1999757b42f88b81907ed6a5a6551dfdd5a8f5b0b5d1518e43b370df438ac0c80177f760386bbcb10c0720f28d5263cd17efd81a60761f0709a5002cd56c7b7380e812ea8873b813df6ae2f53a0ab451176109b07e6799f67e57907a0933fb8c0bd774b892e3067b34d0e4863eb880e3c18c7a19de194ba9d5a04a6f80ac54dd0e903098b9fece9b7634df9652b6788d8537ef4898d2db247211f71fd5d75cc7a4e3c72b19142318123b278565bb84ea998173544914a8bee4ef9eaa446c606936d454024254d6182d938b20996d64774ca33a4f1b5a5bf7e7eb5824f758d9a7a642916a0d763ac4094f0467eae53144a794b0a2afe76a94f0e955749a5494339665257d3e2eaa</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/blog/lib/hbe.js"></script><link href="/blog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/blog/posts/9a0369ec/</url>
    <content><![CDATA[<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h2><p>布隆过滤器（<code>Bloom Filter</code>），是1970年，由一个叫布隆的小伙子提出的，距今已经五十年了，和老哥一样老。</p>
<p>它实际上是一个很长的二进制向量和一系列随机映射函数，二进制大家应该都清楚，存储的数据不是<code>0</code>就是<code>1</code>，默认是<code>0</code>。</p>
<p>主要用于判断一个元素是否在一个集合中，<code>0</code>代表不存在某个数据，<code>1</code>代表存在某个数据。</p>
<p>懂了吗？作为暖男的老哥在给你们画张图来帮助理解：</p>
<img data-src="/blog/posts/9a0369ec/2022-01-26-22-56-13.png" class="">
<span id="more"></span>

<h2 id="布隆过滤器用途"><a href="#布隆过滤器用途" class="headerlink" title="布隆过滤器用途"></a>布隆过滤器用途</h2><ul>
<li>解决<code>Redis</code>缓存穿透（今天重点讲解）</li>
<li>在爬虫时，对爬虫网址进行过滤，已经存在布隆中的网址，不在爬取。</li>
<li>垃圾邮件过滤，对每一个发送邮件的地址进行判断是否在布隆的黑名单中，如果在就判断为垃圾邮件。</li>
</ul>
<p>以上只是简单的用途举例，大家可以举一反三，灵活运用在工作中。</p>
<h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><blockquote>
<p>存入过程</p>
</blockquote>
<p>布隆过滤器上面说了，就是一个二进制数据的集合。当一个数据加入这个集合时，经历如下洗礼（这里有缺点，下面会讲）：</p>
<p>通过K个哈希函数计算该数据，返回K个计算出的hash值<br>这些K个hash值映射到对应的K个二进制的数组下标<br>将K个下标对应的二进制数据改成1。<br>例如，第一个哈希函数返回x，第二个第三个哈希函数返回y与z，那么： X、Y、Z对应的二进制改成1。</p>
<p>如图所示：</p>
<img data-src="/blog/posts/9a0369ec/2022-01-26-22-56-38.png" class="">
<blockquote>
<p>查询过程<br>布隆过滤器主要作用就是查询一个数据，在不在这个二进制的集合中，查询过程如下：</p>
</blockquote>
<p>通过<code>K</code>个哈希函数计算该数据，对应计算出的<code>K</code>个<code>hash</code>值<br>通过<code>hash</code>值找到对应的二进制的数组下标<br>判断：如果存在一处位置的二进制数据是<code>0</code>，那么该数据不存在。如果都是<code>1</code>，该数据存在集合中。（这里有缺点，下面会讲）</p>
<blockquote>
<p>删除过程<br>一般不能删除布隆过滤器里的数据，这是一个缺点之一，我们下面会分析。</p>
</blockquote>
<h2 id="布隆过滤器的优缺点"><a href="#布隆过滤器的优缺点" class="headerlink" title="布隆过滤器的优缺点"></a>布隆过滤器的优缺点</h2><blockquote>
<p>优点<br>由于存储的是二进制数据，所以占用的空间很小<br>它的插入和查询速度是非常快的，时间复杂度是<code>O（K）</code>，可以联想一下<code>HashMap</code>的过程<br>保密性很好，因为本身不存储任何原始数据，只有二进制数据<br>缺点<br>这就要回到我们上面所说的那些缺点了。</p>
</blockquote>
<p>添加数据是通过计算数据的<code>hash</code>值，那么很有可能存在这种情况：两个不同的数据计算得到相同的<code>hash</code>值。</p>
<img data-src="/blog/posts/9a0369ec/2022-01-26-22-56-49.png" class="">
<p>例如图中的“你好”和“hello”，假如最终算出hash值相同，那么他们会将同一个下标的二进制数据改为1。</p>
<p>这个时候，你就不知道下标为2的二进制，到底是代表“你好”还是“hello”。</p>
<h2 id="由此得出如下缺点："><a href="#由此得出如下缺点：" class="headerlink" title="由此得出如下缺点："></a>由此得出如下缺点：</h2><ol>
<li>存在误判<br>假如上面的图没有存<code>&quot;hello&quot;</code>，只存了”你好”，那么用<code>&quot;hello&quot;</code>来查询的时候，会判断<code>&quot;hello&quot;</code>存在集合中。</li>
</ol>
<p>因为“你好”和<code>“hello”</code>的<code>hash</code>值是相同的，通过相同的<code>hash</code>值，找到的二进制数据也是一样的，都是1。</p>
<ol start="2">
<li>删除困难</li>
</ol>
<p>到这里我不说大家应该也明白为什么吧，作为你们的暖男老哥，还是讲一下吧。</p>
<p>还是用上面的举例，因为“你好”和<code>“hello”</code>的<code>hash</code>值相同，对应的数组下标也是一样的。</p>
<p>这时候老哥想去删除“你好”，将下标为<code>2</code>里的二进制数据，由1改成了<code>0</code>。</p>
<p>那么我们是不是连<code>“hello”</code>都一起删了呀。（<code>0</code>代表有这个数据，<code>1</code>代表没有这个数据）</p>
<h2 id="实现布隆过滤器"><a href="#实现布隆过滤器" class="headerlink" title="实现布隆过滤器"></a>实现布隆过滤器</h2><blockquote>
<p>引入依赖</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>29.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilterCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预计要插入多少数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 期望的误判率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> fpp = <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 布隆过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(),size,fpp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//插入10万条样本数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            bloomFilter.put(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用另外十万条测试数据,测试误判率</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &lt; size + <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bloomFilter.mightContain(i))&#123;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(i+<span class="string">&quot;误判了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;总共误判了:&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/blog/posts/9a0369ec/2022-01-26-22-57-09.png" class="">
<p><code>100</code>万数据里有<code>947</code>个误判，约等于<code>0.01%</code>，也就是我们代码里设置的误判率：<code>fpp = 0.01。</code></p>
<h2 id="深入分析代码"><a href="#深入分析代码" class="headerlink" title="深入分析代码"></a>深入分析代码</h2><p>核心<code>BloomFilter.create</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp, Strategy strategy)</span> </span>&#123;</span><br><span class="line">    。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有四个参数：</p>
<ul>
<li><code>funnel</code>：数据类型(一般是调用<code>Funnels</code>工具类中的)</li>
<li><code>expectedInsertions</code>：期望插入的值的个数</li>
<li><code>fpp</code>：误判率(默认值为<code>0.03</code>)</li>
<li><code>strategy</code>：哈希算法</li>
</ul>
<p>我们重点讲一下<code>fpp</code>参数</p>
<h3 id="情景总结"><a href="#情景总结" class="headerlink" title="情景总结"></a>情景总结</h3><ul>
<li>误判率可以通过<code>fpp</code>参数进行调节</li>
<li><code>fpp</code>越小，需要的内存空间就越大：<code>0.0</code>1需要<code>900</code>多万位数，<code>0.03</code>需要<code>700</code>多万位数。</li>
<li><code>fpp</code>越小，集合添加数据时，就需要更多的<code>hash</code>函数运算更多的<code>hash</code>值，去存储到对应的数组下标里。（忘了去看上面的布隆过滤存入数据的过程）</li>
</ul>
<p>上面的<code>numBits</code>，表示存一百万个<code>int</code>类型数字，需要的位数为<code>7298440</code>，<code>700</code>多万位。理论上存一百万个数，一个<code>int</code>是<code>4</code>字节<code>32</code>位，需要<code>481000000=3200</code>万位。如果使用<code>HashMap</code>去存，按<code>HashMap50%</code>的存储效率，需要<code>6400</code>万位。可以看出<code>BloomFilter</code>的存储空间很小，只有<code>HashMap</code>的<code>1/10</code>左右</p>
<p>上面的<code>numHashFunctions</code>表示需要几个<code>hash</code>函数运算，去映射不同的下标存这些数字是否存在（<code>0 </code>or<code> 1</code>）。</p>
<h2 id="解决Redis缓存雪崩"><a href="#解决Redis缓存雪崩" class="headerlink" title="解决Redis缓存雪崩"></a>解决<code>Redis</code>缓存雪崩</h2><p>上面使用<code>Guava</code>实现的布隆过滤器是把数据放在了本地内存中。分布式的场景中就不合适了，无法共享内存。</p>
<p>我们还可以用<code>Redis</code>来实现布隆过滤器，这里使用<code>Redis</code>封装好的客户端工具<code>Redisson</code>。</p>
<p>其底层是使用数据结构<code>bitMap</code>，大家就把它理解成上面说的二进制结构，由于篇幅原因，<code>bitmap</code>不在这篇文章里讲</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p><code>pom</code>配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Java</code>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonBloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Config config = <span class="keyword">new</span> Config();</span><br><span class="line">    config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line">    config.useSingleServer().setPassword(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">    <span class="comment">//构造Redisson</span></span><br><span class="line">    RedissonClient redisson = Redisson.create(config);</span><br><span class="line"></span><br><span class="line">    RBloomFilter&lt;String&gt; bloomFilter = redisson.getBloomFilter(<span class="string">&quot;phoneList&quot;</span>);</span><br><span class="line">    <span class="comment">//初始化布隆过滤器：预计元素为100000000L,误差率为3%</span></span><br><span class="line">    bloomFilter.tryInit(<span class="number">100000000L</span>,<span class="number">0.03</span>);</span><br><span class="line">    <span class="comment">//将号码10086插入到布隆过滤器中</span></span><br><span class="line">    bloomFilter.add(<span class="string">&quot;10086&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断下面号码是否在布隆过滤器中</span></span><br><span class="line">    <span class="comment">//输出false</span></span><br><span class="line">    System.out.println(bloomFilter.contains(<span class="string">&quot;123456&quot;</span>));</span><br><span class="line">    <span class="comment">//输出true</span></span><br><span class="line">    System.out.println(bloomFilter.contains(<span class="string">&quot;10086&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>Daily</category>
      </categories>
  </entry>
  <entry>
    <title>将Java数据输出为本地txt</title>
    <url>/blog/posts/1c3390ab/</url>
    <content><![CDATA[<p>转载<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdmlja3lsaW5qL3AvMTU0OTAxOTQuaHRtbA==">https://www.cnblogs.com/vickylinj/p/15490194.html</span></p>
<p> 将<code>List</code>写入文件：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeList2File</span><span class="params">(List&lt;Long&gt; lines, String filePath)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历写入</span></span><br><span class="line">    BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> lineL : lines) &#123;</span><br><span class="line">        bw.write(long2DateString(lineL) + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bw.flush();</span><br><span class="line">    bw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将文件读为<code>List</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">readFile2List</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到文件流</span></span><br><span class="line">    File inputFile = <span class="keyword">new</span> File(<span class="string">&quot;D:\\dir\\file.txt&quot;</span>);</span><br><span class="line">    InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(inputFile));</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件读到 List中</span></span><br><span class="line">    String line = <span class="keyword">null</span>;</span><br><span class="line">    ArrayList&lt;String&gt; lines = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        lines.add(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lines;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>流</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/blog/posts/1599bffe/</url>
    <content><![CDATA[<h2 id="归并排序（稳定）"><a href="#归并排序（稳定）" class="headerlink" title="归并排序（稳定）"></a>归并排序（稳定）</h2><p>归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<span id="more"></span>

<img data-src="/blog/posts/1599bffe/2022-03-13-13-44-14.png" class="">

<h3 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h3><p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<h3 id="2、算法描述"><a href="#2、算法描述" class="headerlink" title="2、算法描述"></a>2、算法描述</h3><p>归并排序可通过两种方式实现：</p>
<ul>
<li>自上而下的递归</li>
<li>自下而上的迭代<br>一、递归法（假设序列共有n个元素）：</li>
</ul>
<p>①. 将序列每相邻两个数字进行归并操作，形成 <code>floor(n/2)</code>个序列，排序后每个序列包含两个元素；<br>②. 将上述序列再次归并，形成 <code>floor(n/4)</code>个序列，每个序列包含四个元素；<br>③. 重复步骤②，直到所有元素排序完毕。</p>
<p>二、迭代法</p>
<p>①. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>②. 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>③. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>④. 重复步骤③直到某一指针到达序列尾<br>⑤. 将另一序列剩下的所有元素直接复制到合并序列尾</p>
<h3 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><p>归并排序其实要做两件事：</p>
<ul>
<li>分解：将序列每次折半拆分</li>
<li>合并：将划分后的序列段两两排序合并<br>因此，归并排序实际上就是两个操作，拆分+合并</li>
</ul>
<p>如何合并？</p>
<p><code>L[first…mid]</code>为第一段，<code>L[mid+1…last]</code>为第二段，并且两端已经有序，现在我们要将两端合成达到<code>L[first…last]</code>并且也有序。</p>
<p>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给<code>temp[]</code><br>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给<code>temp[]</code><br>此时将<code>temp[]</code>中的元素复制给<code>L[]</code>，则得到的<code>L[first…last]</code>有序</p>
<p>如何分解？</p>
<p>在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列<br>分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p>
<p>这里我写了递归算法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序（递归）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</span></span><br><span class="line"><span class="comment"> * ②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</span></span><br><span class="line"><span class="comment"> * ③. 重复步骤②，直到所有元素排序完毕。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr	 待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergingSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = arr.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] leftArr = Arrays.copyOfRange(arr, <span class="number">0</span>, num);</span><br><span class="line">    <span class="keyword">int</span>[] rightArr = Arrays.copyOfRange(arr, num, arr.length);</span><br><span class="line">    System.out.println(<span class="string">&quot;split two array: &quot;</span> + Arrays.toString(leftArr) + <span class="string">&quot; And &quot;</span> + Arrays.toString(rightArr));</span><br><span class="line">    <span class="keyword">return</span> mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr));      <span class="comment">//不断拆分为最小单元，再排序合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeTwoArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length + arr2.length];  <span class="comment">//申请额外的空间存储合并之后的数组</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123;      <span class="comment">//选取两个序列中的较小值放入新数组</span></span><br><span class="line">        <span class="keyword">if</span>(arr1[i] &lt;= arr2[j])&#123;</span><br><span class="line">            result[k++] = arr1[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[k++] = arr2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; arr1.length)&#123;     <span class="comment">//序列1中多余的元素移入新数组</span></span><br><span class="line">        result[k++] = arr1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; arr2.length)&#123;     <span class="comment">//序列2中多余的元素移入新数组</span></span><br><span class="line">        result[k++] = arr2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Merging: &quot;</span> + Arrays.toString(result));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上, 长度为<code>n</code>的数组, 最终会调用<code>mergeSort</code>函数<code>2n-1</code>次。通过自上而下的递归实现的归并排序, 将存在堆栈溢出的风险。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAvIyVFNCVCOCU4MyVFMyU4MCU4MSVFNSVCRCU5MiVFNSVCOSVCNiVFNiU4RSU5MiVFNSVCQSU4RiVFRiVCQyU4OE1lcmdpbmctU29ydCVFRiVCQyU4OQ==">链接</span></p>
]]></content>
      <tags>
        <tag>Java面试</tag>
        <tag>算法</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/blog/posts/ff8068c0/</url>
    <content><![CDATA[<h2 id="快排-不稳定"><a href="#快排-不稳定" class="headerlink" title="快排 (不稳定)"></a>快排 (不稳定)</h2><p>快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。</p>
<h3 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h3><span id="more"></span>

<p>排序算法的思想非常简单，在待排序的数列中，我们首先要找一个数字作为基准数（这只是个专用名词）。为了方便，我们一般选择第 <code>1</code> 个数字作为基准数（其实选择第几个并没有关系）。接下来我们需要把这个待排序的数列中小于基准数的元素移动到待排序的数列的左边，把大于基准数的元素移动到待排序的数列的右边。这时，左右两个分区的元素就相对有序了；接着把两个分区的元素分别按照上面两种方法继续对每个分区找出基准数，然后移动，直到各个分区只有一个数时为止。</p>
<p>这是典型的分治思想，即分治法。下面我们对一个实际例子进行算法描述，讲解快速排序的排序步骤。</p>
<p><code>以 47、29、71、99、78、19、24、47</code> 的待排序的数列为例进行排序，为了方便区分两个 <code>47</code>，我们对后面的 <code>47</code> 增加一个下画线，即待排序的数列为 <code>47、29、71、99、78、19、24、47</code>。</p>
<p>首先我们需要在数列中选择一个基准数，我们一般会选择中间的一个数或者头尾的数，这里直接选择第 <code>1</code> 个数 <code>47</code> 作为基准数，接着把比 <code>47</code> 小的数字移动到左边，把比 <code>47</code> 大的数字移动到右边，对于相等的数字不做移动。所以实际上我们需要找到中间的某个位置 <code>k</code>，这样 <code>k</code> 左边的值全部比 <code>k</code> 上的值小，<code>k</code> 右边的值全部比 <code>k</code> 上的值大。</p>
<p>接下来开始移动元素。怎么移动呢？其实冒泡排序也涉及对元素的移动，但是那样移动起来很累，比如把最后一个元素移动到第 <code>1</code> 个，就需要比较 <code>n-1</code> 次，同时交换 <code>n-1</code> 次，效率很低。其实，只需把第 <code>1</code> 个元素和最后一个元素交换就好了，这种思想是不是在排序时可以借鉴呢？之前说快速排序就是对冒泡排序的一个改进，就是这个原因。</p>
<p>快速排序的操作是这样的：首先从数列的右边开始往左边找，我们设这个下标为 <code>i</code>，也就是进行减减操作（<code>i--</code>），找到第 <code>1</code> 个比基准数小的值，让它与基准值交换；接着从左边开始往右边找，设这个下标为 <code>j</code>，然后执行加加操作<code>（j++）</code>，找到第 <code>1</code> 个比基准数大的值，让它与基准值交换；然后继续寻找，直到 <code>i </code>与 <code>j</code> 相遇时结束，最后基准值所在的位置即 <code>k</code> 的位置，也就是说 <code>k</code> 左边的值均比 <code>k</code> 上的值小，而 <code>k</code> 右边的值都比 <code>k </code>上的值大。</p>
<p>所以对于上面的数列 47、29、71、99、78、19、24、 <u>47</u>，进行第 <code>1</code> 趟第 <code>1</code> 个交换的排序情况如下，第 <code>1</code> 次的操作情况如图 1 所示。</p>
<img data-src="/blog/posts/ff8068c0/2022-03-12-16-52-14.png" class="">

<p>交换之后，<code>j</code> 移动到了下标为 <code>6</code> 的位置，对 <code>i</code> 继续扫描，如图 <code>2</code> 所示。</p>
<img data-src="/blog/posts/ff8068c0/2022-03-12-16-55-14.png" class="">

<p>此时交换后的数列变为 24、29、47、99、78、19、71、<u>47</u>。接下来我们继续对 i、j 进行操作，如图 3 所示，继续进行 i– 及 j++ 的比较操作。</p>
<img data-src="/blog/posts/ff8068c0/2022-03-12-16-58-42.png" class="">

<p>进行了这两次 i、j 的移动、比较、交换之后，我们最终得到的数列是 24、29、19、47、78、99、71、<u>47</u>。接下来我们继续进行 i– 的操作，发现在 i 为 4 时比 47 大不用交换，在 i 为 3 时与 j 相遇，这时就不需要继续移动、比较了，已经找到 k 了，并且 k 的值为 3。我们可以确认一下当前的数列是不是 k 左边的值都比 47 小，而 k 右边的值都比 47 大（由于要保持相对位置不变，所以 47 同样在基准值 47 的右边）。</p>
<p>47 这个值已经落到了它该在的位置，第 1 趟排序完成了。接下来就是以 k 为基准，分为两部分，然后在左右两部分分别执行上述排序操作，最后数据会分为 4 部分；接着对每部分进行操作，直到每部分都只有一个值为止。</p>
<p>接下来进行第 2 趟排序，现在左边部分为 24、29、19，我们选择第 1 个数 24 作为基准数，接着进行 i–、j++ 的操作，我们发现 i 最初的值为 19，比 24 这个基准值小，所以与基准值进行交换，得到的数列为 19、29、24；当 j 为 1 时，我们发现 29 比 24 大，所以与基准值进行交换，得到的数列 19、24、29，此时 i 为 2，j 为 1；继续 i– 时发现 i 为 1，与 j 相遇，左边部分的数列的 k 为 1，并且左右两部分分别只有一个元素，此时第 2 轮排序的左边部分的排序结束，同时左边部分的所有数据都排序完成。</p>
<p>我们接着看右边部分的排序，待排序的数列为 78、99、71、<u>47</u>，我们同样选择第 1 个值 78 为基准值，接下来进行 i 与 j 的移动与比较，发现 47 比 78 小，进行交换，得到的数列 47、99、71、78；从左往右发现 99 比基准值 78 大，进行交换，得到的数列为 47、78、71、99；继续从右向左看，发现 71 比基准值 78 小，进行交换，得到的数列为 <u>47</u>、71、78、99。此时 i 在整体数组中的下标为 6，j 为 5，若继续 j++ 则与 i 相遇，所以完成此轮排序。</p>
<p>此时右边数列的 k 为 6，一般会是相遇的位置，也就是基准值所在的位置，这时数列又被分为两部分，左边是 47、71，右边是 99，需要继续对左边部分的数据进行排序，虽然只有两个数据，但我们还是继续按照快速排序的思想操作一下，选择 <u>47</u> 作为基准数，将i进行从右向左的移动、比较，发现 i 与 j 相等时没有产生移动，完成第 2 轮排序。</p>
<p>至此，所有排序都已经完成，最终数列的结果是 19、24、29、47、47、71、78、99，怎么样，快速排序是不是非常简单地完成了所有的排序呢？虽然本次快速排序没有改变相同值的元素的顺序，但是由于快速排序需要对数列中的元素来回移动，有时还是会改变相对顺序的（比如 47 在第 1 轮的移动过程中就被移动到 47 的右边了），所以快速排序并不是一个稳定的算法。</p>
<h2 id="快速排序的实现"><a href="#快速排序的实现" class="headerlink" title="快速排序的实现"></a>快速排序的实现</h2><p>通过以上的学习，你是否可以自己写出快速排序的实现代码呢？在接着学习之前，最好自己能对代码的实现进行一些思考，然后和下面的内容进行比对，看看自己有哪些疏忽之处。</p>
<p>其实快速排序有一个比较简单的思想，就是递归。对于每一趟排序都是一样的思想，只不过需要进行排序的数组的范围越来越小了，使用递归实现这种排序最适合不过了。</p>
<h3 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = src[begin];</span><br><span class="line">            <span class="keyword">int</span> i = begin;</span><br><span class="line">            <span class="keyword">int</span> j = end;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; src[j] &gt; key) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    src[i] = src[j];</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; src[i] &lt; key) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    src[j] = src[i];</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            src[i] = key;</span><br><span class="line">            quickSort(src, begin, i - <span class="number">1</span>);</span><br><span class="line">            quickSort(src, i + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> left = low;</span><br><span class="line">    <span class="keyword">int</span> right = high;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = arr[left];   <span class="comment">//挖坑1：保存基准的值</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= temp)&#123;  <span class="comment">//坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= temp)&#123;   <span class="comment">//坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = temp;   <span class="comment">//基准值填补到坑3中，准备分治递归快排</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Sorting: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    quickSort(arr, low, left-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, left+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序的特点及性能"><a href="#快速排序的特点及性能" class="headerlink" title="快速排序的特点及性能"></a>快速排序的特点及性能</h2><p>快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。</p>
<p>但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 <code>O(n2)</code>，实际上每次比较都需要交换，但是这种情况并不常见。我们可以思考一下如果每次比较都需要交换，那么数列的平均时间复杂度是 <code>O(nlogn)</code>，事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。</p>
<p>快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的空间复杂度为 <code>O(logn)</code>，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为<code> O(n)</code>。所以我们一般认为快速排序的空间复杂度为 <code>O(logn)</code>。</p>
<p>快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。</p>
<p>快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。</p>
<p><span class="exturl" data-url="aHR0cDovL2RhdGEuYmlhbmNoZW5nLm5ldC92aWV3LzExNy5odG1s">本文链接</span></p>
]]></content>
      <categories>
        <category>Java面试</category>
        <category>快速排序</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>算法</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>最近前端整理</title>
    <url>/blog/posts/752b1c2a/</url>
    <content><![CDATA[<h2 id="css怎样排除第一个元素给其他元素设置样式"><a href="#css怎样排除第一个元素给其他元素设置样式" class="headerlink" title="css怎样排除第一个元素给其他元素设置样式"></a><code>css</code>怎样排除第一个元素给其他元素设置样式</h2><p>在<code>css</code>中可以利用<code>“:first-child”</code>选择器和<code>“:not”</code>选择器来设置除了第一个元素其他元素的样式。</p>
<p><code>:first-child</code> 选择器用于选取属于其父元素的首个子元素的指定选择器。</p>
<p><code>:not(selector)</code> 选择器匹配非指定元素/选择器的每个元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.select_btn</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:first</span>-child) &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">90px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vue-script结构"><a href="#vue-script结构" class="headerlink" title="vue script结构"></a><code>vue script</code>结构</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Home&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 组件的方法</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// watch擅长处理的场景：一个数据影响多个数据</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// computed擅长处理的场景：一个数据受多个数据影响</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">beforeCreate</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">beforeMount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在挂载开始之前被调用：相关的 render 函数首次被调用。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mounted</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 编译好的HTML挂载到页面完成后执行的事件钩子</span></span><br><span class="line">    <span class="comment">// el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</span></span><br><span class="line">    <span class="comment">// 此钩子函数中一般会做一些ajax请求获取数据进行数据初始化</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Home done&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">beforeUpdate</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">updated</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</span></span><br><span class="line">    <span class="comment">// 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</span></span><br><span class="line">    <span class="comment">// 该钩子在服务器端渲染期间不被调用。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">beforeDestroy</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 实例销毁之前调用。在这一步，实例仍然完全可用。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">destroyed</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="vue监听数据变化-watch"><a href="#vue监听数据变化-watch" class="headerlink" title="vue监听数据变化 watch"></a><code>vue</code>监听数据变化 <code>watch</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;app&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">inputValue</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="attr">passedInputValue</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">inputValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 当inputValue数据发生变化以后，延迟三秒赋值给passedInputValue</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.passedInputValue = <span class="built_in">this</span>.inputValue;</span><br><span class="line">            &#125;, <span class="number">3000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>获取变化之前的值:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">    <span class="function"><span class="title">inputValue</span>(<span class="params">value,oldValue</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个参数为新值，第二个参数为旧值，不能调换顺序</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`新值：<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`旧值：<span class="subst">$&#123;oldValue&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Vue中显示与隐藏"><a href="#Vue中显示与隐藏" class="headerlink" title="Vue中显示与隐藏"></a><code>Vue</code>中显示与隐藏</h2><p><code>v-show</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel_all&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;select_app_show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="v-for使用"><a href="#v-for使用" class="headerlink" title="v-for使用"></a><code>v-for</code>使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a v-<span class="keyword">for</span>=<span class="string">&quot;(item,index) in items&quot;</span> v-on:click=<span class="string">&quot;onclick(index)&quot;</span> href=<span class="string">&quot;javascript:void(0)&quot;</span>&gt;&#123;&#123; index &#125;&#125;&#123;&#123; item.text &#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>扫尾</title>
    <url>/blog/posts/307637a3/</url>
    <content><![CDATA[<p><a href="https://www.zhihu.com/question/36738189/answer/1779425046"><code>LeetCode</code>刷题顺序</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/91525839"><code>DDD</code></a></p>
]]></content>
  </entry>
  <entry>
    <title>文件上传前端小结</title>
    <url>/blog/posts/7733848a/</url>
    <content><![CDATA[<h2 id="页面a标签-点击不跳转"><a href="#页面a标签-点击不跳转" class="headerlink" title="页面a标签 点击不跳转"></a>页面<code>a</code>标签 点击不跳转</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">href=&quot;javascript:viod(0)&quot;</span><br><span class="line"></span><br><span class="line">href=&quot;javascript:;&quot;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>English self_introduction</title>
    <url>/blog/posts/4187faeb/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="126a7936d8c9ad8cf593b9c06eca5fb13e9672d859d14f5c2c0a469abbd9e40c">10d79030e8222445804370796b90fca17946b910b924ddb960429c24562a8e923a4262af1068379632b7ce250c07bccd74db8798c3400e289f4d80863cf41166725342f6d06d83134cd2b7c0cbf00063bf225d1b8a8f421de01dde658c0af77bc6a606dccc0e9cbf9a3fca426e9b86ea8f9fbc824e7aa8729256ae7ece888214c7f7d801ebd9c390438b4a5d05bc6ff891410f8adcc349e1e74d80764098c74e01cf67cf17c1fd04e786e599deec45c851707986e582163f54cb39c459921580e93fdffdc07b7bc03d37beba01f40bdeeff85b2f070c77b6a80a026f9a988450c8531dc3727a770f502eda7d5064e0a9fad35a301da3c453a8ec787ca225230770ec1cc8b11c533aebbd93014c318fd6b5ab303b7184197a031804fdfe093dd20de89597efdfb6bc1dc7e65177cbf8d2c28ac5f3b4938568e08fdd3198873343612793c07e57b57ac60d9e10d76bf58b202615f55a36b0f11c1f00f73d35c7cc83b1c3c36e668a2413eea319f9325bba3c7112cabd745ddcf5cda554ccc3ce41928b9d7b4a3d981697a7b987e093db9c64ac0109b333c3c23f5c3ddc02e8a71291347568a86e00c38869458b6d3513b342ec22187aa76771c6327d0ebcfbd3e325c334f82c69ff865e97ee50e243ba8ec92b46b38eafcd3f0f68067dda7b5a6612c57691af7ea36ee0b03b44ac0ee373c78f8eb7a98461d9148288c3587a924663e72659324588438141cfe2d9106cba4600a0a5934aec8512d7eee803e108338cd5992830caba2b68ce1606f6f8e7e3fb5f791bba8e18ad7f81c1dd707793d4b3b917ee166902b4b82c5cebd6ff2c6bf1f739231a4727f302bf679e361470e8b7e17a494f558bccbbc9db1a277da92b5c6ea9603aa4c1737be287afcfe5a1780dbe1533733401fbf21de6c9cca321f724c0f3f06a1ceaa43a85be8a17a79665ac8bdcee56da850eb60667d9fcab09b450d311a015b070503df8a41b27f4bd70d70d0e0790d83247022209d0e5f76016cc36ade383a7b086ed086f77552911762db3791bf90d880d29405a7ae0c42d83841c2259050bf72faa6fc601b9501d2f9f36f161b0a01358622e85191ffbe7b9731813aed46a5a24043488bc5bda5855f2019e7797cd99ae67d6a120a4f718f27e17b466d5386f8e0c7ba84aefcb3784b7dc892eae6e14f54277bea466edfbab0bd46a44716230b072ae9aedd4d902b955760995b748a78e8b02795bdb742f58ac74ee0dc627bb96688fc4e98697fbe002e8e6d67756ef5a988060e4365ea5849edc0b2b9f3107a5335a044c1b4eed33d59e9bbc902fac9b059fc4c343100a3366ff4fbbd4107eb5aebf63d0a9612054486631b446e87cab74189374f4833013ea592274e30949de33d65c5b479eb111a229cdbc1b51bad5ecf92aba221db55729b7049d642b772fe577fe9022f767c6c301f733da66cb6552d61ab15f35d8eaa520eb9cba97da80e6148af91ccbd3de6e021a57b061cb608b18b6085d924f4488be6aa452748d638068fa0e58d73cb9487d8f92e73aabfdf6c63e3c0c43127cc0423d91f55f1e726af872cf706ebc80e5a54c9440e8a279f4abe652e0b6961d8a68f663da5d40fc91de3c476632ff8f422bef60a82bdd09b0c6d725b5fd70a6b01f7bc445b8f6c847eb5e9d41b0b2575ad796aa0ec078841788c0c4d31e94c7b0fb833dde7a108fca217012bd5e1aa72192cfc20444d5fa49bd5311afbd3683cbf52b34f864533100ec8fabba17cf748a3c2173abb0258724982f775682f0c81e22cbd7e5c5553932090e834189b58a89167d1118c184447ee86fecd7381d3770dac86c6f7cf2ae149aa1c6ef9a08efab9fe6450495bf6eea1262915ca228a7a7853cac2ce509e48b87e292011cac1a231d9af34fb645744626f7be4bcb7d4465d6eb90b2ffba3736a07f29ef9b0feca328b952a59260a0dab81f388016c63db517c706f0fabff6604def5b37b70e790658a466fa8cb43922c13419cd125070bfaedb9f1e0735ed5f87f98b4feaa6bf792018512875ae941110c5a796b403912ceae663ee73b8734f512efdb8d12bc360a3df76334106569c4144f13090a92e71d4b1bd980e7a16ff65452260323367225f9a744778d4756b433aaffdd3784ca7c8a594f8cf0f9b1bc2189c24d2a1727d5ac575a6031184982e2642d6a9046056a4d0e5ac2aa8eb51249b30aff4954031e56a518e0ce26ae087bc3e61c81326c4e8924e9a0947b0f5307fb810213820794452649b58f982026be16669608a56a8cc501bc40ee7eaa3b93778b8aac7b6ca708b1957058426e2f95e66b653fa7ee14e8c98eafc9350b80d12f9776b4730db19e337a04346311481b189f100544b3c3bee8ab9c4f4e825a15ae84e1d20fe2e1a31563ff858b88c6c23ac69af6c0b98537df38bc1be0d33e0bd9029ef46a95888ab8baaca97b0433ba80162a5393be886a6fdbf66f62035e7b7c45f1bc8570a8eefc1044c9427fdddecc2a847c79337e1b405da7338ff4ad2dc59d6c4e052c0e66dcd063de0418b2d8865c6bd2c4d217f521b33efab873f91fcceb17fda6f2008181723320f6ebbebcd5533986053ce95bda1080d0132ac78e85f74675889a0787a598d8301413aa80dc87a1875e51d8d871a95cc07f3d5b61950c6ef3cca9eba6a91b97a0a5f6ccbc323eb0e80516ceaf1f867cda23d78e43368d5816329bb7a1b8ad6cf6a05fbdcb2791608210e0fe439b32c489bbbec852e534feff47a36f92899f8fbf1367b1a1e0175f24e77fa3a433f7150ecc40e2d750bf3d5fdfade9fd100f6b0b0aa1c6fc662bd01fcdb802fadf95121ea16d25349d9f05167c40af710e0d01034f2c060e4e81c93186ae2ff044b994352e7633f84e2f385a52c168e314b69ed634bce3d989a4a2b0aca268f0df40a0769bc678b460989a308ce76c5353af83dce8041ef7dc2c2f69640d0ca75fc494bd1c58386c709c7485ffe762e7f7d410d5aa1f27a3c12084af4a7d3976a15af7e63a752d4c9b9987796b1bce6174691b4d28419e1951c845068142a07b9fb80a3e173187387089c258f6c2ef134beae07ecb85538f85c29adbd9206575485a7562e056a0a15b4b61c1623a9a5131d17d301cd659ce3a7bdde1d22f9f1edc0ecee662e5b616fe6b31ce42bcc67a3079a7a3cdd285155cd02d0cc6e8c68bb076d6c96efef9d4b06b970067147afdae84c3948bbefeb33fcf27093555deb90472b842c841ebf03ce9c2655af945cffd30ed26e8b91c1bf9fce83957f6778360a5aee311dcb8343faa469dcdebc8c217add5865d0932203ef26d905989a6d2b08fdadf6e7c2e37bc696d6e19673bf82392f3b7ba6b10d0411af64e12081fa52983f3411826fe7468b07167d127e98a7fb8755d6e7d5a08e8342f9010c4a0ab8ed80439aec0a66162b9e8e38fac297206bb5099d2885e53a5e33987f631773d1986bacd7000a3a39f28a295b4c6076b9d73136a4166e15f080b7b8daa9a454d366893e7b3e264d00936f38dd3109129560ec8425c7030706797ef58b73fe8da446e331f5aa341de222d949942ced3c768ec0207e41777bbc8f386028be8e81f33caf3d1822c1f8b13cdbc5ddc1a268d2896a05ef18d53e4cc4adca72567b5d29948880f504828d7cd0f7a12e62385ea9fee8064dde1e5a5e10dcdb491ad6e40390acac28015b3ff2361c15d8733ae11f7acba4ca3515446138f47c5428335d30e5cea0baca6440755bf2e30f4d1f46f329aa36bf218379344f7a580172fe4a5cb1f81a3dd1301c11972455c06b05622c719e2e8ba7f0ae3fc7d256cde404f94f7259855fcd7ed2e24efd8b051bd4194d5b1086ad59a320edf954e8e18886baf1adbeed1f74f343668ee399ee989892e633f336e15f80730cdb002b50f601b9fabe9cf9f4afa29bc48a8daac559b3def66d7cb316565a7909b31bf1b8186bbc1aa76aebb7ffa23dbd852c4acd6819ebc06f2f1857e8c7906826d62b61594fc174f791682ae967febe47d14d784d33bc8041ac25c68029c8a73677da39190fbe37cad01c75723f5c0c4b69fd3f73d612ebcf95ae52a3a5ad4f370ef53e94de88ea3c674ee4cf4652e5906e77fdd34d3845454187b2c0ffe90a60fdd21dad7bba7e60b43c2ecc6f0cdc23b4e6acde79bfe9ab834cefe4b8d4a2333986b6118756698d75ad4982a5b5b14215d3648dcdda7cd340a91dea7caeaab2fc645fee7368d09fbfd57d8057091349b0638eacb411b8a5911e30ede9284398bc73617d19b83e00d81246713959ee1e2b1324721e4094d82f2d6b21f8346668e728d46fb42fd21521d73a275ab368a5dd7a1b608da0045cf8694eb732097855ebe0b1c64ae268d3626b5d031dda45d0832ebfed19e2646ed4b01a3c360c38aed9fb4d5c3e5b5fa2774b9d56e4e7e3f36315cd1d7c8479644615a542c0a38983321c870f7f366e06f712b889f8af92600fd18f00e0cc590eb4dc6e4ba84d74add11d22766b1f4ba33807c8e97c8249da2e817afc7e580f7a01eecad132beb3715b48670f7f0cf5741bf13cd25b25cd6d3c0454c02279decf0fc521986955f4f91cd17e4c0aab027f7b9992152025fb4be9b6566f26804479d7ad91f277ad8d873809cc2d0be8e971a0b8de45bedd38dd79d60da361d199e4533043062c29a61d393a001938aa4e05c9aaae708a3e84c19583cab2c4eb5cc453f22fe49797df0c17e9c271e44846acdfc8d7598b7021fcda6e169d2c95931d17bd16adeff4cab706d579bc9f2c96b0d03978213d2fda8ae6462c9f9b365bb983004408c76638a628eac62b398e93b09872e280934983e3e12a1be1d5df0ab807afb9abc657f13e923f30c368162161feefc5bf24c33613b324623b053ce09ec56c8809871733b64c2fe437a9689011936dd69e2d370b364c6ae73262d33c9361e26e4bb57e67e49ee28cef2649b294372042a612b33cf457f21cfac91465c6ff5b3c7c798509b8537692b4a788642ab7df641f5a79fa2ba3cd25cb6225a10ee10c8ef4e19582c81bec38fc55036ae68d98ffc9d9d2f480646c2f121a4de0d4da4bab52b333cb9222508e83a08101a8ae25f1c9e46d857c4ff3f7bef5a3d37ddfe81f39e8cd958aacbf58fd73a69f0d97184be0b142a3618a6e0dd3528d8e8aae71d461343a1b4b0129d3f4568404d73e63c9260f469bf16d3959e7899011e3d0f889f4090adacecc66558b8d8eddb4c3a80776ab823c8c98b73b4097f131c16a8bbf7602fb7ae936f34f8b866f5175671fd3035bca408bee0d351266aa9e7df999f7473625e35a590d3c08805fed829afbf8fdd3f1b49d69eab7bbb985d0af1e6e31145080500db126c1071985ac10f22e4e3a483606473ced3830e75e51641de9576f0a200fee25831f0ca9c4dbc5ff2c82004903b1cafdf3778ab4dfff48b10b536c668f73391ce44040406447f6c138bf08653cc6817263799673bbf8d864a80e4f4bc72c26bd953da863abff134c7466158bfcfe69529167727c1208475ee97d1f09258448e4a083ac7b7327bc052f018f05d3282e067dc8ded16175b8e4e6ae52664e31d19179ff14e0323dcd734ca885899f3e8dadb6ee3a8fcd606afb77185fca08e42bd4c39c5a606631c6eaab8084ea1524f9da2364341cc1bd34c8518b74154407fef2e6b82360bf6057e0e7d797787e9bbb65b0a234b1a1cb4c0a43b180c8de795f2348969c1939995e78483b7a10e64e29d04abcfe77bacd613278b67ab0d018e4abd882d9fe235d5cae85678b2aec11ae17bbff25f0edde87b3557c2d8b8349c2bd32d2c8be5f146f2c6153537891cabbc49d2789de439ab88ab9b99e6f8b0afd145a4ef81ed070a7c55bdfa4baac456eadb02e291fb3eeaa9d234a4ccffa0968cc4c452730b6922ac7031565628ba01de510ac2c96b1422aab65aa2131595526212510bcf2e892c99dbc0eddb57300ed47fc9d5a2f370539872ffd760cac493b9e25f5fa121d70720358f63e870c6b352b86cb36eed7ea67a06d408cd2ee89a2567f9e92a49305e29e810cbb2550a3b9e2339f45a785efbf890eed477aa79b260be95d9896ecf0821faa502f6b8838e1137516cc16034fa6de4c5edab354f90f7ccca6619a2012e453ae1776caf474d373527768871cc669fdb57353e5ca17b3a4bdb879c6bde18922c22e19c80413c2807edc121e62cce90283ba034d98bd1f595ca7da9f90725ce30cfc9aed6155e2964511202b6d9592c24ca4b674e2846abc2eda4b925101f5872b84223e05729849fa6e70aab51762ed513a716244c1f674957e426216123b1080657712b95b6567442dc37530cf19d5c9a18d7ccaef45fa261019b7cec658c8c923943557e3cb45e7546704a3f920eb18f4c5cb9a743df08176fbb5d946784e17322397e43a1231d3905c25082e5bb0402c0e9471642884239dae4d6c0d8e011e6b7e00c9ef3c5f160587766ff4bae71f6e0ffb6069e2dbcd09f3af5fd958e4abd9c7493fa71b0339bc7e19728f65518eda15c9b0f2260a4dee6ea498f775c215dac8dad7da0a0070369d82021dc46ce2007bdafa075533189be269c4c766d382f359361f4508a8c5995f7ab79544f64fb44eb3f40850e5be0577ff734e3845c86b9072dd3726c347362c0a2c473dc9b9537ca70777700f8ace9554bb0f3fb82fc4272d16d755b53c66684318792fcd1bba14a02657dee187c26490425ae055ad3b69a6cb5787aa5383027a557da2d37ef0e8abf49f1fe5fb05b8c10b77b2704ac845ab8e8796af29257e4d60643f728355091db7eebc0b294f80fcb65fc3efc1d7428349beebd55e9354744f867a1859c2de9b8f79e4e04bd983b43a37c20b77ade11f79c9238ff4961bd8738bcdac589cde89afdc03a291e2aaa1f7890b794ce79909d5a19bb770219d431af3ce68019181d8f5f8456567a5882671e1ff2d5814db2d1fe51a74afae139ffe8d6e10024d5d4b2a0ec711a9147f6e5ac49e942882e477f1baf9aae89a3cdc3e662e9a06b81f0d99357557ec1ce2e9cb580ccb832c38ef98981b025c18ba011b5929680ba5de04325b15fd21cb815dfa7ee0f711c51343a2a7589fcd1ab1c212c56e2663072c9359da421d6dbdbc82e5ad405fb96484a04e5da871299b0fca96072c90b7f9296f65e61fa71b5c90a1af485b8c90e963678cf17d8abd119682dd29d1ee35fc7ecd44f9e5b2470c22e65fc9fc04eceb00782bbb367fa1bcc86943a027278071006b4679e68ba1824243ea498080b403707cdd85e7e3c3fd6d17303471ece6af7c5fb2a97af4afb65b82cc9e05faf726ad38b53999f3386405ce6d8a2bb051b49ba2899bca3e346d9da70d73f1f4fffd2866e35edb27b5f5353f23fecfdcd09f5fa12ef8f9867969ee8b5315d968b921059fb4c664528423d151b47ab000783249e7ca1575fe2ff4ffb9d546b1d8e53ed1f594a70721acbaf01456634c105ea47ac5d7db1746a4bd7e9267d15f1824b4a77a0f712723f8dc3d2e986191ef2555e44d3f70f70fc1dd60973f10e30ea2faba32d5f4208d6149194a670d14b55527995647b951d114f8ae7d8e2f5bd38075dc76e2b48c483917c88d97c3c282eaaa609691cc49730f34628b18a8c517cde574b879066a30e761e3107e039dda144823488a717fcdd3004e7a68a00cd1639fe74eeb743e8f01b72cf237bff9780706c86d21d4d432ee821e748a9e3ded4fe625b8c0a09a2d8fbd36b8c6ece756b7cf41bc1cc4a67c566e07d1f76ce05477598d93bde02e2ce06012e6676aabe20735e7c5ef09003f575cb48a8807c7232bebb80d62c796480376c922f3d2838867b74e6a5672451c11b68f85df76925689ddfe91fe40b2dffb6aebed01ffbbdab0167942af2ad231613a672bed3ee4a254e02be8063f21f74e7e1e2aca3ca152caf4460b658be4cc689df0b74da9fdd4627c8714b30052c5350e5c9c6818e821db0901bb23010cd3205c07e90c275b1fdf73f85c1ea8d0d638535e8c26ae6198733cf27629729fbce17e2b82bb0ab5d0858440479f11db7111e9f3d542361ac321c1688e38d87e2f2237b7f80835fd19a1c878ec8de22225fd1424ef3ed6836a846320a5668860100a7846fe71ae1849bb13a93b28ecd5aa5042e00ca455ecf9ee4fae05147a35f1417da87753dd5d22c4b1ee47f50406f4efc12cec66a789b2862b3e76020c467837d3fc58de9f48a09be3ab493949cbc7366bd587e35a0e89e9fbfcb498fdc74a76e7bf9a68135a5f84f2631ec037505de6c8c391ec3ff1c87b075d9639419283c2c633b7481d0e63a4e12ef152535dc8b5174dc8a56c26a1d453f5d4043bac56a7c263d7b3933358d21aaecb4422eed0ff9b1fa7ac6022ef15dd3228881c14f1ec02a4445d970ee445a9c83f4a7b06e7d9e49cd0dc1032ffc14c7d5d38c312407e53c9f36f898269624415d777d79fde460d6be9ad1d311a68ec8ce76a428e57361b301f32c338b676903b03ed7a03d2ba9ce667632c78c7f8e04f347baa83758ac4a41de155d6fa31ddf5f56db5d4becb5ef9d91f57ca37ea00624e665201ff42397848f4082286eea2e73a53821ff68dd96c27e712e74ca55abf4b065e817120c0bfe30f324b3ca1e1631116e0b0a95679ae9944b3150b55f9d268b0ebb453cd330e7562cd21a101ae046481561d3673b71e40fdfe42283a0b35690bfe216e71e6266832d709b60eaf60b44c5f68db7a63da0832eb65ccad8ff038cd190a7627e0b6a2428276ed8f315d293bc86a0831a544f03940d17f332744c743b2f8d277bf69ecff998050765268c04d13fc683f455bbc16977670a2c4e6b48400a657b133c25588e7e1aa0055f3aeee79eeb703a359d83d9e7cc53fc91aec60086505b47661363bc1a3249aec68cac4332252af87c8a66f2393f316e80081de0728ca01fd4b0aee1f3266e6fecf65df7b27a4ea03500064d3a4ccd7fe288ef7ef0f111fbe1170510bed692e3f214234566aa2108eadd03d5391bcbdbe9654a90da9a45e5c8d4417dd8a0da33689fe7e44f9edb0490f5568583de463e07043008cf47d313674600c8f1dc7e504e5d8dbec90424dc61231a452e6a22b3b8a778590a792097d7eb3bcbf9e1e624a82eba97c29185d429e89067065801edbd62d367f66ed6208b6fa317b35ab693acb3d7947965dc15fd212e60e264d70e5ff946db2bf60855350f0be0eae4ace6e75c7d3809ea0164009c5b092c8669a9953126253c2b3666bf615c1b111e70a229d5291625fc0c0334783a272adc3a6673337ff7686a8ac55333facca612070aa2d467d550933bbc9dc2711c99d14bce787f44f9f9d1d9da59c58a62cc8e52aa37cc6055f8ccdf6d4ec0eac0ffd4eddc11091863d6a6f076faf94e920e9798a875284b2e3516d7bd28a34701a3a18028103bd8018630adf92050002b5573b4a8fac786fbb24cdc57cf78b6432bcf5824b777aeb036854c534ef3de6523288de3addb9a67458026adba6cffb01f13dbd4dd61bb3f8fc7b93e6b4f34d620f59f2883751f68f2adfa0bdec83a22cad04e7fe7a5fa01c9ee646fa98942ced0faa8eedfd41dadbff2f5c09df5cc94dda60162c227e574667c05e9487d5167652d78bcd1a8f12a66f4ac6ad97347300bbe60353e4f0e114a1ad5c2b25e0d2afcce564de80c476622e8811f1143db72522b65da51994326733d5272f4dc793ceebb78300cdf72de187d46e79f8eec752cae04050843d2719243333d27a8b8c5cc2a9b926c718a455c141951d0f16a6e1e678e9b51ad235cf811f4cdbf6f4b0a1272df1501b34b4c5a8b951cc823550839fb28e1a8ef8bbd654cfe49e9108b2cb3dd6446e293bb2695d9024d4f586465d2b09ebf5a7e6a79929a7c4af94b0a6acf5e45651697cdaf3489aea9773c0fe22aa27095f05a45232597bdd255842f0a631256498d4927a9a73cb8a666814c78ae3770790cfa3df2786de5794375b4ad43e23bc46b17a854378349ebb661f95e0db0acb870a4cff0d1c6c881ca1f958728838fff4f3cfbc71a45d4f3ec102bce62d994833dbb977dfebe1d71914512e892c4463f18b011e34e00c17cafb141afc1a69fd5e65472c76dea64796243b9332ec3ca2888fb93dd37aa5de067cade8a08559433672429164218e035d54344846c53afb2e4b11b2847b7cee3f7874a1530ad820131501ad242b75190c9b412cbc0eff016f050ed82b1eb663485a4cca335cc28c72bb07968fe9b3635979d9eb2d5cc40786a9b65b993165bc8cf0ee23c652343570e5d94f0aee81af8b82e61f7a05550580be30a124be1bd4ef45d5b160837f0cda1efa522e815b3d81622721af0190e503350d1461731afa3d47797b33a7fd051d40d5b7c99fea326f6db645d110495fe48c3d1feee57100a3c5de5622ca544591e70f477d1a9da36a9ccbdf236fb7aef2db61403463fd84f462c0b5aaa1443899dc3d8fcb86350fa80fcad65dcd83dd7693ced05b825531049459c674b51e6e357a6ec73d06e1e4f14074104aa9d8558ac7a2abc51756e67647896e7ecdf1124459985090bbd89dfb2bc547f27f45c83cda724c054ea51338d70b7864610263e08c70b16ebc2b804c37c1f9a2e4cddf061c411f53dc0f926fb4f5b765b1bcbe0ecca3430a07c9ccd450a691753bfcd9e23eb50ba2be661f89eb1d22761e5c946dd9278068c437d6cb4573065f3b782173074bd78affaacfbc10fec7b99649adab67baff01588ae3ad5b6daa313b00f20b201b07e58544ebc84eea6e176dedbdc3f60f770daea748dc0f3b00db3b389366fd21fdab9c53ac719abded54b595d1ae3d549394b10e60ff91640c11a89fe66b1406bed2eed1ad027a6f2ebc0bcee8bd9080444507804aad15cb42864c184c4c45a6179923ef34c2ee5a546775e113e8ee71bba47c649c606eb624e5670b545fe149f5408b4c2895d2658d19761635d6a7ab5c57512db12ee341a293b922230b5dd117fa1d07fbe0c9f25d9496e2f1bb480e0d0292abf51486fcbc679b43425babb61a75f59b2e90243fe07efbca611df7629023872de0c294acf5ce5e7e865c937701717b1cf2e6d17d12cb9d6c41e031c394040aea985bd40071ba190b015cce8e71c4fb0526cf73a3436b8e71259145aff096878725fe6d1cbd041d3a70ae001c051adc9007c20fc3492240c5a791b26c3b3f71fbd67c8e3de24e4b55066fd120e73203ad372fed5ad025dc69a88fa579c0e67eecfc47595aa949654b8c6e941e8aee2a52ff6f3c3a3dffa079108c13228cc8e2b963fb904f123cdaa7203b22841fd3be546a232c58993a7b419b7c02f5d6b23bf632184a37f90085a230048231ee9e64ad1a345a4d0603bf97754ac279dfd9e52ded9daed69a4c55f8f39eaed93fa8c9fe472cff5d630394600cc592e253274aceb69196161ae0cb8a927c8b9d8f9eb8771191c6554935f0e15c6476022c2c09a5717df9e6a879e1d8fe444ab2724364440853207f180979efb0411657fc76c132d17e203c4c60de1917e13a53131343445f6d8db017aaed72d6dc52429552177b53716c47792530707f3d97fa528d42043e0858b9f7e0c1f813c78a6f22c562810ffae64f50165d2a32a0b8a68f8e9016f2202c7509db241b0599a2d5157750763dae75846741a923249d28b5f092de5270b7c1ccb8f4a13b5c69ec1901002641bd6df2771ed23a645425701fd43236b9c1742070b11c5887339f9072258f9f7efe290ec7fceb5ef887bcceb30bd24e9efa9c583d371afc87f6ecbc9ae9519e1701ec68712182fafebdbdf6a9307384dd2a2845e7bbf87a2989e40b0272b1e9b3059a6ce41b3d06083229918718a1081c0d5071da1c8a9bde7a9675adf6964b985b701d06e070117ca6c3643c7f34c3a169beddf55c9e9e4e6fb99724e81e0dccf22ff74800609bff8d7b516b32d0926326f785b6338eae004b29c4776f6aca4ea0af02975ec43558b2959d88c16ed4d80751d847640a8f578a2496e61db9d0d7ef4e8a54a0cb0351b4fe545f1ce5f400e51d5fa73108a22a693929fddda34a7cfe7432c58917972e11f33de67c9a9725f40dde535edc725acfa8a8afad75e7f30cc52f180058273093218d495ff03494e332dc96669f87cea656df27d4d3330d4ea2a85eeec17d88a2d773947d5c42a61a4d8a288633051c2fd009e894a8391ddad3b8ac5dfd95fce9a0ffcdce7e9cd2a3a519bd4d0f3a4a95d7440474426016e14e38ea2f1b03257fd1029fb7428e9b9c1075355ea7dabe5597fb93e012e1fccdc0ee</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/blog/lib/hbe.js"></script><link href="/blog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>SAP</category>
      </categories>
      <tags>
        <tag>SAP</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/blog/posts/2f57a694/</url>
    <content><![CDATA[<h1 id="正则表达式中的特殊字符"><a href="#正则表达式中的特殊字符" class="headerlink" title="正则表达式中的特殊字符"></a>正则表达式中的特殊字符</h1><h2 id="正则表达式中的特殊字符（📖表示-）"><a href="#正则表达式中的特殊字符（📖表示-）" class="headerlink" title="正则表达式中的特殊字符（📖表示 |）"></a>正则表达式中的特殊字符（📖表示 <code>|</code>）</h2><p>正则真的太难学了: <span class="exturl" data-url="aHR0cHM6Ly9yZWdleG9uZS5jb20v">https://regexone.com/</span>   学习网站这不就来了</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGFidWxhZG9uZy9wLzEyMzIwNDEzLmh0bWw="> git + 正则 </span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly90b29sLm9zY2hpbmEubmV0L3VwbG9hZHMvYXBpZG9jcy9qcXVlcnkvcmVnZXhwLmh0bWw="> 手册 </span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZWdleDEwMS5jb20vci9jTzhscXMvOQ=="> 好用的网站 </span></p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\</code></td>
<td>依照下列规则匹配：在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有<code>&quot;\&quot;</code>的 <code>&quot;b&quot;</code> 通常匹配小写字母 <code>&quot;b&quot;</code>，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 <code>&quot;\&quot;</code>，它将不再匹配任何字符，而是表示一个字符边界。在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。详情请参阅下文中的 “转义（Escaping）” 部分。如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。<code>/[a-z]\s/i</code> 和 <code>new RegExp(&quot;[a-z]\\s&quot;, &quot;i&quot;)</code> 创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（<code>\s</code> 可看后文）并且在 <code>a-z</code> 范围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和正则表达式级别都对它进行转义。例如 <code>/[a-z]:\\/i </code>和 <code>new RegExp(&quot;[a-z]:\\\\&quot;,&quot;i&quot;)</code> 会创建相同的表达式，即匹配类似 <code>&quot;C:\&quot;</code> 字符串。</td>
</tr>
<tr>
<td><code>^</code></td>
<td>匹配输入的开始。如果多行标志被设置为<code> true</code>，那么也匹配换行符后紧跟的位置。例如，<code>/^A/</code> 并不会匹配 <code>&quot;an A&quot; </code>中的 <code>&#39;A&#39;</code>，但是会匹配 <code>&quot;An E&quot; </code>中的<code> &#39;A&#39;</code>。当 <code>&#39;^&#39; </code>作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。反向字符集合 一节有详细介绍和示例。</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配输入的结束。如果多行标志被设置为<code> true</code>，那么也匹配换行符前的位置。例如，<code>/t$/</code> 并不会匹配 <code>&quot;eater&quot;</code> 中的 <code>&#39;t&#39;</code>，但是会匹配 <code>&quot;eat&quot; </code>中的<code>&#39;t&#39;</code>。</td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配前一个表达式<code> 0 次</code>或<code>多次</code>。等价于 <code>&#123;0,&#125;</code>。例如，<code>/bo*/</code> 会匹配 <code>&quot;A ghost boooooed&quot;</code> 中的 <code>&#39;booooo&#39; </code>和 <code>&quot;A bird warbled&quot;</code> 中的 <code>&#39;b&#39;</code>，但是在 <code>&quot;A goat grunted&quot;</code> 中不会匹配任何内容。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配前面一个表达式 <code>1 次</code>或者<code>多次</code>。等价于<code> &#123;1,&#125;</code>。例如，<code>/a+/</code> 会匹配 <code>&quot;candy&quot;</code> 中的 <code>&#39;a&#39;</code> 和<code>&quot;caaaaaaandy&quot;</code>中所有的 <code>&#39;a&#39;</code>，但是在<code>&quot;cndy&quot;</code>中不会匹配任何内容。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配前面一个表达式 <code>0 次</code>或者<code> 1 次</code>。等价于<code> &#123;0,1&#125;</code>。例如，<code>/e?le?/</code> 匹配 <code>&quot;angel&quot;</code> 中的 <code>&#39;el&#39;、&quot;angle&quot;</code> 中的 <code>&#39;le&#39;</code> 以及 <code>&quot;oslo&#39;</code> 中的 <code>&#39;l&#39;</code>。如果紧跟在任何量词 <code>*、 +、?</code> 或 <code>&#123;&#125;</code> 的后面，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 <code>&quot;123abc&quot;</code> 使用 <code>/\d+/</code> 将会匹配 <code>&quot;123&quot;</code>，而使用 <code>/\d+?/</code> 则只会匹配到 <code>&quot;1&quot;</code>。还用于先行断言中，如本表的 <code>x(?=y)</code> 和 <code>x(?!y)</code> 条目所述。</td>
</tr>
<tr>
<td><code>.    </code></td>
<td>小数点）默认匹配除换行符之外的任何单个字符。例如，<code>/.n/</code> 将会匹配 <code>&quot;nay, an apple is on the tree&quot;</code> 中的 <code>&#39;an&#39;</code> 和 <code>&#39;on&#39;</code>，但是不会匹配 <code>&#39;nay&#39;</code>。如果 <code>s (&quot;dotAll&quot;) </code>标志位被设为 <code>true</code>，它也会匹配换行符。</td>
</tr>
<tr>
<td><code>(x)</code></td>
<td>像下面的例子展示的那样，它会匹配 <code>&#39;x&#39;</code> 并且记住匹配项。其中括号被称为捕获括号。模式 <code>/(foo) (bar) \1 \2/ </code>中的 <code>&#39;(foo)&#39;</code> 和 <code>&#39;(bar)&#39;</code> 匹配并记住字符串 <code>&quot;foo bar foo bar&quot;</code> 中前两个单词。模式中的 <code>\1</code> 和 <code>\2</code> 表示第一个和第二个被捕获括号匹配的子字符串，即 <code>foo</code> 和 <code>bar</code>，匹配了原字符串中的后两个单词。注意 <code>\1、\2、...、\n</code> 是用在正则表达式的匹配环节，详情可以参阅后文的 <code>\n</code> 条目。而在正则表达式的替换环节，则要使用像 <code>$1、$2、...、$n</code> 这样的语法，例如，<code>&#39;bar foo&#39;.replace(/(...) (...)/, &#39;$2 $1&#39;)</code>。<code>$&amp;</code> 表示整个用于匹配的原字符串。</td>
</tr>
<tr>
<td><code>(?:x)    </code></td>
<td>匹配 <code>&#39;x&#39;</code> 但是不记住匹配项。这种括号叫作非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。看看这个例子 <code>/(?:foo)&#123;1,2&#125;/</code>。如果表达式是 <code>/foo&#123;1,2&#125;/，&#123;1,2&#125;</code> 将只应用于 <code>&#39;foo&#39;</code> 的最后一个字符 <code>&#39;o&#39;</code>。如果使用非捕获括号，则 <code>&#123;1,2&#125;</code> 会应用于整个 <code>&#39;foo&#39;</code> 单词。更多信息，可以参阅下文的 <code>Using parentheses</code> 条目.</td>
</tr>
<tr>
<td><code>x(?=y)</code></td>
<td>匹配<code>&#39;x&#39;</code>仅仅当<code>&#39;x&#39;</code>后面跟着<code>&#39;y&#39;</code>.这种叫做先行断言。例如，<code>/Jack(?=Sprat)/</code>会匹配到<code>&#39;Jack&#39;</code>仅当它后面跟着``’Sprat’。/Jack(?=Sprat</td>
</tr>
<tr>
<td><code>(?&lt;=y)x</code></td>
<td>匹配<code>&#39;x&#39;</code>仅当<code>&#39;x&#39;</code>前面是<code>&#39;y&#39;</code>.这种叫做后行断言。例如，<code>/(?&lt;=Jack)Sprat/</code>会匹配到<code>&#39; Sprat &#39;</code>仅仅当它前面是<code>&#39;Jack&#39;。/(?&lt;=Jack📖Tom)Sprat/</code>匹配<code>‘ Sprat ’</code>仅仅当它前面是<code>Jack</code>或者是<code>‘Tom’</code>。但是<code>‘Jack’</code>和<code>‘Tom’</code>都不是匹配结果的一部分。</td>
</tr>
<tr>
<td><code>x(?!y)</code></td>
<td>仅仅当<code>&#39;x&#39;</code>后面不跟着<code>&#39;y&#39;</code>时匹配<code>&#39;x&#39;</code>，这被称为正向否定查找。例如，仅仅当这个数字后面没有跟小数点的时候，<code>/\d+(?!\.)/ </code>匹配一个数字。正则表达式<code>/\d+(?!\.)/.exec(&quot;3.141&quot;)</code>匹配<code>‘141’</code>而不是<code>‘3.141’</code></td>
</tr>
<tr>
<td><code>(?&lt;!y)x</code></td>
<td>仅仅当<code>&#39;x&#39;</code>前面不是<code>&#39;y&#39;</code>时匹配<code>&#39;x&#39;</code>，这被称为反向否定查找。例如, 仅仅当这个数字前面没有负号的时候，<code>/(?&lt;!-)\d+/</code> 匹配一个数字。<code>/(?&lt;!-)\d+/.exec(&#39;3&#39;)</code> 匹配到 <code>&quot;3&quot;./(?&lt;!-)\d+/.exec(&#39;-3&#39;) </code>因为这个数字前有负号，所以没有匹配到。</td>
</tr>
<tr>
<td><code>x📖y</code></td>
<td>匹配<code>‘x’</code>或者<code>‘y’</code>。例如，``/green</td>
</tr>
<tr>
<td><code>&#123;n&#125;</code></td>
<td><code>n</code> 是一个正整数，匹配了前面一个字符刚好出现了 <code>n</code> 次。比如，<code> /a&#123;2&#125;/</code> 不会匹配<code>“candy”</code>中的<code>&#39;a&#39;</code>,但是会匹配<code>“caandy”</code>中所有的 <code>a</code>，以及<code>“caaandy”</code>中的前两个<code>&#39;a&#39;</code>。</td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td><code>n</code>是一个正整数，匹配前一个字符至少出现了<code>n</code>次。例如, <code>/a&#123;2,&#125;/ </code>匹配 <code>&quot;aa&quot;</code>, <code>&quot;aaaa&quot;</code> 和 <code>&quot;aaaaa&quot;</code> 但是不匹配 <code>&quot;a&quot;</code>。</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;    </code></td>
<td><code>n</code> 和 <code>m</code> 都是整数。匹配前面的字符至少<code>n</code>次，最多<code>m</code>次。如果 <code>n</code> 或者 <code>m</code> 的值是<code>0</code>， 这个值被忽略。例如，<code>/a&#123;1, 3&#125;/</code> 并不匹配<code>“cndy”</code>中的任意字符，匹配<code>“candy”</code>中的<code>a</code>，匹配<code>“caandy”</code>中的前两个<code>a</code>，也匹配<code>“caaaaaaandy”</code>中的前三个<code>a</code>。注意，当匹配<code>”caaaaaaandy“</code>时，匹配的值是<code>“aaa”</code>，即使原始的字符串中有更多的<code>a</code>。</td>
</tr>
<tr>
<td><code>[xyz]</code></td>
<td>一个字符集合。匹配方括号中的任意字符，包括转义序列。你可以使用破折号（<code>-</code>）来指定一个字符范围。对于点<code>（.）</code>和星号<code>（*）</code>这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。例如，<code>[abcd]</code> 和<code>[a-d]</code>是一样的。他们都匹配<code>&quot;brisket&quot;</code>中的<code>‘b’</code>,也都匹配<code>“city”</code>中的<code>‘c’</code>。<code>/[a-z.]+/</code> 和<code>/[\w.]+/</code>与字符串<code>“test.i.ng”</code>匹配。</td>
</tr>
<tr>
<td><code>[^xyz]</code></td>
<td>一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。例如，<code>[^abc]</code> 和 <code>[^a-c]</code> 是一样的。他们匹配<code>&quot;brisket&quot;</code>中的<code>‘r’</code>，也匹配<code>“chop”</code>中的<code>‘h’</code>。</td>
</tr>
<tr>
<td><code>[\b]</code></td>
<td>匹配一个退格(<code>U+0008</code>)。（不要和<code>\b</code>混淆了。）</td>
</tr>
<tr>
<td><code>\b</code></td>
<td><strong>匹配一个词的边界</strong>。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是<code>0</code>。（不要和<code>[\b]</code>混淆了）使用<code>&quot;moon&quot;</code>举例：<code>/\bm/</code>匹配<code>“moon”</code>中的<code>‘m’</code>；<code>/oo\b/</code>并不匹配<code>&quot;moon&quot;</code>中的<code>&#39;oo&#39;</code>，因为<code>&#39;oo&#39;</code>被一个“字”字符<code>&#39;n&#39;</code>紧跟着。<code>/oon\b/</code>匹配<code>&quot;moon&quot;</code>中的<code>&#39;oon&#39;</code>，因为<code>&#39;oon&#39;</code>是这个字符串的结束部分。这样他没有被一个“字”字符紧着。<code>/\w\b\w/</code>将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。注意: <code>JavaScript</code>的正则表达式引擎将特定的字符集定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，十进制数字和下划线字符。不幸的是，重要的字符，例如<code>“é”</code>或<code>“ü”</code>，被视为断词。</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>匹配一个非单词边界。匹配如下几种情况：字符串第一个字符为非“字”字符字符串最后一个字符为非“字”字符两个单词字符之间两个非单词字符之间空字符串例如，<code>/\B../</code>匹配<code>&quot;noonday&quot;</code>中的<code>&#39;oo&#39;</code>, 而<code>/y\B../</code>匹配<code>&quot;possibly yesterday&quot;</code>中的<code>’yes‘</code></td>
</tr>
<tr>
<td><code>\cX</code></td>
<td>当<code>X</code>是处于<code>A</code>到<code>Z</code>之间的字符的时候，匹配字符串中的一个控制符。例如，<code>/\cM/</code> 匹配字符串中的 <code>control-M (U+000D)</code>。</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配一个数字。等价于[0-9]。例如， <code>/\d/</code> 或者 <code>/[0-9]/</code> 匹配”<code>B2 is the suite number.</code>“中的<code>&#39;2&#39;</code>。</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配一个非数字字符。等价于<code>[^0-9]</code>。例如， <code>/\D/</code> 或者 <code>/[^0-9]/</code> 匹配”<code>B2 is the suite number.</code>“中的’<code>B</code>‘ 。</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>匹配一个换页符 <code>(U+000C)</code>。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>匹配一个换行符 <code>(U+000A)</code>。</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>匹配一个回车符 <code>(U+000D)</code>。</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于<code>[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</code>。例如, <code>/\s\w*/</code> 匹配”foo bar.”中的’ bar’。经测试，\s不匹配”\u180e”，在当前版本Chrome(v80.0.3987.122)和Firefox(76.0.1)控制台输入/\s/.test(“\u180e”)均返回false。</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配一个非空白字符。等价于 <code>[^\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</code>。例如，<code>/\S\w*/</code> 匹配<code>&quot;foo bar.&quot;</code>中的’foo’。</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>匹配一个水平制表符 <code>(U+0009</code>)。</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>匹配一个垂直制表符 (U+000B)。</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配一个单字字符（字母、数字或者下划线）。等价于 <code>[A-Za-z0-9_]</code>。例如, <code>/\w/</code> 匹配 <code>&quot;apple,&quot;</code> 中的 <code>&#39;a&#39;，&quot;$5.28,&quot;</code>中的 <code>&#39;5&#39;</code> 和 <code>&quot;3D.&quot;</code> 中的 <code>&#39;3&#39;</code>。</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配一个非单字字符。等价于 <code>[^A-Za-z0-9_]</code>。例如,<code> /\W/</code> 或者 <code>/[^A-Za-z0-9_]/</code> 匹配 <code>&quot;50%.&quot;</code> 中的 <code>&#39;%&#39;</code>。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。比如 <code>/apple(,)\sorange\1/</code> 匹配<code>&quot;apple, orange, cherry, peach.&quot;</code>中的<code>&#39;apple, orange,&#39;</code> 。</td>
</tr>
<tr>
<td><code>\0</code></td>
<td>匹配<code> NULL（U+0000）</code>字符， 不要在这后面跟其它小数，因为 <code>\0&lt;digits&gt;</code> 是一个八进制转义序列。</td>
</tr>
<tr>
<td><code>\xhh</code></td>
<td>匹配一个两位十六进制数<code>（\x00-\xFF）</code>表示的字符。</td>
</tr>
<tr>
<td><code>\uhhhh</code></td>
<td>匹配一个四位十六进制数表示的 <code>UTF-16</code> 代码单元。</td>
</tr>
<tr>
<td><code>\u&#123;hhhh&#125;或\u&#123;hhhhh&#125;</code></td>
<td>（仅当设置了u标志时）匹配一个十六进制数表示的 <code>Unicode</code> 字符。</td>
</tr>
</tbody></table>
<hr/>




<table>
<thead>
<tr>
<th>表达式</th>
<th>可匹配</th>
</tr>
</thead>
<tbody><tr>
<td><code>\r, \n</code></td>
<td>代表回车和换行符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>代表 <code>&quot;\&quot;</code> 本身</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>直接插入排序</title>
    <url>/blog/posts/2b06d603/</url>
    <content><![CDATA[<h2 id="插入排序（稳定）"><a href="#插入排序（稳定）" class="headerlink" title="插入排序（稳定）"></a>插入排序（稳定）</h2><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<p>①. 从第一个元素开始，该元素可以认为已经被排序<br>②. 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>③. 如果该元素（已排序）大于新元素，将该元素移到下一位置<br>④. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>⑤. 将新元素插入到该位置后<br>⑥. 重复步骤②~⑤</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];    <span class="comment">// 取出下一个元素，在已经排序的元素序列中从后向前扫描</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j-- ) &#123;</span><br><span class="line">            <span class="keyword">if</span>( j &gt; <span class="number">0</span> &amp;&amp; arr[j-<span class="number">1</span>] &gt; temp ) &#123;</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];    <span class="comment">// 如果该元素（已排序）大于取出的元素temp，将该元素移到下一位置</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Temping:  &quot;</span> + Arrays.toString(arr));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将新元素插入到该位置后</span></span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                System.out.println(<span class="string">&quot;Sorting:  &quot;</span> + Arrays.toString(arr));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换次数较多的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j=i+<span class="number">1</span>; j&gt;<span class="number">0</span>; j-- ) &#123;</span><br><span class="line">            <span class="keyword">if</span>( arr[j-<span class="number">1</span>] &lt;= arr[j] )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];      <span class="comment">//交换操作</span></span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">            System.out.println(<span class="string">&quot;Sorting:  &quot;</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ai = a[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (ai &lt; a[j]) &#123;</span><br><span class="line">            a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">            <span class="keyword">if</span> (j-- == left) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = ai;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv">链接</span></p>
]]></content>
      <categories>
        <category>Java面试</category>
        <category>直接插入排序</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>算法</tag>
        <tag>直接插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title>获取指定集合要求中的mapkey值并重新返回map</title>
    <url>/blog/posts/97604c34/</url>
    <content><![CDATA[<p>最近遇到一个很奇怪的诉求,进行分批处理时,所得到的是一个<code>List&lt;List&lt;String&gt;&gt; partition = Lists.partition(list, 1000)</code>的分批<code>List</code>,由于只是一个类似于<code>Map&lt;string,Object&gt;</code>的<code>key</code>值进行了分组,但是业务方法使用了后面的实体类,所以想将<code>value</code>值保持和前面分组一致,同时<code>map</code>的<code>key</code>值变成<code>Object</code>实体类的其他属性.</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先根据某个值进行分类</span></span><br><span class="line">List&lt;List&lt;String&gt;&gt; partition = Lists.partition(list, <span class="number">1000</span>);</span><br><span class="line">partition.forEach(m -&gt;  &#123;</span><br><span class="line">                    Map&lt;String, DriverSettlement&gt; driverSettlementMap = m.stream()</span><br><span class="line">                            .map(driversMap::get).collect(Collectors.toMap(Student::getId, t -&gt; t));</span><br><span class="line">                    method(driverSettlementMap);</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">//这边的t-&gt;t 表示本身</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>map</tag>
        <tag>Stream流</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/blog/posts/a4ce31d2/</url>
    <content><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>所谓贪心算法是指，在对问题求解时，总是做出<strong>在当前看来是最好的选择</strong>。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p>
<p>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<span id="more"></span>

<p><strong>所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</strong></p>
<h2 id="贪心算法的基本思路"><a href="#贪心算法的基本思路" class="headerlink" title="贪心算法的基本思路"></a>贪心算法的基本思路</h2><ol>
<li><p>建立数学模型来描述问题。</p>
</li>
<li><p>把求解的问题分成若干个子问题。</p>
</li>
<li><p>对每一子问题求解，得到子问题的局部最优解。</p>
</li>
<li><p>把子问题的解局部最优解合成原来解问题的一个解。</p>
</li>
</ol>
<h2 id="贪心算法的实现框架"><a href="#贪心算法的实现框架" class="headerlink" title="贪心算法的实现框架"></a>贪心算法的实现框架</h2><p>贪心算法适用的前提是：局部最优策略能导致产生全局最优解</p>
<p>实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">从问题的某一初始解出发；</span><br><span class="line"><span class="keyword">while</span> （能朝给定总目标前进一步）</span><br><span class="line">&#123; </span><br><span class="line">        利用可行的决策，求出可行解的一个解元素;</span><br><span class="line">&#125;</span><br><span class="line">由所有解元素组合成问题的一个可行解;</span><br></pre></td></tr></table></figure>
<h2 id="贪心策略的选择"><a href="#贪心策略的选择" class="headerlink" title="贪心策略的选择"></a>贪心策略的选择</h2><p>因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p>
<h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><p>下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。</p>
<blockquote>
<p> [背包问题]有一个背包，背包容量是<code>M=150</code>。有<code>7</code>个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。<br>  <figure class="highlight plaintext"><figcaption><span>A     B    C    D     E     F    G</span></figcaption><table><tr><td class="code"><pre><span class="line">重量 35   30   60   50   40   10   25</span><br><span class="line">价值 10   40   30   50   35   40   30</span><br></pre></td></tr></table></figure><br><strong>分析：</strong></p>
</blockquote>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">目标函数： `∑pi`最大（价值总和最大）</span><br><span class="line">约束条件是装入的物品总重量不超过背包容量：`∑wi&lt;=M( M=<span class="number">150</span>)`</span><br><span class="line">    （<span class="number">1</span>）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？</span><br><span class="line">    （<span class="number">2</span>）每次挑选所占重量最小的物品装入是否能得到最优解？</span><br><span class="line">    （<span class="number">3</span>）每次选取单位重量价值最大的物品，成为解本题的策略。</span><br></pre></td></tr></table></figure>
<p>值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。</p>
<p>比如，求最小生成树的<code>Prim</code>算法和<code>Kruskal</code>算法都是漂亮的贪心算法。</p>
<p>贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。</p>
<p>可惜的是，它需要证明后才能真正运用到题目的算法中。</p>
<p>一般来说，<strong>贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">对于例题中的<span class="number">3</span>种贪心策略，都是无法成立（无法被证明）的，解释如下：</span><br><span class="line">   （<span class="number">1</span>）贪心策略：选取价值最大者。反例：</span><br><span class="line">   W=<span class="number">30</span></span><br><span class="line">   物品：<span class="keyword">A</span>     B   C</span><br><span class="line">   重量：<span class="number">28</span>  <span class="number">12</span>  <span class="number">12</span></span><br><span class="line">   价值：<span class="number">30</span>  <span class="number">20</span>  <span class="number">20</span></span><br><span class="line">   根据策略，首先选取物品<span class="keyword">A</span>，接下来就无法再选取了，可是，选取B、C则更好。</span><br><span class="line"></span><br><span class="line">   （<span class="number">2</span>）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。</span><br><span class="line"></span><br><span class="line">   （<span class="number">3</span>）贪心策略：选取单位重量价值最大的物品。反例：</span><br><span class="line">   W=<span class="number">30</span></span><br><span class="line">   物品： <span class="keyword">A</span>   B    C</span><br><span class="line">   重量：<span class="number">28</span>  <span class="number">20</span>  <span class="number">10</span></span><br><span class="line">   价值：<span class="number">28</span>  <span class="number">20</span>  <span class="number">10</span></span><br><span class="line">   根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择<span class="keyword">A</span>，则答案错误。</span><br></pre></td></tr></table></figure>
<p><strong>其实该情况是符合贪心策略的</strong>，因为该总情况不管先选哪两个都会把背包塞满，因为该题物品可以分割成任意大小，所以，就算空下一下，也可以将最后一个物品分割，放进去，它们的单位重量的价值是一样的，所以，最后背包最后重量相同，重量相同那么价值也相同。</p>
<p><strong><font color='yellow'>所以采用第三种策略，代码如下：(不是最优解)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreedyPackage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> MAX_WEIGHT = <span class="number">150</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">35</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">packageGreedy</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">int</span> weights[], <span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = weights.length;<span class="comment">//物品的数量</span></span><br><span class="line">        <span class="keyword">double</span>[] r = <span class="keyword">new</span> <span class="keyword">double</span>[n];<span class="comment">//性价比数组</span></span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//性价比排序物品的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            r[i] = (<span class="keyword">double</span>) values[i] / weights[i];</span><br><span class="line">            index[i] = i;<span class="comment">//默认排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> temp = <span class="number">0</span>;<span class="comment">//对性价比进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">//降序，对性价比和对应下标进行排序</span></span><br><span class="line">                <span class="keyword">if</span> (r[i] &lt; r[j]) &#123;</span><br><span class="line">                    temp = r[i];</span><br><span class="line">                    r[i] = r[j];</span><br><span class="line">                    r[j] = temp;</span><br><span class="line">                    <span class="keyword">int</span> x = index[i];</span><br><span class="line">                    index[i] = index[j];</span><br><span class="line">                    index[j] = x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序好的重量和价值分别存到数组</span></span><br><span class="line">        <span class="keyword">int</span>[] w1 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] v1 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">//排序好的重量和价值分别存到数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            w1[i] = weights[index[i]];</span><br><span class="line">            v1[i] = values[index[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用来装物品的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] x = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">//放入物品的最大价值</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//放入物品的总重量</span></span><br><span class="line">        <span class="keyword">int</span> totalweights = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//物品重量比包的总容量小，表示还可以装得下</span></span><br><span class="line">            <span class="keyword">if</span> (w1[i] &lt; capacity) &#123;</span><br><span class="line">                x[i] = <span class="number">1</span>;<span class="comment">//表示该物品被装了</span></span><br><span class="line">                maxValue += v1[i];</span><br><span class="line">                System.out.println(w1[i] + <span class="string">&quot;kg的物品被放进包包,价值：&quot;</span> + v1[i]);</span><br><span class="line">                totalweights += w1[i];</span><br><span class="line">                capacity = capacity - w1[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总共放入的物品数量：&quot;</span> + Arrays.toString(x));</span><br><span class="line">        System.out.println(<span class="string">&quot;总共放入的物品总重量&quot;</span> + totalweights);</span><br><span class="line">        System.out.println(<span class="string">&quot;放入物品的最大价值：&quot;</span> + maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GreedyPackage greedyPackage = <span class="keyword">new</span> GreedyPackage();</span><br><span class="line">        greedyPackage.packageGreedy(greedyPackage.MAX_WEIGHT, greedyPackage.weights, greedyPackage.values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Java面试</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>超级好用的StringJoiner</title>
    <url>/blog/posts/ba83fda/</url>
    <content><![CDATA[<h1 id="超级好用的StringJoiner"><a href="#超级好用的StringJoiner" class="headerlink" title="超级好用的StringJoiner"></a>超级好用的<code>StringJoiner</code></h1><p>主要先说一下自己的最近的需求,类似于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&amp;lt;402162465.20106.1625035747695.JavaMail.saicapp@deployment-invoiceservice-7bc58468c5-gtqb7&amp;gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其实是读取的时候 &lt;&gt; 大小于号 变成了字符串,所以现在要做的就是把他还原成</span></span><br><span class="line"><span class="comment">//&lt;402162465.20106.1625035747695.JavaMail.saicapp@deployment-invoiceservice-7bc58468c5-gtqb7&gt;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>需要做的有两步,将<code>&amp;lt;</code> <code>&amp;gt;</code> 去掉,然后再加前后缀 <code>&lt;</code>,<code>&gt;</code></p>
<p>基本上的做法就是:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">messageIdHandle</span><span class="params">(String messageId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//&amp;lt;402162465.20106.1625035747695.JavaMail.saicapp@deployment-invoiceservice-7bc58468c5-gtqb7&amp;gt;</span></span><br><span class="line">    <span class="comment">//去除前后缀</span></span><br><span class="line">    String noPreMessageId = StrUtil.removePrefix(messageId, <span class="string">&quot;&amp;lt;&quot;</span>);</span><br><span class="line">    String noPreAndSufMessageId = StrUtil.removeSuffix(noPreMessageId, <span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//拼接&lt;&gt; 号</span></span><br><span class="line">    StringJoiner stringJoiner = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">    StringJoiner realMessageId = stringJoiner.add(<span class="string">&quot;&quot;</span>).add(noPreAndSufMessageId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realMessageId.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我觉得<code>StringJoiner</code>挺好玩的!</p>
<h2 id="StringJoiner类详解"><a href="#StringJoiner类详解" class="headerlink" title="StringJoiner类详解"></a><code>StringJoiner</code>类详解</h2><img data-src="/blog/posts/ba83fda/2022-01-26-23-02-22.png" class="">

<p>我们可以构造由定界符分隔的字符序列，并可选地以提供的前缀开头并以提供的后缀结尾。然后调用<code>add</code>方法添加字符串。例子代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringJoiner stringJoiner = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>);</span><br><span class="line">stringJoiner.add(<span class="string">&quot;George&quot;</span>).add(<span class="string">&quot;Sally&quot;</span>).add(<span class="string">&quot;Fred&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(stringJoiner);</span><br></pre></td></tr></table></figure>
<p>打印结果:</p>
<img data-src="/blog/posts/ba83fda/2022-01-26-23-02-31.png" class="">

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>StringJoiner总共有五个参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String prefix;    <span class="comment">//前缀</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String delimiter; <span class="comment">//分隔符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String suffix;    <span class="comment">//后缀</span></span><br><span class="line"><span class="keyword">private</span> StringBuilder value;  </span><br><span class="line"><span class="keyword">private</span> String emptyValue;   </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> StringBuilder value; </span><br><span class="line"><span class="comment">//其实是Joiner的底层，说到底StringJoiner还是调用的StringBuiler方法，只是这层封装里加上了有关于前缀，后缀和连接符的操作，让我们可以方便一些。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* By default, the string consisting of prefix+suffix, returned by</span></span><br><span class="line"><span class="comment">* toString(), or properties of value, when no elements have yet been added,</span></span><br><span class="line"><span class="comment">* i.e. when it is empty.  This may be overridden by the user to be some</span></span><br><span class="line"><span class="comment">* other value including the empty String.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="keyword">private</span> String emptyValue;</span><br><span class="line"><span class="comment">//emptyValue 你可以把它看作是当你的StringJoiner对象没有进行任何add的操作时，调用toString() 方法会return 这个字符串而不是空。具体的用法后面看到setEmptyValue的时候再举例子。</span></span><br></pre></td></tr></table></figure>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><img data-src="/blog/posts/ba83fda/2022-01-26-23-02-42.png" class="">
<p>参数比较多的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringJoiner</span><span class="params">(CharSequence delimiter,CharSequence prefix,CharSequence suffix)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(prefix, <span class="string">&quot;The prefix must not be null&quot;</span>);</span><br><span class="line">    Objects.requireNonNull(delimiter, <span class="string">&quot;The delimiter must not be null&quot;</span>);</span><br><span class="line">    Objects.requireNonNull(suffix, <span class="string">&quot;The suffix must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">// make defensive copies of arguments</span></span><br><span class="line">    <span class="keyword">this</span>.prefix = prefix.toString();</span><br><span class="line">    <span class="keyword">this</span>.delimiter = delimiter.toString();</span><br><span class="line">    <span class="keyword">this</span>.suffix = suffix.toString();</span><br><span class="line">    <span class="keyword">this</span>.emptyValue = <span class="keyword">this</span>.prefix + <span class="keyword">this</span>.suffix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面三个参数分别是前缀后缀和连接符，然后这里有一个操作就是将<code>emptyValue</code>赋值了前缀+后缀的字符串。也就是说当你用了这个构造器的时候，<code>emptyValue</code>就已经有值了，就是前缀+后缀拼接。当你<code>StringJoiner</code>不执行<code>add</code>方法直接<code>toString()</code>时，会<code>return</code>的对象就是你的前缀+后缀。例子：</p>
<img data-src="/blog/posts/ba83fda/2022-01-26-23-02-52.png" class="">
<p>参数比较少的构造器:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringJoiner</span><span class="params">(CharSequence delimiter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(delimiter, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还是调用的三参构造器，只不过前后缀默认值为<code>&quot;&quot;</code>,也就是没有前后缀。这种情况下<code>emptyValue</code>是什么呢？ 其实和上面一样的，<code>&quot;&quot;+&quot;&quot;</code>就是<code>&quot;&quot;</code>,不难理解。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>先看上面提到最多的<code>toString().</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> emptyValue;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (suffix.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">               <span class="keyword">return</span> value.toString();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">int</span> initialLength = value.length();</span><br><span class="line">               String result = value.append(suffix).toString();</span><br><span class="line">               <span class="comment">// reset value to pre-append initialLength</span></span><br><span class="line">               value.setLength(initialLength);</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>当<code>value</code>为空(也就是<code>StringBuilder</code>为空)时，会<code>return emptyVaule</code>， 如果不为空，就会加上一个给你加后缀的操作。当然这里加后缀你可以看作一次性的，他在加之前会取一个长度，不管你后缀多长，加完之后会<code>set</code>到初始长度。</p>
<p>知道了后缀是这里加的，那前缀呢。</p>
<p>来看最核心的<code>add</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringJoiner <span class="title">add</span><span class="params">(CharSequence newElement)</span> </span>&#123;</span><br><span class="line">    prepareBuilder().append(newElement);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> StringBuilder <span class="title">prepareBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        value.append(delimiter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = <span class="keyword">new</span> StringBuilder().append(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前缀就是在你调用第一个add的时候就加上了，为什么是第一个呢，因为第一次调用<code>add</code>的时候，你的<code>value</code>肯定是空的，所以它会走<code>else</code>的逻辑给你构造一个<code>StringBuilder</code>出来，这个时候会把前缀加好。所以你后面不管有几个<code>add</code>，都是基于一个<code>StringBuilder</code>上在加字符串。当你的<code>value</code>不为空了，就会给你拼接上连接符，最后再拼接上<code>add()</code>方法里的参数。完美。</p>
<p>再结合<code>toString</code>方法来看，当你没有调用过<code>add</code>方法而直接<code>toString</code>时，<code>value</code>为空，它就会<code>return emptyValue</code>了。</p>
<p>再来看个和<code>emptyValue</code>有关的方法<code>setEmptyValue(CharSequence emptyValue)：</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> StringJoiner <span class="title">setEmptyValue</span><span class="params">(CharSequence emptyValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.emptyValue = Objects.requireNonNull(emptyValue,</span><br><span class="line">        <span class="string">&quot;The empty value must not be null&quot;</span>).toString();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法其实是暴露给开发者主动设置<code>emptyValue</code>值的方法，也就是说，当你没有调用<code>set</code>方法，<code>emptyValue</code>默认值为前缀+后缀，不管前后缀是否为空；当你调用了<code>set</code>方法，<code>emptyValue</code>就是设置的值。 举个例子：</p>
<img data-src="/blog/posts/ba83fda/2022-01-26-23-03-07.png" class="">
<p>这里的打印结果就是<code>anson</code>，注意不是<code>[anson]</code>哦。</p>
<p>还有一个有关字符串操作的方法 <code>merge(StringJoiner)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringJoiner <span class="title">merge</span><span class="params">(StringJoiner other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">if</span> (other.value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> length = other.value.length();</span><br><span class="line">        <span class="comment">// lock the length so that we can seize the data to be appended</span></span><br><span class="line">        <span class="comment">// before initiate copying to avoid interference, especially when</span></span><br><span class="line">        <span class="comment">// merge &#x27;this&#x27;</span></span><br><span class="line">        StringBuilder builder = prepareBuilder();</span><br><span class="line">        builder.append(other.value, other.prefix.length(), length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面调用了一个<code>StringBuilder</code>的<code>append()</code>重载方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(s, start, end);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说<code>merge</code>操作是把另一个<code>StringJoiner(简称sj2)</code>的从前缀开始(不包括前缀)包括连接符但是不包括后缀的字符串加进去<code>sj1</code>里面。</p>
<p>上个例子:  </p>
<img data-src="/blog/posts/ba83fda/2022-01-26-23-03-17.png" class="">
<p>前后缀都是<code>sj1</code>的，<code>ac</code>间的连接符是<code>sj2</code>的。</p>
<p>最后再看个简单的方法收尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Remember that we never actually append the suffix unless we return</span></span><br><span class="line">    <span class="comment">// the full (present) value or some sub-string or length of it, so that</span></span><br><span class="line">    <span class="comment">// we can add on more if we need to.</span></span><br><span class="line">    <span class="keyword">return</span> (value != <span class="keyword">null</span> ? value.length() + suffix.length() :</span><br><span class="line">            emptyValue.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>length()</code>方法大家最熟悉，获取长度。这里能看到有一个好处就是当你没有调用<code>add</code>方法也就是没有初始化<code>StringBuilder</code>时，调用这个方法不会空指针，因为有默认的<code>emptyValue。</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，<code>Java 8</code>的新类<code>StringJoiner</code>用法很简单，其实就是一个披着<code>StringJoiner</code>皮的<code>StringBuilder</code>而已嘛。不过有人帮你封装好了加减后缀和连接符的方法也是好的！</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/blog/posts/43d00a99/</url>
    <content><![CDATA[<h2 id="选择排序（不稳定）ON2"><a href="#选择排序（不稳定）ON2" class="headerlink" title="选择排序（不稳定）ON2"></a>选择排序（不稳定）ON2</h2><p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p>
<h3 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h3><p>选择排序的基本思想：比较 + 交换。</p>
<p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<h3 id="2、算法描述"><a href="#2、算法描述" class="headerlink" title="2、算法描述"></a>2、算法描述</h3><p>①. 从待排序序列中，找到关键字最小的元素；<br>②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br>③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</p>
<h3 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><p>选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++)&#123;    <span class="comment">//选出之后待排序中值最小的位置</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[min];      <span class="comment">//交换操作</span></span><br><span class="line">            arr[min] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            System.out.println(<span class="string">&quot;Sorting:  &quot;</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><span class="exturl" data-url="aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv">链接</span></p>
]]></content>
      <categories>
        <category>Java面试</category>
        <category>选择排序</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>算法</tag>
        <tag>选择排序</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤器和拦截器的区别</title>
    <url>/blog/posts/5e7baeeb/</url>
    <content><![CDATA[<h1 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h1><img data-src="/blog/posts/5e7baeeb/2022-02-15-22-48-46.png" class="">

<ol>
<li><p>过滤器和拦截器触发时机不一样，过滤器是在请求进入容器后，但请求进入<code>servlet</code>之前进行预处理的。请求结束返回也是，是在<code>servlet</code>处理完后，返回给前端之前。</p>
</li>
<li><p>拦截器可以获取<code>IOC</code>容器中的各个<code>bean</code>，而过滤器就不行，因为拦截器是<code>spring</code>提供并管理的，<code>spring</code>的功能可以被拦截器使用，在拦截器里注入一个<code>service</code>，可以调用业务逻辑。而过滤器是<code>JavaEE</code>标准，只需依赖<code>servlet api</code> ，不需要依赖<code>spring</code>。  </p>
</li>
</ol>
<span id="more"></span>

<img data-src="/blog/posts/5e7baeeb/2022-02-15-22-48-57.png" class="">

<ol start="3">
<li><p>过滤器的实现基于<code>回调函数</code>。而<code>拦截器（代理模式）</code>的实现基于反射</p>
</li>
<li><p><code>Filter</code>是依赖于<code>Servlet</code>容器，属于<code>Servlet</code>规范的一部分，而拦截器则是独立存在的，可以在任何情况下使用。</p>
</li>
<li><p><code>Filter</code>的执行由<code>Servlet</code>容器回调完成，而拦截器通常通过动态代理（反射）的方式来执行。</p>
</li>
<li><p><code>Filter</code>的生命周期由<code>Servlet</code>容器管理，而拦截器则可以通过<code>IoC</code>容器来管理，因此可以通过注入等方式来获取其他<code>Bean</code>的实例，因此使用会更方便。</p>
</li>
</ol>
<h2 id="SpringBoot使用过滤器"><a href="#SpringBoot使用过滤器" class="headerlink" title="SpringBoot使用过滤器"></a><code>SpringBoot</code>使用过滤器</h2><p>两种方式： </p>
<ol>
<li>使用<code>spring boot</code>提供的<code>FilterRegistrationBean</code>注册<code>Filter </code></li>
<li>使用原生<code>servlet</code>注解定义<code>Filter </code><br>两种方式的本质都是一样的，都是去<code>FilterRegistrationBean</code>注册自定义<code>Filter</code></li>
</ol>
<blockquote>
<p>方式一: （使用<code>spring boot</code>提供的<code>FilterRegistrationBean</code>注册<code>Filter</code> ）</p>
</blockquote>
<p>①. 先定义<code>Filter</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cy.springboot01.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-03-12-9:04 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// do something 处理request 或response</span></span><br><span class="line">        System.out.println(<span class="string">&quot;filter1&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用filter链中的下一个filter</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②、注册自定义<code>Filter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">registrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean(<span class="keyword">new</span> MyFilter());</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方式一的<code>①②步骤</code>可以用下面这段代码代替：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">registFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        registration.setFilter(<span class="keyword">new</span> LogCostFilter());</span><br><span class="line">        registration.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        registration.setName(<span class="string">&quot;LogCostFilter&quot;</span>);</span><br><span class="line">        registration.setOrder(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogCostFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        System.out.println(<span class="string">&quot;Execute cost=&quot;</span>+(System.currentTimeMillis()-start));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方式二：（使用原生<code>servlet</code>注解定义<code>Filter</code> ）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注入spring容器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 定义filterName 和过滤的url</span></span><br><span class="line"><span class="meta">@WebFilter(filterName = &quot;my2Filter&quot; ,urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">My2Filter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里直接用<code>@WebFilter</code>就可以进行配置，同样，可以设置<code>url</code>匹配模式，过滤器名称等。这里需要注意一点的是<code>@WebFilter</code>这个注解是<code>Servlet3.0</code>的规范，并不是<code>Spring boot</code>提供的。<strong>除了这个注解以外，我们还需在启动类中加另外一个注解：<code>@ServletComponetScan</code>，指定扫描的包。</strong></p>
<h2 id="SpringBoot配置拦截器"><a href="#SpringBoot配置拦截器" class="headerlink" title="SpringBoot配置拦截器"></a><code>SpringBoot</code>配置拦截器</h2><p>首先我们实现拦截器类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogCostInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Interceptor cost=&quot;</span>+(System.currentTimeMillis()-start));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<strong>我们还需要实现<code>HandlerInterceptor</code>这个接口</strong>，这个接口包括三个方法，<code>preHandle</code>是请求执行前执行的，<code>postHandler</code>是请求结束执行的，但只有<code>preHandle</code>方法返回<code>true</code>的时候才会执行，<code>afterCompletion</code>是视图渲染完成后才执行，同样需要<code>preHandle</code>返回<code>true</code>，                 </p>
<p> 该方法通常用于清理资源等工作。除了实现上面的接口外，我们还需对其进行配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LogCostInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　**这里我们实现了<code>WebMvcConfigurer</code>**，这里我们重写了<code>addInterceptors</code>这个方法，进行拦截器的配置，主要配置项就两个，一个是指定拦截器，第二个是指定拦截的<code>URL</code>。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java面试</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java面试</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞队列</title>
    <url>/blog/posts/159c6098/</url>
    <content><![CDATA[<h2 id="阻塞队列接口结构和实现类"><a href="#阻塞队列接口结构和实现类" class="headerlink" title="阻塞队列接口结构和实现类"></a>阻塞队列接口结构和实现类</h2><p><strong>阻塞队列</strong>，顾名思义，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p>
<img data-src="/blog/posts/159c6098/2022-03-13-16-33-09.png" class="">

<span id="more"></span>

<p>线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素。</p>
<p>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞。</p>
<p>当阻塞队列是满时，往队列里添加元素的操作将会被阻塞。</p>
<p>试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。</p>
<p>同样试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程从列中移除一个或者多个元素或者完全清空队列后使队列重新变得空闲起来并后续新增</p>
<p><strong>为什么用？有什么好处？</strong></p>
<p>在多线程领域：所谓阻塞，在某些情况下余挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒</p>
<p>为什么需要<code>BlockingQueue</code><br>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切<code>BlockingQueue</code>都给你一手包办了</p>
<p>在<code>Concurrent</code>包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>
<p>架构介绍</p>
<img data-src="/blog/posts/159c6098/2022-03-13-16-39-46.png" class="">

<p>种类分析：</p>
<ul>
<li><code>ArrayBlockingQueue</code>：由数组结构组成的有界阻塞队列。</li>
<li><code>LinkedBlockingQueue</code>：由链表结构组成的有界（但大小默认值为<code>Integer.MAX_VALUE</code>）阻塞队列。</li>
<li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。</li>
<li><code>DelayQueue</code>：使用优先级队列实现妁延迟无界阻塞队列。</li>
<li><code>SynchronousQueue</code>：不存储元素的阻塞队列。</li>
<li><code>LinkedTransferQueue</code>：由链表结构绒成的无界阻塞队列。</li>
<li><code>LinkedBlockingDeque</code>：由链表结构组成的双向阻塞队列。</li>
</ul>
<p><strong><code>BlockingQueue</code>的核心方法</strong></p>
<table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>性质</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>抛出异常</td>
<td>当阻塞队列满时：在往队列中add插入元素会抛出 IIIegalStateException：Queue full    当阻塞队列空时：再往队列中remove移除元素，会抛出NoSuchException</td>
</tr>
<tr>
<td>特殊性</td>
<td>插入方法，成功true，失败false  移除方法：成功返回出队列元素，队列没有就返回空</td>
</tr>
<tr>
<td>一直阻塞</td>
<td>当阻塞队列满时，生产者继续往队列里put元素，队列会一直阻塞生产线程直到put数据or响应中断退出。  当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用。</td>
</tr>
<tr>
<td>超时退出</td>
<td>当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td>
</tr>
</tbody></table>
<h2 id="线程通信之生产者消费者传统"><a href="#线程通信之生产者消费者传统" class="headerlink" title="线程通信之生产者消费者传统"></a>线程通信之生产者消费者传统</h2><p>阻塞队列用在哪里？</p>
<ul>
<li>生产者消费者模式<ul>
<li>传统版（<code>synchronized, wait, notify</code>）</li>
<li>阻塞队列版（<code>lock, await, signal</code>）</li>
</ul>
</li>
<li>线程池</li>
<li>消息中间件</li>
</ul>
<p>实现一个简单的生产者消费者模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 同步代码块，加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待不能生产</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            number++;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通知 唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 同步代码块，加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待不能消费</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            number--;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通知 唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>increment()</code>和<code>decrement()</code>内的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">while</span>(number != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 等待不能生产</span></span><br><span class="line">    condition.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能用 (javaw文档中指出)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">if</span>(number != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 等待不能生产</span></span><br><span class="line">    condition.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized和Lock有什么区别"><a href="#Synchronized和Lock有什么区别" class="headerlink" title="Synchronized和Lock有什么区别"></a><code>Synchronized</code>和<code>Lock</code>有什么区别</h2><ol>
<li><code>synchronized</code>属于<code>JVM</code>层面，属于<code>java</code>的关键字<ul>
<li><code>monitorenter</code>（底层是通过<code>monitor</code>对象来完成，其实<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象 只能在同步块或者方法中才能调用 <code>wait/ notify</code>等方法）</li>
<li><code>Lock</code>是具体类（<code>java.util.concurrent.locks.Lock</code>）是<code>api</code>层面的锁</li>
</ul>
</li>
<li>使用方法：<ul>
<li><code>synchronized：</code>不需要用户去手动释放锁，当<code>synchronized</code>代码执行后，系统会自动让线程释放对锁的占用。</li>
<li><code>ReentrantLock：</code>则需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁的现象，需要<code>lock()</code> 和 <code>unlock()</code> 配置<code>try catch</code>语句来完成</li>
</ul>
</li>
<li>等待是否中断<ul>
<li><code>synchronized：</code>不可中断，除非抛出异常或者正常运行完成。</li>
<li><code>ReentrantLock：</code>可中断，可以设置超时方法<ul>
<li>设置超时方法，<code>trylock(long timeout, TimeUnit unit)</code></li>
<li><code>lockInterrupible()</code> 放代码块中，调用<code>interrupt()</code> 方法可以中断</li>
</ul>
</li>
</ul>
</li>
<li>加锁是否公平<ul>
<li><code>synchronized</code>：非公平锁</li>
<li><code>ReentrantLock</code>：默认非公平锁，构造函数可以传递<code>boolean</code>值，<code>true</code>为公平锁，<code>false</code>为非公平锁</li>
</ul>
</li>
<li>锁绑定多个条件<code>Condition</code><ul>
<li><code>synchronized</code>：没有，要么随机，要么全部唤醒</li>
<li><code>ReentrantLock</code>：用来实现分组唤醒需要唤醒的线程，可以精确唤醒，而不是像<code>synchronized</code>那样，要么随机，要么全部唤醒</li>
</ul>
</li>
</ol>
<h2 id="锁绑定多个条件Condition"><a href="#锁绑定多个条件Condition" class="headerlink" title="锁绑定多个条件Condition"></a>锁绑定多个条件<code>Condition</code></h2><p>实现场景</p>
<p>多线程之间按顺序调用，实现 <code>A-&gt; B -&gt; C</code> 三个线程启动，要求如下：<br><code>AA</code>打印<code>5</code>次，<code>BB</code>打印<code>10</code>次，<code>CC</code>打印<code>15</code>次<br>紧接着<br><code>AA</code>打印<code>5</code>次，<code>BB</code>打印<code>10</code>次，<code>CC</code>打印<code>15</code>次<br>…<br>来<code>10</code>轮</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A 1   B 2   c 3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建一个重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这三个相当于备用钥匙</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知B线程执行）</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 通知2号去干活了</span></span><br><span class="line">            condition2.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知C线程执行）</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">// 通知2号去干活了</span></span><br><span class="line">            condition3.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知C线程执行）</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 通知1号去干活了</span></span><br><span class="line">            condition1.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedAndReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                    shareResource.print5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                shareResource.print10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                shareResource.print15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">A	 <span class="number">1</span>	<span class="number">0</span></span><br><span class="line">A	 <span class="number">1</span>	<span class="number">1</span></span><br><span class="line">A	 <span class="number">1</span>	<span class="number">2</span></span><br><span class="line">A	 <span class="number">1</span>	<span class="number">3</span></span><br><span class="line">A	 <span class="number">1</span>	<span class="number">4</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">0</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">1</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">2</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">3</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">4</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">5</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">6</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">7</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">8</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">9</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">0</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">1</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">2</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">3</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">4</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">5</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">6</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">7</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">8</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">9</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">10</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">11</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">12</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">13</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">14</span></span><br><span class="line">A	 <span class="number">1</span>	<span class="number">0</span></span><br><span class="line">A	 <span class="number">1</span>	<span class="number">1</span></span><br><span class="line">A	 <span class="number">1</span>	<span class="number">2</span></span><br><span class="line">A	 <span class="number">1</span>	<span class="number">3</span></span><br><span class="line">A	 <span class="number">1</span>	<span class="number">4</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">0</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">1</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">2</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">3</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">4</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">5</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">6</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">7</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">8</span></span><br><span class="line">B	 <span class="number">2</span>	<span class="number">9</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">0</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">1</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">2</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">3</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">4</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">5</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">6</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">7</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">8</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">9</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">10</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">11</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">12</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">13</span></span><br><span class="line">C	 <span class="number">3</span>	<span class="number">14</span></span><br></pre></td></tr></table></figure>
<h2 id="线程通信之生产者消费者阻塞队列版"><a href="#线程通信之生产者消费者阻塞队列版" class="headerlink" title="线程通信之生产者消费者阻塞队列版"></a>线程通信之生产者消费者阻塞队列版</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认开启，进行生产消费</span></span><br><span class="line">    <span class="comment">// 这里用到了volatile是为了保持数据的可见性，也就是当TLAG修改时，要马上通知其它线程进行修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> FLAG = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原子包装类，而不用number++</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里不能为了满足条件，而实例化一个具体的SynchronousBlockingQueue</span></span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 而应该采用依赖注入里面的，构造注入方法传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        <span class="comment">// 查询出传入的class是什么</span></span><br><span class="line">        System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> retValue;</span><br><span class="line">        <span class="comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span></span><br><span class="line">        <span class="comment">// 当FLAG为true的时候，开始生产</span></span><br><span class="line">        <span class="keyword">while</span>(FLAG) &#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2秒存入1个data</span></span><br><span class="line">            retValue = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(retValue) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 插入队列:&quot;</span> + data  + <span class="string">&quot;成功&quot;</span> );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 插入队列:&quot;</span> + data  + <span class="string">&quot;失败&quot;</span> );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 停止生产，表示FLAG=false，生产介绍&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String retValue;</span><br><span class="line">        <span class="comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span></span><br><span class="line">        <span class="comment">// 当FLAG为true的时候，开始生产</span></span><br><span class="line">        <span class="keyword">while</span>(FLAG) &#123;</span><br><span class="line">            <span class="comment">// 2秒存入1个data</span></span><br><span class="line">            retValue = blockingQueue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(retValue != <span class="keyword">null</span> &amp;&amp; retValue != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费队列:&quot;</span> + retValue  + <span class="string">&quot;成功&quot;</span> );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                FLAG = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费失败，队列中已为空，退出&quot;</span> );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 退出消费队列</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止生产的判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.FLAG = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerWithBlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入具体的实现类， ArrayBlockingQueue</span></span><br><span class="line">        MyResource myResource = <span class="keyword">new</span> MyResource(<span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 生产线程启动\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myProducer();</span><br><span class="line">                System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费线程启动&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myConsumer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5秒后，停止生产和消费</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n\n5秒中后，生产和消费线程停止，线程结束&quot;</span>);</span><br><span class="line">        myResource.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.ArrayBlockingQueue</span><br><span class="line">producer	 生产线程启动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consumer	 消费线程启动</span><br><span class="line">producer	 插入队列:<span class="number">1</span>成功</span><br><span class="line">consumer	 消费队列:<span class="number">1</span>成功</span><br><span class="line">producer	 插入队列:<span class="number">2</span>成功</span><br><span class="line">consumer	 消费队列:<span class="number">2</span>成功</span><br><span class="line">producer	 插入队列:<span class="number">3</span>成功</span><br><span class="line">consumer	 消费队列:<span class="number">3</span>成功</span><br><span class="line">producer	 插入队列:<span class="number">4</span>成功</span><br><span class="line">consumer	 消费队列:<span class="number">4</span>成功</span><br><span class="line">producer	 插入队列:<span class="number">5</span>成功</span><br><span class="line">consumer	 消费队列:<span class="number">5</span>成功</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>秒中后，生产和消费线程停止，线程结束</span><br><span class="line">producer	 停止生产，表示FLAG=<span class="keyword">false</span>，生产介绍</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consumer	 消费失败，队列中已为空，退出</span><br></pre></td></tr></table></figure>


















]]></content>
      <tags>
        <tag>Java 面试</tag>
        <tag>数据结构</tag>
        <tag>阻塞队列</tag>
      </tags>
  </entry>
  <entry>
    <title>面试之旅关于Java知识点</title>
    <url>/blog/posts/6b5f7afc/</url>
    <content><![CDATA[<h1 id="Java知识点"><a href="#Java知识点" class="headerlink" title="Java知识点"></a><code>Java</code>知识点</h1><h2 id="Collection类"><a href="#Collection类" class="headerlink" title="Collection类"></a><code>Collection</code>类</h2><img data-src="/blog/posts/6b5f7afc/2022-02-16-21-41-42.png" class="">

<span id="more"></span>

<blockquote>
<p><code>Collection</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子接口</span><br><span class="line"></span><br><span class="line">	Set,List</span><br><span class="line">集合中只能放置对象的引用,不能放置原生数据类型,</span><br><span class="line"></span><br><span class="line">我们需要使用原生数据类型的封装类才能加入到集合中</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Ordered</code>与<code>Sorted</code>接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Ordered排序,按照某种由具体情况决定的顺序排序,是后天指定的</span><br><span class="line"></span><br><span class="line">Sorted排序,按照天然顺序进行排序,是先天指定的</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>List</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实现类包括</span><br><span class="line">	LinkedList,Vector,ArrayList</span><br><span class="line">列表接口,继承与Collection,可以按索引的顺序访问,有索引的Collection</span><br><span class="line">	具有列表的功能,元素顺序均是按添加的先后进行排列的,</span><br><span class="line">	允许重复的元素,允许多个<span class="keyword">null</span>元素</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java面试</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试之旅之关于Spring事务处理</title>
    <url>/blog/posts/7e4601e3/</url>
    <content><![CDATA[<h1 id="Spring事务处理"><a href="#Spring事务处理" class="headerlink" title="Spring事务处理"></a><code>Spring</code>事务处理</h1><h2 id="Spring和事务的关系"><a href="#Spring和事务的关系" class="headerlink" title="Spring和事务的关系"></a><code>Spring</code>和事务的关系</h2><p>关系型数据库、某些消息队列等产品或中间件称为事务性资源，因为它们本身支持事务，也能够处理事务。</p>
<p><code>Spring</code>很显然不是事务性资源，但是它可以管理事务性资源，所以<code>Spring</code>和事务之间是管理关系。</p>
<p>就像<code>Jack Ma</code>虽然不会写代码，但是他却管理者一大批会写代码的码农。</p>
<span id="more"></span>

<h2 id="Spring事务三要素"><a href="#Spring事务三要素" class="headerlink" title="Spring事务三要素"></a><code>Spring</code>事务三要素</h2><ul>
<li><p>数据源：表示具体的事务性资源，是事务的真正处理者，如<code>MySQL</code>等。</p>
</li>
<li><p>事务管理器：像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。</p>
</li>
<li><p>事务应用和属性配置：像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属性如隔离级别、超时时间等。</p>
</li>
</ul>
<h2 id="Spring事务的注解配置"><a href="#Spring事务的注解配置" class="headerlink" title="Spring事务的注解配置"></a><code>Spring</code>事务的注解配置</h2><ul>
<li><p>把一个<code>DataSource（如DruidDataSource）</code>作为一个<code>@Bean</code>注册到<code>Spring</code>容器中，配置好事务性资源。</p>
</li>
<li><p>把一个<code>@EnableTransactionManagement</code>注解放到一个<code>@Configuration</code>类上，配置好事务管理器，并启用事务管理。</p>
</li>
<li><p>把一个<code>@Transactional</code>注解放到类上或方法上，可以设置注解的属性，表明该方法按配置好的属性参与到事务中。</p>
</li>
</ul>
<h2 id="事务注解的本质"><a href="#事务注解的本质" class="headerlink" title="事务注解的本质"></a>事务注解的本质</h2><ul>
<li><p><code>@Transactional</code>这个注解仅仅是一些（和事务相关的）元数据，在运行时被事务基础设施读取消费，并使用这些元数据来配置<code>bean</code>的事务行为。</p>
</li>
<li><p>大致来说具有两方面功能，一是表明该方法要参与事务，二是配置相关属性来定制事务的参与方式和运行行为。</p>
</li>
</ul>
<h2 id="Spring声明式事务实现原理"><a href="#Spring声明式事务实现原理" class="headerlink" title="Spring声明式事务实现原理"></a><code>Spring</code>声明式事务实现原理</h2><p>声明式事务成为可能，主要得益于<code>Spring AOP</code>。使用一个事务拦截器，在方法调用的前后/周围进行事务性增强（<code>advice</code>），来驱动事务完成。</p>
<h2 id="如何回滚一个事务"><a href="#如何回滚一个事务" class="headerlink" title="如何回滚一个事务"></a>如何回滚一个事务</h2><p>就是在一个事务上下文中当前正在执行的代码里抛出一个异常，事务基础设施代码会捕获任何未处理的异常，并且做出决定是否标记这个事务为回滚。</p>
<h2 id="默认回滚规则"><a href="#默认回滚规则" class="headerlink" title="默认回滚规则"></a>默认回滚规则</h2><p>默认只把<code>runtime</code>, <code>unchecked exceptions</code>标记为回滚，即<code>RuntimeException</code>及其子类，<code>Error</code>默认也导致回滚。<code>Checked exceptions</code>默认不导致回滚。这些规则和<code>EJB</code>是一样的。</p>
<h2 id="如何配置回滚异常"><a href="#如何配置回滚异常" class="headerlink" title="如何配置回滚异常"></a>如何配置回滚异常</h2><p>使用<code>@Transactional</code>注解的<code>rollbackFor/rollbackForClassName</code>属性，可以精确配置导致回滚的异常类型，包括<code>checked exceptions</code>。</p>
<p><code>noRollbackFor/noRollbackForClassName</code>属性，可以配置不导致回滚的异常类型，当遇到这样的未处理异常时，照样提交相关事务。</p>
<h2 id="事务注解在类-方法上"><a href="#事务注解在类-方法上" class="headerlink" title="事务注解在类/方法上"></a>事务注解在类/方法上</h2><p><code>@Transactional</code>注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的所有方法。如果此时方法上也标注了，则方法上的优先级高。</p>
<h2 id="事务注解在类上的继承性"><a href="#事务注解在类上的继承性" class="headerlink" title="事务注解在类上的继承性"></a>事务注解在类上的继承性</h2><p><code>@Transactional</code>注解的作用可以传播到子类，即如果父类标了子类就不用标了。但倒过来就不行了。</p>
<p>子类标了，并不会传到父类，所以父类方法不会有事务。父类方法需要在子类中重新声明而参与到子类上的注解，这样才会有事务。</p>
<h2 id="事务注解在接口-类上"><a href="#事务注解在接口-类上" class="headerlink" title="事务注解在接口/类上"></a>事务注解在接口/类上</h2><p><code>@Transactional</code>注解可以用在接口上，也可以在类上。在接口上时，必须使用基于接口的代理才行，即<code>JDK</code>动态代理。</p>
<p>事实是<code>Java</code>的注解不能从接口继承，如果你使用基于类的代理，即<code>CGLIB</code>，或基于织入方面，即<code>AspectJ</code>，事务设置不会被代理和织入基础设施认出来，目标对象不会被包装到一个事务代理中。</p>
<p><code>Spring</code>团队建议注解标注在类上而非接口上。</p>
<h2 id="只在public方法上生效？"><a href="#只在public方法上生效？" class="headerlink" title="只在public方法上生效？"></a>只在<code>public</code>方法上生效？</h2><p>当采用代理来实现事务时，（注意是代理），<code>@Transactional</code>注解只能应用在<code>public</code>方法上。当标记在<code>protected、private、package-visible</code>方法上时，不会产生错误，但也不会表现出为它指定的事务配置。可以认为它作为一个普通的方法参与到一个<code>public</code>方法的事务中。</p>
<p>如果想在非<code>public</code>方法上生效，考虑使用<code>AspectJ（织入方式）</code>。</p>
<h2 id="目标类里的自我调用没有事务？"><a href="#目标类里的自我调用没有事务？" class="headerlink" title="目标类里的自我调用没有事务？"></a>目标类里的自我调用没有事务？</h2><p>在代理模式中（这是默认的），只有从外部的方法调用进入通过代理会被拦截，这意味着自我调用（实际就是，目标对象中的一个方法调用目标对象的另一个方法）在运行时不会导致一个实际的事务，即使被调用的方法标有注解。</p>
<p>如果你希望自我调用也使用事务来包装，考虑使用<code>AspectJ</code>的方式。在这种情况下，首先是没有代理。相反，目标类被织入（即它的字节码被修改）来把<code>@Transactional</code>加入到运行时行为，在任何种类的方法上都可以。</p>
<h2 id="事务与线程"><a href="#事务与线程" class="headerlink" title="事务与线程"></a>事务与线程</h2><p>和<code>JavaEE</code>事务上下文一样，<code>Spring</code>事务和一个线程的执行相关联，底层是一个<code>ThreadLocal&lt;Map&lt;Object, Object&gt;&gt;</code>，就是每个线程一个<code>map</code>，<code>key</code>是<code>DataSource</code>，<code>value</code>是<code>Connection</code>。</p>
<h2 id="逻辑事务与物理事务"><a href="#逻辑事务与物理事务" class="headerlink" title="逻辑事务与物理事务"></a>逻辑事务与物理事务</h2><p>事务性资源实际打开的事务就是物理事务，如数据库的<code>Connection</code>打开的事务。<code>Spring</code>会为每个<code>@Transactional</code>方法创建一个事务范围，可以理解为是逻辑事务。</p>
<p>在逻辑事务中，大范围的事务称为外围事务，小范围的事务称为内部事务，外围事务可以包含内部事务，但在逻辑上是互相独立的。每一个这样的逻辑事务范围，都能够单独地决定<code>rollback-only</code>状态。</p>
<p>那么如何处理逻辑事务和物理事务之间的关联关系呢，这就是传播特性解决的问题。</p>
<h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><p>事务传播行为(为了解决业务层方法之间互相调用的事务问题): 当事务方法被另一个事务方法调用时,必须指定事务应该如何传播。</p>
<p>例如:方法可能继续在现有事务中运行,也可能开启一个新事务,并在自己的事务中运行。在<code>TransactionDefinition</code>定义中包括了如下几个表示传播行为的常量:</p>
<p><code>REQUIRED，SUPPORTS，MANDATORY，REQUIRES_NEW，NOT_SUPPORTED，NEVER，NESTED</code></p>
<blockquote>
<p>支持当前事务的情况:</p>
</blockquote>
<ul>
<li><code>TransactionDefinition.PROPAGATION_REQUIRED:</code> 如果当前存在事务,则加入该事务;如果当前没有事务,则创建一个新的事务。</li>
<li><code>TransactionDefinition.PROPAGATION_SUPPORTS:</code> 如果当前存在事务,则加入该事务;如果当前没有事务,则以非事务的方式继续运行。</li>
<li><code>TransactionDefinition.PROPAGATION_MANDATORY:</code> 如果当前存在事务,则加入该事务;如果当前没有事务,则抛出异常。(<code>mandatory:强制性</code>)</li>
</ul>
<blockquote>
<p>不支持当前事务的情况:</p>
</blockquote>
<ul>
<li><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW:</code> 创建一个新的事务,如果当前存在事务,则把当前事务挂起。</li>
<li><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED:</code> 以非事务方式运行,如果当前存在事务,则把当前事务挂起。</li>
<li><code>TransactionDefinition.PROPAGATION_NEVER:</code> 以非事务方式运行,如果当前存在事务,则抛出异常。</li>
</ul>
<blockquote>
<p>其他情况:</p>
</blockquote>
<ul>
<li><code>TransactionDefinition.PROPAGATION_NESTED: </code>如果当前存在事务,则创建一个事务作为当前事务的嵌套事务来运行;如果当前没有事务,则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED。</code></li>
</ul>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p><code>TransactionDefinition</code> 接口中定义了<code>五个</code>表示隔离级别的常量:</p>
<p><code>DEFAULT，READ_UNCOMMITTED，READ_COMMITTED，REPEATABLE_READ，SERIALIZABLE</code></p>
<ul>
<li><code>TransactionDefinition.ISOLATION_DEFAULT:</code> 使用后端数据库默认的隔离级别,<code>Mysql</code> 默认采用的<code>REPEATABLE_READ</code>隔离级别 <code>Oracle</code> 默认采用的 <code>READ_COMMITTED</code>隔离级别。</li>
<li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED: </code>最低的隔离级别,允许读取尚未提交的数据变更,可能会导致脏读、幻读或不可重复读。</li>
<li><code>TransactionDefinition.ISOLATION_READ_COMMITTED:</code> 允许读取并发事务已经提交的数据,可以阻止脏读,但是幻读或不可重复读仍有可能发生。</li>
<li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ:</code> 对同一字段的多次读取结果都是一致的,除非数据是被本身事务自己所修改,可以阻止脏读和不可重复读,但幻读仍有可能发生。</li>
<li><code>TransactionDefinition.ISOLATION_SERIALIZABLE:</code> 最高的隔离级别,完全服从<code>ACID</code>的隔离级别。所有的事务依次逐个执行,这样事务之间就完全不可能产生干扰,也就是说,该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<blockquote>
<p>脏读</p>
</blockquote>
<p>一个事务修改了一行数据但没有提交，第二个事务可以读取到这行被修改的数据，如果第一个事务回滚，第二个事务获取到的数据将是无效的。</p>
<blockquote>
<p>不可重复读</p>
</blockquote>
<p>一个事务读取了一行数据，第二个事务修改了这行数据，第一个事务重新读取这行数据，将获得到不同的值。</p>
<blockquote>
<p>幻读</p>
</blockquote>
<p>一个事务按照一个<code>where</code>条件读取所有符合的数据行，第二个事务插入了一行数据且恰好也满足这个<code>where</code>条件，第一个事务再以这个<code>where</code>条件重新读取，将会获取额外多出来的这一行。</p>
<p><strong>帮助记忆：</strong><br>写读是脏读，读写读是不可重复读，<code>where insert where</code>是幻读。</p>
<img data-src="/blog/posts/7e4601e3/2022-02-16-21-43-16.png" class="">



]]></content>
      <categories>
        <category>Java面试</category>
        <category>Spring事务</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>Spring事务</tag>
      </tags>
  </entry>
  <entry>
    <title>面试之旅关于计算机网络</title>
    <url>/blog/posts/c7cf6e41/</url>
    <content><![CDATA[<h1 id="常见面试题整理–计算机网络篇（每位开发者必备）"><a href="#常见面试题整理–计算机网络篇（每位开发者必备）" class="headerlink" title="常见面试题整理–计算机网络篇（每位开发者必备）"></a>常见面试题整理–计算机网络篇（每位开发者必备）</h1><img data-src="/blog/posts/c7cf6e41/2022-02-16-21-31-41.png" class="">

<h2 id="1-请简述TCP-UDP的区别"><a href="#1-请简述TCP-UDP的区别" class="headerlink" title="1. 请简述TCP\UDP的区别"></a>1. 请简述<code>TCP\UDP</code>的区别</h2><p><code>TCP</code>和<code>UDP</code>是<code>OSI</code>模型中的运输层中的协议。<code>TCP</code>提供可靠的通信传输，而<code>UDP</code>则常被用于让广播和细节控制交给应用的通信传输。</p>
<p>两者的区别大致如下：</p>
<ul>
<li><code>TCP</code>面向连接，<code>UDP</code>面向非连接即发送数据前不需要建立链接</li>
<li><code>TCP</code>提供可靠的服务（数据传输），<code>UDP</code>无法保证</li>
<li><code>TCP</code>面向字节流，<code>UDP</code>面向报文</li>
<li><code>TCP</code>数据传输慢，<code>UDP</code>数据传输快</li>
</ul>
<h2 id="2-请简单说一下你了解的端口及对应的服务？"><a href="#2-请简单说一下你了解的端口及对应的服务？" class="headerlink" title="2. 请简单说一下你了解的端口及对应的服务？"></a>2. 请简单说一下你了解的端口及对应的服务？</h2><span id="more"></span>

<img data-src="/blog/posts/c7cf6e41/2022-02-16-21-31-53.png" class="">

<p><strong>端口简介：本文介绍端口的概念，分类，以及如何关闭/开启一个端口</strong></p>
<ul>
<li><p><code>21端口</code>：21端口主要用于<code>FTP（File Transfer Protocol，文件传输协议）</code>服务。</p>
</li>
<li><p><code>23</code>端口：23端口主要用于<code>Telnet（远程登录）</code>服务，是<code>Internet</code>上普遍采用的登录和仿真程序。</p>
</li>
<li><p><code>25端口</code>：25端口为<code>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</code>服务器所开放，主要用于发送邮件，如今绝大多数邮件服务器都使用该协议。</p>
</li>
<li><p><code>53端口</code>：53端口为<code>DNS（Domain Name Server，域名服务器）</code>服务器所开放，主要用于域名解析，<code>DNS</code>服务在<code>NT</code>系统中使用的最为广泛。</p>
</li>
<li><p><code>67、68端口</code>：67、68端口分别是为<code>Bootstrap</code>服务的<code>Bootstrap Protocol Server（引导程序协议服务端）</code>和<code>Bootstrap Protocol Client（引导程序协议客户端）</code>开放的端口。</p>
</li>
<li><p><code>69端口</code>：<code>TFTP</code>是Cisco公司开发的一个<code>简单文件传输协议</code>，类似于<code>FTP</code>。</p>
</li>
<li><p><code>79端口</code>：79端口是为<code>Finger</code>服务开放的，主要用于查询远程主机在线用户、操作系统类型以及是否缓冲区溢出等用户的详细信息。</p>
</li>
<li><p><code>80端口</code>：80端口是为<code>HTTP（HyperText Transport Protocol，超文本传输协议）</code>开放的，这是上网冲浪使用最多的协议，主要用于在<code>WWW（World Wide Web，万维网）</code>服务上传输信息的协议。</p>
</li>
<li><p><code>99端口</code>：99端口是用于一个名为<code>“Metagram Relay”（亚对策延时）</code>的服务，该服务比较少见，一般是用不到的。</p>
</li>
<li><p><code>109、110端口</code>：109端口是为<code>POP2（Post Office Protocol Version 2，邮局协议2）</code>服务开放的，<code>110端口是为POP3（邮件协议3）</code>服务开放的，<code>POP2、POP3</code>都是主要用于接收邮件的。</p>
</li>
<li><p><code>111端口</code>：111端口是<code>SUN</code>公司的<code>RPC（Remote Procedure Call，远程过程调用）</code>服务所开放的端口，主要用于分布式系统中不同计算机的内部进程通信，RPC在多种网络服务中都是很重要的组件。</p>
</li>
<li><p><code>113端口</code>：113端口主要用于<code>Windows</code>的<code>“Authentication Service”（验证服务）</code>。</p>
</li>
<li><p><code>119端口</code>：119端口是为<code>“Network News Transfer Protocol”（网络新闻组传输协议，简称NNTP）</code>开放的。</p>
</li>
<li><p><code>135端口</code>：135端口主要用于使用<code>RPC（Remote Procedure Call，远程过程调用）</code>协议并提供<code>DCOM（分布式组件对象模型）</code>服务。</p>
</li>
<li><p><code>137端口</code>：137端口主要用于<code>“NetBIOS Name Service”（NetBIOS名称服务）</code>。</p>
</li>
<li><p><code>139端口</code>：139端口是为<code>“NetBIOS Session Service”</code>提供的，主要用于提供<code>Windows</code>文件和打印机共享以及<code>Unix</code>中的<code>Samba</code>服务。</p>
</li>
<li><p><code>143端口</code>：143端口主要是用于<code>“Internet Message Access Protocol”v2（Internet消息访问协议，简称IMAP）</code>。</p>
</li>
<li><p><code>161端口</code>：161端口是用于<code>“Simple Network Management Protocol”（简单网络管理协议，简称SNMP）</code>。</p>
</li>
<li><p><code>443端口</code>：43端口即网页浏览端口，主要是用于<code>HTTPS</code>服务，是提供加密和通过安全端口传输的另一种<code>HTTP</code>。</p>
</li>
<li><p><code>554端口</code>：554端口默认情况下用于<code>“Real Time Streaming Protocol”（实时流协议，简称RTSP）</code>。</p>
</li>
<li><p><code>1024端口</code>：1024端口一般不固定分配给某个服务，在英文中的解释是<code>“Reserved”（保留）</code>。</p>
</li>
<li><p><code>1080端口</code>：1080端口是Socks代理服务使用的端口，大家平时上网使用的WWW服务使用的是HTTP协议的代理服务。</p>
</li>
<li><p><code>1755端口</code>：1755端口默认情况下用于<code>“Microsoft Media Server”（微软媒体服务器，简称MMS）</code>。</p>
</li>
<li><p><code>4000端口</code>：4000端口是用于大家经常使用的<code>QQ</code>聊天工具的，再细说就是为<code>QQ</code>客户端开放的端口，<code>QQ</code>服务端使用的端口是<code>8000</code>。</p>
</li>
<li><p><code>5554端口</code>：在今年4月30日就报道出现了一种针对微软<code>lsass服务</code>的新蠕虫病毒——震荡波（Worm.Sasser），该病毒可以利用<code>TCP 5554端口</code>开启一个<code>FTP</code>服务，主要被用于病毒的传播。</p>
</li>
<li><p><code>5632端口</code>：5632端口是被大家所熟悉的远程控制软件<code>pcAnywhere</code>所开启的端口。</p>
</li>
<li><p><code>8080端口</code>：8080端口同80端口，是被用于<code>WWW</code>代理服务的，可以实现网页</p>
</li>
</ul>
<h2 id="3-说一说TCP的三次握手"><a href="#3-说一说TCP的三次握手" class="headerlink" title="3. 说一说TCP的三次握手"></a>3. 说一说<code>TCP</code>的三次握手</h2><p>在<code>TCP/IP</code>协议中，<code>TCP协议</code>提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换<code>TCP</code>窗口大小信息。</p>
<p>下面详细说一下三次握手（来自简析<code>TCP</code>的三次握手与四次分手）</p>
<img data-src="/blog/posts/c7cf6e41/2022-02-16-21-32-08.png" class="">

<img data-src="/blog/posts/c7cf6e41/2022-02-16-21-32-16.png" class="">

<h2 id="4-有哪些私有（保留）地址？"><a href="#4-有哪些私有（保留）地址？" class="headerlink" title="4. 有哪些私有（保留）地址？"></a>4. 有哪些私有（保留）地址？</h2><ul>
<li><code>A</code>类：<code>10.0.0.0 - 10.255.255.255</code></li>
<li><code>B</code>类：<code>172.16.0.0 - 172.31.255.255</code></li>
<li><code>C</code>类：<code>192.168.0.0 - 192.168.255.255</code></li>
</ul>
<h2 id="5-IP地址分为哪几类？简单说一下各个分类"><a href="#5-IP地址分为哪几类？简单说一下各个分类" class="headerlink" title="5. IP地址分为哪几类？简单说一下各个分类"></a>5. <code>IP</code>地址分为哪几类？简单说一下各个分类</h2><img data-src="/blog/posts/c7cf6e41/2022-02-16-21-32-36.png" class="">

<p><code>IPv6 </code>– 采用<code>128bit</code>，首部固定部分为<code>40</code>字节。</p>
<h2 id="6-在浏览器中输入网址之后执行会发生什么？"><a href="#6-在浏览器中输入网址之后执行会发生什么？" class="headerlink" title="6. 在浏览器中输入网址之后执行会发生什么？"></a>6. 在浏览器中输入网址之后执行会发生什么？</h2><ul>
<li>查找域名对应的<code>IP</code>地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，<code>ISPNDS</code>缓存，根域名服务器</li>
<li>浏览器向<code>IP</code>对应的<code>web</code>服务器发送一个<code>HTTP</code>请求</li>
<li>服务器响应请求，发回网页内容</li>
<li>浏览器解析网页内容</li>
</ul>
<p>更加详细的一种说法（以百度为例）（来自计算机网络之面试常考 - 牛客网）</p>
<img data-src="/blog/posts/c7cf6e41/2022-02-16-21-32-47.png" class="">

<h2 id="7-简单解释一些ARP协议的工作过程"><a href="#7-简单解释一些ARP协议的工作过程" class="headerlink" title="7. 简单解释一些ARP协议的工作过程"></a>7. 简单解释一些<code>ARP</code>协议的工作过程</h2><img data-src="/blog/posts/c7cf6e41/2022-02-16-21-33-01.png" class="">

<h2 id="8-说一说OSI七层模型"><a href="#8-说一说OSI七层模型" class="headerlink" title="8. 说一说OSI七层模型"></a>8. 说一说<code>OSI</code>七层模型</h2><img data-src="/blog/posts/c7cf6e41/2022-02-16-21-33-15.png" class="">

<h2 id="9-说一说TCP-IP四层模型"><a href="#9-说一说TCP-IP四层模型" class="headerlink" title="9. 说一说TCP/IP四层模型"></a>9. 说一说<code>TCP/IP</code>四层模型</h2><p><code>ISO</code>制定的<code>OSI</code>参考模型的过于庞大、复杂招致了许多批评。与此对照，由技术人员自己开发的<code>TCP/IP</code>协议栈获得了更为广泛的应用。如图所示，是<code>TCP/IP</code>参考模型和<code>OSI</code>参考模型的对比示意图。</p>
<img data-src="/blog/posts/c7cf6e41/2022-02-16-21-33-24.png" class="">

<img data-src="/blog/posts/c7cf6e41/2022-02-16-21-33-31.png" class="">

<p>具体讲解：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vQmx1ZVR6YXIvYXJ0aWNsZXMvODExMTYwLmh0bWw=">链接</span></p>
<h2 id="10-HTTP-协议包括哪些请求？"><a href="#10-HTTP-协议包括哪些请求？" class="headerlink" title="10. HTTP 协议包括哪些请求？"></a>10. <code>HTTP</code> 协议包括哪些请求？</h2><ul>
<li><p><code>GET</code>：对服务器资源的简单请求</p>
</li>
<li><p><code>POST</code>：用于发送包含用户提交数据的请求</p>
</li>
<li><p>———–以及————</p>
</li>
<li><p><code>HEAD</code>：类似于GET请求，不过返回的响应中没有具体内容，用于获取报头</p>
</li>
<li><p><code>PUT</code>：传说中请求文档的一个版本</p>
</li>
<li><p><code>DELETE</code>：发出一个删除指定文档的请求</p>
</li>
<li><p><code>TRACE</code>：发送一个请求副本，以跟踪其处理进程</p>
</li>
<li><p><code>OPTIONS</code>：返回所有可用的方法，检查服务器支持哪些方法</p>
</li>
<li><p><code>CONNECT</code>：用于<code>ssl</code>隧道的基于代理的请求</p>
</li>
</ul>
<h2 id="11-简述HTTP中GET和POST的区别"><a href="#11-简述HTTP中GET和POST的区别" class="headerlink" title="11. 简述HTTP中GET和POST的区别"></a>11. 简述<code>HTTP</code>中<code>GET</code>和<code>POST</code>的区别</h2><p>从原理性看：</p>
<ul>
<li>根据<code>HTTP</code>规范，<code>GET</code>用于信息获取，而且应该是安全和幂等的</li>
<li>根据<code>HTTP</code>规范，<code>POST</code>请求表示可能修改服务器上资源的请求</li>
</ul>
<p>从表面上看：</p>
<ul>
<li><code>GET</code>请求的数据会附在<code>URL</code>后面，<code>POST</code>的数据放在<code>HTTP</code>包体</li>
<li><code>POST</code>安全性比<code>GET</code>安全性高</li>
</ul>
]]></content>
      <categories>
        <category>Java面试</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>面试之旅关于操作系统</title>
    <url>/blog/posts/4847d2e5/</url>
    <content><![CDATA[<h1 id="常见面试题整理–操作系统篇（每位开发者必备）"><a href="#常见面试题整理–操作系统篇（每位开发者必备）" class="headerlink" title="常见面试题整理–操作系统篇（每位开发者必备）"></a>常见面试题整理–操作系统篇（每位开发者必备）</h1><img data-src="/blog/posts/4847d2e5/2022-02-16-21-18-10.png" class="">

<h2 id="1-请分别简单说一说进程和线程以及它们的区别。"><a href="#1-请分别简单说一说进程和线程以及它们的区别。" class="headerlink" title="1. 请分别简单说一说进程和线程以及它们的区别。"></a>1. 请分别简单说一说进程和线程以及它们的区别。</h2><blockquote>
<p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。线程是进程的实体，是<code>CPU</code>调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。一个进程可以有多个线程，多个线程也可以并发执行</p>
</blockquote>
<span id="more"></span>

<h2 id="2-线程同步的方式有哪些？"><a href="#2-线程同步的方式有哪些？" class="headerlink" title="2. 线程同步的方式有哪些？"></a>2. 线程同步的方式有哪些？</h2><ul>
<li>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li>
<li>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li>事件（信号): 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ul>
<h2 id="3-进程的通信方式有哪些？"><a href="#3-进程的通信方式有哪些？" class="headerlink" title="3. 进程的通信方式有哪些？"></a>3. 进程的通信方式有哪些？</h2><p>主要分为：管道、系统<code>IPC</code>（包括消息队列、信号量、共享存储）、<code>SOCKET</code></p>
<p>管道主要分为：普通管道<code>PIPE</code> 、流管道（<code>s_pipe</code>）、命名管道（<code>name_pipe</code>）</p>
<ul>
<li>管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程</li>
<li>命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信</li>
<li>信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。</li>
<li>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</li>
<li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li>共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。</li>
</ul>
<h2 id="4-什么是缓冲区溢出？有什么危害？其原因是什么？"><a href="#4-什么是缓冲区溢出？有什么危害？其原因是什么？" class="headerlink" title="4. 什么是缓冲区溢出？有什么危害？其原因是什么？"></a>4. 什么是缓冲区溢出？有什么危害？其原因是什么？</h2><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p>
<p>危害有以下两点：</p>
<ul>
<li>程序崩溃，导致拒绝额服务</li>
<li>跳转并且执行一段恶意代码</li>
</ul>
<p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p>
<h2 id="5-什么是死锁？死锁产生的条件"><a href="#5-什么是死锁？死锁产生的条件" class="headerlink" title="5. 什么是死锁？死锁产生的条件"></a>5. 什么是死锁？死锁产生的条件</h2><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p>
<p>死锁产生的四个条件（有一个条件不成立，则不会产生死锁）</p>
<ol>
<li>互斥条件：一个资源一次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>
<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>
</ol>
<h2 id="6-进程有哪几种状态？"><a href="#6-进程有哪几种状态？" class="headerlink" title="6. 进程有哪几种状态？"></a>6. 进程有哪几种状态？</h2><ul>
<li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源</li>
<li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于<code>CPU</code>数</li>
<li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行</li>
</ul>
<h2 id="7-分页和分段有什么区别？"><a href="#7-分页和分段有什么区别？" class="headerlink" title="7. 分页和分段有什么区别？"></a>7. 分页和分段有什么区别？</h2><ul>
<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</li>
<li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定</li>
<li>段向用户提供二维地址空间；页向用户提供的是一维地址空间</li>
<li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li>
</ul>
<h2 id="8-操作系统中进程调度策略有哪几种？"><a href="#8-操作系统中进程调度策略有哪几种？" class="headerlink" title="8. 操作系统中进程调度策略有哪几种？"></a>8. 操作系统中进程调度策略有哪几种？</h2><p><code>FCFS</code>(先来先服务)，优先级，时间片轮转，多级反馈</p>
<h2 id="9-说一说进程同步有哪几种机制"><a href="#9-说一说进程同步有哪几种机制" class="headerlink" title="9. 说一说进程同步有哪几种机制?"></a>9. 说一说进程同步有哪几种机制?</h2><p>原子操作、信号量机制、自旋锁管程、会合、分布式系统</p>
<h2 id="10-说一说死锁的处理基本策略和常用方法"><a href="#10-说一说死锁的处理基本策略和常用方法" class="headerlink" title="10. 说一说死锁的处理基本策略和常用方法"></a>10. 说一说死锁的处理基本策略和常用方法</h2><ul>
<li><p>解决死锁的基本方法如下：<br>预防死锁、避免死锁、检测死锁、解除死锁</p>
</li>
<li><p>解决四多的常用策略如下：<br>鸵鸟策略、预防策略、避免策略、检测与解除死锁</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java面试</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>面试之旅关于数据库</title>
    <url>/blog/posts/666b2933/</url>
    <content><![CDATA[<h1 id="常见面试题整理–数据库篇（每位开发者必备）"><a href="#常见面试题整理–数据库篇（每位开发者必备）" class="headerlink" title="常见面试题整理–数据库篇（每位开发者必备）"></a>常见面试题整理–数据库篇（每位开发者必备）</h1><img data-src="/blog/posts/666b2933/2022-02-16-21-40-29.png" class="">

<h2 id="1-什么是存储过程？有哪些优缺点？"><a href="#1-什么是存储过程？有哪些优缺点？" class="headerlink" title="1. 什么是存储过程？有哪些优缺点？"></a>1. 什么是存储过程？有哪些优缺点？</h2><span id="more"></span>

<p>存储过程是一些预编译的<code>SQL</code>语句。</p>
<p>更加直白的理解：存储过程可以说是一个记录集，它是由一些<code>T-SQL</code>语句组成的代码块，这些<code>T-SQL</code>语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。</p>
<p>存储过程是一个预编译的代码块，执行效率比较高<br>一个存储过程替代大量<code>T_SQL</code>语句 ，可以降低网络通信量，提高通信速率<br>可以一定程度上确保数据安全</p>
<h2 id="2-索引是什么？有什么作用以及优缺点"><a href="#2-索引是什么？有什么作用以及优缺点" class="headerlink" title="2. 索引是什么？有什么作用以及优缺点"></a>2. 索引是什么？有什么作用以及优缺点</h2><p>索引是对数据库表中一或多个列的值进行排序的结构，是帮助<code>MySQL</code>高效获取数据的数据结构</p>
<p>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</p>
<p><code>MySQL</code>数据库几个基本的索引类型：*<code>普通索引</code>、<code>唯一索引</code>、<code>主键索引</code>、<code>全文索引</code>*</p>
<ul>
<li>索引加快数据库的检索速度</li>
<li>索引降低了插入、删除、修改等维护任务的速度</li>
<li>唯一索引可以确保每一行数据的唯一性</li>
<li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li>
<li>索引需要占物理和数据空间</li>
</ul>
<h2 id="3-什么是事务？"><a href="#3-什么是事务？" class="headerlink" title="3. 什么是事务？"></a>3. 什么是事务？</h2><p>事务（<code>Transaction</code>）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</p>
<h2 id="4-数据库的乐观锁和悲观锁是什么？"><a href="#4-数据库的乐观锁和悲观锁是什么？" class="headerlink" title="4. 数据库的乐观锁和悲观锁是什么？"></a>4. 数据库的乐观锁和悲观锁是什么？</h2><p>数据库管理系统（<code>DBMS</code>）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p>
<p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<ul>
<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</li>
<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li>
</ul>
<h2 id="5-使用索引查询一定能提高查询的性能吗？为什么"><a href="#5-使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="5. 使用索引查询一定能提高查询的性能吗？为什么"></a>5. 使用索引查询一定能提高查询的性能吗？为什么</h2><p>通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.</p>
<p>索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的<code>INSERT,DELETE,UPDATE</code>将为此多付出<code>4,5次</code>的磁盘<code>I/O</code>. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(<code>INDEX RANGE SCAN</code>)适用于两种情况:</p>
<p>基于一个范围的检索,一般查询返回结果集小于表中记录数的<code>30%</code>基于非唯一性索引的检索</p>
<h2 id="6-简单说一说drop、delete与truncate的区别"><a href="#6-简单说一说drop、delete与truncate的区别" class="headerlink" title="6. 简单说一说drop、delete与truncate的区别"></a>6. 简单说一说<code>drop</code>、<code>delete</code>与<code>truncate</code>的区别</h2><p><code>SQL</code>中的<code>drop</code>、<code>delete</code>、<code>truncate</code>都表示删除，但是三者有一些差别</p>
<ul>
<li><code>delete</code>和<code>truncate</code>只删除表的数据不删除表的结构</li>
<li>速度,一般来说: <code>drop &gt; truncate &gt;delete</code></li>
<li><code>delete</code>语句是<code>dml</code>,这个操作会放到<code>rollback segement</code>中,事务提交之后才生效;</li>
<li>如果有相应的<code>trigger</code>,执行的时候将被触发. <code>truncate,drop</code>是<code>ddl</code>, 操作立即生效,原数据不放到<code>rollback segment</code>中,不能回滚. 操作不触发<code>trigger</code>.</li>
</ul>
<h2 id="7-drop、delete与truncate分别在什么场景之下使用？"><a href="#7-drop、delete与truncate分别在什么场景之下使用？" class="headerlink" title="7. drop、delete与truncate分别在什么场景之下使用？"></a>7. <code>drop</code>、<code>delete</code>与<code>truncate</code>分别在什么场景之下使用？</h2><ul>
<li>不再需要一张表的时候，用<code>drop</code></li>
<li>想删除部分数据行时候，用<code>delete</code>，并且带上<code>where</code>子句</li>
<li>保留表而删除所有数据的时候用<code>truncate</code></li>
</ul>
<h2 id="8-超键、候选键、主键、外键分别是什么？"><a href="#8-超键、候选键、主键、外键分别是什么？" class="headerlink" title="8. 超键、候选键、主键、外键分别是什么？"></a>8. 超键、候选键、主键、外键分别是什么？</h2><ul>
<li><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>
</li>
<li><p>候选键：是最小超键，即没有冗余元素的超键。</p>
</li>
<li><p>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（<code>Null</code>）。</p>
</li>
<li><p>外键：在一个表中存在的另一个表的主键称此表的外键。</p>
</li>
</ul>
<h2 id="9-什么是视图？以及视图的使用场景有哪些？"><a href="#9-什么是视图？以及视图的使用场景有哪些？" class="headerlink" title="9. 什么是视图？以及视图的使用场景有哪些？"></a>9. 什么是视图？以及视图的使用场景有哪些？</h2><blockquote>
<p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
</blockquote>
<blockquote>
<p>只暴露部分字段给访问者，所以就建一个虚表，就是视图。<br>查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</p>
</blockquote>
<h2 id="10-说一说三个范式。"><a href="#10-说一说三个范式。" class="headerlink" title="10. 说一说三个范式。"></a>10. 说一说三个范式。</h2><p><strong>第一范式（<code>1NF</code>）</strong>：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</p>
<p><strong>第二范式（<code>2NF</code>）</strong>：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</p>
<p><strong>第三范式（<code>3NF</code>）</strong>：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在<code>&quot;A → B → C&quot;</code>的决定关系，则<code>C</code>传递函数依赖于<code>A</code>。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 <code>x </code>→ 非关键字段<code>y</code></p>
]]></content>
      <categories>
        <category>Java面试</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>面试之旅关于数据结构</title>
    <url>/blog/posts/9f9a6182/</url>
    <content><![CDATA[<h1 id="面试之旅关于数据结构"><a href="#面试之旅关于数据结构" class="headerlink" title="面试之旅关于数据结构"></a>面试之旅关于数据结构</h1><p><strong><span class="exturl" data-url="aHR0cDovL2RhdGEuYmlhbmNoZW5nLm5ldC9pbnRyby8=">数据结构详细讲解</span></strong></p>
<p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p>
<h2 id="数据结构中的逻辑结构"><a href="#数据结构中的逻辑结构" class="headerlink" title="数据结构中的逻辑结构"></a>数据结构中的逻辑结构</h2><blockquote>
<p>集合结构</p>
</blockquote>
<p>集合结构的里面的元素关系是孤立的</p>
<img data-src="/blog/posts/9f9a6182/2022-02-16-21-37-01.png" class="">

<blockquote>
<p>线性结构</p>
</blockquote>
<p>线性结构里面的元素关系：一对一</p>
<img data-src="/blog/posts/9f9a6182/2022-02-16-21-37-13.png" class="">


<blockquote>
<p>树形结构</p>
</blockquote>
<p>树形结构里面的元素关系：一对多</p>
<img data-src="/blog/posts/9f9a6182/2022-02-16-21-37-28.png" class="">


<blockquote>
<p>图结构</p>
</blockquote>
<p>图结构里面的元素关系：多对多</p>
<img data-src="/blog/posts/9f9a6182/2022-02-16-21-37-47.png" class="">

<h2 id="数据结构的物理结构"><a href="#数据结构的物理结构" class="headerlink" title="数据结构的物理结构"></a>数据结构的物理结构</h2><p>物理结构:是指数据的逻辑结构在计算机中的存储形式。存储结构有两种：</p>
<blockquote>
<p>顺序存储结构：</p>
</blockquote>
<p>顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</p>
<img data-src="/blog/posts/9f9a6182/2022-02-16-21-37-57.png" class="">

<blockquote>
<p>链式存储结构</p>
</blockquote>
<p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</p>
<img data-src="/blog/posts/9f9a6182/2022-02-16-21-38-04.png" class="">


<h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2><ul>
<li><p>数组（<code>Array</code>）</p>
</li>
<li><p>堆栈（<code>Stack</code>）</p>
</li>
<li><p>队列（<code>Queue</code>）</p>
</li>
<li><p>链表（<code>Linked List</code>）</p>
</li>
<li><p>树（<code>Tree</code>）</p>
</li>
<li><p>图（<code>Graph</code>）</p>
</li>
<li><p>堆（<code>Heap</code>）</p>
</li>
<li><p>散列表（<code>Hash</code>）</p>
</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种数据结构，和数组同级。比如，<code>Java</code>中我们使用的<code>ArrayList</code>，其实现原理是数组。而<code>LinkedList</code>的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。下面对单向链表做一个介绍。</p>
<p>单向链表是一种线性表，实际上是由节点（<code>Node</code>）组成的，一个链表拥有不定数量的节点。其数据在内存中存储是不连续的，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由N各节点（<code>Node</code>）组成单向链表，每一个<code>Node</code>记录本<code>Node</code>的数据及下一个<code>Node</code>。向外暴露的只有一个头节点（<code>Head</code>），我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。</p>
<img data-src="/blog/posts/9f9a6182/2022-02-16-21-38-15.png" class="">

<p>上图中最左边的节点即为头结点（<code>Head</code>），但是添加节点的顺序是从右向左的，添加的新节点会被作为新节点。最先添加的节点对下一节点的引用可以为空。引用是引用下一个节点而非下一个节点的对象。因为有着不断的引用，所以头节点就可以操作所有节点了。</p>
<p>下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成了一个单向链表。</p>
<img data-src="/blog/posts/9f9a6182/2022-02-16-21-38-25.png" class="">

<p>节点（<code>Node</code>）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。下面图是具体的说明：</p>
<img data-src="/blog/posts/9f9a6182/2022-02-16-21-38-31.png" class="">

<blockquote>
<p>单链表实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjn.LinkAndQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义链表设计</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zjn</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLink</span> </span>&#123;</span><br><span class="line">    Node head = <span class="keyword">null</span>; <span class="comment">// 头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表中的节点，data代表节点的值，next是指向下一个节点的引用</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> zjn</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node next = <span class="keyword">null</span>;<span class="comment">// 节点的引用，指向下一个节点</span></span><br><span class="line">        <span class="keyword">int</span> data;<span class="comment">// 节点的对象，即内容</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向链表中插入数据</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> d</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(d);<span class="comment">// 实例化一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index:删除第index个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        Node preNode = head;</span><br><span class="line">        Node curNode = preNode.next;</span><br><span class="line">        <span class="keyword">while</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">                preNode.next = curNode.next;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            preNode = curNode;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回节点长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在不知道头指针的情况下删除指定节点</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteNode11</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span> || n.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = n.data;</span><br><span class="line">        n.data = n.next.data;</span><br><span class="line">        n.next.data = tmp;</span><br><span class="line">        n.next = n.next.next;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(tmp.data);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLink list = <span class="keyword">new</span> MyLink();</span><br><span class="line">        list.addNode(<span class="number">5</span>);</span><br><span class="line">        list.addNode(<span class="number">3</span>);</span><br><span class="line">        list.addNode(<span class="number">1</span>);</span><br><span class="line">        list.addNode(<span class="number">2</span>);</span><br><span class="line">        list.addNode(<span class="number">55</span>);</span><br><span class="line">        list.addNode(<span class="number">36</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;linkLength:&quot;</span> + list.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;head.data:&quot;</span> + list.head.data);</span><br><span class="line">        list.printList();</span><br><span class="line">        list.deleteNode(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After deleteNode(4):&quot;</span>);</span><br><span class="line">        list.printList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>非线性存储结构</p>
<img data-src="/blog/posts/9f9a6182/2022-02-16-21-38-44.png" class="">

<p><span class="exturl" data-url="aHR0cDovL2RhdGEuYmlhbmNoZW5nLm5ldC92aWV3LzIzLmh0bWw=">树的详细讲解</span></p>
]]></content>
      <categories>
        <category>Java面试</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA快捷键</title>
    <url>/blog/posts/610bdf07/</url>
    <content><![CDATA[<h1 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a><code>IDEA</code>快捷键</h1><h2 id="Ctrl快捷键"><a href="#Ctrl快捷键" class="headerlink" title="Ctrl快捷键"></a><code>Ctrl</code>快捷键</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Ctrl + F 在当前文件进行文本查找 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + R 在当前文件进行文本替换 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Z 撤销 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Y 删除光标所在行 或 删除选中的行 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + X 剪切光标所在行 或 剪切选择内容</span><br><span class="line"></span><br><span class="line">Ctrl + C 复制光标所在行 或 复制选择内容</span><br><span class="line"></span><br><span class="line">Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围（必备）</span><br><span class="line"></span><br><span class="line">Ctrl + E 显示最近打开的文件记录列表 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + N 根据输入的 名/类名 查找类文件 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + G 在当前文件跳转到指定行处</span><br><span class="line"></span><br><span class="line">Ctrl + J 插入自定义动态代码模板 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + P 方法参数提示显示 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Q 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</span><br><span class="line"></span><br><span class="line">Ctrl + U 前往当前光标所在的方法的父类的方法 / 接口定义 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + B 进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用</span><br><span class="line"></span><br><span class="line">Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用</span><br><span class="line"></span><br><span class="line">Ctrl + H 显示当前类的层次结构</span><br><span class="line"></span><br><span class="line">Ctrl + O 选择可重写的方法</span><br><span class="line"></span><br><span class="line">Ctrl + I 选择可继承的方法</span><br><span class="line"></span><br><span class="line">Ctrl + + 展开代码</span><br><span class="line"></span><br><span class="line">Ctrl + - 折叠代码</span><br><span class="line"></span><br><span class="line">Ctrl + / 释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + [  移动光标到当前所在代码的花括号开始位置</span><br><span class="line"></span><br><span class="line">Ctrl + ] 移动光标到当前所在代码的花括号结束位置</span><br><span class="line"></span><br><span class="line">Ctrl + F1 在光标所在的错误代码处显示错误信息 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + F3 调转到所选中的词的下一个引用位置 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + F4 关闭当前编辑文件</span><br><span class="line"></span><br><span class="line">Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</span><br><span class="line"></span><br><span class="line">Ctrl + F9 执行 Make Project 操作</span><br><span class="line"></span><br><span class="line">Ctrl + F11 选中文件 / 文件夹，使用助记符设定 / 取消书签 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</span><br><span class="line"></span><br><span class="line">Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上 delete，则是关闭对应选中的窗口</span><br><span class="line"></span><br><span class="line">Ctrl + End 跳到文件尾</span><br><span class="line"></span><br><span class="line">Ctrl + Home 跳到文件头</span><br><span class="line"></span><br><span class="line">Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl +逗号 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Delete 删除光标后面的单词或是中文句 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + BackSpace 删除光标前面的单词或是中文句 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + <span class="number">1</span>,<span class="number">2</span>,<span class="number">3.</span>.<span class="number">.9</span> 定位到对应数值的书签位置 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + 光标定位按 Ctrl 不要松开，会显示光标所在的类信息摘要</span><br><span class="line"></span><br><span class="line">Ctrl + 左方向键 光标跳转到当前单词 / 中文句的左侧开头位置 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + 右方向键 光标跳转到当前单词 / 中文句的右侧开头位置 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + 前方向键 等效于鼠标滚轮向前效果 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + 后方向键 等效于鼠标滚轮向后效果 （必备）</span><br></pre></td></tr></table></figure>

<h2 id="Alt快捷键"><a href="#Alt快捷键" class="headerlink" title="Alt快捷键"></a><code>Alt</code>快捷键</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Alt + 显示版本控制常用操作菜单弹出层 （必备）</span><br><span class="line"></span><br><span class="line">Alt + Q 弹出一个提示，显示当前类的声明 / 上下文信息</span><br><span class="line"></span><br><span class="line">Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 （必备）</span><br><span class="line"></span><br><span class="line">Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层</span><br><span class="line"></span><br><span class="line">Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示</span><br><span class="line"></span><br><span class="line">Alt + F7 查找光标所在的方法 / 变量 / 类被调用的地方</span><br><span class="line"></span><br><span class="line">Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</span><br><span class="line"></span><br><span class="line">Alt + Home 定位 / 显示到当前文件的 Navigation Bar</span><br><span class="line"></span><br><span class="line">Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示 的结果也不同 （必备）</span><br><span class="line"></span><br><span class="line">Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 （必备）</span><br><span class="line"></span><br><span class="line">Alt + 左方向键 切换当前已打开的窗口中的子视图，比如 Debug 窗口中有 Output、Debugger 等子视图，用此快捷键就可以在子视图中切换 （必备）</span><br><span class="line"></span><br><span class="line">Alt + 右方向键 按切换当前已打开的窗口中的子视图，比如 Debug 窗口中有 Output、Debugger 等子视图，用此快捷键就可以在子视图中切换 （必备）</span><br><span class="line"></span><br><span class="line">Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置 （必备）</span><br><span class="line"></span><br><span class="line">Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置 （必备）</span><br><span class="line"></span><br><span class="line">Alt + <span class="number">1</span>,<span class="number">2</span>,<span class="number">3.</span>.<span class="number">.9</span> 显示对应数值的选项卡，其中 <span class="number">1</span> 是 Project 用得最多 （必备）</span><br></pre></td></tr></table></figure>

<h2 id="Shift快捷键"><a href="#Shift快捷键" class="headerlink" title="Shift快捷键"></a><code>Shift</code>快捷键</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Shift + F1 如果有外部文档可以连接外部文档</span><br><span class="line"></span><br><span class="line">Shift + F2 跳转到上一个高亮错误 或 警告位置</span><br><span class="line"></span><br><span class="line">Shift + F3 在查找模式下，查找匹配上一个</span><br><span class="line"></span><br><span class="line">Shift + F4 对当前打开的文件，使用新 Windows 窗口打开，旧窗口保留</span><br><span class="line"></span><br><span class="line">Shift + F6 对文件 / 文件夹 重命名</span><br><span class="line"></span><br><span class="line">Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</span><br><span class="line"></span><br><span class="line">Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</span><br><span class="line"></span><br><span class="line">Shift + F9 等效于点击工具栏的 Debug 按钮</span><br><span class="line"></span><br><span class="line">Shift + F10 等效于点击工具栏的 Run 按钮</span><br><span class="line"></span><br><span class="line">Shift + F11 弹出书签显示层 （必备）</span><br><span class="line"></span><br><span class="line">Shift + Tab 取消缩进 （必备）</span><br><span class="line"></span><br><span class="line">Shift + ESC 隐藏当前 或 最后一个激活的工具窗口</span><br><span class="line"></span><br><span class="line">Shift + End 选中光标到当前行尾位置</span><br><span class="line"></span><br><span class="line">Shift + Home 选中光标到当前行头位置</span><br><span class="line"></span><br><span class="line">Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置 （必备）</span><br><span class="line"></span><br><span class="line">Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件 （必备）</span><br><span class="line"></span><br><span class="line">Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动 （必备）</span><br></pre></td></tr></table></figure>

<h2 id="Ctrl-Alt-快捷键"><a href="#Ctrl-Alt-快捷键" class="headerlink" title="Ctrl + Alt 快捷键"></a><code>Ctrl + Alt 快捷键</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + J 弹出模板选择窗口，将选定的代码加入动态模板中</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + H 调用层次</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + V 快速引进变量</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + Y 同步、刷新</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + F11 切换全屏模式</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + Space 类名自动完成</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件</span><br><span class="line"></span><br><span class="line">Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件</span><br></pre></td></tr></table></figure>

<h2 id="Ctrl-Shift快捷键"><a href="#Ctrl-Shift快捷键" class="headerlink" title="Ctrl + Shift快捷键"></a><code>Ctrl + Shift</code>快捷键</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + Z 取消撤销 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在 输入的内容后面多加一个正斜杠 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + V 弹出缓存的最近拷贝的内容管理器弹出层</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + E 显示最近修改的文件列表的弹出层</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + H 显示方法层次结构</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + B 跳转到类型声明处 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + I 快速查看光标所在的方法 或 类的定义</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + A 查找动作 / 设置</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + / 代码块注释 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + [ 选中从光标所在位置到它的顶部中括号位置 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + ] 选中从光标所在位置到它的底部中括号位置 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + + 展开所有代码 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + - 折叠所有代码 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + F7 高亮显示所有该选中文本，按 Esc 高亮消失 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + F9 编译选中的文件 / 包 / Module</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + F12 编辑器最大化 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + Space 智能代码提示</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift +Backspace 退回到上次修改的地方 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + <span class="number">1</span>,<span class="number">2</span>,<span class="number">3.</span>.<span class="number">.9</span>  快速添加指定数值的书签 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + 左键单击 把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + 左方向键 在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句（必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句（必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序（必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句（必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法 排序 （必备）</span><br></pre></td></tr></table></figure>

<h2 id="Alt-Shift-快捷键"><a href="#Alt-Shift-快捷键" class="headerlink" title="Alt + Shift 快捷键"></a><code>Alt + Shift 快捷键</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Alt + Shift + N 选择 / 添加 task （必备）</span><br><span class="line"></span><br><span class="line">Alt + Shift + F 显示添加到收藏夹弹出层 / 添加到收藏夹</span><br><span class="line"></span><br><span class="line">Alt + Shift + C 查看最近操作项目的变化情况列表</span><br><span class="line"></span><br><span class="line">Alt + Shift + I 查看项目当前文件</span><br><span class="line"></span><br><span class="line">Alt + Shift + F7  在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</span><br><span class="line"></span><br><span class="line">Alt + Shift + F9 弹出 Debug 的可选择菜单</span><br><span class="line"></span><br><span class="line">Alt + Shift + F10 弹出 Run 的可选择菜单</span><br><span class="line"></span><br><span class="line">Alt + Shift + 左键双击 选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 （必备）</span><br><span class="line"></span><br><span class="line">Alt + Shift + 前方向键 移动光标所在行向上移动 （必备）</span><br><span class="line"></span><br><span class="line">Alt + Shift + 后方向键 移动光标所在行向下移动 （必备）</span><br></pre></td></tr></table></figure>

<h2 id="Ctrl-Shift-Alt-快捷键"><a href="#Ctrl-Shift-Alt-快捷键" class="headerlink" title="Ctrl + Shift + Alt 快捷键"></a><code>Ctrl + Shift + Alt</code> 快捷键</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Ctrl + Shift + Alt + V 无格式黏贴 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + Alt + N 前往指定的变量 / 方法</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + Alt + S 打开当前项目设置 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + Alt + C 复制参考信息</span><br></pre></td></tr></table></figure>

<h2 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a><code>其他快捷键</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">F2 跳转到下一个高亮错误 或 警告位置 （必备）</span><br><span class="line"></span><br><span class="line">F3 在查找模式下，定位到下一个匹配处</span><br><span class="line"></span><br><span class="line">F4 编辑源 （必备）</span><br><span class="line"></span><br><span class="line">F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</span><br><span class="line"></span><br><span class="line">F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</span><br><span class="line"></span><br><span class="line">F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</span><br><span class="line"></span><br><span class="line">F11 添加书签 （必备）</span><br><span class="line"></span><br><span class="line">F12 回到前一个工具窗口 （必备）</span><br><span class="line"></span><br><span class="line">Tab 缩进 （必备）</span><br><span class="line"></span><br><span class="line">ESC 从工具窗口进入代码文件窗口 （必备）连按两次Shift 弹出 Search Everywhere 弹出层</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="IntelliJ-IDEA-快捷键大全-Mac"><a href="#IntelliJ-IDEA-快捷键大全-Mac" class="headerlink" title="IntelliJ IDEA 快捷键大全 Mac"></a><code>IntelliJ IDEA</code> 快捷键大全 <code>Mac</code></h1><h2 id="Mac键盘符号和修饰键说明"><a href="#Mac键盘符号和修饰键说明" class="headerlink" title="Mac键盘符号和修饰键说明"></a><code>Mac</code>键盘符号和修饰键说明</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">⌘ Command</span><br><span class="line"></span><br><span class="line">⇧ Shift</span><br><span class="line"></span><br><span class="line">⌥ Option</span><br><span class="line"></span><br><span class="line">⌃ Control</span><br><span class="line"></span><br><span class="line">↩︎ Return/Enter</span><br><span class="line"></span><br><span class="line">⌫ Delete</span><br><span class="line"></span><br><span class="line">⌦ 向前删除键（Fn+Delete）</span><br><span class="line"></span><br><span class="line">↑ 上箭头</span><br><span class="line"></span><br><span class="line">↓ 下箭头</span><br><span class="line"></span><br><span class="line">← 左箭头</span><br><span class="line"></span><br><span class="line">→ 右箭头</span><br><span class="line"></span><br><span class="line">⇞ Page Up（Fn+↑）</span><br><span class="line"></span><br><span class="line">⇟ Page Down（Fn+↓）</span><br><span class="line"></span><br><span class="line">Home Fn + ←</span><br><span class="line"></span><br><span class="line">End Fn + →</span><br><span class="line"></span><br><span class="line">⇥ 右制表符（Tab键）</span><br><span class="line"></span><br><span class="line">⇤ 左制表符（Shift+Tab）</span><br><span class="line"></span><br><span class="line">⎋ Escape (Esc)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Editing（编辑）"><a href="#Editing（编辑）" class="headerlink" title="Editing（编辑）"></a><code>Editing</code>（编辑）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">⌃Space 基本的代码补全（补全任何类、方法、变量）</span><br><span class="line"></span><br><span class="line">⌃⇧Space 智能代码补全（过滤器方法列表和变量的预期类型）</span><br><span class="line"></span><br><span class="line">⌘⇧↩ 自动结束代码，行末自动添加分号</span><br><span class="line"></span><br><span class="line">⌘P 显示方法的参数信息</span><br><span class="line"></span><br><span class="line">⌃J, Mid. button click 快速查看文档</span><br><span class="line"></span><br><span class="line">⇧F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档）</span><br><span class="line"></span><br><span class="line">⌘+鼠标放在代码上 显示代码简要信息</span><br><span class="line"></span><br><span class="line">⌘F1 在错误或警告处显示具体描述信息</span><br><span class="line"></span><br><span class="line">⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、</span><br><span class="line"></span><br><span class="line">hashCode/equals,toString）</span><br><span class="line"></span><br><span class="line">⌃O 覆盖方法（重写父类方法）</span><br><span class="line"></span><br><span class="line">⌃I 实现方法（实现接口中的方法）</span><br><span class="line"></span><br><span class="line">⌘⌥T 包围代码（使用<span class="keyword">if</span>..<span class="keyword">else</span>, <span class="keyword">try</span>..<span class="keyword">catch</span>, <span class="keyword">for</span>, <span class="keyword">synchronized</span>等包围 选中的代码）</span><br><span class="line"></span><br><span class="line">⌘/ 注释/取消注释与行注释</span><br><span class="line"></span><br><span class="line">⌘⌥/ 注释/取消注释与块注释</span><br><span class="line"></span><br><span class="line">⌥↑ 连续选中代码块</span><br><span class="line"></span><br><span class="line">⌥↓ 减少当前选中的代码块</span><br><span class="line"></span><br><span class="line">⌃⇧Q 显示上下文信息</span><br><span class="line"></span><br><span class="line">⌥↩ 显示意向动作和快速修复代码</span><br><span class="line"></span><br><span class="line">⌘⌥L 格式化代码</span><br><span class="line"></span><br><span class="line">⌃⌥O 优化<span class="keyword">import</span></span><br><span class="line"></span><br><span class="line">⌃⌥I 自动缩进线</span><br><span class="line"></span><br><span class="line">⇥ / ⇧⇥ 缩进代码 / 反缩进代码</span><br><span class="line"></span><br><span class="line">⌘X 剪切当前行或选定的块到剪贴板</span><br><span class="line"></span><br><span class="line">⌘C 复制当前行或选定的块到剪贴板</span><br><span class="line"></span><br><span class="line">⌘V 从剪贴板粘贴</span><br><span class="line"></span><br><span class="line">⌘⇧V 从最近的缓冲区粘贴</span><br><span class="line"></span><br><span class="line">⌘D 复制当前行或选定的块</span><br><span class="line"></span><br><span class="line">⌘⌫ 删除当前行或选定的块的行</span><br><span class="line"></span><br><span class="line">⌃⇧J 智能的将代码拼接成一行</span><br><span class="line"></span><br><span class="line">⌘↩ 智能的拆分拼接的行</span><br><span class="line"></span><br><span class="line">⇧↩ 开始新的一行</span><br><span class="line"></span><br><span class="line">⌘⇧U 大小写切换</span><br><span class="line"></span><br><span class="line">⌘⇧] / ⌘⇧[ 选择直到代码块结束/开始</span><br><span class="line"></span><br><span class="line">⌥⌦ 删除到单词的末尾（⌦键为Fn+Delete）</span><br><span class="line"></span><br><span class="line">⌥⌫ 删除到单词的开头</span><br><span class="line"></span><br><span class="line">⌘+ / ⌘- 展开 / 折叠代码块</span><br><span class="line"></span><br><span class="line">⌘⇧+ 展开所以代码块</span><br><span class="line"></span><br><span class="line">⌘⇧- 折叠所有代码块</span><br><span class="line"></span><br><span class="line">⌘W 关闭活动的编辑器选项卡</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Search-Replace（查询-替换）"><a href="#Search-Replace（查询-替换）" class="headerlink" title="Search/Replace（查询/替换）"></a><code>Search/Replace</code>（查询/替换）</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Double ⇧ 查询任何东西</span><br><span class="line"></span><br><span class="line">⌘F 文件内查找</span><br><span class="line"></span><br><span class="line">⌘G 查找模式下，向下查找</span><br><span class="line"></span><br><span class="line">⌘⇧G 查找模式下，向上查找</span><br><span class="line"></span><br><span class="line">⌘<span class="built_in">R</span> 文件内替换</span><br><span class="line"></span><br><span class="line">⌘⇧F 全局查找（根据路径）</span><br><span class="line"></span><br><span class="line">⌘⇧<span class="built_in">R</span> 全局替换（根据路径）</span><br><span class="line"></span><br><span class="line">⌘⇧S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置）</span><br><span class="line"></span><br><span class="line">⌘⇧M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置）</span><br></pre></td></tr></table></figure>

<h2 id="Usage-Search（使用查询）"><a href="#Usage-Search（使用查询）" class="headerlink" title="Usage Search（使用查询）"></a><code>Usage Search（使用查询）</code></h2><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">⌥<span class="built_in">F7</span> / ⌘<span class="built_in">F7</span> 在文件中查找用法 / 在类中查找用法</span><br><span class="line"></span><br><span class="line">⌘⇧<span class="built_in">F7</span> 在文件中突出显示的用法</span><br><span class="line"></span><br><span class="line">⌘⌥<span class="built_in">F7</span> 显示用法</span><br></pre></td></tr></table></figure>

<h2 id="Compile-and-Run（编译和运行）"><a href="#Compile-and-Run（编译和运行）" class="headerlink" title="Compile and Run（编译和运行）"></a><code>Compile and Run（编译和运行）</code></h2><figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">⌘<span class="variable">F9</span> 编译<span class="variable">Project</span></span><br><span class="line"></span><br><span class="line">⌘⇧<span class="variable">F9</span> 编译选择的文件、包或模块</span><br><span class="line"></span><br><span class="line">⌃⌥<span class="variable">R</span> 弹出 <span class="built_in">Run</span> 的可选择菜单</span><br><span class="line"></span><br><span class="line">⌃⌥<span class="built_in">D</span> 弹出 <span class="built_in">Debug</span> 的可选择菜单</span><br><span class="line"></span><br><span class="line">⌃<span class="variable">R</span> 运行</span><br><span class="line"></span><br><span class="line">⌃<span class="built_in">D</span> 调试</span><br><span class="line"></span><br><span class="line">⌃⇧<span class="variable">R</span><span class="operator">,</span> ⌃⇧<span class="built_in">D</span> 从编辑器运行上下文环境配置</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Debugging（调试）"><a href="#Debugging（调试）" class="headerlink" title="Debugging（调试）"></a><code>Debugging</code>（调试）</h2><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">F8</span> 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</span><br><span class="line"></span><br><span class="line"><span class="symbol">F7</span> 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该</span><br><span class="line"></span><br><span class="line">方法体还有方法，则不会进入该内嵌的方法中</span><br><span class="line"></span><br><span class="line">⇧<span class="built_in">F7</span> 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法</span><br><span class="line"></span><br><span class="line">⇧F8 跳出</span><br><span class="line"></span><br><span class="line">⌥F9 运行到光标处，如果光标前有其他断点会进入到该断点</span><br><span class="line"></span><br><span class="line">⌥F8 计算表达式（可以更改变量值使其生效）</span><br><span class="line"></span><br><span class="line">⌘⌥R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上</span><br><span class="line"></span><br><span class="line">⌘F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点）</span><br><span class="line"></span><br><span class="line">⌘⇧F8 查看断点信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Navigation（导航）"><a href="#Navigation（导航）" class="headerlink" title="Navigation（导航）"></a><code>Navigation（导航）</code></h2><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">⌘O 查找类文件</span><br><span class="line"></span><br><span class="line">⌘⇧O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/</span><br><span class="line"></span><br><span class="line">⌘⌥O 前往指定的变量 / 方法</span><br><span class="line"></span><br><span class="line">⌃← / ⌃→ 左右切换打开的编辑tab页</span><br><span class="line"></span><br><span class="line"><span class="symbol">F12</span> 返回到前一个工具窗口</span><br><span class="line"></span><br><span class="line">⎋ 从工具窗口进入代码文件窗口</span><br><span class="line"></span><br><span class="line">⇧⎋ 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口</span><br><span class="line"></span><br><span class="line">⌘⇧<span class="built_in">F4</span> 关闭活动run/messages/find/... tab</span><br><span class="line"></span><br><span class="line">⌘L 在当前文件跳转到某一行的指定处</span><br><span class="line"></span><br><span class="line">⌘E 显示最近打开的文件记录列表</span><br><span class="line"></span><br><span class="line">⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方</span><br><span class="line"></span><br><span class="line">⌘⇧⌫ 跳转到最后一个编辑的地方</span><br><span class="line"></span><br><span class="line">⌥<span class="built_in">F1</span> 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在 代码编辑窗口可以选择显示该文件的Finder)</span><br><span class="line"></span><br><span class="line">⌘<span class="keyword">B</span> / ⌘ 鼠标点击 进入光标所在的方法/变量的接口或是定义处</span><br><span class="line"></span><br><span class="line">⌘⌥<span class="keyword">B</span> 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</span><br><span class="line"></span><br><span class="line">⌥ <span class="meta">Space</span>, ⌘Y 快速打开光标所在方法、类的定义</span><br><span class="line"></span><br><span class="line">⌃⇧<span class="keyword">B</span> 跳转到类型声明处</span><br><span class="line"></span><br><span class="line">⌘U 前往当前光标所在方法的父类的方法 / 接口定义</span><br><span class="line"></span><br><span class="line">⌃↓ / ⌃↑ 当前光标跳转到当前文件的前一个/后一个方法名位置</span><br><span class="line"></span><br><span class="line">⌘] / ⌘[ 移动光标到当前所在代码的花括号开始/结束位置</span><br><span class="line"></span><br><span class="line">⌘F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）</span><br><span class="line"></span><br><span class="line">⌃H 显示当前类的层次结构</span><br><span class="line"></span><br><span class="line">⌘⇧H 显示方法层次结构</span><br><span class="line"></span><br><span class="line">⌃⌥H 显示调用层次结构</span><br><span class="line"></span><br><span class="line"><span class="symbol">F2</span> / ⇧<span class="built_in">F2</span> 跳转到下一个/上一个突出错误或警告的位置</span><br><span class="line"></span><br><span class="line"><span class="symbol">F4</span> / ⌘↓ 编辑/查看代码源</span><br><span class="line"></span><br><span class="line">⌥ Home 显示到当前文件的导航条</span><br><span class="line"></span><br><span class="line"><span class="symbol">F3</span>选中文件/文件夹/代码行，添加/取消书签</span><br><span class="line"></span><br><span class="line">⌥<span class="built_in">F3</span> 选中文件/文件夹/代码行，使用助记符添加/取消书签</span><br><span class="line"></span><br><span class="line">⌃<span class="number">0</span>...⌃<span class="number">9</span> 定位到对应数值的书签位置</span><br><span class="line"></span><br><span class="line">⌘<span class="built_in">F3</span> 显示所有书签</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Refactoring（重构）"><a href="#Refactoring（重构）" class="headerlink" title="Refactoring（重构）"></a><code>Refactoring（重构）</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">F5 复制文件到指定目录</span><br><span class="line"></span><br><span class="line">F6 移动文件到指定目录</span><br><span class="line"></span><br><span class="line">⌘⌫ 在文件上为安全删除文件，弹出确认框</span><br><span class="line"></span><br><span class="line">⇧F6 重命名文件</span><br><span class="line"></span><br><span class="line">⌘F6 更改签名</span><br><span class="line"></span><br><span class="line">⌘⌥N 一致性</span><br><span class="line"></span><br><span class="line">⌘⌥M 将选中的代码提取为方法</span><br><span class="line"></span><br><span class="line">⌘⌥V 提取变量</span><br><span class="line"></span><br><span class="line">⌘⌥F 提取字段</span><br><span class="line"></span><br><span class="line">⌘⌥C 提取常量</span><br><span class="line"></span><br><span class="line">⌘⌥P 提取参数</span><br></pre></td></tr></table></figure>

<h2 id="VCS-Local-History（版本控制-本地历史记录）"><a href="#VCS-Local-History（版本控制-本地历史记录）" class="headerlink" title="VCS/Local History（版本控制/本地历史记录）"></a><code>VCS/Local History</code>（版本控制/本地历史记录）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">⌘K 提交代码到版本控制器</span><br><span class="line"></span><br><span class="line">⌘T 从版本控制器更新代码</span><br><span class="line"></span><br><span class="line">⌥⇧C 查看最近的变更记录</span><br><span class="line"></span><br><span class="line">⌃C 快速弹出版本控制器操作面板</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Live-Templates（动态代码模板）"><a href="#Live-Templates（动态代码模板）" class="headerlink" title="Live Templates（动态代码模板）"></a><code>Live Templates（动态代码模板）</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">⌘⌥J 弹出模板选择窗口，将选定的代码使用动态模板包住</span><br><span class="line"></span><br><span class="line">⌘J 插入自定义动态代码模板</span><br></pre></td></tr></table></figure>

<h2 id="General（通用）"><a href="#General（通用）" class="headerlink" title="General（通用）"></a><code>General（通用）</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">⌘<span class="number">1.</span>..⌘<span class="number">9</span> 打开相应编号的工具窗口</span><br><span class="line"></span><br><span class="line">⌘S 保存所有</span><br><span class="line"></span><br><span class="line">⌘⌥Y 同步、刷新</span><br><span class="line"></span><br><span class="line">⌃⌘F 切换全屏模式</span><br><span class="line"></span><br><span class="line">⌘⇧F12 切换最大化编辑器</span><br><span class="line"></span><br><span class="line">⌥⇧F 添加到收藏夹</span><br><span class="line"></span><br><span class="line">⌥⇧I 检查当前文件与当前的配置文件</span><br><span class="line"></span><br><span class="line">`§⌃, ⌃``快速切换当前的scheme（切换主题、代码样式等）</span><br><span class="line"></span><br><span class="line">⌘, 打开IDEA系统设置</span><br><span class="line"></span><br><span class="line">⌘; 打开项目结构对话框</span><br><span class="line"></span><br><span class="line">⇧⌘A 查找动作（可设置相关选项）</span><br><span class="line"></span><br><span class="line">⌃⇥ 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口）</span><br><span class="line"></span><br><span class="line">Other（一些官方文档上没有体现的快捷键）</span><br><span class="line">⌘⇧<span class="number">8</span> 竖编辑模式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">⌘O 查找类文件 Ctrl + N</span><br><span class="line"></span><br><span class="line">⌘⌥O 前往指定的变量 / 方法 Ctrl + Shift + Alt + N</span><br><span class="line"></span><br><span class="line">⌃← / ⌃→ 左右切换打开的编辑tab页 Alt← / Alt→</span><br><span class="line"></span><br><span class="line">⎋ 从工具窗口进入代码文件窗口 ESC</span><br><span class="line"></span><br><span class="line">⌘L 在当前文件跳转到某一行的指定处 Ctrl + G</span><br><span class="line"></span><br><span class="line">⌘E 显示最近打开的文件记录列表 Ctrl + E</span><br><span class="line"></span><br><span class="line">⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方 Ctrl + Alt + ← Ctrl + Alt + →</span><br><span class="line"></span><br><span class="line">⌘⇧⌫ 跳转到最后一个编辑的地方</span><br><span class="line"></span><br><span class="line">⌃H 显示当前类的层次结构 Ctrl + H</span><br><span class="line"></span><br><span class="line">⌘⇧H 显示方法层次结构</span><br><span class="line"></span><br><span class="line">⌃⌥H 显示调用层次结构</span><br><span class="line"></span><br><span class="line">F4 / ⌘↓ 编辑/查看代码源</span><br><span class="line"></span><br><span class="line">⌘⌥U 显示类UML图</span><br><span class="line"></span><br><span class="line">⌃J 查看注释</span><br></pre></td></tr></table></figure>

<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">⌥⌦ 删除到单词的末尾（⌦键为Fn+Delete）</span><br><span class="line"></span><br><span class="line">⌥⌫ 删除到单词的开头</span><br><span class="line"></span><br><span class="line">⌘+ / ⌘- 展开 / 折叠代码块</span><br><span class="line"></span><br><span class="line">⌘F1 在错误或警告处显示具体描述信息</span><br><span class="line"></span><br><span class="line">⌘⌥L 格式化代码</span><br><span class="line"></span><br><span class="line">⌃⌥O 优化<span class="keyword">import</span></span><br><span class="line"></span><br><span class="line">⇧↩ 开始新的一行</span><br><span class="line"></span><br><span class="line">⌘⇧↩ 自动结束代码，行末自动添加分号</span><br><span class="line"></span><br><span class="line">⌃I 实现方法（实现接口中的方法）</span><br><span class="line"></span><br><span class="line">⇧F6 重命名文件或者变量</span><br><span class="line"></span><br><span class="line">⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString）</span><br><span class="line"></span><br><span class="line">⌘P 显示方法的参数信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double⇧ 查找任何东西</span><br><span class="line"></span><br><span class="line">⌘⇧F 全局查找（根据路径）</span><br><span class="line"></span><br><span class="line">⌘F 文件内查找</span><br><span class="line"></span><br><span class="line">⌘G 查找模式下，向下查找</span><br><span class="line"></span><br><span class="line">⌘⇧G 查找模式下，向上查找</span><br><span class="line"></span><br><span class="line">⌘⌥B 跳转到接口的实现</span><br><span class="line"></span><br><span class="line">⌘U 查看接口定义</span><br><span class="line"></span><br><span class="line">⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方</span><br><span class="line"></span><br><span class="line">⌘B / ⌘ 鼠标点击 进入光标所在的方法/变量的接口或是定义处</span><br><span class="line"></span><br><span class="line">⌃⇧B 跳转到类型声明处</span><br><span class="line"></span><br><span class="line">⌥ Space, ⌘Y 快速打开光标所在方法、类的定义</span><br><span class="line"></span><br><span class="line">⌘O 查找类文件</span><br><span class="line"></span><br><span class="line">⌘⇧O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/</span><br><span class="line"></span><br><span class="line">F12 返回到前一个工具窗口</span><br><span class="line"></span><br><span class="line">⎋ 从工具窗口进入代码文件窗口</span><br><span class="line"></span><br><span class="line">⇧⎋ 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口</span><br><span class="line"></span><br><span class="line">F3选中文件/文件夹/代码行，添加/取消书签</span><br><span class="line"></span><br><span class="line">⌥F3 选中文件/文件夹/代码行，使用助记符添加/取消书签</span><br><span class="line"></span><br><span class="line">⌃<span class="number">0</span>…⌃<span class="number">9</span> 定位到对应数值的书签位置</span><br><span class="line"></span><br><span class="line">⌘F3 显示所有书签</span><br><span class="line"></span><br><span class="line">⌥F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)</span><br><span class="line"></span><br><span class="line">⌘F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">⌃⌘F 切换全屏模式</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK动态代理原理剖析(简洁版)</title>
    <url>/blog/posts/dfdc2005/</url>
    <content><![CDATA[<h2 id="动态代理两个实例-视频中学的"><a href="#动态代理两个实例-视频中学的" class="headerlink" title="动态代理两个实例(视频中学的)"></a>动态代理两个实例(视频中学的)</h2><p>动态代理在<code>Java</code>中有着广泛的应用，比如<code>Spring AOP、Hibernate</code>数据查询、测试框架的后端<code>mock、RPC</code>远程调用、<code>Java</code>注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。<br>本文主要介绍<code>Java</code>中两种常见的动态代理方式：<code>JDK</code>原生动态代理和<code>CGLIB</code>动态代理。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>本文将介绍的<code>Java</code>动态代理与设计模式中的代理模式有关，什么是代理模式呢？</p>
<span id="more"></span>

<p><strong>代理模式：</strong>给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。</p>
<p>代理模式角色分为 <code>3</code> 种：</p>
<ul>
<li><p><code>Subject（抽象主题角色）</code>：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</p>
</li>
<li><p><code>RealSubject（真实主题角色）</code>：真正实现业务逻辑的类；</p>
</li>
<li><p><code>Proxy（代理主题角色）</code>：用来代理和封装真实主题；</p>
</li>
</ul>
<p>代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层</p>
<img data-src="/blog/posts/dfdc2005/2022-03-14-17-42-04.png" class="">

<blockquote>
<p>代理模式按照职责（使用场景）来分类，至少可以分为以下几类：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、远程代理。 </span><br><span class="line"><span class="number">2</span>、虚拟代理。 </span><br><span class="line"><span class="number">3</span>、Copy-on-Write 代理。 </span><br><span class="line"><span class="number">4</span>、保护（Protect or Access）代理。 </span><br><span class="line"><span class="number">5</span>、Cache代理。 </span><br><span class="line"><span class="number">6</span>、防火墙（Firewall）代理。 </span><br><span class="line"><span class="number">7</span>、同步化（Synchronization）代理。 </span><br><span class="line"><span class="number">8</span>、智能引用（Smart Reference）代理等等。</span><br></pre></td></tr></table></figure>

<p>如果根据字节码的创建时机来分类，可以分为静态代理和动态代理：</p>
<ul>
<li>所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了。</li>
<li>而动态代理的源码是在程序运行期间由<code>JVM</code>根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件</li>
</ul>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>我们先通过实例来学习静态代理，然后理解静态代理的缺点，再来学习本文的主角：动态代理</p>
<p>编写一个接口 <code>UserService</code> ，以及该接口的一个实现类 <code>UserServiceImpl</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;查询 selectById&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新 update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将通过静态代理对 <code>UserServiceImpl</code> 进行功能增强，在调用 <code>select</code> 和 <code>update</code> 之前记录一些日志。写一个代理类 <code>UserServiceProxy</code>，代理类需要实现 <code>UserService</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserService proxy = <span class="keyword">new</span> UserServiceProxy(userServiceImpl);</span><br><span class="line"></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p>
<h4 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h4><p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。<br>1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p>
<pre><code>- 只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大
- 新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类
</code></pre>
<p>2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护</p>
<h3 id="如何改进？"><a href="#如何改进？" class="headerlink" title="如何改进？"></a>如何改进？</h3><p>当然是让代理类<strong>动态的生成</strong>啦，也就是动态代理。</p>
<p><strong>为什么类可以动态的生成？</strong></p>
<p>这就涉及到<code>Java</code>虚拟机的<strong>类加载机制</strong>了，推荐翻看《深入理解Java虚拟机》7.3节 类加载的过程。</p>
<p>Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下3件事情：</p>
<p>通过一个类的全限定名来获取定义此类的二进制字节流<br>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口</p>
<p>由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，获取类的二进制字节流（class字节码）就有很多途径：</p>
<p>从ZIP包获取，这是JAR、EAR、WAR等格式的基础<br>从网络中获取，典型的应用是 Applet<br>运行时计算生成，这种场景使用最多的是动态代理技术，在 java.lang.reflect.Proxy 类中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 *$Proxy 的代理类的二进制字节流<br>由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类<br>从数据库中获取等等</p>
<p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。</p>
<h3 id="常见的字节码操作类库"><a href="#常见的字节码操作类库" class="headerlink" title="常见的字节码操作类库"></a>常见的字节码操作类库</h3><p>这里有一些介绍：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vamF2YS1zb3VyY2UubmV0L29wZW4tc291cmNlL2J5dGVjb2RlLWxpYnJhcmllcw==">java-source.net/open-source…</span></p>
<h3 id="实现动态代理的思考方向"><a href="#实现动态代理的思考方向" class="headerlink" title="实现动态代理的思考方向"></a>实现动态代理的思考方向</h3><p>为了让生成的代理类与目标对象（真实主题角色）保持一致性，从现在开始将介绍以下两种最常见的方式：</p>
<ul>
<li>通过实现接口的方式 -&gt; <code>JDK</code>动态代理</li>
<li>通过继承类的方式 -&gt; <code>CGLIB</code>动态代理</li>
</ul>
<p>注：使用<code>ASM</code>对使用者要求比较高，使用<code>Javassist</code>会比较麻烦</p>
<h3 id="JDk动态代理"><a href="#JDk动态代理" class="headerlink" title="JDk动态代理"></a><code>JDk</code>动态代理</h3><p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code>，我们仍然通过案例来学习</p>
<p>编写一个调用逻辑处理器 <code>LogHandler</code> 类，提供日志增强功能，并实现 <code>InvocationHandler</code> 接口；在 <code>LogHandler</code> 中维护一个目标对象，这个对象是被代理的对象（真实主题角色）；在 <code>invoke</code> 方法中编写方法调用的逻辑处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jinmao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-03-14-10:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> LogHandler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理的对象，实际的方法执行者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法注入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy:代理类代理的真实代理对象com.sun.proxy.$Proxy0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method:我们所要调用某个对象真实的方法的Method对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args:指代代理对象方法传递的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">//调用target的method方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用invoke方法之前执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;log start time [%s] %n&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之后执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;log end time [%s] %n&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写客户端，获取动态生成的代理类的对象须借助 <code>Proxy</code> 类的 <code>newProxyInstance</code> 方法，具体步骤可见代码和注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.cy.learn.dynamic.proxy.utils.ProxyUtils;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@creator</span> jinmao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-03-14-13:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span></span><br><span class="line">        <span class="comment">// System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span></span><br><span class="line">        <span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class="line">        UserServiceImpl userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        <span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class="line">        LogHandler logHandler = <span class="keyword">new</span> LogHandler(userServiceImpl);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class="line"><span class="comment">           a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class="line"><span class="comment">           b.然后根据相应的字节码转换成对应的class，</span></span><br><span class="line"><span class="comment">           c.然后调用newInstance()创建代理实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line">        <span class="comment">// 调用代理的方法</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">        <span class="comment">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">        <span class="comment">//ProxyUtils.generateClassFile(userServiceImpl.getClass(), &quot;UserServiceProxy&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">log start time [Mon Mar <span class="number">14</span> <span class="number">18</span>:<span class="number">02</span>:<span class="number">11</span> CST <span class="number">2022</span>] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Mon Mar <span class="number">14</span> <span class="number">18</span>:<span class="number">02</span>:<span class="number">11</span> CST <span class="number">2022</span>] </span><br><span class="line">log start time [Mon Mar <span class="number">14</span> <span class="number">18</span>:<span class="number">02</span>:<span class="number">11</span> CST <span class="number">2022</span>] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Mon Mar <span class="number">14</span> <span class="number">18</span>:<span class="number">02</span>:<span class="number">11</span> CST <span class="number">2022</span>] </span><br></pre></td></tr></table></figure>
<p><code>InvocationHandler</code> 和 <code>Proxy</code> 的主要方法介绍如下：</p>
<p><strong><code>java.lang.reflect.InvocationHandler</code></strong></p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Object invoke(Object proxy, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>) 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</span></span><br></pre></td></tr></table></figure>

<p><strong><code>java.lang.reflect.Proxy</code></strong></p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">static InvocationHandler getInvocationHandler(Object proxy)  用于获取指定代理对象所关联的调用处理器<span class="keyword"></span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) 返回指定接口的代理类<span class="keyword"></span></span><br><span class="line"><span class="keyword">static</span> Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的<span class="built_in"> invoke </span>方法<span class="keyword"></span></span><br><span class="line"><span class="keyword">static</span> boolean isProxyClass(Class&lt;?&gt; cl) 返回 cl 是否为一个代理类</span><br></pre></td></tr></table></figure>
<h3 id="代理类的调用过程"><a href="#代理类的调用过程" class="headerlink" title="代理类的调用过程"></a>代理类的调用过程</h3><p>生成的代理类到底长什么样子呢？借助下面的工具类，把代理类保存下来再探个究竟</p>
<p>（通过设置环境变量<code>sun.misc.ProxyGenerator.saveGeneratedFiles=true</code>也可以保存代理类）</p>
<p>手写一个工具类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.ProxyGenerator;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@creator</span> jinmao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-03-14-13:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ProxyUtils</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将根据类信息动态生成的二进制字节码保存到硬盘中，默认的是clazz目录下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz: 需要生成动态代理类的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxyName: 为动态生成的代理类的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateClassFile</span><span class="params">(Class clazz, String proxyName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据类信息和提供的代理类名称，生成字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces());</span><br><span class="line">        String paths = clazz.getResource(<span class="string">&quot;.&quot;</span>).getPath();</span><br><span class="line">        System.out.println(paths);</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//保留到硬盘中</span></span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(paths + proxyName + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            out.write(classFile);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将这两行注释放开即可:</p>
<img data-src="/blog/posts/dfdc2005/2022-03-14-18-10-35.png" class="">

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">log start time [Mon Mar <span class="number">14</span> <span class="number">18</span>:<span class="number">25</span>:<span class="number">57</span> CST <span class="number">2022</span>] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Mon Mar <span class="number">14</span> <span class="number">18</span>:<span class="number">25</span>:<span class="number">57</span> CST <span class="number">2022</span>] </span><br><span class="line">log start time [Mon Mar <span class="number">14</span> <span class="number">18</span>:<span class="number">25</span>:<span class="number">57</span> CST <span class="number">2022</span>] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Mon Mar <span class="number">14</span> <span class="number">18</span>:<span class="number">25</span>:<span class="number">57</span> CST <span class="number">2022</span>] </span><br></pre></td></tr></table></figure>


<p><code>IDEA</code> 再次运行之后就可以在 <code>out</code> 的类路径下找到 <code>UserServiceProxy.class</code>，双击后<code>IDEA</code>的反编译插件会将该二进制<code>class</code>文件</p>
<img data-src="/blog/posts/dfdc2005/2022-03-14-18-12-41.png" class="">

<p><code>UserServiceProxy</code>的反编译代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cy.learn.dynamic.proxy.UserService;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">&quot;com.cy.learn.dynamic.proxy.UserService&quot;</span>).getMethod(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.cy.learn.dynamic.proxy.UserService&quot;</span>).getMethod(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中看一段我们自己的和新方法<code>select()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var2;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的<code>super</code>就是<code>extends</code>的<code>Proxy</code>类,我们来看<code>super</code>中的<code>h</code>到底是什么?</p>
<img data-src="/blog/posts/dfdc2005/2022-03-14-18-24-12.png" class="">

<p>而<code>super.h.invoke</code>方法即为我们手写的<code>LogHandler</code>中的<code>invoke</code>方法,所以日志才会打印</p>
<img data-src="/blog/posts/dfdc2005/2022-03-14-18-25-17.png" class="">

<blockquote>
<p>小总结</p>
</blockquote>
<p>从 <code>UserServiceProxy</code> 的代码中我们可以发现：</p>
<ul>
<li><code>UserServiceProxy</code> 继承了 <code>Proxy</code> 类，并且实现了被代理的所有接口，以及<code>equals、hashCode、toString</code>等方法</li>
<li>由于 <code>UserServiceProxy</code> 继承了 <code>Proxy</code> 类，所以每个代理类都会关联一个 <code>InvocationHandler</code> 方法调用处理器</li>
<li>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</li>
<li>每个方法都有一个 <code>Method</code> <code>对象来描述，Method</code> 对象在<code>static</code>静态代码块中创建，以<code> m + 数字</code> 的格式命名</li>
<li>调用方法的时候通过 <code>super.h.invoke(this, m1, (Object[])null)</code>; 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 <code>LogHandler</code> 对象，它继承 <code>InvocationHandler</code> 类，负责实际的调用处理逻辑</li>
</ul>
<p>而 <code>LogHandler</code> 的 <code>invoke</code> 方法接收到 <code>method、args</code> 等参数后，进行一些处理，然后通过反射让被代理的对象 <code>target</code> 执行方法</p>
<p>JDK动态代理执行方法调用的过程简图如下：</p>
<img data-src="/blog/posts/dfdc2005/2022-03-14-18-28-41.png" class="">


<h2 id="Proxy-newProxyInstance源码debug"><a href="#Proxy-newProxyInstance源码debug" class="headerlink" title="Proxy.newProxyInstance源码debug"></a><code>Proxy.newProxyInstance</code>源码<code>debug</code></h2><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回将方法调用分派到指定调用处理程序的指定接口的代理类的实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    <span class="comment">//复制一份传入的接口字节码对象数组</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找或生成指定的代理类</span></span><br><span class="line">    <span class="comment">//此处使用类加载器和接口生成一个Proxy子类字节码对象</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs); ------------------------------------&gt;  进入该核心方法</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用指定的调用处理程序调用其构造函数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取构造器对象和调用处理器</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用构造器和调用处理器创建proxy代理对象并返回</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span>  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入<code>getProxyClass0</code>方法：</p>
<img data-src="/blog/posts/dfdc2005/2022-03-14-22-06-24.png" class="">


<p>进入到<code>get</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过缓存查找值。如果给定的 (key, subKey) 对的缓存中没有条目或条目已被清除</span></span><br><span class="line"><span class="comment">// 则这始终评估subKeyFactory函数并可选地评估valueFactory函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(parameter);</span><br><span class="line"></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 惰性地为特定的cacheKey安装第二级值map</span></span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">            = map.putIfAbsent(cacheKey,</span><br><span class="line">                                valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            valuesMap = oldValuesMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建subKey并从valuesMap中检索由该subKey存储的可能的Supplier&lt;V&gt;</span></span><br><span class="line">    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    Factory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// supplier可以是一个Factory或者CacheValue&lt;V&gt;实例</span></span><br><span class="line">            V value = supplier.get(); -----------------------------------&gt;  进入该和新方法</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则缓存中没有供应商 </span></span><br><span class="line">        <span class="comment">//或返回null的供应商(可以是一个清除的CacheValue)</span></span><br><span class="line">        <span class="comment">//或一个工厂，没有成功安装CacheValue)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 懒惰地建造工厂</span></span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// successfully installed Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry with winning supplier</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                <span class="comment">// successfully replaced</span></span><br><span class="line">                <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span><br><span class="line">                <span class="comment">// with our Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// retry with current supplier</span></span><br><span class="line">                supplier = valuesMap.get(subKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Supplier.get</code>方法,此处是<code>Factory</code>实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// serialize access</span></span><br><span class="line">    <span class="comment">// re-check</span></span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//在我们等待的时候发生了一些变化: </span></span><br><span class="line">        <span class="comment">//可能是我们被CacheValue替换了 </span></span><br><span class="line">        <span class="comment">//或因为失败而被删除-&gt; </span></span><br><span class="line">        <span class="comment">//返回null信号WeakCache.get()重试 </span></span><br><span class="line">        <span class="comment">//循环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else still us (supplier == this)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new value</span></span><br><span class="line">    V value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        value = Objects.requireNonNull(valueFactory.apply(key, parameter)); ---------&gt; 进入该apply核心方法</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// remove us on failure</span></span><br><span class="line">            valuesMap.remove(subKey, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断言非空值</span></span><br><span class="line">    <span class="keyword">assert</span> value != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用CacheValue (WeakReference)包装值</span></span><br><span class="line">    CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> CacheValue&lt;&gt;(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put into reverseMap</span></span><br><span class="line">    reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try replacing us with CacheValue (this should always succeed)</span></span><br><span class="line">    <span class="keyword">if</span> (!valuesMap.replace(subKey, <span class="keyword">this</span>, cacheValue)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;Should not reach here&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// successfully replaced us with new CacheValue -&gt; return the value</span></span><br><span class="line">    <span class="comment">// wrapped by it</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>apply</code>源码,此处为<code>Proxy</code>实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="comment">//验证类装入器解析此名称 指向同一个Class对象的接口</span></span><br><span class="line">        Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//验证Class对象实际表示接口。</span></span><br><span class="line">        <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确认该接口不是重复的接口。</span></span><br><span class="line">        <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">    <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录非公共代理接口的包，</span></span><br><span class="line">    <span class="comment">// 使代理类将在同一个包中定义。</span></span><br><span class="line">    <span class="comment">// 验证所有的非公共代理接口都在同一个包中。</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">            accessFlags = Modifier.FINAL;</span><br><span class="line">            String name = intf.getName();</span><br><span class="line">            <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            String pkg = ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有非公共代理接口，使用  com.sun.proxy 包</span></span><br><span class="line">        proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为要生成的代理类选择一个名称</span></span><br><span class="line">    <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">    <span class="comment">// 这理解解释了为什么我们每次debug的时候都会有一个 com.sun.proxy.$Proxy0  这种类名</span></span><br><span class="line">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成特定的代理类</span></span><br><span class="line">    <span class="comment">//在上面中我讲生成的class文件输出在了out中，就是调用了这个方法，地方使用了AccessController.doPrivileged，为native方法，由C++编写</span></span><br><span class="line">    <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">        proxyName, interfaces, accessFlags);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用native方法</span></span><br><span class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                            proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">        <span class="comment">//类formaterror表示(禁止代理类生成代码)还有一些其他的 提供给代理的参数的无效方面 类创建(如虚拟机限制超过)</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小总结</p>
</blockquote>
<p><code>newProxyInstance</code> -&gt; <code>getProxyClass0</code> -&gt; <code>supplier.get()</code> -&gt; <code>valueFactory.apply</code> 就是生成代理类的大概原理啦，只要有兴趣，<code>debug</code>一下就可以了。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNzQ0OTU0NDMzNTQ0">参考文章</span> </p>
]]></content>
      <tags>
        <tag>Java面试</tag>
        <tag>JDK</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java关于时间的轮子</title>
    <url>/blog/posts/7a29d22a/</url>
    <content><![CDATA[<h1 id="建议收藏，减少百度重复造轮子"><a href="#建议收藏，减少百度重复造轮子" class="headerlink" title="建议收藏，减少百度重复造轮子"></a>建议收藏，减少百度重复造轮子</h1><p>我们应该都知道<code>SimpleDateFormat</code>是线程不安全的，在多线程的环境下会出现日期错乱的问题。</p>
<p>假设我们有一些字符串日期，需要格式化成日期，然后编写下面的程序，同时多个线程请求，观察结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要格式化的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat DATE_FORMAT = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        List&lt;String&gt; date = Arrays.asList(<span class="string">&quot;2021-01-01 12:12:12&quot;</span>, <span class="string">&quot;2021-01-02 11:11:11&quot;</span>, <span class="string">&quot;2021-01-11 09:09:09&quot;</span>);</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">10</span>).forEach(v -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    latch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(DATE_FORMAT.parse(date.get(i % date.size())));</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException | ParseException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<img data-src="/blog/posts/7a29d22a/2021-11-22-15-37-24.png" class="">

<p>观察上面的结果可以发现，程序最终的运行结果是抛出了异常。也就是说：<code>SimpleDateFormat</code>类是线程不安全的。</p>
<p>其实<code>SimpleDateFormat</code>不安全主要是<code>SimpleDateFormat</code>类中的包含的<code>Calender</code>类是作为共享成员变量存在<code>SimpleDateFormat</code>中。</p>
<p>假如在多线程环境下，如果两个线程都使用同一个 <code>SimpleDateFormat</code> 实例，那么就有可能存在其中一个线程修改了 <code>calendar</code> 后紧接着另一个线程也修改了 <code>calendar</code>，那么随后第一个线程用到 <code>calendar</code> 时已经不是它所期待的值。</p>
<p>因此在<code>Java8</code>中，<code>JDK</code>给我们提供了线程安全的时间类<code>“LocalDate”、“LocalDateTIme”</code>和<code>“LocalTime”</code>。通过查阅官方文档，可以了解到类是不可变的，并且线程安全。</p>
<img data-src="/blog/posts/7a29d22a/2021-11-22-15-38-42.png" class="">



<p>常用整理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Desc</span> 日期工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> jinMao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/11/12 </span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DateType</span> </span>&#123;</span><br><span class="line">        NORM_DATE_PATTERN(<span class="string">&quot;yyyy-MM-dd&quot;</span>),</span><br><span class="line">        NORM_DATETIME_PATTERN(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>),</span><br><span class="line">        NORM_TIME_PATTERN(<span class="string">&quot;HH:mm:ss&quot;</span>),</span><br><span class="line">        NORM_DATETIME_MINUTE_PATTERN(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>),</span><br><span class="line">        NORM_DATETIME_MS_PATTERN(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>),</span><br><span class="line">        CHINESE_DATE_PATTERN(<span class="string">&quot;yyyy年MM月dd日&quot;</span>),</span><br><span class="line">        PURE_DATE_PATTERN(<span class="string">&quot;yyyyMMdd&quot;</span>),</span><br><span class="line">        PURE_TIME_PATTERN(<span class="string">&quot;HHmmss&quot;</span>),</span><br><span class="line">        PURE_DATETIME_PATTERN(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>),</span><br><span class="line">        PURE_DATETIME_MS_PATTERN(<span class="string">&quot;yyyyMMddHHmmssSSS&quot;</span>),</span><br><span class="line">        PURE_DATE_MD_PATTERN(<span class="string">&quot;MMdd&quot;</span>),</span><br><span class="line">        ;</span><br><span class="line">        <span class="keyword">private</span> String format;</span><br><span class="line"></span><br><span class="line">        DateType(String format) &#123;</span><br><span class="line">            <span class="keyword">this</span>.format = format;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getFormat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> format;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一周的每天表示的常量，用于返回中文展示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] DAY_OF_WEEK = &#123;<span class="string">&quot;周一&quot;</span>, <span class="string">&quot;周二&quot;</span>, <span class="string">&quot;周三&quot;</span>, <span class="string">&quot;周四&quot;</span>, <span class="string">&quot;周五&quot;</span>, <span class="string">&quot;周六&quot;</span>, <span class="string">&quot;周日&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把长整型的时间戳转换成日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> format 格式化日期格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 格式化之后的日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stampToDate</span><span class="params">(<span class="keyword">long</span> time, String format)</span> </span>&#123;</span><br><span class="line">        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(format);</span><br><span class="line">        <span class="keyword">return</span> dateTimeFormatter.format(LocalDateTime.ofInstant(Instant.ofEpochMilli(time), ZoneId.systemDefault()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把日期转换成指定格式的字符串日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 传递的日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 指定格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToString</span><span class="params">(Date date, DateType type)</span> </span>&#123;</span><br><span class="line">        ZonedDateTime now = dateToZonedDateTime(date);</span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(type.getFormat());</span><br><span class="line">        <span class="keyword">return</span> now.format(formatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把日期转换成字默认的符串日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 传递日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToString</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dateToString(date, DateType.NORM_DATETIME_MINUTE_PATTERN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把当前日期格式化成指定的的字符串日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 指定的格式化日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToString</span><span class="params">(DateType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dateToString(<span class="keyword">new</span> Date(), type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把当前日期格式化成默认的字符串日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dateToString(<span class="keyword">new</span> Date(), DateType.NORM_DATETIME_MINUTE_PATTERN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串日期转换成Date</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dateStr  日期字符串，可以是20200101、2020-01-01、2020年01月01日</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dateType 格式化日期类型，必须包含完整的年月日</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Date类型日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">strToDate</span><span class="params">(String dateStr, DateType dateType)</span> </span>&#123;</span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(dateType.getFormat());</span><br><span class="line">        <span class="keyword">return</span> Date.from(LocalDate.parse(dateStr, formatter).atStartOfDay(ZoneId.systemDefault()).toInstant());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串日期转换成Date</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dateStr  日期字符串，可以是20200101131313、2020-01-01 13:13:13</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dateType 格式化日期类型，必须包含完整的年月日时分秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Date类型日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">strToDateTime</span><span class="params">(String dateStr, DateType dateType)</span> </span>&#123;</span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(dateType.getFormat());</span><br><span class="line">        <span class="keyword">return</span> Date.from(LocalDateTime.parse(dateStr, formatter).atZone(ZoneId.systemDefault()).toInstant());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否是当天</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 传递的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true|false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isToday</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().equals(dateToLocalDate(date));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取给定日期之前或者之后的日期</span></span><br><span class="line"><span class="comment">     * beforeOrAfterNumDay(new Date(), 0) 当天 2020-10-10</span></span><br><span class="line"><span class="comment">     * beforeOrAfterNumDay(new Date(), -1) 当天的前一天 2020-10-09</span></span><br><span class="line"><span class="comment">     * beforeOrAfterNumDay(new Date(), 1) 当天的后一天  2020-10-11</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 给定的Date类型的日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num  天数偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算之后的日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">getBeforeOrAfterNumDay</span><span class="params">(Date date, <span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateToDate(dateToLocalDate(date).plusDays(num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前日期之前或者之后的月份</span></span><br><span class="line"><span class="comment">     * beforeOrAfterNumMonth(0) 当月 2020-10</span></span><br><span class="line"><span class="comment">     * beforeOrAfterNumMonth(-1) 当天的前一月 2020-09</span></span><br><span class="line"><span class="comment">     * beforeOrAfterNumMonth(1) 当天的后一月 2020-11</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 月份偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算之后的月份</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getBeforeOrAfterNumMonth</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String date = LocalDate.now().plusMonths(num).toString();</span><br><span class="line">        <span class="keyword">return</span> date.substring(<span class="number">0</span>, date.lastIndexOf(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给当前时间增加年数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num  增加的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回增加日期之后的新日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">addYear</span><span class="params">(Date date, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeToDate(dateToLocalDateTime(date).plusYears(num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照指定分割符号获取当前年份和月份</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> separator 分隔符号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 7位字符串日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentYearAndMonth</span><span class="params">(String separator)</span> </span>&#123;</span><br><span class="line">        String month = LocalDate.now().getMonth().getValue() &gt;= <span class="number">10</span> ? <span class="string">&quot;&quot;</span> + LocalDate.now().getMonth().getValue() : <span class="string">&quot;0&quot;</span> + LocalDate.now().getMonth().getValue();</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().getYear() + separator + month;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照指定分割符号获取当前年份和一月份</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> separator 分隔符号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 7位字符串日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentYearWithFirstMonth</span><span class="params">(String separator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().getYear() + separator + <span class="string">&quot;01&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验两个 月日 字符串日期的大小</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;比如 01-02 和 02-03 比较 得到的结果就是 true&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;比如 01-03 和 02-03 比较 得到的结果就是 true&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;比如 01-04 和 02-03 比较 得到的结果就是 false&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beginDate 开始日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endDate   结束日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> split     分隔符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 比较结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkDate</span><span class="params">(String beginDate, String endDate, String split)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(endDate.replace(split, <span class="string">&quot;&quot;</span>)) - Integer.parseInt(beginDate.replace(split, <span class="string">&quot;&quot;</span>)) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照指定的分隔符获取当前月份和日期</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;比如 今天是2020年2月2日 分隔符为“-” 则获取的日期为 “02-02”&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> separator 指定的分隔符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentMonthAndDay</span><span class="params">(String separator)</span> </span>&#123;</span><br><span class="line">        String month = LocalDate.now().getMonth().getValue() &gt;= <span class="number">10</span> ? <span class="string">&quot;&quot;</span> + LocalDate.now().getMonth().getValue() : <span class="string">&quot;0&quot;</span> + LocalDate.now().getMonth().getValue();</span><br><span class="line">        String day = LocalDate.now().getDayOfMonth() &gt;= <span class="number">10</span> ? <span class="string">&quot;&quot;</span> + LocalDate.now().getDayOfMonth() : <span class="string">&quot;0&quot;</span> + LocalDate.now().getDayOfMonth();</span><br><span class="line">        <span class="keyword">return</span> month + separator + day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给当前时间增加月数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num  增加的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回增加日期之后的新日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">addMonth</span><span class="params">(Date date, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeToDate(dateToLocalDateTime(date).plusMonths(num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给当前时间增加天数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num  增加的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回增加日期之后的新日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">addDay</span><span class="params">(Date date, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeToDate(dateToLocalDateTime(date).plusDays(num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给当前时间增加小时</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num  增加的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回增加日期之后的新日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">addHours</span><span class="params">(Date date, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeToDate(dateToLocalDateTime(date).plusHours(num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给当前时间增加分钟</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num  增加的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回增加日期之后的新日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">addMinutes</span><span class="params">(Date date, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeToDate(dateToLocalDateTime(date).plusMinutes(num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给当前时间增加秒数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num  增加的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回增加日期之后的新日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">addSeconds</span><span class="params">(Date date, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeToDate(dateToLocalDateTime(date).plusSeconds(num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给当前时间增加纳秒</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num  增加的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回增加日期之后的新日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">addNanos</span><span class="params">(Date date, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeToDate(dateToLocalDateTime(date).plusNanos(num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给当前时间增加周数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num  增加的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回增加日期之后的新日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">addWeeks</span><span class="params">(Date date, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeToDate(dateToLocalDateTime(date).plusWeeks(num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当天是星期几</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 整形的星期数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDayOfWeek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().atStartOfDay(ZoneId.systemDefault()).getDayOfWeek().getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当天是星期几</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 中文表示的星期数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDayOfWeekWithChinese</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DAY_OF_WEEK[getDayOfWeek() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取传递的日期在当天是星期几</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 传递的日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 整形的星期数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDayOfWeek</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dateToLocalDate(date).atStartOfDay(ZoneId.systemDefault()).getDayOfWeek().getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取传递的日期在当天是星期几</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 传递的日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 中文表示的星期数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDayOfWeekWithChinese</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DAY_OF_WEEK[getDayOfWeek(date) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断给定的日期是否在给定的日期范围内</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date      给定的日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beginTime 开始日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endTime   结束日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true|false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">belongDateRange</span><span class="params">(Date date, Date beginTime, Date endTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.before(beginTime) &amp;&amp; date.after(endTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前的小时（24小时制）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前的小时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNowHour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().getHour();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定日期获取年龄</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> birthday 指定日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 年龄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAgeByBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        LocalDateTime birthdayDate = dateToLocalDateTime(birthday);</span><br><span class="line">        <span class="keyword">if</span> (LocalDateTime.now().isBefore(birthdayDate)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Duration duration = Duration.between(birthdayDate, LocalDateTime.now());</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) duration.toDays();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的时间获取这个时间是第几周</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 指定的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 周数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getWeekOfYear</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        WeekFields weekFields = WeekFields.of(DayOfWeek.MONDAY, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dateToLocalDateTime(date).get(weekFields.weekOfYear());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取给定时间的上个小时的开始时间和结束时间</span></span><br><span class="line"><span class="comment">     * 给一个为&quot;2020-10-26-09:36:24&quot;得到结果为 [2020-10-26 08:00:00, 2020-10-26 08:59:59, 08]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 给定的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] getPreviousBeginHourAndEndHour(Date date) &#123;</span><br><span class="line">        String[] lastHours = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">        String hour = dateToLocalDateTime(date).getHour() - <span class="number">1</span> + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (hour.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            hour = <span class="number">0</span> + hour;</span><br><span class="line">        &#125;</span><br><span class="line">        LocalDate localDateTime = dateToLocalDate(date);</span><br><span class="line">        lastHours[<span class="number">0</span>] = localDateTime + <span class="string">&quot; &quot;</span> + hour + <span class="string">&quot;:00:00&quot;</span>;</span><br><span class="line">        lastHours[<span class="number">1</span>] = localDateTime + <span class="string">&quot; &quot;</span> + hour + <span class="string">&quot;:59:59&quot;</span>;</span><br><span class="line">        lastHours[<span class="number">2</span>] = hour;</span><br><span class="line">        <span class="keyword">return</span> lastHours;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上周的开始日期和结束日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] getPreviousBeginDayAndEndDay() &#123;</span><br><span class="line">        <span class="keyword">return</span> getPreviousBeginDayAndEndDay(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据给定的时间获取上周的开始日期和结束日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 给定的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] getPreviousBeginDayAndEndDay(Date date) &#123;</span><br><span class="line">        LocalDate prevDay = dateToLocalDate(date).plusWeeks(-<span class="number">1</span>);</span><br><span class="line">        DayOfWeek week = prevDay.getDayOfWeek();</span><br><span class="line">        <span class="keyword">int</span> value = week.getValue();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;prevDay.minusDays(value - <span class="number">1</span>).toString(), prevDay.plusDays(<span class="number">7</span> - value).toString()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的开始日期和结束日期获取两者之间的日期集合，格式为 “yyyy-MM-dd”</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 日期集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getDatesBetweenStartDateAndEndDate</span><span class="params">(String start, String end)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        LocalDate startDate = LocalDate.parse(start);</span><br><span class="line">        LocalDate endDate = LocalDate.parse(end);</span><br><span class="line">        <span class="keyword">long</span> distance = ChronoUnit.DAYS.between(startDate, endDate);</span><br><span class="line">        <span class="keyword">if</span> (distance &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Stream.iterate(startDate, d -&gt; d.plusDays(<span class="number">1</span>)).limit(distance + <span class="number">1</span>).forEach(f -&gt; list.add(f.toString()));</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的开始日期和结束日期获取两者之间的日期集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 日期集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Date&gt; <span class="title">getDatesBetweenStartDateAndEndDate</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">        List&lt;Date&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        LocalDate startDate = dateToLocalDate(start);</span><br><span class="line">        LocalDate endDate = dateToLocalDate(end);</span><br><span class="line">        <span class="keyword">long</span> distance = ChronoUnit.DAYS.between(startDate, endDate);</span><br><span class="line">        <span class="keyword">if</span> (distance &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Stream.iterate(startDate, d -&gt; d.plusDays(<span class="number">1</span>)).limit(distance + <span class="number">1</span>).forEach(f -&gt; list.add(localDateToDate(f)));</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取给定日期的月份的最后一天</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> yearMonth 给定的月份，格式为“yyyy-MM” 2020-01----&gt;2020-02-31</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 本月最后一天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLastDayOfMonth</span><span class="params">(String yearMonth)</span> </span>&#123;</span><br><span class="line">        LocalDate resDate = LocalDate.parse(yearMonth + <span class="string">&quot;-01&quot;</span>);</span><br><span class="line">        Month month = resDate.getMonth();</span><br><span class="line">        <span class="keyword">int</span> length = month.length(resDate.isLeapYear());</span><br><span class="line">        <span class="keyword">return</span> LocalDate.of(resDate.getYear(), month, length).toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的秒数获取格式化之后的时间</span></span><br><span class="line"><span class="comment">     * getFormatBySeconds(799) ---&gt; 00:13:19</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seconds 给定的秒数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 格式化之后的时间字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTimeBySeconds</span><span class="params">(<span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (seconds &gt; <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;23:59:59&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        seconds = seconds % <span class="number">86400</span>;</span><br><span class="line">        String hours = String.valueOf(seconds / <span class="number">3600</span>).length() &gt; <span class="number">1</span> ? String.valueOf(seconds / <span class="number">3600</span>) : <span class="string">&quot;0&quot;</span> + (seconds / <span class="number">3600</span>);</span><br><span class="line">        seconds = seconds % <span class="number">3600</span>;</span><br><span class="line">        String minutes = String.valueOf(seconds / <span class="number">60</span>).length() &gt; <span class="number">1</span> ? String.valueOf(seconds / <span class="number">60</span>) : <span class="string">&quot;0&quot;</span> + (seconds / <span class="number">60</span>);</span><br><span class="line">        String second = String.valueOf(seconds % <span class="number">60</span>).length() &gt; <span class="number">1</span> ? String.valueOf(seconds % <span class="number">60</span>) : <span class="string">&quot;0&quot;</span> + (seconds % <span class="number">60</span>);</span><br><span class="line">        <span class="keyword">return</span> hours + <span class="string">&quot;:&quot;</span> + minutes + <span class="string">&quot;:&quot;</span> + second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算给定两个日期之前的时间差</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin 开始时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间差值（单位秒）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTimeDifference</span><span class="params">(Date begin, Date end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (((end.getTime() - begin.getTime()) / (<span class="number">1000</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取给定时间的日期集合，包含开始时间和结束时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beginTime 开始时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endTime   结束时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间范围集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getRangeOfDates</span><span class="params">(String beginTime, String endTime)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; dayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        LocalDate startDate = LocalDate.parse(beginTime);</span><br><span class="line">        LocalDate endDate = LocalDate.parse(endTime);</span><br><span class="line">        <span class="keyword">long</span> days = ChronoUnit.DAYS.between(startDate, endDate);</span><br><span class="line">        LongStream.range(<span class="number">0</span>, days + <span class="number">1</span>).forEach(d -&gt; dayList.add(startDate.plusDays(d).toString()));</span><br><span class="line">        <span class="keyword">return</span> dayList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把Date类型的日期转化成ZoneDateTime类型的日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date date类型日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ZoneDateTime类型日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">dateToZonedDateTime</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ZonedDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把ZoneDateTime类型的日期转化成Date类型的日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zonedDateTime ZoneDateTime类型日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> date类型日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">zonedDateTimeToDate</span><span class="params">(ZonedDateTime zonedDateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Date.from(zonedDateTime.toInstant());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把Date类型的日志转换成LocalDate类型的日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date Date类型日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LocalDate类型日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">dateToLocalDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把LocalDate类型的日志转换成Date类型的日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDate LocalDate类型日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Date类型日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">localDateToDate</span><span class="params">(LocalDate localDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把Date类型的日志转换成LocalDateTime类型的日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date Date类型日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LocalDateTime类型日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">dateToLocalDateTime</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把LocalDateTime类型的日志转换成Date类型的日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime LocalDateTime类型日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Date类型日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">localDateTimeToDate</span><span class="params">(LocalDateTime localDateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvZWsxNkktaTQ2OWY4dlVfdFd1bFQ3Zw==">本文参考链接</span></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试必问--ArrayList的底层</title>
    <url>/blog/posts/feb84842/</url>
    <content><![CDATA[<h2 id="1-ArrayList、LinkedList-和-Vector-的区别。"><a href="#1-ArrayList、LinkedList-和-Vector-的区别。" class="headerlink" title="1. ArrayList、LinkedList 和 Vector 的区别。"></a>1. <code>ArrayList</code>、<code>LinkedList</code> 和 <code>Vector</code> 的区别。</h2><ol>
<li><code>ArrayList</code>非线程安全的，<code>Vector</code>是线程安全的。</li>
<li><code>ArrayList</code>扩容时按照<code>50%</code>增加，<code>Vector</code>按照<code>100%</code>增加。</li>
<li><code>ArrayList</code>的性能要高于<code>Vector</code></li>
<li><code>LinkedList</code>是链表实现的，因此查询慢，增删快。</li>
<li><code>LinkedList</code>提供了<code>List</code>接口没有提供的方法，方便数据的头尾操作。</li>
</ol>
<h2 id="2-ArrayList简介"><a href="#2-ArrayList简介" class="headerlink" title="2. ArrayList简介"></a>2. <code>ArrayList</code>简介</h2><span id="more"></span>

<p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 <code>Java</code> 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p>
<p>它继承于 <code>AbstractList</code>，实现了 <code>List, RandomAccess, Cloneable, java.io.Serializable</code> 这些接口。</p>
<img data-src="/blog/posts/feb84842/2022-02-09-15-44-02.png" class="">

<p>在我们学数据结构的时候就知道了线性表的顺序存储，插入删除元素的时间复杂度为<code>O（n）</code>,求表长以及增加元素，取第 <code>i</code>元素的时间复杂度为<code>O（1）</code></p>
<ul>
<li><code>ArrayList</code> 继承了<code>AbstractList</code>，实现了<code>List</code>。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</li>
<li><code>ArrayList</code> 实现了<code>RandomAccess</code> 接口， <code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 <code>List</code> 集合是支持快速随机访问的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>
<li><code>ArrayList</code> 实现了<code>Cloneable</code> 接口，即覆盖了函数 <code>clone()</code>，能被克隆。</li>
<li><code>ArrayList</code> 实现<code>java.io.Serializable</code> 接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li>
<li>和 <code>Vector</code> 不同，<code>ArrayList</code> 中的操作不是线程安全的！所以，建议在单线程中才使用 <code>ArrayList</code>，而在多线程中可以选择 <code>Vector</code> 或者<code> CopyOnWriteArrayList。</code></li>
</ul>
<h2 id="3-ArrayList核心源码-JDK版本为1-8"><a href="#3-ArrayList核心源码-JDK版本为1-8" class="headerlink" title="3. ArrayList核心源码(JDK版本为1.8)"></a>3. <code>ArrayList</code>核心源码(<code>JDK</code>版本为<code>1.8</code>)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* new 一个集合默认为空，容量为10</span></span><br><span class="line"><span class="comment">* Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">      <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认无参构造函数</span></span><br><span class="line"><span class="comment">     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）      </span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span></span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line">        <span class="comment">//如果最小容量大于已有的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//得到最小扩容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取“默认的容量”和“传入参数”两者之间的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中的元素数。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意=和==的区别</span></span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="comment">//equals()方法比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class="line"><span class="comment">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; </span></span><br><span class="line"><span class="comment">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 </span></span><br><span class="line"><span class="comment">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 </span></span><br><span class="line"><span class="comment">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class="line"><span class="comment">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">            <span class="comment">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的元素替换此列表中指定位置的元素。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对index进行界限检查</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回原来在这个位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class="line"><span class="comment">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">      <span class="comment">//从列表中删除的元素 </span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment">     *返回true，如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除所有元素。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组中所有的元素的值设为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class="line"><span class="comment">     *将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除指定集合中包含的所有元素。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="comment">//如果此列表被修改则返回true</span></span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class="line"><span class="comment">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class="line"><span class="comment">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 </span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回列表中的列表迭代器（按适当的顺序）。 </span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序返回该列表中的元素的迭代器。 </span></span><br><span class="line"><span class="comment">     *返回的迭代器是fail-fast 。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-ArrayList源码分析"><a href="#4-ArrayList源码分析" class="headerlink" title="4. ArrayList源码分析"></a>4. <code>ArrayList</code>源码分析</h2><blockquote>
<p><code>System.arraycopy()</code>和<code>Arrays.copyOf()</code>方法</p>
</blockquote>
<p>通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面<code>add(int index, E element)</code>方法就很巧妙的用到了<code>arraycopy()</code>方法让数组自己复制自己实现让<code>index</code>开始之后的所有成员后移一个位置:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class="line"><span class="comment">    *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">    *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又如<code>toArray()</code>方法中用到了<code>copyOf()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class="line"><span class="comment">    *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">    *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"><span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两者联系与区别</p>
</blockquote>
<p>联系： 看两者源代码可以发现<code>copyOf()</code>内部调用了<code>System.arraycopy()</code>方法 区别：</p>
<ul>
<li><code>arraycopy()</code>需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li>
<li><code>copyOf()</code>是系统自动在内部新建一个数组，并返回该数组。</li>
</ul>
<h2 id="5-ArrayList-核心扩容技术"><a href="#5-ArrayList-核心扩容技术" class="headerlink" title="5. ArrayList 核心扩容技术"></a>5. <code>ArrayList</code> 核心扩容技术</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//得到最小扩容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//判断是否需要扩容,上面两个方法都要调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。</span></span><br><span class="line">        <span class="comment">//这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//elementData为保存ArrayList数据的数组</span></span><br><span class="line">       <span class="comment">///elementData.length求数组长度elementData.size是求数组中的元素个数</span></span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);  <span class="comment">// 扩容方法copyOf</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：移位运算符 　</p>
<ul>
<li><strong>简介</strong>:移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:<code>&lt;&lt;(左移)、&gt;&gt;(带符号右移)和&gt;&gt;&gt;(无符号右移)</code>。 　　</li>
<li><strong>作用</strong>:对于大数据的<code>2</code>进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 　比如这里：<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>; 右移一位相当于除<code>2</code>，右移<code>n</code>位相当于除以 <code>2</code> 的 <code>n</code> 次方。这里 <code>oldCapacity</code> 明显右移了1位所以相当于<code>oldCapacity /2</code>。</li>
</ul>
<p><strong>另外需要注意的是</strong>：</p>
<ul>
<li><code>java</code> 中的<code>length</code> 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 <code>length</code> 这个属性.</li>
<li><code>java</code> 中的<code>length()</code>方法是针对字 符串<code>String</code>说的,如果想看这个字符串的长度则用到 <code>length()</code>这个方法.</li>
<li><code>java</code> 中的<code>size()</code>方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>
</ul>
<h3 id="6-内部类"><a href="#6-内部类" class="headerlink" title="6. 内部类"></a>6. 内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class">(2)<span class="title">private</span> <span class="title">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class">(3)<span class="title">private</span> <span class="title">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span>  </span></span><br><span class="line"><span class="class">(4)<span class="title">static</span> <span class="title">final</span> <span class="title">class</span> <span class="title">ArrayListSpliterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">E</span>&gt;  </span></span><br></pre></td></tr></table></figure>
<p><code>ArrayList</code>有四个内部类，其中的<code>Itr</code>是实现了<code>Iterator</code>接口，同时重写了里面的<code>hasNext()， next()， remove()</code> 等方法；其中的<code>ListItr</code> 继承 <code>Itr</code>，实现了<code>ListIterator</code>接口，同时重写了<code>hasPrevious()， nextIndex()， previousIndex()， previous()， set(E e)， add(E e)</code> 等方法，所以这也可以看出了 <code>Iterator</code>和<code>ListIterator</code>的区别: <code>ListIterator</code>在<code>Iterator</code>的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是<code>Iterator</code>不能实现的。</p>
]]></content>
      <categories>
        <category>Java面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMvc中标准的后端接口格式</title>
    <url>/blog/posts/f976ebe7/</url>
    <content><![CDATA[<h1 id="用SpringBoot手把手教你写出优雅的后端接口"><a href="#用SpringBoot手把手教你写出优雅的后端接口" class="headerlink" title="用SpringBoot手把手教你写出优雅的后端接口"></a>用<code>SpringBoot</code>手把手教你写出优雅的后端接口</h1><p>一个后端接口大致分为四个部分组成：<code>接口地址（url）</code>、<code>接口请求方式（get、post等）</code>、<code>请求数据（request）</code>、<code>响应数据（response）</code>。如何构建这几个部分每个公司要求都不同，没有什么“一定是最好的”标准，但一个优秀的后端接口和一个糟糕的后端接口对比起来差异还是蛮大的，其中最重要的关键点就是看是否规范!</p>
<p>本文就一步一步演示如何构建起一个优秀的后端接口体系，体系构建好了自然就有了规范，同时再构建新的后端接口也会十分轻松。</p>
<p>所需依赖包</p>
<span id="more"></span>

<p>这里用的是<code>SpringBoot</code>配置项目，本文讲解的重点是后端接口，所以只需要导入一个<code>spring-boot-starter-web</code>包就可以了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--web依赖包，web应用必备--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--StringUtils的使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>本文还用了<code>swagger</code>来生成<code>API</code>文档，<code>lombok</code>来简化类，不过这两者不是必须的，可用可不用。</p>
<h2 id="一、参数校验"><a href="#一、参数校验" class="headerlink" title="一、参数校验"></a>一、参数校验</h2><p>一个接口一般对参数（请求数据）都会进行安全校验，参数校验的重要性自然不必多说，那么如何对参数进行校验就有讲究了。</p>
<h2 id="二、业务层校验"><a href="#二、业务层校验" class="headerlink" title="二、业务层校验"></a>二、业务层校验</h2><p>首先我们来看一下最常见的做法，就是在业务层进行参数校验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span> || user.getId() == <span class="keyword">null</span> || user.getAccount() == <span class="keyword">null</span> || user.getPassword() == <span class="keyword">null</span> || user.getEmail() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;对象或者对象字段不能为空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(user.getAccount()) || StringUtils.isEmpty(user.getPassword()) || StringUtils.isEmpty(user.getEmail())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;不能输入空字符串&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (user.getAccount().length() &lt; <span class="number">6</span> || user.getAccount().length() &gt; <span class="number">11</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;账号长度必须是6-11个字符&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (user.getPassword().length() &lt; <span class="number">6</span> || user.getPassword().length() &gt; <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;密码长度必须是6-16个字符&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!Pattern.matches(<span class="string">&quot;^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$&quot;</span>, user.getEmail())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;邮箱格式不正确&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数校验完毕后这里就写上业务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做当然是没有什么错的，而且格式排版整齐也一目了然，不过这样太繁琐了，这还没有进行业务操作呢光是一个参数校验就已经这么多行代码，实在不够优雅。</p>
<p>我们来改进一下，使用<code>Spring Validator</code>和<code>Hibernate Validator</code>这两套<code>Validator</code>来进行方便的参数校验！这两套<code>Validator</code>依赖包已经包含在前面所说的<code>web</code>依赖包里了，所以可以直接使用。<br>但是从<code>springboot-2.3</code>开始，校验包被独立成了一个<code>starter</code>组件<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZy1wcm9qZWN0cy9zcHJpbmctYm9vdC93aWtpL1NwcmluZy1Cb290LTIuMy1SZWxlYXNlLU5vdGVzI3ZhbGlkYXRpb24tc3RhcnRlci1uby1sb25nZXItaW5jbHVkZWQtaW4td2ViLXN0YXJ0ZXJz">参见：validation-starter-no-longer-included-in-web-starters</span>，<br>所以需要引入如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--校验组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>内置的校验有很多</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>校验功能</th>
</tr>
</thead>
<tbody><tr>
<td>@AssertFalse</td>
<td>必须是false</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>必须是true</td>
</tr>
<tr>
<td>@DecimalMax</td>
<td>小于等于给定的值</td>
</tr>
<tr>
<td>@DecimalMin</td>
<td>大于等于给定的值</td>
</tr>
<tr>
<td>@Digits</td>
<td>可设定最大整数位数和最大小数位数</td>
</tr>
<tr>
<td>@Email</td>
<td>校验是否符合Email格式</td>
</tr>
<tr>
<td>@Future</td>
<td>必须是将来的时间</td>
</tr>
<tr>
<td>@FutureOrPresent</td>
<td>当前或将来时间</td>
</tr>
<tr>
<td>@Max</td>
<td>最大值</td>
</tr>
<tr>
<td>@Min</td>
<td>最小值</td>
</tr>
<tr>
<td>@Negative</td>
<td>负数（不包括0）</td>
</tr>
<tr>
<td>@NegativeOrZero</td>
<td>负数或0</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>不为null并且包含至少一个非空白字符</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>不为null并且不为空</td>
</tr>
<tr>
<td>@NotNull</td>
<td>不为null</td>
</tr>
<tr>
<td>@Null</td>
<td>为null</td>
</tr>
<tr>
<td>@Past</td>
<td>必须是过去的时间</td>
</tr>
<tr>
<td>@PastOrPresent</td>
<td>必须是过去的时间，包含现在</td>
</tr>
<tr>
<td>@Pattern</td>
<td>必须满足正则表达式</td>
</tr>
<tr>
<td>@PositiveOrZero</td>
<td>正数或0</td>
</tr>
<tr>
<td>@Size</td>
<td>校验容器的元素个数</td>
</tr>
</tbody></table>
<h2 id="三、Validator-BindResult进行校验"><a href="#三、Validator-BindResult进行校验" class="headerlink" title="三、Validator + BindResult进行校验"></a>三、<code>Validator</code> + <code>BindResult</code>进行校验</h2><p><code>Validator</code>可以非常方便的制定校验规则，并自动帮你完成校验。首先在入参里需要校验的字段加上注解,每个注解对应不同的校验规则，并可制定校验失败后的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户id不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户账号不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 6, max = 11, message = &quot;账号长度必须是6-11个字符&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String account;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户密码不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 6, max = 11, message = &quot;密码长度必须是6-16个字符&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户邮箱不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验规则和错误提示信息配置完毕后，接下来只需要在接口需要校验的参数上加上<code>@Valid</code>注解，并添加<code>BindResult</code>参数即可方便完成验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/addUser&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> User user, BindingResult bindingResult)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果有参数校验失败，会将错误信息封装成对象组装在BindingResult里</span></span><br><span class="line">        <span class="keyword">for</span> (ObjectError error : bindingResult.getAllErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> error.getDefaultMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userService.addUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当请求数据传递到接口的时候<code>Validator</code>就自动完成校验了，校验的结果就会封装到<code>BindingResult</code>中去，如果有错误信息我们就直接返回给前端，业务逻辑代码也根本没有执行下去。</p>
<p>此时，业务层里的校验代码就已经不需要了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 直接编写业务逻辑</span></span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>现在可以看一下参数校验效果。我们故意给这个接口传递一个不符合校验规则的参数，先传递一个错误数据给接口，故意将<code>password</code>这个字段不满足校验条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;account&quot;</span>: <span class="string">&quot;12345678&quot;</span>,</span><br><span class="line">    <span class="string">&quot;email&quot;</span>: <span class="string">&quot;123@qq.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看一下接口的响应数据：</p>
<img data-src="/blog/posts/f976ebe7/2022-02-19-14-08-48.png" class="">

<p>这样是不是方便很多？不难看出使用<code>Validator</code>校验有如下几个好处：</p>
<ul>
<li><p>简化代码，之前业务层那么一大段校验代码都被省略掉了。</p>
</li>
<li><p>使用方便，那么多校验规则可以轻而易举的实现，比如邮箱格式验证，之前自己手写正则表达式要写那么一长串，还容易出错，用<code>Validator</code>直接一个注解搞定。（还有更多校验规则注解，可以自行去了解哦）</p>
</li>
<li><p>减少耦合度，使用<code>Validator</code>能够让业务层只关注业务逻辑，从基本的参数校验逻辑中脱离出来。</p>
</li>
</ul>
<p>使用<code>Validator + BindingResult</code>已经是非常方便实用的参数校验方式了，在实际开发中也有很多项目就是这么做的，不过这样还是不太方便，因为你每写一个接口都要添加一个<code>BindingResult</code>参数，然后再提取错误信息返回给前端。</p>
<p>这样有点麻烦，并且重复代码很多（尽管可以将这个重复代码封装成方法）。我们能否去掉<code>BindingResult</code>这一步呢？当然是可以的！</p>
<h2 id="Validator-自动抛出异常"><a href="#Validator-自动抛出异常" class="headerlink" title="Validator + 自动抛出异常"></a><code>Validator</code> + 自动抛出异常</h2><p>将<code>BindingResult</code> 去掉：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/addUser&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;sucess&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去掉之后会发生什么事情呢？直接来试验一下，还是按照之前一样故意传递一个不符合校验规则的参数给接口。此时我们观察控制台可以发现接口已经引发<code>MethodArgumentNotValidException</code>异常了：</p>
<img data-src="/blog/posts/f976ebe7/2022-02-19-14-09-00.png" class="">

<p>其实这样就已经达到我们想要的效果了，参数校验不通过自然就不执行接下来的业务逻辑，去掉<code>BindingResult</code>后会自动引发异常，异常发生了自然而然就不会执行业务逻辑。也就是说，我们完全没必要添加相关<code>BindingResult</code>相关操作嘛。</p>
<p>不过事情还没有完，异常是引发了，可我们并没有编写返回错误信息的代码呀，那参数校验失败了会响应什么数据给前端呢？</p>
<p>我们来看一下刚才异常发生后接口响应的数据：</p>
<img data-src="/blog/posts/f976ebe7/2022-02-19-14-09-15.png" class="">


<p>没错，是直接将整个错误对象相关信息都响应给前端了！这样就很难受，不过解决这个问题也很简单，就是我们接下来要讲的全局异常处理！</p>
<h2 id="五、全局异常处理"><a href="#五、全局异常处理" class="headerlink" title="五、全局异常处理"></a>五、全局异常处理</h2><p>参数校验失败会自动引发异常，我们当然不可能再去手动捕捉异常进行处理，不然还不如用之前<code>BindingResult</code>方式呢。又不想手动捕捉这个异常，又要对这个异常进行处理，那正好使用<code>SpringBoot</code>全局异常处理来达到一劳永逸的效果！</p>
<h2 id="六、基本使用"><a href="#六、基本使用" class="headerlink" title="六、基本使用"></a>六、基本使用</h2><p>首先，我们需要新建一个类，在这个类上加上<code>@ControllerAdvice</code>或<code>@RestControllerAdvice</code>注解，这个类就配置成全局处理类了。（这个根据你的<code>Controller</code>层用的是<code>@Controller</code>还是<code>@RestController</code>来决定）</p>
<p>然后在类中新建方法，在方法上加上<code>@ExceptionHandler</code>注解并指定你想处理的异常类型，接着在方法内编写对该异常的操作逻辑，就完成了对该异常的全局处理！</p>
<p>我们现在就来演示一下对参数校验失败抛出的<code>MethodArgumentNotValidException</code>全局处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionControllerAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">MethodArgumentNotValidExceptionHandler</span><span class="params">(MethodArgumentNotValidException e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从异常对象中拿到ObjectError对象</span></span><br><span class="line">        ObjectError objectError = e.getBindingResult().getAllErrors().get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 然后提取错误提示信息进行返回</span></span><br><span class="line">        <span class="keyword">return</span> objectError.getDefaultMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看下这次校验失败后的响应数据：</p>
<img data-src="/blog/posts/f976ebe7/2022-02-19-14-09-28.png" class="">


<p>没错，这次返回的就是我们制定的错误提示信息！我们通过全局异常处理优雅的实现了我们想要的功能！以后我们再想写接口参数校验，就只需要在入参的成员变量上加上<code>Validator</code>校验规则注解，然后在参数上加上<code>@Valid</code>注解即可完成校验，校验失败会自动返回错误提示信息，无需任何其他代码！更多的校验思路：<code>SpringBoot</code>实现通用的接口参数校验</p>
<h2 id="七、自定义异常"><a href="#七、自定义异常" class="headerlink" title="七、自定义异常"></a>七、自定义异常</h2><p>全局处理当然不会只能处理一种异常，用途也不仅仅是对一个参数校验方式进行优化。在实际开发中，如何对异常处理其实是一个很麻烦的事情。传统处理异常一般有以下烦恼：</p>
<ul>
<li><p>是捕获异常<code>(try…catch)</code>还是抛出异常<code>(throws)</code></p>
</li>
<li><p>是在<code>controller</code>层做处理还是在<code>service</code>层处理又或是在<code>dao</code>层做处理</p>
</li>
<li><p>处理异常的方式是啥也不做，还是返回特定数据，如果返回又返回什么数据</p>
</li>
<li><p>不是所有异常我们都能预先进行捕捉，如果发生了没有捕捉到的异常该怎么办？</p>
</li>
</ul>
<p>以上这些问题都可以用全局异常处理来解决，全局异常处理也叫统一异常处理，全局和统一处理代表什么？代表规范！规范有了，很多问题就会迎刃而解！</p>
<p>全局异常处理的基本使用方式大家都已经知道了，我们接下来更进一步的规范项目中的异常处理方式：自定义异常。</p>
<p>在很多情况下，我们需要手动抛出异常，比如在业务层当有些条件并不符合业务逻辑，我这时候就可以手动抛出异常从而触发事务回滚。那手动抛出异常最简单的方式就是<code>throw new RuntimeException(&quot;异常信息&quot;)</code>了，不过使用自定义会更好一些：</p>
<ul>
<li><p>自定义异常可以携带更多的信息，不像这样只能携带一个字符串。</p>
</li>
<li><p>项目开发中经常是很多人负责不同的模块，使用自定义异常可以统一了对外异常展示的方式。</p>
</li>
<li><p>自定义异常语义更加清晰明了，一看就知道是项目中手动抛出的异常。</p>
</li>
</ul>
<p>我们现在就来开始写一个自定义异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span> <span class="comment">//只要getter方法，无需setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">APIException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1001</span>, <span class="string">&quot;接口错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">APIException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1001</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">APIException</span><span class="params">(<span class="keyword">int</span> code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在刚才的全局异常处理类中记得添加对我们自定义异常的处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(APIException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">APIExceptionHandler</span><span class="params">(APIException e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e.getMsg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就对异常的处理就比较规范了，当然还可以添加对<code>Exception</code>的处理，这样无论发生什么异常我们都能屏蔽掉然后响应数据给前端，不过建议最后项目上线时这样做，能够屏蔽掉错误信息暴露给前端，在开发中为了方便调试还是不要这样做。</p>
<p>现在全局异常处理和自定义异常已经弄好了，不知道大家有没有发现一个问题，就是当我们抛出自定义异常的时候全局异常处理只响应了异常中的错误信息<code>msg</code>给前端，并没有将错误代码<code>code</code>返回。这就要引申出我们接下来要讲的东西了：数据统一响应</p>
<h2 id="八、数据统一响应"><a href="#八、数据统一响应" class="headerlink" title="八、数据统一响应"></a>八、数据统一响应</h2><p>现在我们规范好了参数校验方式和异常处理方式，然而还没有规范响应数据！比如我要获取一个分页信息数据，获取成功了呢自然就返回的数据列表，获取失败了后台就会响应异常信息，即一个字符串，就是说前端开发者压根就不知道后端响应过来的数据会是啥样的！所以，统一响应数据是前后端规范中必须要做的！</p>
<h2 id="九、自定义统一响应"><a href="#九、自定义统一响应" class="headerlink" title="九、自定义统一响应"></a>九、自定义统一响应</h2><p>统一数据响应第一步肯定要做的就是我们自己自定义一个响应体类，无论后台是运行正常还是发生异常，响应给前端的数据格式是不变的！那么如何定义响应体呢？关于异常的设计：如何更优雅的设计异常</p>
<p>可以参考我们自定义异常类，也来一个响应信息代码<code>code</code>和响应信息说明<code>msg</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultVO</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态码，比如1000代表响应成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应信息，用来说明响应情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应的具体数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResultVO</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1000</span>, <span class="string">&quot;success&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResultVO</span><span class="params">(<span class="keyword">int</span> code, String msg, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们修改一下全局异常处理那的返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(APIException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVO&lt;String&gt; <span class="title">APIExceptionHandler</span><span class="params">(APIException e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意哦，这里返回类型是自定义响应体</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultVO&lt;&gt;(e.getCode(), <span class="string">&quot;响应失败&quot;</span>, e.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVO&lt;String&gt; <span class="title">MethodArgumentNotValidExceptionHandler</span><span class="params">(MethodArgumentNotValidException e)</span> </span>&#123;</span><br><span class="line">    ObjectError objectError = e.getBindingResult().getAllErrors().get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 注意哦，这里返回类型是自定义响应体</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultVO&lt;&gt;(<span class="number">1001</span>, <span class="string">&quot;参数校验失败&quot;</span>, objectError.getDefaultMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看一下此时如果发生异常了会响应什么数据给前端：</p>
<p>OK，这个异常信息响应就非常好了，状态码和响应说明还有错误提示数据都返给了前端，并且是所有异常都会返回相同的格式！异常这里搞定了，别忘了我们到接口那也要修改返回类型，我们新增一个接口好来看看效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/getUser&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVO&lt;User&gt; <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setAccount(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;123@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultVO&lt;&gt;(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下如果响应正确返回的是什么效果：</p>
<img data-src="/blog/posts/f976ebe7/2022-02-19-14-09-48.png" class="">

<p>这样无论是正确响应还是发生异常，响应数据的格式都是统一的，十分规范！</p>
<p>数据格式是规范了，不过响应码<code>code</code>和响应信息<code>msg</code>还没有规范呀！大家发现没有，无论是正确响应，还是异常响应，响应码和响应信息是想怎么设置就怎么设置，要是<code>10</code>个开发人员对同一个类型的响应写<code>10</code>个不同的响应码，那这个统一响应体的格式规范就毫无意义！所以，必须要将响应码和响应信息给规范起来。</p>
<h2 id="十、响应码枚举"><a href="#十、响应码枚举" class="headerlink" title="十、响应码枚举"></a>十、响应码枚举</h2><p>要规范响应体中的响应码和响应信息用枚举简直再恰当不过了，我们现在就来创建一个响应码枚举类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ResultCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SUCCESS(<span class="number">1000</span>, <span class="string">&quot;操作成功&quot;</span>),</span><br><span class="line"></span><br><span class="line">    FAILED(<span class="number">1001</span>, <span class="string">&quot;响应失败&quot;</span>),</span><br><span class="line"></span><br><span class="line">    VALIDATE_FAILED(<span class="number">1002</span>, <span class="string">&quot;参数校验失败&quot;</span>),</span><br><span class="line"></span><br><span class="line">    ERROR(<span class="number">5000</span>, <span class="string">&quot;未知错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    ResultCode(<span class="keyword">int</span> code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改响应体的构造方法，让其只准接受响应码枚举来设置响应码和响应信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ResultVO</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(ResultCode.SUCCESS, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ResultVO</span><span class="params">(ResultCode resultCode, T data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.code = resultCode.getCode();</span><br><span class="line">    <span class="keyword">this</span>.msg = resultCode.getMsg();</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后同时修改全局异常处理的响应码设置方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(APIException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVO&lt;String&gt; <span class="title">APIExceptionHandler</span><span class="params">(APIException e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意哦，这里传递的响应码枚举</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultVO&lt;&gt;(ResultCode.FAILED, e.getMsg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVO&lt;String&gt; <span class="title">MethodArgumentNotValidExceptionHandler</span><span class="params">(MethodArgumentNotValidException e)</span> </span>&#123;</span><br><span class="line">    ObjectError objectError = e.getBindingResult().getAllErrors().get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 注意哦，这里传递的响应码枚举</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultVO&lt;&gt;(ResultCode.VALIDATE_FAILED, objectError.getDefaultMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样响应码和响应信息只能是枚举规定的那几个，就真正做到了响应数据格式、响应码和响应信息规范化、统一化！这些可以参考：<code>Java</code>项目构建基础：统一结果，统一异常，统一日志</p>
<h2 id="十一、全局处理响应数据"><a href="#十一、全局处理响应数据" class="headerlink" title="十一、全局处理响应数据"></a>十一、全局处理响应数据</h2><p>接口返回统一响应体 + 异常也返回统一响应体，其实这样已经很好了，但还是有可以优化的地方。要知道一个项目下来定义的接口搞个几百个太正常不过了，要是每一个接口返回数据时都要用响应体来包装一下好像有点麻烦，有没有办法省去这个包装过程呢？当然是有滴，还是要用到全局处理。</p>
<p>首先，先创建一个类加上注解使其成为全局处理类。然后继承<code>ResponseBodyAdvice</code>接口重写其中的方法，即可对我们的<code>controller</code>进行增强操作，具体看代码和注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &#123;&quot;com.cy.controller&quot;&#125;)</span> <span class="comment">// 注意哦，这里要加上需要扫描的包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseControllerAdvice</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// supports方法是来给定条件判断是否该调用beforeBodyWrite，MethodParameter里面有各种数据，false就不调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果接口返回的类型本身就是ResultVO那就没有必要进行额外的操作，返回false</span></span><br><span class="line">        <span class="keyword">return</span> !returnType.getGenericParameterType().equals(ResultVO.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应结果拦截根据业务去封装返回体</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object data, MethodParameter returnType, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// String类型不能直接包装，所以要进行些特别的处理</span></span><br><span class="line">        <span class="keyword">if</span> (returnType.getGenericParameterType().equals(String.class)) &#123;</span><br><span class="line">            ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将数据包装在ResultVO里后，再转换为json字符串响应给前端</span></span><br><span class="line">                <span class="keyword">return</span> objectMapper.writeValueAsString(<span class="keyword">new</span> ResultVO&lt;&gt;(data));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> APIException(<span class="string">&quot;返回String类型错误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将原本的数据包装在ResultVO里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultVO&lt;&gt;(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写的这两个方法是用来在<code>controller</code>将数据进行返回前进行增强操作，<code>supports</code>方法要返回为<code>true</code>才会执行<code>beforeBodyWrite</code>方法，所以如果有些情况不需要进行增强操作可以在<code>supports</code>方法里进行判断。对返回数据进行真正的操作还是在<code>beforeBodyWrite</code>方法中，我们可以直接在该方法里包装数据，这样就不需要每个接口都进行数据包装了，省去了很多麻烦。</p>
<p>我们可以现在去掉接口的数据包装来看下效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/getUser&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setAccount(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;123@qq.com&quot;</span>);</span><br><span class="line">    <span class="comment">// 注意哦，这里是直接返回的User类型，并没有用ResultVO进行包装</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来看下响应数据：</p>
<img data-src="/blog/posts/f976ebe7/2022-02-19-14-10-03.png" class="">

<p>成功对数据进行了包装！</p>
<blockquote>
<p>注意：<code>beforeBodyWrite</code>方法里包装数据无法对<code>String</code>类型的数据直接进行强转，所以要进行特殊处理，这里不讲过多的细节，有兴趣可以自行深入了解。</p>
</blockquote>
<h2 id="十二、总结"><a href="#十二、总结" class="headerlink" title="十二、总结"></a>十二、总结</h2><p>自此整个后端接口基本体系就构建完毕了</p>
<ul>
<li><p>通过<code>Validator</code> + 自动抛出异常来完成了方便的参数校验</p>
</li>
<li><p>通过全局异常处理 + 自定义异常完成了异常操作的规范</p>
</li>
<li><p>通过数据统一响应完成了响应数据的规范</p>
</li>
<li><p>多个方面组装非常优雅的完成了后端接口的协调，让开发人员有更多的经历注重业务逻辑代码，轻松构建后端接口</p>
</li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>接口</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream流的介绍</title>
    <url>/blog/posts/8b8fedea/</url>
    <content><![CDATA[<h1 id="Stream-流的介绍"><a href="#Stream-流的介绍" class="headerlink" title="Stream 流的介绍"></a><code>Stream</code> 流的介绍</h1><h2 id="1-1-java8-stream介绍"><a href="#1-1-java8-stream介绍" class="headerlink" title="1.1 java8 stream介绍"></a>1.1 <code>java8 stream</code>介绍</h2><p>　　<code>java8</code>新增了<code>stream</code>流的特性，能够让用户以函数式的方式、更为简单的操纵集合等数据结构，并实现了用户无感知的并行计算。</p>
<h2 id="1-2-从零开始实现一个stream流"><a href="#1-2-从零开始实现一个stream流" class="headerlink" title="1.2 从零开始实现一个stream流"></a>1.2 从零开始实现一个<code>stream</code>流</h2><p>　　相信很多人在使用过<code>java8</code>的<code>streamAPI</code>接口之后，都会对其实现原理感到好奇，但往往在看到<code>jdk</code>的<code>stream</code>源码后却被其复杂的抽象、封装给弄糊涂了，而无法很好的理解其背后的原理。究其原因，是因为<code>jdk</code>的<code>stream</code>源码是高度工程化的代码，工程化的代码为了效率和满足各式各样的需求，会将代码实现的极其复杂，不易理解。</p>
<p>　　在这里，我们将抛开<code>jdk</code>的实现思路，从零开始实现一个<code>stream</code>流。</p>
<p>　　我们的<code>stream</code>流同样拥有惰性求值，函数式编程接口等特性，并兼容<code>jdk</code>的<code>Collection</code>等数据结构(但不支持并行计算 <code>orz</code>)。</p>
<p>　　相信在亲手实现一个<code>stream</code>流的框架之后，大家能更好的理解流计算的原理。</p>
<span id="more"></span>

<h2 id="stream的优点"><a href="#stream的优点" class="headerlink" title="stream的优点"></a><code>stream</code>的优点</h2><p>在探讨探究<code>stream</code>的实现原理和动手实现之前，我们先要体会<code>stream</code>流计算的独特之处。</p>
<blockquote>
<p>举个例子： 有一个<code>List&lt;Person&gt;</code>列表,我们需要获得年龄为<code>70</code>岁的前<code>10</code>个<code>Person</code>的姓名。</p>
</blockquote>
<blockquote>
<p>过程式的解决方案：</p>
</blockquote>
<p>　　稍加思考，我们很快就写出了一个过程式的解决方案(伪代码)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; personList = fromDB(); <span class="comment">// 获得List&lt;Person&gt;</span></span><br><span class="line"><span class="keyword">int</span> limit = <span class="number">10</span>; <span class="comment">// 限制条件</span></span><br><span class="line">List&lt;String&gt; nameList = <span class="keyword">new</span> ArrayList(); <span class="comment">// 收集的姓名集合</span></span><br><span class="line"><span class="keyword">for</span>(Person personItem : personList)&#123;</span><br><span class="line">    <span class="keyword">if</span>(personItem.age == <span class="number">70</span>)&#123; <span class="comment">// 满足条件</span></span><br><span class="line">        nameList.add(personItem.name); <span class="comment">// 加入姓名集合</span></span><br><span class="line">        <span class="keyword">if</span>(nameList.size() &gt;= <span class="number">10</span>)&#123; <span class="comment">// 判断是否超过限制</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nameList;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数式<code>stream</code>解决方案：</p>
</blockquote>
<p>　　下面我们给出一种基于<code>stream</code>流的解决方案(伪代码)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; personList = fromDB(); <span class="comment">// 获得List&lt;Person&gt;</span></span><br><span class="line">List&lt;String&gt; nameList = personList.stream()</span><br><span class="line">　　　　　　.filter(item-&gt;item.age == <span class="number">70</span>) <span class="comment">// 过滤条件</span></span><br><span class="line">　　　　　　.limit(<span class="number">10</span>)    <span class="comment">// limit限制条件</span></span><br><span class="line">　　　　　　.map(item-&gt;item.name) <span class="comment">// 获得姓名</span></span><br><span class="line">　　　　　　.collect(Collector.toList()); <span class="comment">// 转化为list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nameList;</span><br></pre></td></tr></table></figure>

<p>两种方案的不同之处：</p>
<p>　　从函数式的角度上看，过程式的代码实现将收集元素、循环迭代、各种逻辑判断耦合在一起，暴露了太多细节。当未来需求变动和变得更加复杂的情况下，过程式的代码将变得难以理解和维护(需要控制台打印出 年龄为<code>70</code>岁的前10个<code>Person</code>中，姓王的<code>Person</code>的名称）。</p>
<p>　　函数式的解决方案解开了代码细节和业务逻辑的耦合，类似于<code>sql</code>语句，表达的是”要做什么”而不是”如何去做”，使程序员可以更加专注于业务逻辑，写出易于理解和维护的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; personList = fromDB(); <span class="comment">// 获得List&lt;Person&gt;</span></span><br><span class="line">personList.stream()</span><br><span class="line">    .filter(item-&gt;item.age == <span class="number">70</span>) <span class="comment">// 过滤条件</span></span><br><span class="line">    .limit(<span class="number">10</span>)    <span class="comment">// limit限制条件</span></span><br><span class="line">    .filter(item-&gt;item.name.startWith(<span class="string">&quot;王&quot;</span>))  <span class="comment">// 过滤条件</span></span><br><span class="line">    .map(item-&gt;item.name) <span class="comment">// 获得姓名</span></span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>


<h1 id="stream-API接口介绍"><a href="#stream-API接口介绍" class="headerlink" title="stream API接口介绍"></a><code>stream API</code>接口介绍</h1><p><code>stream API</code>的接口是函数式的，尽管<code>java 8</code>也引入了<code>lambda</code>表达式，但<code>java</code>实质上依然是由接口-匿名内部类来实现函数传参的，所以需要事先定义一系列的函数式接口。</p>
<blockquote>
<p><code>Function:</code> 类似于 <code>y = F(x)</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">R</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数式接口</span></span><br><span class="line"><span class="comment">     * 类似于 y = F(x)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>BiFunction</code>: 类似于 <code>z = F(x,y)</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">R</span>, <span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数式接口</span></span><br><span class="line"><span class="comment">     * 类似于 z = F(x,y)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ForEach</code>: 遍历处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ForEach</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代器遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 被迭代的每一项</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(T item)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Comparator</code>: 比较器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较方法逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o1    参数1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o2    参数2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>      返回值大于0 ---&gt; (o1 &gt; o2)</span></span><br><span class="line"><span class="comment">     *              返回值等于0 ---&gt; (o1 = o2)</span></span><br><span class="line"><span class="comment">     *              返回值小于0 ---&gt; (o1 &lt; o2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Predicate:</code> 条件判断</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数式接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 迭代的每一项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 满足条件</span></span><br><span class="line"><span class="comment">     *          false 不满足条件</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">satisfy</span><span class="params">(T item)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Supplier：</code>提供初始值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供初始值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 初始化的值</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>EvalFunction：stream</code>求值函数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EvalFunction</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * stream流的强制求值方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 求值返回一个新的stream</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">MyStream&lt;T&gt; <span class="title">apply</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stream-API接口："><a href="#stream-API接口：" class="headerlink" title="stream API接口："></a><code>stream API</code>接口：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * stream流的API接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stream</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 映射 lazy 惰性求值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapper 转换逻辑 T-&gt;R</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个新的流</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    &lt;R&gt; <span class="function">MyStream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;R,T&gt; mapper)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扁平化 映射 lazy 惰性求值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapper 转换逻辑 T-&gt;MyStream&lt;R&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  一个新的流(扁平化之后)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    &lt;R&gt; <span class="function">MyStream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? extends MyStream&lt;R&gt;, T&gt; mapper)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤 lazy 惰性求值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> predicate 谓词判断</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个新的流，其中元素是满足predicate条件的</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">MyStream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;T&gt; predicate)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 截断 lazy 惰性求值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 截断流，只获取部分</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个新的流，其中的元素不超过 n</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">MyStream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去重操作 lazy 惰性求值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个新的流，其中的元素不重复(!equals）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">MyStream&lt;T&gt; <span class="title">distinct</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 窥视 lazy 惰性求值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 同一个流，peek不改变流的任何行为</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">MyStream&lt;T&gt; <span class="title">peek</span><span class="params">(ForEach&lt;T&gt; consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历 eval 强制求值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer 遍历逻辑</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(ForEach&lt;T&gt; consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 浓缩 eval 强制求值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initVal 浓缩时的初始值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accumulator 浓缩时的 累加逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 浓缩之后的结果</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    &lt;R&gt; <span class="function">R <span class="title">reduce</span><span class="params">(R initVal, BiFunction&lt;R, R, T&gt; accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收集 eval 强制求值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> collector 传入所需的函数组合子，生成高阶函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 收集之后的结果</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    &lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;T,A,R&gt; collector)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大值 eval 强制求值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> comparator 大小比较逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 流中的最大值</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">T <span class="title">max</span><span class="params">(Comparator&lt;T&gt; comparator)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小值 eval 强制求值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> comparator 大小比较逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 流中的最小值</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">T <span class="title">min</span><span class="params">(Comparator&lt;T&gt; comparator)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数 eval 强制求值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  当前流的个数</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流中是否存在满足predicate的项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 匹配项</span></span><br><span class="line"><span class="comment">     *         false 不存在 匹配项</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流中的元素是否全部满足predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 全部满足</span></span><br><span class="line"><span class="comment">     *          false 不全部满足</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回空的 stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 空stream</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">MyStream&lt;T&gt; <span class="title">makeEmptyStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// isEnd = true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyStream.Builder&lt;T&gt;().isEnd(<span class="keyword">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MyStream-实现细节"><a href="#MyStream-实现细节" class="headerlink" title="MyStream 实现细节"></a><code>MyStream</code> 实现细节</h2><p>简单介绍了<code>API</code>接口定义之后，我们开始深入探讨流的内部实现。</p>
<p>　　流由两个重要的部分所组成，当前数据项(head)”和”下一数据项的求值函数<code>(nextItemEvalProcess)</code>。</p>
<p>　　其中，<code>nextItemEvalProcess</code>是流能够实现”惰性求值”的关键。</p>
<img data-src="/blog/posts/8b8fedea/2022-02-13-23-00-11.png" class="">

<blockquote>
<p>流的基本属性：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStream</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Stream</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流的头部</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> T head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流的下一项求值函数</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> NextItemEvalProcess nextItemEvalProcess;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是流的结尾</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> MyStream&lt;T&gt; target;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.target = <span class="keyword">new</span> MyStream&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder&lt;T&gt; <span class="title">head</span><span class="params">(T head)</span></span>&#123;</span><br><span class="line">            target.head = head;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Builder&lt;T&gt; <span class="title">isEnd</span><span class="params">(<span class="keyword">boolean</span> isEnd)</span></span>&#123;</span><br><span class="line">            target.isEnd = isEnd;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder&lt;T&gt; <span class="title">nextItemEvalProcess</span><span class="params">(NextItemEvalProcess nextItemEvalProcess)</span></span>&#123;</span><br><span class="line">            target.nextItemEvalProcess = nextItemEvalProcess;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyStream&lt;T&gt; <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前流强制求值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 求值之后返回一个新的流</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MyStream&lt;T&gt; <span class="title">eval</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.nextItemEvalProcess.eval();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前流 为空</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmptyStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下一个元素求值过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextItemEvalProcess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求值方法</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> EvalFunction evalFunction;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NextItemEvalProcess</span><span class="params">(EvalFunction evalFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.evalFunction = evalFunction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyStream <span class="title">eval</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> evalFunction.apply();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-stream流在使用过程中的三个阶段"><a href="#4-1-stream流在使用过程中的三个阶段" class="headerlink" title="4.1 stream流在使用过程中的三个阶段"></a>4.1 <code>stream</code>流在使用过程中的三个阶段</h3><ol>
<li><p>生成并构造一个流 (List.stream() 等方法)</p>
</li>
<li><p>在流的处理过程中添加、绑定惰性求值流程  (map、filter、limit 等方法)</p>
</li>
<li><p>对流使用强制求值函数，生成最终结果 (max、collect、forEach等方法)</p>
</li>
</ol>
<h3 id="4-2-生成并构造一个流"><a href="#4-2-生成并构造一个流" class="headerlink" title="4.2 生成并构造一个流"></a>4.2 生成并构造一个流</h3><p>　　流在生成时是”纯净”的，其最初的<code>NextItemEvalProcess</code>求值之后就是指向自己的下一个元素。</p>
<p>　　我们以一个<code>Integer</code>整数流的生成为例。<code>IntegerStreamGenerator.getIntegerStream(1,10) </code>会返回一个流结构，其逻辑上等价于一个从<code>1</code>到<code>10</code>的整数流。但实质是一个惰性求值的<code>stream</code>对象，这里称其为<code>IntStream</code>，其<code>NextItemEvalProcess</code>是一个闭包，方法体是一个递归结构的求值函数，其中下界参数<code>low = low + 1</code>。</p>
<p>　　当<code>IntStream</code>第一次被求值时，流开始初始化，<code>isStart = false</code>。当初始化完成之后，每一次求值，都会生成一个新的流对象，其中<code>head(low) = low + 1</code>。当<code>low &gt; high</code>时，流被终止，返回空的流对象。</p>
<img data-src="/blog/posts/8b8fedea/2022-02-13-23-00-27.png" class="">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整数流生成器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerStreamGenerator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得一个有限的整数流 介于[low-high]之间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> low 下界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> high 上界</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyStream&lt;Integer&gt; <span class="title">getIntegerStream</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getIntegerStreamInner(low,high,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归函数。配合getIntegerStream(int low,int high)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MyStream&lt;Integer&gt; <span class="title">getIntegerStreamInner</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">boolean</span> isStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high)&#123;</span><br><span class="line">            <span class="comment">// 到达边界条件，返回空的流</span></span><br><span class="line">            <span class="keyword">return</span> Stream.makeEmptyStream();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isStart)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyStream.Builder&lt;Integer&gt;()</span><br><span class="line">                    .process(<span class="keyword">new</span> NextItemEvalProcess(()-&gt;getIntegerStreamInner(low,high,<span class="keyword">false</span>)))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyStream.Builder&lt;Integer&gt;()</span><br><span class="line">                    <span class="comment">// 当前元素 low</span></span><br><span class="line">                    .head(low)</span><br><span class="line">                    <span class="comment">// 下一个元素 low+1</span></span><br><span class="line">                    .process(<span class="keyword">new</span> NextItemEvalProcess(()-&gt;getIntegerStreamInner(low+<span class="number">1</span>,high,<span class="keyword">false</span>)))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，生成一个流的关键在于确定如何求值下一项元素。对于整数流来说，<code>low = low + 1</code>就是其下一项的求值过程。</p>
<p>　　那么对于我们非常关心的<code>jdk</code>集合容器，又该如何生成对应的流呢?</p>
<p>　　答案是<code>Iterator</code>迭代器，<code>jdk</code>的集合容器都实现了<code>Iterator</code>迭代器接口，通过迭代器我们可以轻易的取得容器的下一项元素，而不用关心容器内部实现细节。换句话说，只要实现过迭代器接口，就可以自然的转化为<code>stream</code>流，从而获得流计算的所有能力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合流生成器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionStreamGenerator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个List转化为stream流</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MyStream&lt;T&gt; <span class="title">getListStream</span><span class="params">(List&lt;T&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getListStream(list.iterator(),<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iterator list 集合的迭代器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isStart 是否是第一次迭代</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">MyStream&lt;T&gt; <span class="title">getListStream</span><span class="params">(Iterator&lt;T&gt; iterator, <span class="keyword">boolean</span> isStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!iterator.hasNext())&#123;</span><br><span class="line">            <span class="comment">// 不存在迭代的下一个元素，返回空的流</span></span><br><span class="line">            <span class="keyword">return</span> Stream.makeEmptyStream();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isStart)&#123;</span><br><span class="line">            <span class="comment">// 初始化，只需要设置 求值过程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyStream.Builder&lt;T&gt;()</span><br><span class="line">                    .nextItemEvalProcess(<span class="keyword">new</span> NextItemEvalProcess(()-&gt; getListStream(iterator,<span class="keyword">false</span>)))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 非初始化，设置head和接下来的求值过程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyStream.Builder&lt;T&gt;()</span><br><span class="line">                    .head(iterator.next())</span><br><span class="line">                    .nextItemEvalProcess(<span class="keyword">new</span> NextItemEvalProcess(()-&gt; getListStream(iterator,<span class="keyword">false</span>)))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h2><p>　　我们选择一个简单而又不失一般性的例子，串联起这些内容。通过完整的描述一个流求值的全过程，加深大家对流的理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Integer sum = IntegerStreamGenerator.getIntegerStream(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">                .filter(item-&gt; item%<span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 过滤出偶数</span></span><br><span class="line">                .map(item-&gt; item * item)    <span class="comment">// 映射为平方</span></span><br><span class="line">                .limit(<span class="number">2</span>)                   <span class="comment">// 截取前两个</span></span><br><span class="line">                .reduce(<span class="number">0</span>,(i1,i2)-&gt; i1+i2); <span class="comment">// 最终结果累加求和(初始值为0)</span></span><br><span class="line"></span><br><span class="line">    System.out.println(sum); <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于我们的<code>stream</code>实现采用的是链式编程的方式，不太好理解，将其展开为逻辑等价的形式。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;　　　　 <span class="comment">// 生成整数流 1-10</span></span><br><span class="line">    Stream&lt;Integer&gt; intStream = IntegerStreamGenerator.getIntegerStream(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// intStream基础上过滤出偶数</span></span><br><span class="line">    Stream&lt;Integer&gt; filterStream =  intStream.filter(item-&gt; item%<span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// filterStream基础上映射为平方</span></span><br><span class="line">    Stream&lt;Integer&gt; mapStream = filterStream.map(item-&gt; item * item);</span><br><span class="line">    <span class="comment">// mapStream基础上截取前两个</span></span><br><span class="line">    Stream&lt;Integer&gt; limitStream = mapStream.limit(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 最终结果累加求和(初始值为0)</span></span><br><span class="line">    Integer sum = limitStream.reduce(<span class="number">0</span>,(i1,i2)-&gt; i1+i2);</span><br><span class="line"></span><br><span class="line">    System.out.println(sum); <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>reduce</code>强制求值操作之前的执行过程图：</p>
</blockquote>
<img data-src="/blog/posts/8b8fedea/2022-02-13-23-00-42.png" class="">

<blockquote>
<p><code>reduce</code>强制求值过程中的执行过程图 ：</p>
</blockquote>
<img data-src="/blog/posts/8b8fedea/2022-02-13-23-00-49.png" class="">

<p>可以看到，<code>stream</code>的求值过程并不会一口气将初始的流全部求值，而是按需的、一个一个的进行求值。</p>
<p><code>stream</code>的一次求值过程至多只会遍历流中元素一次；如果存在短路操作(<code>limit、anyMatch</code>等)，实际迭代的次数会更少。</p>
<p>因此不必担心多层的<code>map、filter</code>处理逻辑的嵌套会让流进行多次迭代，导致效率急剧下降。</p>
<img data-src="/blog/posts/8b8fedea/2022-02-13-23-00-59.png" class="">

<hr/>



<h2 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h2><img data-src="/blog/posts/8b8fedea/2022-02-13-23-01-07.png" class="">

<ul>
<li><p>无状态：指元素的处理不受之前元素的影响；</p>
</li>
<li><p>有状态：指该操作只有拿到所有元素之后才能继续下去。</p>
</li>
<li><p>非短路操作：指必须处理所有元素才能得到最终结果；</p>
</li>
<li><p>短路操作：指遇到某些符合条件的元素就可以得到最终结果，如<code> A || B</code>，只要<code>A</code>为<code>true</code>，则无需判断<code>B</code>的结果。</p>
</li>
</ul>
<h3 id="1-流的常用创建方法"><a href="#1-流的常用创建方法" class="headerlink" title="1. 流的常用创建方法"></a>1. 流的常用创建方法</h3><h4 id="1-1-使用Collection下的-stream-和-parallelStream-方法"><a href="#1-1-使用Collection下的-stream-和-parallelStream-方法" class="headerlink" title="1.1 使用Collection下的 stream() 和 parallelStream() 方法"></a>1.1 使用<code>Collection</code>下的 <code>stream()</code> 和 <code>parallelStream()</code> 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = list.stream(); <span class="comment">//获取一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream(); <span class="comment">//获取一个并行流</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-使用Arrays-中的-stream-方法，将数组转成流"><a href="#1-2-使用Arrays-中的-stream-方法，将数组转成流" class="headerlink" title="1.2 使用Arrays 中的 stream() 方法，将数组转成流"></a>1.2 使用<code>Arrays</code> 中的 <code>stream()</code> 方法，将数组转成流</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(nums);</span><br></pre></td></tr></table></figure>
<h4 id="1-3-使用Stream中的静态方法：of-、iterate-、generate"><a href="#1-3-使用Stream中的静态方法：of-、iterate-、generate" class="headerlink" title="1.3 使用Stream中的静态方法：of()、iterate()、generate()"></a>1.3 使用<code>Stream</code>中的静态方法：<code>of()、iterate()、generate()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">2</span>).limit(<span class="number">6</span>);</span><br><span class="line">stream2.forEach(System.out::println); <span class="comment">// 0 2 4 6 8 10</span></span><br><span class="line"> </span><br><span class="line">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="number">2</span>);</span><br><span class="line">stream3.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="1-4-使用-BufferedReader-lines-方法，将每行内容转成流"><a href="#1-4-使用-BufferedReader-lines-方法，将每行内容转成流" class="headerlink" title="1.4 使用 BufferedReader.lines() 方法，将每行内容转成流"></a>1.4 使用 <code>BufferedReader.lines()</code> 方法，将每行内容转成流</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;F:\\test_stream.txt&quot;</span>));</span><br><span class="line">Stream&lt;String&gt; lineStream = reader.lines();</span><br><span class="line">lineStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="1-5-使用-Pattern-splitAsStream-方法，将字符串分隔成流"><a href="#1-5-使用-Pattern-splitAsStream-方法，将字符串分隔成流" class="headerlink" title="1.5 使用 Pattern.splitAsStream() 方法，将字符串分隔成流"></a>1.5 使用 <code>Pattern.splitAsStream()</code> 方法，将字符串分隔成流</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stringStream = pattern.splitAsStream(<span class="string">&quot;a,b,c,d&quot;</span>);</span><br><span class="line">stringStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="2-流的中间操作"><a href="#2-流的中间操作" class="headerlink" title="2. 流的中间操作"></a><code>2.</code> 流的中间操作</h3><h4 id="2-1-筛选与切片"><a href="#2-1-筛选与切片" class="headerlink" title="2.1 筛选与切片"></a><code>2.1</code> 筛选与切片</h4><p><code>filter：</code>过滤流中的某些元素</p>
<p><code>limit(n)：</code>获取<code>n</code>个元素</p>
<p><code>skip(n)：</code>跳过<code>n</code>元素，配合<code>limit(n)</code>可实现分页</p>
<p><code>distinct：</code>通过流中元素的 <code>hashCode()</code> 和 <code>equals()</code> 去除重复元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">14</span>);</span><br><span class="line"> </span><br><span class="line">Stream&lt;Integer&gt; newStream = stream.filter(s -&gt; s &gt; <span class="number">5</span>) <span class="comment">//6 6 7 9 8 10 12 14 14</span></span><br><span class="line">        .distinct() <span class="comment">//6 7 9 8 10 12 14</span></span><br><span class="line">        .skip(<span class="number">2</span>) <span class="comment">//9 8 10 12 14</span></span><br><span class="line">        .limit(<span class="number">2</span>); <span class="comment">//9 8</span></span><br><span class="line">newStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-映射"><a href="#2-2-映射" class="headerlink" title="2.2 映射"></a><code>2.2</code> 映射</h4><ul>
<li><code>map：</code>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li>
<li><code>flatMap：</code>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;1,2,3&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将每个元素转成一个新的且不带逗号的元素</span></span><br><span class="line">Stream&lt;String&gt; s1 = list.stream().map(s -&gt; s.replaceAll(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">s1.forEach(System.out::println); <span class="comment">// abc  123</span></span><br><span class="line"> </span><br><span class="line">Stream&lt;String&gt; s3 = list.stream().flatMap(s -&gt; &#123;</span><br><span class="line">    <span class="comment">//将每个元素转换成一个stream</span></span><br><span class="line">    String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; s2 = Arrays.stream(split);</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;);</span><br><span class="line">s3.forEach(System.out::println); <span class="comment">// a b c 1 2 3</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-排序"><a href="#2-3-排序" class="headerlink" title="2.3 排序"></a><code>2.3</code> 排序</h4><ul>
<li><code>sorted()：</code>自然排序，流中元素需实现<code>Comparable</code>接口</li>
<li><code>sorted(Comparator com)：</code>定制排序，自定义<code>Comparator</code>排序器  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;ff&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line"><span class="comment">//String 类自身已实现Compareable接口</span></span><br><span class="line">list.stream().sorted().forEach(System.out::println);<span class="comment">// aa dd ff</span></span><br><span class="line"> </span><br><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>);</span><br><span class="line">Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;aa&quot;</span>, <span class="number">30</span>);</span><br><span class="line">Student s4 = <span class="keyword">new</span> Student(<span class="string">&quot;dd&quot;</span>, <span class="number">40</span>);</span><br><span class="line">List&lt;Student&gt; studentList = Arrays.asList(s1, s2, s3, s4);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义排序：先按姓名升序，姓名相同则按年龄升序</span></span><br><span class="line">studentList.stream().sorted(</span><br><span class="line">        (o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1.getName().equals(o2.getName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="2-4-消费"><a href="#2-4-消费" class="headerlink" title="2.4 消费"></a>2.4 消费</h4><p><code>peek：</code>如同于<code>map</code>，能得到流中的每一个元素。但<code>map</code>接收的是一个<code>Function</code>表达式，有返回值；而<code>peek</code>接收的是<code>Consumer</code>表达式，没有返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>);</span><br><span class="line">List&lt;Student&gt; studentList = Arrays.asList(s1, s2);</span><br><span class="line"> </span><br><span class="line">studentList.stream()</span><br><span class="line">        .peek(o -&gt; o.setAge(<span class="number">100</span>))</span><br><span class="line">        .forEach(System.out::println);   </span><br><span class="line"> </span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line">Student&#123;name=<span class="string">&#x27;aa&#x27;</span>, age=<span class="number">100</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;bb&#x27;</span>, age=<span class="number">100</span>&#125;            </span><br></pre></td></tr></table></figure>
<h3 id="3-流的终止操作"><a href="#3-流的终止操作" class="headerlink" title="3. 流的终止操作"></a>3. 流的终止操作</h3><h4 id="3-1-匹配、聚合操作"><a href="#3-1-匹配、聚合操作" class="headerlink" title="3.1 匹配、聚合操作"></a>3.1 匹配、聚合操作</h4><p><code>allMatch</code>：接收一个 <code>Predicate</code> 函数，当流中每个元素都符合该断言时才返回<code>true</code>，否则返回<code>false</code></p>
<ul>
<li><code>noneMatch</code>：接收一个 <code>Predicate</code> 函数，当流中每个元素都不符合该断言时才返回<code>true</code>，否则返回<code>false</code></li>
<li><code>anyMatch</code>：接收一个 <code>Predicate</code> 函数，只要流中有一个元素满足该断言则返回<code>true</code>，否则返回<code>false</code></li>
<li><code>findFirst</code>：返回流中第一个元素</li>
<li><code>findAny</code>：返回流中的任意元素</li>
<li><code>count</code>：返回流中元素的总个数</li>
<li><code>max</code>：返回流中元素最大值</li>
<li><code>min</code>：返回流中元素最小值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">boolean</span> allMatch = list.stream().allMatch(e -&gt; e &gt; <span class="number">10</span>); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">boolean</span> noneMatch = list.stream().noneMatch(e -&gt; e &gt; <span class="number">10</span>); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">boolean</span> anyMatch = list.stream().anyMatch(e -&gt; e &gt; <span class="number">4</span>);  <span class="comment">//true</span></span><br><span class="line"> </span><br><span class="line">Integer findFirst = list.stream().findFirst().get(); <span class="comment">//1</span></span><br><span class="line">Integer findAny = list.stream().findAny().get(); <span class="comment">//1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> count = list.stream().count(); <span class="comment">//5</span></span><br><span class="line">Integer max = list.stream().max(Integer::compareTo).get(); <span class="comment">//5</span></span><br><span class="line">Integer min = list.stream().min(Integer::compareTo).get(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-规约操作"><a href="#3-2-规约操作" class="headerlink" title="3.2 规约操作"></a>3.2 规约操作</h4><p><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)：</code>第一次执行时，<code>accumulator</code>函数的第一个参数为流中的第一个元素，第二个参数为流中元素的第二个元素；第二次执行时，第一个参数为第一次函数执行的结果，第二个参数为流中的第三个元素；依次类推。</p>
<p><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)：</code>流程跟上面一样，只是第一次执行时，<code>accumulator</code>函数的第一个参数为<code>identity</code>，而第二个参数为流中的第一个元素。</p>
<p><code>&lt;U&gt; U reduce(U identity,BiFunction&lt;U, ? super T, U&gt; accumulator,BinaryOperator&lt;U&gt; combiner)：</code>在串行流(<code>stream</code>)中，该方法跟第二个方法一样，即第三个参数<code>combiner</code>不会起作用。在并行流(<code>parallelStream</code>)中,我们知道流被<code>fork join</code>出多个线程进行执行，此时每个线程的执行流程就跟第二个方法<code>reduce(identity,accumulator)</code>一样，而第三个参数<code>combiner</code>函数，则是将每个线程的执行结果当成一个新的流，然后使用第一个方法<code>reduce(accumulator)</code>流程进行规约。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//经过测试，当元素个数小于24时，并行时线程数等于元素个数，当大于等于24时，并行时线程数为16</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>);</span><br><span class="line"> </span><br><span class="line">Integer v = list.stream().reduce((x1, x2) -&gt; x1 + x2).get();</span><br><span class="line">System.out.println(v);   <span class="comment">// 300</span></span><br><span class="line"> </span><br><span class="line">Integer v1 = list.stream().reduce(<span class="number">10</span>, (x1, x2) -&gt; x1 + x2);</span><br><span class="line">System.out.println(v1);  <span class="comment">//310</span></span><br><span class="line"> </span><br><span class="line">Integer v2 = list.stream().reduce(<span class="number">0</span>,</span><br><span class="line">        (x1, x2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stream accumulator: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">            <span class="keyword">return</span> x1 - x2;</span><br><span class="line">        &#125;,</span><br><span class="line">        (x1, x2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stream combiner: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">            <span class="keyword">return</span> x1 * x2;</span><br><span class="line">        &#125;);</span><br><span class="line">System.out.println(v2); <span class="comment">// -300</span></span><br><span class="line"> </span><br><span class="line">Integer v3 = list.parallelStream().reduce(<span class="number">0</span>,</span><br><span class="line">        (x1, x2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;parallelStream accumulator: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">            <span class="keyword">return</span> x1 - x2;</span><br><span class="line">        &#125;,</span><br><span class="line">        (x1, x2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;parallelStream combiner: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">            <span class="keyword">return</span> x1 * x2;</span><br><span class="line">        &#125;);</span><br><span class="line">System.out.println(v3); <span class="comment">//197474048</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-收集操作"><a href="#3-3-收集操作" class="headerlink" title="3.3 收集操作"></a>3.3 收集操作</h4><ul>
<li><code>collect</code>：接收一个<code>Collector</code>实例，将流中元素收集成另外一个数据结构。</li>
<li><code>Collector&lt;T, A, R&gt;</code> 是一个接口，有以下5个抽象方法：</li>
<li><code>Supplier&lt;A&gt; supplier()</code>：创建一个结果容器A</li>
<li><code>BiConsumer&lt;A, T&gt; accumulator()</code>：消费型接口，第一个参数为容器A，第二个参数为流中元素<code>T</code>。</li>
<li><code>BinaryOperator&lt;A&gt; combiner()</code>：函数接口，该参数的作用跟上一个方法(<code>reduce</code>)中的<code>combiner</code>参数一样，将并行流中各个子进程的运行结果(<code>accumulator</code>函数操作后的容器<code>A</code>)进行合并。</li>
<li><code>Function&lt;A, R&gt; finisher()</code>：函数式接口，参数为：容器<code>A</code>，返回类型为：<code>collect</code>方法最终想要的结果<code>R</code>。</li>
<li><code>Set&lt;Characteristics&gt; characteristics()</code>：返回一个不可变的<code>Set</code>集合，用来表明该<code>Collector</code>的特征。有以下三个特征：<ul>
<li><code>CONCURRENT</code>：表示此收集器支持并发。（官方文档还有其他描述，暂时没去探索，故不作过多翻译）</li>
<li><code>UNORDERED</code>：表示该收集操作不会保留流中元素原有的顺序。</li>
<li><code>IDENTITY_FINISH</code>：表示<code>finisher</code>参数只是标识而已，可忽略。</li>
</ul>
</li>
</ul>
<h5 id="3-3-1-Collector-工具库：Collectors"><a href="#3-3-1-Collector-工具库：Collectors" class="headerlink" title="3.3.1 Collector 工具库：Collectors"></a>3.3.1 <code>Collector</code> 工具库：Collectors</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>,<span class="number">2</span>);</span><br><span class="line">Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;cc&quot;</span>, <span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">List&lt;Student&gt; list = Arrays.asList(s1, s2, s3);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//装成list</span></span><br><span class="line">List&lt;Integer&gt; ageList = list.stream().map(Student::getAge).collect(Collectors.toList()); <span class="comment">// [10, 20, 10]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//转成set</span></span><br><span class="line">Set&lt;Integer&gt; ageSet = list.stream().map(Student::getAge).collect(Collectors.toSet()); <span class="comment">// [20, 10]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//转成map,注:key不能相同，否则报错</span></span><br><span class="line">Map&lt;String, Integer&gt; studentMap = list.stream().collect(Collectors.toMap(Student::getName, Student::getAge)); <span class="comment">// &#123;cc=10, bb=20, aa=10&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//字符串分隔符连接</span></span><br><span class="line">String joinName = list.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>)); <span class="comment">// (aa,bb,cc)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//聚合操作</span></span><br><span class="line"><span class="comment">//1.学生总数</span></span><br><span class="line">Long count = list.stream().collect(Collectors.counting()); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">//2.最大年龄 (最小的minBy同理)</span></span><br><span class="line">Integer maxAge = list.stream().map(Student::getAge).collect(Collectors.maxBy(Integer::compare)).get(); <span class="comment">// 20</span></span><br><span class="line"><span class="comment">//3.所有人的年龄</span></span><br><span class="line">Integer sumAge = list.stream().collect(Collectors.summingInt(Student::getAge)); <span class="comment">// 40</span></span><br><span class="line"><span class="comment">//4.平均年龄</span></span><br><span class="line">Double averageAge = list.stream().collect(Collectors.averagingDouble(Student::getAge)); <span class="comment">// 13.333333333333334</span></span><br><span class="line"><span class="comment">// 带上以上所有方法</span></span><br><span class="line">DoubleSummaryStatistics statistics = list.stream().collect(Collectors.summarizingDouble(Student::getAge));</span><br><span class="line">System.out.println(<span class="string">&quot;count:&quot;</span> + statistics.getCount() + <span class="string">&quot;,max:&quot;</span> + statistics.getMax() + <span class="string">&quot;,sum:&quot;</span> + statistics.getSum() + <span class="string">&quot;,average:&quot;</span> + statistics.getAverage());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//分组</span></span><br><span class="line">Map&lt;Integer, List&lt;Student&gt;&gt; ageMap = list.stream().collect(Collectors.groupingBy(Student::getAge));</span><br><span class="line"><span class="comment">//多重分组,先根据类型分再根据年龄分</span></span><br><span class="line">Map&lt;Integer, Map&lt;Integer, List&lt;Student&gt;&gt;&gt; typeAgeMap = list.stream().collect(Collectors.groupingBy(Student::getType, Collectors.groupingBy(Student::getAge)));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//分区</span></span><br><span class="line"><span class="comment">//分成两部分，一部分大于10岁，一部分小于等于10岁</span></span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; partMap = list.stream().collect(Collectors.partitioningBy(v -&gt; v.getAge() &gt; <span class="number">10</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//规约</span></span><br><span class="line">Integer allAge = list.stream().map(Student::getAge).collect(Collectors.reducing(Integer::sum)).get(); <span class="comment">//40</span></span><br></pre></td></tr></table></figure>
<h5 id="3-3-2-Collectors-toList-解析"><a href="#3-3-2-Collectors-toList-解析" class="headerlink" title="3.3.2 Collectors.toList() 解析"></a>3.3.2 <code>Collectors.toList()</code> 解析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//toList 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">            (left, right) -&gt; &#123;</span><br><span class="line">                left.addAll(right);</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;, CH_ID);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//为了更好地理解，我们转化一下源码中的lambda表达式</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    Supplier&lt;List&lt;T&gt;&gt; supplier = () -&gt; <span class="keyword">new</span> ArrayList();</span><br><span class="line">    BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator = (list, t) -&gt; list.add(t);</span><br><span class="line">    BinaryOperator&lt;List&lt;T&gt;&gt; combiner = (list1, list2) -&gt; &#123;</span><br><span class="line">        list1.addAll(list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;;</span><br><span class="line">    Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; finisher = (list) -&gt; list;</span><br><span class="line">    Set&lt;Collector.Characteristics&gt; characteristics = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Collector&lt;T, List&lt;T&gt;, List&lt;T&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Supplier <span class="title">supplier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> supplier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> BiConsumer <span class="title">accumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> accumulator;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> BinaryOperator <span class="title">combiner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> combiner;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Function <span class="title">finisher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> finisher;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> characteristics;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
        <category>Stream</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>The learning of Shell</title>
    <url>/blog/posts/55b095e0/</url>
    <content><![CDATA[<p>Nowdays , i hava a task about how to use shell script ,so it is time to learn shell .</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamluZ21veHVrb25nL3AvNzg2NzM5Ny5odG1s"> shell  入门 </span></p>
<p><span class="exturl" data-url="aHR0cDovL3Rvb2wucmJ0cmVlLmNuLw=="> 好用的工具网站 </span></p>
<span id="more"></span>

<h2 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a><code>ALL</code></h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC1jb21tYW5kLW1hbnVhbC5odG1s">https://www.runoob.com/linux/linux-command-manual.html</span></p>
<h2 id="zip和upzip"><a href="#zip和upzip" class="headerlink" title="zip和upzip"></a><code>zip</code>和<code>upzip</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zip命令的选项说明</span></span><br><span class="line"><span class="comment"># -A：调整可执行的自动解压缩文件。</span></span><br><span class="line"><span class="comment"># -b&lt;工作目录&gt;：指定暂时存放文件的目录。</span></span><br><span class="line"><span class="comment"># -c：替每个被压缩的文件加上注释。</span></span><br><span class="line"><span class="comment"># -d：从压缩文件内删除指定的文件。</span></span><br><span class="line"><span class="comment"># -D：压缩文件内不建立目录名称。</span></span><br><span class="line"><span class="comment"># -f：此参数的效果和指定&quot;-u&quot;参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中。</span></span><br><span class="line"><span class="comment"># -F：尝试修复已损坏的压缩文件。</span></span><br><span class="line"><span class="comment"># -g：将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件。</span></span><br><span class="line"><span class="comment"># -h：在线帮助。</span></span><br><span class="line"><span class="comment"># -i&lt;范本样式&gt;：只压缩符合条件的文件。</span></span><br><span class="line"><span class="comment"># -j：只保存文件名称及其内容，而不存放任何目录名称。</span></span><br><span class="line"><span class="comment"># -J：删除压缩文件前面不必要的数据。</span></span><br><span class="line"><span class="comment"># -k：使用MS-DOS兼容格式的文件名称。</span></span><br><span class="line"><span class="comment"># -l：压缩文件时，把LF字符置换成LF+CR字符。</span></span><br><span class="line"><span class="comment"># -ll：压缩文件时，把LF+CR字符置换成LF字符。</span></span><br><span class="line"><span class="comment"># -L：显示版权信息。</span></span><br><span class="line"><span class="comment"># -m：将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。</span></span><br><span class="line"><span class="comment"># -n&lt;字尾字符串&gt;：不压缩具有特定字尾字符串的文件。</span></span><br><span class="line"><span class="comment"># -o：以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。</span></span><br><span class="line"><span class="comment"># -q：不显示指令执行过程。</span></span><br><span class="line"><span class="comment"># -r：递归处理，将指定目录下的所有文件和子目录一并处理。</span></span><br><span class="line"><span class="comment"># -S：包含系统和隐藏文件。</span></span><br><span class="line"><span class="comment"># -t&lt;日期时间&gt;：把压缩文件的日期设成指定的日期。</span></span><br><span class="line"><span class="comment"># -T：检查备份文件内的每个文件是否正确无误。</span></span><br><span class="line"><span class="comment"># -u：更换较新的文件到压缩文件内。</span></span><br><span class="line"><span class="comment"># -v：显示指令执行过程或显示版本信息。</span></span><br><span class="line"><span class="comment"># -V：保存VMS操作系统的文件属性。</span></span><br><span class="line"><span class="comment"># -w：在文件名称里假如版本编号，本参数仅在VMS操作系统下有效。</span></span><br><span class="line"><span class="comment"># -x&lt;范本样式&gt;：压缩时排除符合条件的文件。</span></span><br><span class="line"><span class="comment"># -X：不保存额外的文件属性。</span></span><br><span class="line"><span class="comment"># -y：直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效。</span></span><br><span class="line"><span class="comment"># -z：替压缩文件加上注释。</span></span><br><span class="line"><span class="comment"># -$：保存第一个被压缩文件所在磁盘的卷册名称。</span></span><br><span class="line"><span class="comment"># -&lt;压缩效率&gt;：压缩效率是一个介于1-9的数值。</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$zip</span> -m new_zip_name old_filename</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压到当前目录 如果文件已存在，会提示是否替换，可以使用 -o 或 -n 参数简化交互；</span></span><br><span class="line"><span class="variable">$unzip</span> test.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压到指定目录 解压后的文件路径:/&#123;targetPath&#125;/test</span></span><br><span class="line"><span class="variable">$unzip</span> -d &#123;targetPath&#125; test.zip </span><br><span class="line"></span><br><span class="line"><span class="comment"># 不覆盖已经存在的文件</span></span><br><span class="line"><span class="variable">$unzip</span> -n test.zip</span><br><span class="line"></span><br><span class="line"><span class="comment">#强制覆盖已经存在的文件</span></span><br><span class="line"><span class="variable">$unzip</span> -o test.zip</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看压缩包中的文件列表</span></span><br><span class="line"><span class="comment"># 文件大小、时间、文件名称 不进行解压缩</span></span><br><span class="line"><span class="variable">$unzip</span> -l test.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看压缩包中的文件信息【更详细】 </span></span><br><span class="line"><span class="comment"># 文件大小、压缩比、日期、文件名称</span></span><br><span class="line"><span class="variable">$unzip</span> -v test.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查压缩包是否损坏</span></span><br><span class="line"><span class="variable">$unzip</span> -t test.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示压缩文件的备注</span></span><br><span class="line"><span class="variable">$unzip</span> -z test.zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行解压不显示任何信息</span></span><br><span class="line"><span class="variable">$unzip</span> -q test.zip</span><br><span class="line"><span class="variable">$unzip</span> -oq test.zip <span class="comment"># 静默解压没有任何提示</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Bash-shell脚本打印出正在执行的命令"><a href="#Bash-shell脚本打印出正在执行的命令" class="headerlink" title="Bash shell脚本打印出正在执行的命令"></a><code>Bash shell</code>脚本打印出正在执行的命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认情况下，bash脚本不会打印执行的每个命令，这个有时候不太方面。</span></span><br><span class="line"><span class="comment"># 如下的方法可以让bash脚本打印出执行的命令：</span></span><br><span class="line">1） 在脚本里添加 </span><br><span class="line">    <span class="built_in">set</span> -v 或者</span><br><span class="line">    <span class="comment">#!/bin/bash -v</span></span><br><span class="line"></span><br><span class="line">    以加 <span class="built_in">set</span> -v 最好。</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span> -v  和 <span class="built_in">set</span> -o verbose  是一样的</span><br><span class="line"></span><br><span class="line">2) 添加</span><br><span class="line">    <span class="built_in">set</span> -x </span><br><span class="line"></span><br><span class="line">    或者</span><br><span class="line">    <span class="comment">#!/bin/bash -x</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="sed指令"><a href="#sed指令" class="headerlink" title="sed指令"></a><code>sed</code>指令</h2><p><span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzQwMjguaHRtbA=="> 参考地址 </span></p>
<p><code>sed</code> 命令的基本格式如下：<code>sed [选项] [脚本命令] 文件名</code></p>
<p>该命令常用的选项及含义:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-e</code></td>
<td>脚本命令    该选项会将其后跟的脚本命令添加到已有的命令中。</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>脚本命令文件    该选项会将其后文件中的脚本命令添加到已有的命令中。</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>默认情况下，<code>sed</code> 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 <code>print</code> 命令来完成输出。</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>此选项会直接修改源文件，要慎用。</td>
</tr>
</tbody></table>
<h3 id="sed-s-替换脚本命令"><a href="#sed-s-替换脚本命令" class="headerlink" title="sed s 替换脚本命令"></a><code>sed s </code>替换脚本命令</h3><p>此命令的基本格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其中，address 表示指定要操作的具体行，pattern 指的是需要替换的内容，replacement 指的是要替换的新内容。</span></span><br><span class="line">[address]s/pattern/replacement/flags</span><br></pre></td></tr></table></figure>
<p>其中<code>flag</code>:</p>
<table>
<thead>
<tr>
<th><code>flags</code> 标记</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>n</code></td>
<td><code>1~512</code> 之间的数字，表示指定要替换的字符串出现第几次时才进行替换，例如，一行中有 <code>3</code> 个 <code>A</code>，但用户只想替换第二个 <code>A</code>，这是就用到这个标记；</td>
</tr>
<tr>
<td><code>g</code></td>
<td>对数据中所有匹配到的内容进行替换，如果没有 <code>g</code>，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 <code>3</code> 个 <code>A</code>，则只会替换第一个 <code>A</code>；</td>
</tr>
<tr>
<td><code>p</code></td>
<td>会打印与替换命令中指定的模式匹配的行。此标记通常与 <code>-n</code> 选项一起使用。</td>
</tr>
<tr>
<td><code>w file</code></td>
<td>将缓冲区中的内容写到指定的 <code>file</code> 文件中；</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>用正则表达式匹配的内容进行替换；</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>匹配第 <code>n</code> 个子串，该子串之前在 <code>pattern</code> 中用 () 指定。</td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义（转义替换部分包含：<code>&amp;、\</code> 等）。</td>
</tr>
</tbody></table>
<blockquote>
<p><code>tips</code>  – 需要转义的一些字符:</p>
</blockquote>
<img data-src="/blog/posts/55b095e0/2022-05-13-00-07-09.png" class="">

<ol>
<li><p>比如，可以指定 <code>sed</code> 用新文本替换第几处模式匹配的地方：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sed</span> <span class="string">&#x27;s/test/trial/2&#x27;</span> data4.txt</span><br><span class="line">This is a <span class="built_in">test</span> of the trial script.</span><br><span class="line">This is the second <span class="built_in">test</span> of the trial script.</span><br></pre></td></tr></table></figure>
<p> 可以看到，使用数字 <code>2</code> 作为标记的结果就是，<code>sed</code> 编辑器只替换每行中第 <code>2</code> 次出现的匹配模式。</p>
</li>
<li><p>如果要用新文件替换所有匹配的字符串，可以使用 <code>g</code> 标记：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sed</span> <span class="string">&#x27;s/test/trial/g&#x27;</span> data4.txt</span><br><span class="line">This is a trial of the trial script.</span><br><span class="line">This is the second trial of the trial script.</span><br></pre></td></tr></table></figure></li>
<li><p>我们知道，<code>-n</code> 选项会禁止 <code>sed</code> 输出，但 <code>p</code> 标记会输出修改过的行，将二者匹配使用的效果就是只输出被替换命令修改过的行，例如：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cat</span> data5.txt</span><br><span class="line">This is a <span class="built_in">test</span> line.</span><br><span class="line">This is a different line.</span><br><span class="line"><span class="variable">$sed</span> -n <span class="string">&#x27;s/test/trial/p&#x27;</span> data5.txt</span><br><span class="line">This is a trial line.</span><br></pre></td></tr></table></figure></li>
<li><p><code>w</code> 标记会将匹配后的结果保存到指定文件中，比如：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sed</span> <span class="string">&#x27;s/test/trial/w test.txt&#x27;</span> data5.txt</span><br><span class="line">This is a trial line.</span><br><span class="line">This is a different line.</span><br><span class="line"><span class="variable">$#cat</span> test.txt</span><br><span class="line">This is a trial line.</span><br></pre></td></tr></table></figure></li>
<li><p>在使用 <code>s</code> 脚本命令时，替换类似文件路径的字符串会比较麻烦，需要将路径中的正斜线进行转义，例如：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/\/bin\/bash/\/bin\/csh/&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>
<h3 id="sed-d-替换脚本命令"><a href="#sed-d-替换脚本命令" class="headerlink" title="sed d 替换脚本命令"></a><code>sed d</code> 替换脚本命令</h3><p>此命令的基本格式为：<code>[address]d</code></p>
</li>
</ol>
<p>如果需要删除文本中的特定行，可以用 <code>d</code> 脚本命令，它会删除指定行中的所有内容。但使用该命令时要特别小心，如果你忘记指定具体行的话，文件中的所有内容都会被删除，举个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cat</span> data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line"><span class="variable">$sed</span> <span class="string">&#x27;d&#x27;</span> data1.txt</span><br><span class="line"><span class="comment">#什么也不输出，证明成了空文件</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>通过行号指定，比如删除 <code>data6.txt</code> 文件内容中的第 <code>3</code> 行：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cat</span> data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line"><span class="variable">$sed</span> <span class="string">&#x27;3d&#x27;</span> data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure></li>
<li><p>或者通过特定行区间指定，比如删除 <code>data6.txt</code> 文件内容中的第 <code>2、3</code> 行：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sed</span> <span class="string">&#x27;2,3d&#x27;</span> data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure></li>
<li><p>也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心，你指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能，因此，<code>sed</code> 会删除两个指定行之间的所有行（包括指定的行），例如：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sed</span> <span class="string">&#x27;/1/,/3/d&#x27;</span> data6.txt</span><br><span class="line"><span class="comment">#删除第 1~3 行的文本数据</span></span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure></li>
<li><p>或者通过特殊的文件结尾字符，比如删除 <code>data6.txt</code> 文件内容中第 <code>3</code> 行开始的所有的内容：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sed</span> <span class="string">&#x27;3,$d&#x27;</span> data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在此强调，在默认情况下 <code>sed</code> 并不会修改原始文件，这里被删除的行只是从 <code>sed</code> 的输出中消失了，原始文件没做任何改变。</p>
<p><span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzQwMjguaHRtbA=="> 完整版参考地址 </span></p>
<h2 id="Grep指令"><a href="#Grep指令" class="headerlink" title="Grep指令"></a><code>Grep</code>指令</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC1jb21tLWdyZXAuaHRtbA=="> 菜鸟链接 </span></p>
<h2 id="awk指令"><a href="#awk指令" class="headerlink" title="awk指令"></a><code>awk</code>指令</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC1jb21tLWF3ay5odG1s"> 菜鸟链接 </span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ2dqdWNoZW5nL2FyY2hpdmUvMjAxMy8wMS8xMy8yODU4NDcwLmh0bWw="> good 1 </span></p>
<h2 id="cut指令"><a href="#cut指令" class="headerlink" title="cut指令"></a><code>cut</code>指令</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC1jb21tLWN1dC5odG1s"> 菜鸟链接 </span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYWxvbmcyMS9wLzEwMzY2ODg2Lmh0bWw="> 三剑客链接 </span></p>
<h2 id="JSON格式化工具jq指令"><a href="#JSON格式化工具jq指令" class="headerlink" title="JSON格式化工具jq指令"></a><code>JSON</code>格式化工具<code>jq</code>指令</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS9wLzc1NjUzNzEuaHRtbA=="> 参考链接 </span></p>
<h2 id="awk内置函数-split-substr-length-gsub"><a href="#awk内置函数-split-substr-length-gsub" class="headerlink" title="awk内置函数(split/substr/length/gsub)"></a><code>awk</code>内置函数<code>(split/substr/length/gsub)</code></h2><p>一、<code>split</code> 初始化和类型强制</p>
<p><code>awk</code>的内建函数<code>split</code>允许你把一个字符串分隔为单词并存储在数组中。你可以自己定义域分隔符或者使用现在<code>FS(域分隔符)</code>的值。<br>格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">split (string, array, field separator)</span><br><span class="line">split (string, array) –&gt;如果第三个参数没有提供，awk就默认使用当前FS值。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例子：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line">time=<span class="string">&quot;12:34:56&quot;</span>  </span><br><span class="line">out=`<span class="built_in">echo</span> <span class="variable">$time</span> | awk <span class="string">&#x27;&#123;split($0,a,&quot;:&quot;);print a[1],a[2],a[3]&#125;&#x27;</span>`  </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$out</span>  </span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line"><span class="comment">#12 34 56  </span></span><br></pre></td></tr></table></figure>

<p>计算指定范围内的和(计算每个人<code>1</code>月份的工资之和)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.txt:</span></span><br><span class="line"><span class="comment"># Tom　　  2012-12-11      car     53000  </span></span><br><span class="line"><span class="comment"># John　　 2013-01-13      bike    41000  </span></span><br><span class="line"><span class="comment"># vivi    2013-01-18      car     42800  </span></span><br><span class="line"><span class="comment"># Tom　　  2013-01-20      car     32500  </span></span><br><span class="line"><span class="comment"># John　　 2013-01-28      bike    63500  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#`awk`处理命令：</span></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123;split($2,a,&quot;-&quot;);if(a[2]==01)&#123;b[$1]=b[$1]+$4&#125;&#125;END&#123;for(i in b)print i,b[i]&#125;&#x27;</span> test.txt   </span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line"><span class="comment"># Tom　　 32500  </span></span><br><span class="line"><span class="comment"># vivi 42800  </span></span><br><span class="line"><span class="comment"># John　　 104500  </span></span><br></pre></td></tr></table></figure>

<p>二、<code>substr</code> 截取字符串</p>
<p>返回从起始位置起，指定长度之子字符串；若未指定长度，则返回从起始位置到字符串末尾的子字符串。<br>格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">substr(s,p) 返回字符串s中从p开始的后缀部分</span><br><span class="line">substr(s,p,n) 返回字符串s中从p开始长度为n的后缀部分</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例子：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;abc&quot;</span> | awk <span class="string">&#x27;&#123;print substr($0,2,2)&#125;&#x27;</span>  </span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line"><span class="comment"># bc  </span></span><br><span class="line"><span class="comment"># 解释：</span></span><br><span class="line"><span class="comment"># awk -F &#x27;,&#x27; &#x27;&#123;print substr($3,6)&#125;&#x27;    ---&gt;  表示是从第3个字段里的第6个字符开始，一直到设定的分隔符&quot;,&quot;结束.</span></span><br><span class="line"><span class="comment"># substr($3,10,8)  ---&gt;  表示是从第3个字段里的第10个字符开始，截取8个字符结束.</span></span><br><span class="line"><span class="comment"># substr($3,6)     ---&gt;  表示是从第3个字段里的第6个字符开始，一直到结尾</span></span><br></pre></td></tr></table></figure>
<p>三、<code>length</code> 字符串长度</p>
<p><code>length</code>函数返回没有参数的字符串的长度。<code>length</code>函数返回整个记录中的字符数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;abc&quot;</span> | awk <span class="string">&#x27;&#123;print length&#125;&#x27;</span>   </span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="comment"># 3  </span></span><br></pre></td></tr></table></figure>


<p>四、<code>gsub</code>函数</p>
<p>gsub函数则使得在所有正则表达式被匹配的时候都发生替换。<code>gsub(regular expression, subsitution string, target string);简称 gsub（r,s,t)</code>。</p>
<p>举例：把一个文件里面所有包含 <code>abc</code> 的行里面的 <code>abc</code> 替换成 <code>def</code>，然后输出第一列和第三列</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;abc cde abr&quot;</span> | awk <span class="string">&#x27;$0 ~ /abc/ &#123;gsub(&quot;abc&quot;,&quot;def&quot;,$0); print $1, $3&#125;&#x27;</span>  </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># def abr </span></span><br></pre></td></tr></table></figure>

<h2 id="Linux-shell-将字符串分割成数组"><a href="#Linux-shell-将字符串分割成数组" class="headerlink" title="Linux shell 将字符串分割成数组"></a><code>Linux shell</code> 将字符串分割成数组</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;one,two,three,four&quot;</span></span><br><span class="line"><span class="comment"># 要将$a分割开，可以这样：</span></span><br><span class="line"></span><br><span class="line">OLD_IFS=<span class="string">&quot;<span class="variable">$IFS</span>&quot;</span></span><br><span class="line">IFS=<span class="string">&quot;,&quot;</span></span><br><span class="line">arr=(<span class="variable">$a</span>)</span><br><span class="line">IFS=<span class="string">&quot;<span class="variable">$OLD_IFS</span>&quot;</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="variable">$&#123;arr[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$s</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># arr=($a)用于将字符串$a分割到数组$arr $&#123;arr[0]&#125; $&#123;arr[1]&#125; ... 分别存储分割后的数组第1 2 ... 项 ，$&#123;arr[@]&#125;存储整个数组。变量$IFS存储着分隔符，这里我们将其设为逗号 &quot;,&quot; OLD_IFS用于备份默认的分隔符，使用完后将之恢复默认。</span></span><br></pre></td></tr></table></figure>

<h2 id="linux截取中间字符串-shell截取指定字符串之间的内容"><a href="#linux截取中间字符串-shell截取指定字符串之间的内容" class="headerlink" title="linux截取中间字符串,shell截取指定字符串之间的内容"></a><code>linux</code>截取中间字符串,<code>shell</code>截取指定字符串之间的内容</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#截取字符串</span></span><br><span class="line"><span class="comment">#path=ss/usr/share/src/root/home/admin</span></span><br><span class="line">path=ss/usr/share/src/root/home/admin/src/add</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$path</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path%src*&#125;</span> <span class="comment">#从右向左截取第一个 src 后的字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path%/*&#125;</span>从右向左截取 第一个 / 后的字符串</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path%%/*&#125;</span>从右向左截取 最后一个 / 后的字符串</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path#*/&#125;</span>从左向右截取第一个 / 后的字符串</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path##*/&#125;</span>从左向右截取最后一个 / 后的字符串</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path:3&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path:6:60&#125;</span>截取变量path从前三个字符串</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#path&#125;</span>计算 path变量 一共有几个字符串</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path/root/kyo&#125;</span>把path变量里的第一个root字符串，替换为 kyo字符串</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path//s/m&#125;</span>把path变量里的所有的s字符，替换为 m 字符</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;path&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Shell环境生成UUID"><a href="#Shell环境生成UUID" class="headerlink" title="Shell环境生成UUID"></a><code>Shell</code>环境生成<code>UUID</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UUID=$(uuidgen |sed <span class="string">&#x27;s/-//g&#x27;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$UUID</span></span><br><span class="line"><span class="comment"># 918c61bd48914f0e8fb1295208b6e87e</span></span><br></pre></td></tr></table></figure>
<h2 id="Shell中-各种含义"><a href="#Shell中-各种含义" class="headerlink" title="Shell中$ 各种含义"></a><code>Shell</code>中<code>$</code> 各种含义</h2><table>
<thead>
<tr>
<th>符 号</th>
<th>含 义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>脚本名</td>
</tr>
<tr>
<td><code>$#</code></td>
<td>参数个数</td>
</tr>
<tr>
<td><code>$n</code></td>
<td>传递给脚本的参数值，<code>$1</code>第<code>1</code>参数、<code>$2</code>第<code>2</code>参数</td>
</tr>
<tr>
<td><code>$?</code></td>
<td>上次退出的状态（返回值），<code>0</code>没有错误，<code>1</code>错误</td>
</tr>
<tr>
<td><code>$*</code></td>
<td>所有参数列表。<code>&quot;$*&quot;</code>时，是<code>&quot;$1 $2 … $n&quot;</code>的形式</td>
</tr>
<tr>
<td><code>$@</code></td>
<td>所有参数列表。<code>&quot;$@&quot;</code>时，是<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; </code>的形式</td>
</tr>
<tr>
<td><code>$$</code></td>
<td>当前进程的编号<code>（ProcessID）</code></td>
</tr>
<tr>
<td><code>$!</code></td>
<td><code>shell</code>最后运行的后台<code>Process</code>的<code>PID</code></td>
</tr>
<tr>
<td><code>$var</code></td>
<td>变量，会与后面的连接，如<code>$var_a</code>，会当做变量<code>var_a</code></td>
</tr>
<tr>
<td><code>$&#123;var&#125;</code></td>
<td>变量，界定范围</td>
</tr>
<tr>
<td><code>$()</code></td>
<td>与<code>(反引号)类似，里面执行完再返回值，</code>所有<code>shell</code>通用</td>
</tr>
<tr>
<td><code>$[]</code></td>
<td>可进行算术运算和逻辑运算，不支持浮点和字符串</td>
</tr>
<tr>
<td><code>$(())</code></td>
<td>可进行算术运算和逻辑运算，不支持浮点和字符串。里面的变量可以省略<code>$</code></td>
</tr>
</tbody></table>
<h2 id="linux-下shell中if的“-e，-d，-f”是什么意思"><a href="#linux-下shell中if的“-e，-d，-f”是什么意思" class="headerlink" title="linux 下shell中if的“-e，-d，-f”是什么意思"></a><code>linux</code> 下<code>shell</code>中<code>if</code>的<code>“-e，-d，-f”</code>是什么意思</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文件表达式</span><br><span class="line">-e filename 如果 filename存在，则为真</span><br><span class="line">-d filename 如果 filename为目录，则为真 </span><br><span class="line">-f filename 如果 filename为常规文件，则为真</span><br><span class="line">-L filename 如果 filename为符号链接，则为真</span><br><span class="line">-r filename 如果 filename可读，则为真 </span><br><span class="line">-w filename 如果 filename可写，则为真 </span><br><span class="line">-x filename 如果 filename可执行，则为真</span><br><span class="line">-s filename 如果文件长度不为0，则为真</span><br><span class="line">-h filename 如果文件是软链接，则为真</span><br><span class="line">filename1 -nt filename2 如果 filename1比 filename2新，则为真。</span><br><span class="line">filename1 -ot filename2 如果 filename1比 filename2旧，则为真。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">整数变量表达式</span><br><span class="line">-eq 等于</span><br><span class="line">-ne 不等于</span><br><span class="line">-gt 大于</span><br><span class="line">-ge 大于等于</span><br><span class="line">-lt 小于</span><br><span class="line">-le 小于等于</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">字符串变量表达式</span><br><span class="line">If  [ <span class="variable">$a</span> = <span class="variable">$b</span> ]                 如果string1等于string2，则为真</span><br><span class="line">                                字符串允许使用赋值号做等号</span><br><span class="line"><span class="keyword">if</span>  [ <span class="variable">$string1</span> !=  <span class="variable">$string2</span> ]   如果string1不等于string2，则为真       </span><br><span class="line"><span class="keyword">if</span>  [ -n <span class="variable">$string</span>  ]             如果string 非空(非0），返回0(<span class="literal">true</span>)  </span><br><span class="line"><span class="keyword">if</span>  [ -z <span class="variable">$string</span>  ]             如果string 为空，则为真</span><br><span class="line"><span class="keyword">if</span>  [ <span class="variable">$sting</span> ]                  如果string 非空，返回0 (和-n类似) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    逻辑非 !                   条件表达式的相反</span><br><span class="line"><span class="keyword">if</span> [ ! 表达式 ]</span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$num</span> ]               如果不存在目录<span class="variable">$num</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    逻辑与 –a                   条件表达式的并列</span><br><span class="line"><span class="keyword">if</span> [ 表达式1  –a  表达式2 ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    逻辑或 -o                   条件表达式的或</span><br><span class="line"><span class="keyword">if</span> [ 表达式1  –o 表达式2 ]</span><br></pre></td></tr></table></figure>

<h2 id="shell获取文件扩展名"><a href="#shell获取文件扩展名" class="headerlink" title="shell获取文件扩展名"></a><code>shell</code>获取文件扩展名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">basename example.tar.a.b.c.gz .c.gz</span><br><span class="line"><span class="comment"># =&gt; example.tar.a.b</span></span><br><span class="line"> </span><br><span class="line">FILE=<span class="string">&quot;example.tar.gz&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;FILE%%.*&#125;</span>&quot;</span>     取头   example </span><br><span class="line"><span class="comment"># =&gt; example</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;FILE%.*&#125;</span>&quot;</span>      去尾   example.tar.a.b.c</span><br><span class="line"><span class="comment"># =&gt; example.tar</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;FILE#*.&#125;</span>&quot;</span>      去头   tar.a.b.c.gz</span><br><span class="line"><span class="comment"># =&gt; tar.gz</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;FILE##*.&#125;</span>&quot;</span>     取尾   gz</span><br><span class="line"><span class="comment"># =&gt; gz</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在bash中可以这么写</span></span><br><span class="line">filename=$(basename <span class="string">&quot;<span class="variable">$fullfile</span>&quot;</span>)   </span><br><span class="line">extension=<span class="string">&quot;<span class="variable">$&#123;filename##*.&#125;</span>&quot;</span></span><br><span class="line">filename=<span class="string">&quot;<span class="variable">$&#123;filename%.*&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Linux-shell-中获取当前目录的方法"><a href="#Linux-shell-中获取当前目录的方法" class="headerlink" title="Linux shell 中获取当前目录的方法"></a><code>Linux shell</code> 中获取当前目录的方法</h2><blockquote>
<p>当前目录</p>
</blockquote>
<p>每当你在终端进行操作时，你都会有一个当前工作目录。 使用pwd来判定当前目录在文件系统内的确切位置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$pwd</span></span><br><span class="line">/root</span><br></pre></td></tr></table></figure>
<p>在<code>shell</code>中也可以使用<code>pwd</code>来获取当前目录，并赋值给变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">CRTDIR=$(<span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>工作目录</p>
</blockquote>
<p>获取当前执行的脚本文件的父目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">workdir=$(<span class="built_in">cd</span> $(dirname <span class="variable">$0</span>); <span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂点的工作目录获取</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PRG=<span class="string">&quot;<span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="keyword">while</span> [ -h <span class="string">&quot;<span class="variable">$PRG</span>&quot;</span> ] ; <span class="keyword">do</span></span><br><span class="line">  ls=`ls -ld <span class="string">&quot;<span class="variable">$PRG</span>&quot;</span>`</span><br><span class="line">  link=`expr <span class="string">&quot;<span class="variable">$ls</span>&quot;</span> : <span class="string">&#x27;.*-&gt; \(.*\)$&#x27;</span>`</span><br><span class="line">  <span class="keyword">if</span> expr <span class="string">&quot;<span class="variable">$link</span>&quot;</span> : <span class="string">&#x27;/.*&#x27;</span> &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">    PRG=<span class="string">&quot;<span class="variable">$link</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    PRG=`dirname <span class="string">&quot;<span class="variable">$PRG</span>&quot;</span>`/<span class="string">&quot;<span class="variable">$link</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">PRGDIR=$(<span class="built_in">cd</span> $(dirname <span class="variable">$PRG</span>); <span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Linux-Shell获取文件夹下的文件名"><a href="#Linux-Shell获取文件夹下的文件名" class="headerlink" title="Linux Shell获取文件夹下的文件名"></a><code>Linux Shell</code>获取文件夹下的文件名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># get all filename in specified path</span></span><br><span class="line">path=<span class="variable">$1</span></span><br><span class="line">files=$(ls <span class="variable">$path</span>)</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> <span class="variable">$files</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$filename</span> &gt;&gt; filename.txt</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="shell获取目录下所有文件夹的名称并输出"><a href="#shell获取目录下所有文件夹的名称并输出" class="headerlink" title="shell获取目录下所有文件夹的名称并输出"></a><code>shell</code>获取目录下所有文件夹的名称并输出</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#方法一 </span></span><br><span class="line">dir=$(ls -l /usr/ |awk <span class="string">&#x27;/^d/ &#123;print $NF&#125;&#x27;</span>)</span><br><span class="line">or i <span class="keyword">in</span> <span class="variable">$dir</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span>   </span><br><span class="line"><span class="comment">#######</span></span><br><span class="line"><span class="comment">#方法二</span></span><br><span class="line"><span class="keyword">for</span> dir <span class="keyword">in</span> $(ls /usr/)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    [ -d <span class="variable">$dir</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="variable">$dir</span></span><br><span class="line"><span class="keyword">done</span>        </span><br><span class="line"><span class="comment">##方法三</span></span><br><span class="line">ls -l /usr/ |awk <span class="string">&#x27;/^d/ &#123;print $NF&#125;&#x27;</span>   <span class="comment">## 其实同方法一，直接就可以显示不用for循环</span></span><br></pre></td></tr></table></figure>


<h2 id="常用-Linux-jq命令语法整理"><a href="#常用-Linux-jq命令语法整理" class="headerlink" title="常用 Linux jq命令语法整理"></a>常用 <code>Linux jq</code>命令语法整理</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZWF0MTE3MzAxMDI1Ni9hcnRpY2xlL2RldGFpbHMvMTE4MjMwNTYyIzp+OnRleHQ9SlElMjAlRTYlOTglQUYlRTQlQjglODAlRTQlQjglQUElMjAlRTUlOTElQkQlRTQlQkIlQTQlMjAlRTglQTElOEMlRTUlQjclQTUlRTUlODUlQjclRUYlQkMlOEMlRTQlQjglQkIlRTglQTYlODElRTclOTQlQTglRTQlQkElOEUlRTUlQTQlODQlRTclOTAlODZqc29uJUU2JTk2JTg3JUU2JTlDJUFDJUUzJTgwJTgyJTIwJUU4JUFGJUFEJUU2JUIzJTk1LCVFNSVCRSU4OCVFNyVBRSU4MCVFNSU4RCU5NSVFRiVCQyU4QyVFNSVBNiU4MiVFNCVCOCU4QiVFRiVCQyU5QSUyMGpxJTIwJTVCb3B0aW9ucy4uLiU1RCUyMGZpbHRlciUyMCU1QmZpbGVzLi4uJTVE">参考链接</span></p>
<img data-src="/blog/posts/55b095e0/2022-05-13-20-25-50.png" class="">

<img data-src="/blog/posts/55b095e0/2022-05-13-20-26-18.png" class="">

<img data-src="/blog/posts/55b095e0/2022-05-13-20-26-42.png" class="">

<img data-src="/blog/posts/55b095e0/2022-05-13-20-27-00.png" class="">


<h2 id="shell脚本中整数型变量自增（加1）的实现方式"><a href="#shell脚本中整数型变量自增（加1）的实现方式" class="headerlink" title="shell脚本中整数型变量自增（加1）的实现方式"></a><code>shell</code>脚本中整数型变量自增（加<code>1</code>）的实现方式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">本脚本测试shell脚本中整型变量自增 加1的几种方法</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">定义整型变量</span></span><br><span class="line">a=1</span><br><span class="line">echo $a</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">第一种整型变量自增方式</span></span><br><span class="line">a=$(($a+1))</span><br><span class="line">echo $a</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">第二种整型变量自增方式</span></span><br><span class="line">a=$[$a+1]</span><br><span class="line">echo $a</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">第三种整型变量自增方式</span></span><br><span class="line">a=`expr $a + 1`</span><br><span class="line">echo $a</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">第四种整型变量自增方式</span></span><br><span class="line">let a++</span><br><span class="line">echo $a</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">第五种整型变量自增方式</span></span><br><span class="line">let a+=1</span><br><span class="line">echo $a</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">第六种整型变量自增方式</span></span><br><span class="line">((a++))</span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>

<h2 id="shell判断一个变量是否为空"><a href="#shell判断一个变量是否为空" class="headerlink" title="shell判断一个变量是否为空"></a><code>shell</code>判断一个变量是否为空</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ ! $a ] &amp;&amp; echo &quot;a is null&quot; </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span> </span><br><span class="line">a= </span><br><span class="line">if [ ! -n &quot;$a&quot; ]; then </span><br><span class="line">echo &quot;IS NULL&quot; </span><br><span class="line">else </span><br><span class="line">echo &quot;NOT NULL&quot; </span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span> </span><br><span class="line">a= </span><br><span class="line">if [ ! $a ]; then</span><br><span class="line">echo &quot;IS NULL&quot; </span><br><span class="line">else </span><br><span class="line">echo &quot;NOT NULL&quot; </span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span> </span><br><span class="line">a= </span><br><span class="line">if test -z &quot;$a&quot; then </span><br><span class="line">echo &quot;a is not set!&quot; </span><br><span class="line">else </span><br><span class="line">echo &quot;a is set !&quot; </span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span> </span><br><span class="line">a= </span><br><span class="line">if [ &quot;$a&quot; = &quot;&quot; ]; then </span><br><span class="line">echo &quot;a is not set!&quot; </span><br><span class="line">else </span><br><span class="line">echo &quot;a is set !&quot; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="输出到文件"><a href="#输出到文件" class="headerlink" title="输出到文件"></a>输出到文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">两种方法：</span></span><br><span class="line"><span class="meta">2&gt;</span><span class="bash">&amp;1 | tee mylog.log</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> test.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash">举例：</span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">sh batchjob.sh 2&gt;&amp;1 | tee mylog.log</span><br><span class="line">ls * &gt; test.txt</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">find ./ -name &quot;*.xml&quot; &gt; result.txt</span><br><span class="line">find ./ -name &quot;*.xml&quot; 2&gt;&amp;1 | tee mylog.log</span><br></pre></td></tr></table></figure>

<h2 id="Shell-实现多线程（多任务）"><a href="#Shell-实现多线程（多任务）" class="headerlink" title="Shell 实现多线程（多任务）"></a><code>Shell</code> 实现多线程（多任务）</h2><ol>
<li>命令结尾添加：<code>&amp;</code></li>
<li>解决主线程提前退出问题，添加 <code>wait</code></li>
<li>控制后台执行数（线程数），<code>mkfifo</code></li>
</ol>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vemhlbmdiaW4vcC85NTEzNzYyLmh0bWw=">https://www.cnblogs.com/zhengbin/p/9513762.html</span></p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2语法简介</title>
    <url>/blog/posts/b5314c4/</url>
    <content><![CDATA[<h1 id="Vue语法"><a href="#Vue语法" class="headerlink" title="Vue语法"></a>Vue语法</h1><h2 id="el挂载点以及data数据项"><a href="#el挂载点以及data数据项" class="headerlink" title="el挂载点以及data数据项"></a>el挂载点以及data数据项</h2><blockquote>
<p>el挂载点</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>el:挂载点<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span> &#123;&#123; message &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// el:&quot;.app&quot;,</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// el:&quot;div&quot;,</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//el:&quot;#body&quot;,</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">message</span>:<span class="string">&quot;黑马程序员&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>==不能够把<code>el</code>挂载到<code>body</code>标签中==</p>
<blockquote>
<p>data 数据对象</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>data:数据对象<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; message &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span> &#123;&#123; school.name &#125;&#125; &#123;&#123; school.mobile &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; campus[0] &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; campus[3] &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">message</span>:<span class="string">&quot;你好 小黑!&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">school</span>:&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">name</span>:<span class="string">&quot;黑马程序员&quot;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">mobile</span>:<span class="string">&quot;400-618-9090&quot;</span></span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="attr">campus</span>:[<span class="string">&quot;北京校区&quot;</span>,<span class="string">&quot;上海校区&quot;</span>,<span class="string">&quot;广州校区&quot;</span>,<span class="string">&quot;深圳校区&quot;</span>]</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="相关基本语法"><a href="#相关基本语法" class="headerlink" title="相关基本语法"></a>相关基本语法</h2><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a><strong>v-text</strong></h3><blockquote>
<p><strong>设置标签的文本值(textContent)</strong></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-text指令<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">&quot;message+&#x27;!&#x27;&quot;</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">&quot;info+&#x27;!&#x27;&quot;</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message +&#x27;!&#x27;&#125;&#125;深圳<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">message</span>:<span class="string">&quot;黑马程序员!!!&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">info</span>:<span class="string">&quot;前端与移动教研部&quot;</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>==<code>v-text</code>是有替换作用的==</strong></p>
<h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a><strong>v-html</strong></h3><p>设置标签的 <code>innerHtml</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">content</span>: <span class="string">&quot;&lt;h1 style=&#x27;backgroundcolor:blue;&#x27;&gt;这是v-html,会解析出来&lt;/h1&gt;&quot;</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果:</p>


<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a><strong>v-on</strong></h3><p><strong>为元素绑定事件</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>V-on<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;单击v-on&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;dolt&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;双击v-on&quot;</span> @<span class="attr">dblclick</span>=<span class="string">&quot;testText(food)&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> @<span class="attr">click</span>=<span class="string">&quot;testText&quot;</span>&gt;</span>&#123;&#123; food &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">food</span>: <span class="string">&quot;这是测试&quot;</span></span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">dolt</span>:<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&quot;做IT!!!&quot;</span>);</span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="attr">testText</span>:<span class="function">(<span class="params">a</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(a);</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="v-on补充"><a href="#v-on补充" class="headerlink" title="v-on补充"></a><code>v-on</code>补充</h4><p>==主要是事件修饰符==</p>
<ul>
<li><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</li>
<li><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。</li>
<li><code>.capture</code> - 添加事件侦听器时使用 <code>capture</code> 模式。</li>
<li><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>
<li><code>.&#123;keyCode | keyAlias&#125;</code> - 只当事件是从特定键触发时才触发回调。</li>
<li><code>.native</code> - 监听组件根元素的原生事件。</li>
<li><code>.once</code> - 只触发一次回调。</li>
<li><code>.left</code> - (2.2.0) 只当点击鼠标左键时触发。</li>
<li><code>.right</code> - (2.2.0) 只当点击鼠标右键时触发。</li>
<li><code>.middle</code> - (2.2.0) 只当点击鼠标中键时触发。</li>
<li><code>.passive</code> - (2.3.0) 以 <code>&#123; passive: true &#125;</code> 模式添加侦听器</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方法处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 动态事件 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:</span>[<span class="attr">event</span>]=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 内联语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doThat(&#x27;hello&#x27;, $event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态事件缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @[<span class="attr">event</span>]=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 停止冒泡 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 阻止默认行为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 阻止默认行为，没有表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  串联修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop.prevent</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 键修饰符，键别名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;onEnter&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 键修饰符，键代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.13</span>=<span class="string">&quot;onEnter&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击回调只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对象语法 (2.4.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">&quot;&#123; mousedown: doThis, mouseup: doThat &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><strong>v-show</strong></h3><p><strong>根据表达值的真假,切换元素的显示和隐藏</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-show指令<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;切换显示状态&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeIsShow&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;累加年龄&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;addAge&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./img/monkey.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-show</span>=<span class="string">&quot;age&gt;=18&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./img/monkey.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">isShow</span>:<span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">          <span class="attr">age</span>:<span class="number">17</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">changeIsShow</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.isShow = !<span class="built_in">this</span>.isShow;</span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          <span class="attr">addAge</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.age++;</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">      &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><strong>v-if</strong></h3><p><strong>根据表达值的真假,切换元素的显示和隐藏</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-if指令<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;切换显示&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;toggleIsShow&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>黑马程序员<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>黑马程序员 - v-show修饰<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;temperature&gt;=35&quot;</span>&gt;</span>热死啦<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">isShow</span>:<span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">temperature</span>:<span class="number">20</span></span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">toggleIsShow</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.isShow = !<span class="built_in">this</span>.isShow;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a><strong>v-bind</strong></h3><p><strong>设置元素的属性</strong></p>
<p>动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</p>
<p>在绑定 class 或 style attribute 时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。</p>
<p>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</p>
<p>没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 绑定一个 attribute --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imageSrc&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态 attribute 名 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:</span>[<span class="attr">key</span>]=<span class="string">&quot;value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imageSrc&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态 attribute 名缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 内联字符串拼接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;&#x27;/path/to/images/&#x27; + fileName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- class 绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; red: isRed &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[classA, classB]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- style 绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; fontSize: size + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;[styleObjectA, styleObjectB]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 绑定一个全是 attribute 的对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: someProp, &#x27;other-attr&#x27;: otherProp &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过 prop 修饰符绑定 DOM attribute --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:text-content.prop</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">:prop</span>=<span class="string">&quot;someThing&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">v-bind</span>=<span class="string">&quot;$props&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- XLink --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">:xlink:special</span>=<span class="string">&quot;foo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a><strong>v-for</strong></h3><p><strong>根据数据生成列表结构</strong></p>
<blockquote>
<p>我们可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的别名。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.message&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">var example1 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#example-1&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123; message: &#x27;Foo&#x27; &#125;,</span><br><span class="line">      &#123; message: &#x27;Bar&#x27; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//结果为</span><br><span class="line">· Foo</span><br><span class="line">· Bar</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 v-for 块中，我们可以访问所有父作用域的 property。v-for 还支持一个可选的第二个参数，即当前项的索引。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example-2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">var example2 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#example-2&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMessage: &#x27;Parent&#x27;,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; message: &#x27;Foo&#x27; &#125;,</span><br><span class="line">      &#123; message: &#x27;Bar&#x27; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>你也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item of items&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-for使用对象"><a href="#v-for使用对象" class="headerlink" title="v-for使用对象"></a><code>v-for</code>使用对象</h4><blockquote>
<p>你也可以用 <code>v-for</code> 来遍历一个对象的 <code>property</code>。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;v-for-object&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in object&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#v-for-object&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      title: &#x27;How to do lists in Vue&#x27;,</span><br><span class="line">      author: &#x27;Jane Doe&#x27;,</span><br><span class="line">      publishedAt: &#x27;2016-04-10&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>你也可以提供第二个的参数为 property 名称 (也就是键名)：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name) in object&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>还可以用第三个参数作为索引：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name, index) in object&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a><strong>v-model</strong></h3><p><strong>获取和设置表单元素的值(双向数据绑定)</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-model指令<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;修改message&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;setM&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;getM&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">message</span>:<span class="string">&quot;黑马程序员&quot;</span></span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">getM</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="built_in">this</span>.message);</span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="attr">setM</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.message =<span class="string">&quot;酷丁鱼&quot;</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>==<code>v-model</code>指令的作用是便捷的设置和获取表单元素的值==</li>
<li>绑定的数据会和表单元素值相关联</li>
<li>绑定的数据&lt;-&gt;表达元素的值</li>
</ul>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a><strong>axios</strong></h2><h3 id="关于使用"><a href="#关于使用" class="headerlink" title="关于使用"></a>关于使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用npm 安装</span></span><br><span class="line">$ npm install axios</span><br><span class="line"><span class="comment">//使用bower</span></span><br><span class="line">$ bower install axios</span><br><span class="line"><span class="comment">//使用cdn</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="关于请求"><a href="#关于请求" class="headerlink" title="关于请求"></a>关于请求</h3><p><strong>发送<code>Get</code>请求</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送Get请求</span></span><br><span class="line"><span class="comment">// 为给定 ID 的 user 创建请求</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的请求也可以这样做</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>发送<code>POST</code>请求</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>执行多个并发请求</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">&#x27;/user/12345/permissions&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 两个请求现在都执行完成</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h2 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h2><p><strong>可以通过向 <code>axios</code> 传递相关配置来创建请求</strong></p>
<blockquote>
<p>axios(config)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送 POST 请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取远端图片</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  <span class="attr">method</span>:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;http://bit.ly/2mTM3nY&#x27;</span>,</span><br><span class="line">  <span class="attr">responseType</span>:<span class="string">&#x27;stream&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  response.data.pipe(fs.createWriteStream(<span class="string">&#x27;ada_lovelace.jpg&#x27;</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>axios(url[, config])</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送 GET 请求（默认的方法）</span></span><br><span class="line">axios(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求方法别名</span></span><br><span class="line">axios.request(config)</span><br><span class="line">axios.get(url[, config])</span><br><span class="line">axios.delete(url[, config])</span><br><span class="line">axios.head(url[, config])</span><br><span class="line">axios.options(url[, config])</span><br><span class="line">axios.post(url[, data[, config]])</span><br><span class="line">axios.put(url[, data[, config]])</span><br><span class="line">axios.patch(url[, data[, config]])</span><br><span class="line"></span><br><span class="line"><span class="comment">//并发</span></span><br><span class="line">axios.all(iterable)</span><br><span class="line">axios.spread(callback)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>创建实例</strong></p>
<p><strong>axios.create([config])</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Custom-Header&#x27;</span>: <span class="string">&#x27;foobar&#x27;</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>实例方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios#request(config)</span><br><span class="line">axios#get(url[, config])</span><br><span class="line">axios#<span class="keyword">delete</span>(url[, config])</span><br><span class="line">axios#head(url[, config])</span><br><span class="line">axios#options(url[, config])</span><br><span class="line">axios#post(url[, data[, config]])</span><br><span class="line">axios#put(url[, data[, config]])</span><br><span class="line">axios#patch(url[, data[, config]])</span><br></pre></td></tr></table></figure>

<h3 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="comment">// `url` 是用于请求的服务器 URL</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `method` 是创建请求时使用的方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class="line">  <span class="comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">  <span class="comment">// 只能用在 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span></span><br><span class="line">  <span class="comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span></span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="function"><span class="keyword">function</span> (<span class="params">data, headers</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class="line">  <span class="attr">transformResponse</span>: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 是即将被发送的自定义请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `params` 是即将与请求一起发送的 URL 参数</span></span><br><span class="line">  <span class="comment">// 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span></span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span></span><br><span class="line">  <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  <span class="attr">paramsSerializer</span>: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">&#x27;brackets&#x27;</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `data` 是作为请求主体被发送的数据</span></span><br><span class="line">  <span class="comment">// 只适用于这些请求方法 &#x27;PUT&#x27;, &#x27;POST&#x27;, 和 &#x27;PATCH&#x27;</span></span><br><span class="line">  <span class="comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 浏览器专属：FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node 专属： Stream</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span></span><br><span class="line">  <span class="comment">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).</span></span><br><span class="line">  <span class="attr">adapter</span>: <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span></span><br><span class="line">  <span class="attr">auth</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;janedoe&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;s00pers3cret&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `responseType` 表示服务器响应的数据类型，可以是 &#x27;arraybuffer&#x27;, &#x27;blob&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;</span></span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseEncoding` indicates encoding to use for decoding responses</span></span><br><span class="line">  <span class="comment">// Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests</span></span><br><span class="line">  <span class="attr">responseEncoding</span>: <span class="string">&#x27;utf8&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span></span><br><span class="line">  <span class="attr">xsrfCookieName</span>: <span class="string">&#x27;XSRF-TOKEN&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfHeaderName` is the name of the http header that carries the xsrf token value</span></span><br><span class="line">  <span class="attr">xsrfHeaderName</span>: <span class="string">&#x27;X-XSRF-TOKEN&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// `onUploadProgress` 允许为上传处理进度事件</span></span><br><span class="line">  <span class="attr">onUploadProgress</span>: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do whatever you want with the native progress event</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许为下载处理进度事件</span></span><br><span class="line">  <span class="attr">onDownloadProgress</span>: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span></span><br><span class="line">  <span class="attr">maxContentLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span></span><br><span class="line">  <span class="attr">validateStatus</span>: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// default</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span></span><br><span class="line">  <span class="comment">// 如果设置为0，将不会 follow 任何重定向</span></span><br><span class="line">  <span class="attr">maxRedirects</span>: <span class="number">5</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `socketPath` defines a UNIX Socket to be used in node.js.</span></span><br><span class="line">  <span class="comment">// e.g. &#x27;/var/run/docker.sock&#x27; to send requests to the docker daemon.</span></span><br><span class="line">  <span class="comment">// Only either `socketPath` or `proxy` can be specified.</span></span><br><span class="line">  <span class="comment">// If both are specified, `socketPath` is used.</span></span><br><span class="line">  <span class="attr">socketPath</span>: <span class="literal">null</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span></span><br><span class="line">  <span class="comment">// `keepAlive` 默认没有启用</span></span><br><span class="line">  <span class="attr">httpAgent</span>: <span class="keyword">new</span> http.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  <span class="attr">httpsAgent</span>: <span class="keyword">new</span> https.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#x27;proxy&#x27; 定义代理服务器的主机名称和端口</span></span><br><span class="line">  <span class="comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">    <span class="attr">auth</span>: &#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&#x27;mikeymike&#x27;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;rapunz3l&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `cancelToken` 指定用于取消请求的 cancel token</span></span><br><span class="line">  <span class="comment">// （查看后面的 Cancellation 这节了解更多）</span></span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h3><p><strong>某个请求的响应包含以下信息</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应</span></span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class="line">  <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  <span class="attr">statusText</span>: <span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 服务器响应的头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `config` 是为请求提供的配置信息</span></span><br><span class="line">  <span class="attr">config</span>: &#123;&#125;,</span><br><span class="line"> <span class="comment">// &#x27;request&#x27;</span></span><br><span class="line">  <span class="comment">// `request` is the request that generated this response</span></span><br><span class="line">  <span class="comment">// It is the last ClientRequest instance in node.js (in redirects)</span></span><br><span class="line">  <span class="comment">// and an XMLHttpRequest instance the browser</span></span><br><span class="line">  <span class="attr">request</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用 <code>then</code> 时，你将接收下面这样的响应 :</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue属性介绍</title>
    <url>/blog/posts/e7e56598/</url>
    <content><![CDATA[<h1 id="Vue属性"><a href="#Vue属性" class="headerlink" title="Vue属性"></a>Vue属性</h1><h2 id="创建Vue实例"><a href="#创建Vue实例" class="headerlink" title="创建Vue实例"></a>创建Vue实例</h2><blockquote>
<p>每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="实例选项-数据"><a href="#实例选项-数据" class="headerlink" title="实例选项/数据"></a>实例选项/数据</h3><h4 id="data"><a href="#data" class="headerlink" title="data"></a><strong>data</strong></h4><ul>
<li>类型：<code>Object</code> | <code>Function</code></li>
<li>限制：组件的定义只接受 <code>function</code></li>
</ul>
<p><strong>实例:</strong></p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接创建一个实例</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: data</span><br><span class="line">&#125;)</span><br><span class="line">vm.a <span class="comment">// =&gt; 1</span></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue.extend() 中 data 必须是函数</span></span><br><span class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意，如果你为 data property 使用了箭头函数，则 this 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: <span class="function"><span class="params">vm</span> =&gt;</span> (&#123; <span class="attr">a</span>: vm.myProp &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="props"><a href="#props" class="headerlink" title="props"></a><strong>props</strong></h4><ul>
<li><p>类型：<code>Array&lt;string&gt; | Object</code></p>
</li>
<li><p>详细：<br><code>props</code> 可以是数组或对象，用于接收来自父组件的数据。<code>props</code> 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。<br>你可以基于对象的语法使用以下选项：</p>
<ul>
<li><code>type</code>：可以是下列原生构造函数中的一种：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>、<code>Object</code>、<code>Date</code>、<code>Function</code>、<code>Symbol</code>、任何自定义构造函数、或上述内容组成的数组。会检查一个 <code>prop</code> 是否是给定的类型，否则抛出警告。``Prop` 类型的更多信息在此。</li>
<li><code>default：any</code><br>为该 <code>prop</code> 指定一个默认值。如果该 <code>prop</code> 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。</li>
<li><code>required：Boolean</code><br>定义该 <code>prop</code> 是否是必填项。在非生产环境中，如果这个值为 <code>truthy</code> 且该 prop 没有被传入的，则一个控制台警告将会被抛出。</li>
<li><code>validator：Function</code><br>自定义验证函数会将该 <code>prop</code> 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 <code>falsy</code> 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在这里查阅更多 <code>prop</code> 验证的相关信息。</li>
</ul>
</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单语法</span></span><br><span class="line">Vue.component(<span class="string">&#x27;props-demo-simple&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;size&#x27;</span>, <span class="string">&#x27;myMessage&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 对象语法，提供验证</span></span><br><span class="line">Vue.component(<span class="string">&#x27;props-demo-advanced&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="comment">// 检测类型</span></span><br><span class="line">    <span class="attr">height</span>: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 检测类型 + 其他验证</span></span><br><span class="line">    <span class="attr">age</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">validator</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt;= <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="propsData"><a href="#propsData" class="headerlink" title="propsData"></a><strong>propsData</strong></h4><ul>
<li>类型：<code>&#123; [key: string]: any &#125;</code></li>
<li>限制：只用于 <code>new</code> 创建的实例中。</li>
<li>详细：创建实例时传递 <code>props</code>。主要作用是方便测试。</li>
</ul>
<p><strong>实例:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Comp = Vue.extend(&#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;msg&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Comp(&#123;</span><br><span class="line">  <span class="attr">propsData</span>: &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a><strong>computed</strong></h4><ul>
<li>类型：<code>&#123; [key: string]: Function | &#123; get: Function, set: Function &#125; &#125;</code></li>
<li>详细：<br>计算属性将被混入到<code>Vue</code> 实例中。所有 <code>getter</code> 和 <code>setter</code> 的 <code>this</code> 上下文自动地绑定为 <code>Vue</code> 实例。<br>注意如果你为一个计算属性使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="attr">aDouble</span>: <span class="function"><span class="params">vm</span> =&gt;</span> vm.a * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是<strong>不会被更新</strong>的。</p>
<p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 仅读取</span></span><br><span class="line">    <span class="attr">aDouble</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.a * <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 读取和设置</span></span><br><span class="line">    <span class="attr">aPlus</span>: &#123;</span><br><span class="line">      <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a = v - <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.aPlus   <span class="comment">// =&gt; 2</span></span><br><span class="line">vm.aPlus = <span class="number">3</span></span><br><span class="line">vm.a       <span class="comment">// =&gt; 2</span></span><br><span class="line">vm.aDouble <span class="comment">// =&gt; 4</span></span><br></pre></td></tr></table></figure>
<h4 id="methods"><a href="#methods" class="headerlink" title="methods"></a><strong>methods</strong></h4><ul>
<li>类型：<code>&#123; [key: string]: Function &#125;</code></li>
<li>详细：<br><code>methods</code> 将被混入到 <code>Vue</code> 实例中。可以直接通过 <code>VM</code> 实例访问这些方法，或者在指令表达式中使用。方法中的 <code>this</code> 自动绑定为 <code>Vue</code> 实例。</li>
</ul>
<blockquote>
<p>注意，不应该使用箭头函数来定义 method函数<br>(例如 plus: () =&gt; this.a++)。<br>理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。</p>
</blockquote>
<p><strong>实例:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">plus</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.a++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.plus()</span><br><span class="line">vm.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a><strong>watch</strong></h4><ul>
<li>类型：<code>&#123; [key: string]: string | Function | Object | Array &#125;</code></li>
<li>详细：一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。<code>Vue</code> 实例将会在实例化时调用 <code>$watch()</code>，遍历 <code>watch</code> 对象的每一个 <code>property</code>。</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">d</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">e</span>: &#123;</span><br><span class="line">      <span class="attr">f</span>: &#123;</span><br><span class="line">        <span class="attr">g</span>: <span class="number">5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;new: %s, old: %s&#x27;</span>, val, oldVal)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 方法名</span></span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#x27;someMethod&#x27;</span>,</span><br><span class="line">    <span class="comment">// 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深</span></span><br><span class="line">    <span class="attr">c</span>: &#123;</span><br><span class="line">      <span class="attr">handler</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 该回调将会在侦听开始之后被立即调用</span></span><br><span class="line">    <span class="attr">d</span>: &#123;</span><br><span class="line">      <span class="attr">handler</span>: <span class="string">&#x27;someMethod&#x27;</span>,</span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 你可以传入回调数组，它们会被逐一调用</span></span><br><span class="line">    <span class="attr">e</span>: [</span><br><span class="line">      <span class="string">&#x27;handle1&#x27;</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">handle2</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">handler</span>: <span class="function"><span class="keyword">function</span> <span class="title">handle3</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// watch vm.e.f&#x27;s value: &#123;g: 5&#125;</span></span><br><span class="line">    <span class="string">&#x27;e.f&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.a = <span class="number">2</span> <span class="comment">// =&gt; new: 2, old: 1</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，不应该使用箭头函数来定义 <code>watcher</code> 函数 (例如 <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue))</code>。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 <code>Vue</code> 实例，<code>this.updateAutocomplete</code> 将是 <code>undefined</code>。</strong></p>
<h3 id="实例选项-Dom"><a href="#实例选项-Dom" class="headerlink" title="实例选项/Dom"></a>实例选项/Dom</h3><h4 id="el"><a href="#el" class="headerlink" title="el"></a><strong>el</strong></h4><ul>
<li>类型：<code>string | Element</code></li>
<li>限制：只在用 new 创建实例时生效。</li>
<li>详细：提供一个在页面上已存在的 <code>DOM</code> 元素作为 <code>Vue</code> 实例的挂载目标。可以是 <code>CSS</code> 选择器，也可以是一个 <code>HTMLElement</code> 实例。<br>在实例挂载之后，元素可以用 <code>vm.$el</code> 访问。<br>如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 <code>vm.$mount()</code> 手动开启编译。</li>
</ul>
<blockquote>
<p>提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载 root 实例到 html 或者 body 上。</p>
</blockquote>
<hr>
如果 render 函数和 template property 都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 Runtime + Compiler 构建的 Vue 库。


<h4 id="template"><a href="#template" class="headerlink" title="template"></a><strong>template</strong></h4><ul>
<li>类型：<code>string</code></li>
<li>详细：一个字符串模板作为 <code>Vue</code> 实例的标识使用。模板将会替换挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。<br>如果值以 # 开始，则它将被用作选择符，并使用匹配元素的 <code>innerHTML</code> 作为模板。常用的技巧是用 <code>&lt;script type=&quot;x-template&quot;&gt;</code> 包含模板。</li>
</ul>
<p>出于安全考虑，你应该只使用你信任的 Vue 模板。避免使用其他人生成的内容作为你的模板。</p>
<hr>
如果 Vue 选项中包含渲染函数，该模板将被忽略。


<h4 id="render"><a href="#render" class="headerlink" title="render"></a><strong>render</strong></h4><ul>
<li>类型：(createElement: () =&gt; VNode) =&gt; VNode</li>
<li>详细：字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 <code>createElement</code> 方法作为第一个参数用来创建 <code>VNode</code>。</li>
</ul>
<blockquote>
<p>如果组件是一个函数组件，渲染函数还会接收一个额外的 context 参数，为没有实例的函数组件提供上下文信息。</p>
</blockquote>
<hr>
Vue 选项中的 render 函数若存在，则 Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。

<h4 id="renderError"><a href="#renderError" class="headerlink" title="renderError"></a><strong>renderError</strong></h4><ul>
<li>类型：(createElement: () =&gt; VNode, error: Error) =&gt; VNode</li>
<li>详细：<strong>只在开发者环境下工作。</strong><br>当 <code>render</code> 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 <code>renderError</code>。这个功能配合 <code>hot-reload</code> 非常实用。</li>
</ul>
<p><strong>实例:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;oops&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  renderError (h, err) &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;pre&#x27;</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;&#125;, err.stack)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="选项-生命周期钩子"><a href="#选项-生命周期钩子" class="headerlink" title="选项/生命周期钩子"></a>选项/生命周期钩子</h3><blockquote>
<p>所有的生命周期钩子自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对 <code>property</code> 和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 <code>created: () =&gt; this.fetchTodos())</code>。这是因为箭头函数绑定了父上下文，因此 <code>this</code> 与你期待的 <code>Vue</code> 实例不同，<code>this.fetchTodos</code> 的行为未定义。</p>
</blockquote>
<h4 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a><strong>beforeCreate</strong></h4><ul>
<li>类型：<code>Function</code></li>
<li>详细：在实例初始化之后，数据观测 <code>(data observer)</code> 和 <code>event/watcher</code> 事件配置之前被调用。</li>
</ul>
<h4 id="created"><a href="#created" class="headerlink" title="created"></a><strong>created</strong></h4><ul>
<li>类型：<code>Function</code></li>
<li>详细：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 <code>(data observer)</code>，<code>property</code> 和方法的运算，<code>watch/event</code> 事件回调。然而，挂载阶段还没开始，<code>$el property</code> 目前尚不可用。</li>
</ul>
<h4 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a><strong>beforeMount</strong></h4><ul>
<li>类型：<code>Function</code></li>
<li>详细：在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</li>
</ul>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a><strong>mounted</strong></h4><ul>
<li><p>类型：<code>Function</code></p>
</li>
<li><p>详细：</p>
<ul>
<li><p>实例被挂载后调用，这时 <code>el</code> 被新创建的 <code>vm.$el</code> 替换了。如果根实例挂载到了一个文档内的元素上，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p>
</li>
<li><p>注意 <code>mounted</code> 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <code>vm.$nextTick：</code></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Code that will run only after the</span></span><br><span class="line">  <span class="comment">// entire view has been rendered</span></span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选项-资源"><a href="#选项-资源" class="headerlink" title="选项/资源"></a><strong>选项/资源</strong></h3></li>
</ul>
<h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a><strong><code>Component</code></strong></h4><blockquote>
<p>关于组件的使用补充:</p>
</blockquote>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例:"></a><strong>实例:</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 button-counter 的新组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>组件是可复用的 <code>Vue</code> 实例，且带有一个名字：在这个例子中是 <code>&lt;button-counter&gt;</code>。我们可以在一个通过 <code>new Vue</code> 创建的 <code>Vue</code> 根实例中，把这个组件作为自定义元素来使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>因为组件是可复用的 <code>Vue</code> 实例，所以它们与 <code>new Vue</code> 接收相同的选项，例如 <code>data、computed、watch、methods</code> 以及生命周期钩子等。仅有的例外是像 <code>el</code> 这样根实例特有的选项。</strong></p>
<h5 id="data-必须是一个函数"><a href="#data-必须是一个函数" class="headerlink" title="==data 必须是一个函数=="></a><strong>==data 必须是一个函数==</strong></h5><p>当我们定义这个 <code>&lt;button-counter&gt;</code> 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取而代之的是，<strong>一个组件的 <code>data</code> 选项必须是一个函数</strong>，因此每个实例可以维护一份被返回对象的独立的拷贝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="组件的组织"><a href="#组件的组织" class="headerlink" title="组件的组织"></a><strong>组件的组织</strong></h5><p>通常一个应用会以一棵嵌套的组件树的形式来组织：</p>


<p>例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。</p>
<p>为了能在模板中使用，这些组件必须先注册以便 <code>Vue</code> 能够识别。这里有两种组件的注册类型：<strong>全局注册</strong>和<strong>局部注册</strong>。至此，我们的组件都只是通过 <code>Vue.component</code> 全局注册的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component-name&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// ... options ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>全局注册的组件可以用在其被注册之后的任何 (通过 <code>new Vue</code>) 新创建的 <code>Vue</code> 根实例，也包括其组件树中的所有子组件的模板中。</p>
<p>到目前为止，关于组件注册你需要了解的就这些了，如果你阅读完本页内容并掌握了它的内容，我们会推荐你再回来把**<a href="#zujianzhuce">组件注册</a>**读完。</p>
<h5 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a><span id="zujianzhuce">组件注册</span></h5><blockquote>
<p>全局注册略</p>
</blockquote>
<blockquote>
<p>局部注册</p>
</blockquote>
<p>全局注册往往是不够理想的。比如，如果你使用一个像 <code>webpack</code>这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 <code>JavaScript</code> 的无谓的增加。</p>
<p>在这些情况下，你可以通过一个普通的 <code>JavaScript</code> 对象来定义组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentC = &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>然后在 <code>components</code> 选项中定义你想要使用的组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>: ComponentA,</span><br><span class="line">    <span class="string">&#x27;component-b&#x27;</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对于 <code>components</code> 对象中的每个 <code>property</code> 来说，其 <code>property</code> 名就是自定义元素的名字，其 <code>property</code> 值就是这个组件的选项对象。</p>
<p>注意<strong>局部注册的组件在其子组件中不可用</strong>。例如，如果你希望 <code>ComponentA</code> 在 <code>ComponentB</code> 中可用，则你需要这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>: ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者如果你通过 <code>Babel</code> 和 <code>webpack</code> 使用 <code>ES2015</code> 模块，那么代码看起来更像：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">&#x27;./ComponentA.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过-Prop-向子组件传递数据"><a href="#通过-Prop-向子组件传递数据" class="headerlink" title="通过 Prop 向子组件传递数据"></a><strong>通过 Prop 向子组件传递数据</strong></h5><p>早些时候，我们提到了创建一个博文组件的事情。问题是如果你不能向这个组件传递某一篇博文的标题或内容之类的我们想展示的数据的话，它是没有办法使用的。这也正是 <code>prop</code> 的由来。</p>
<p><code>Prop</code> 是你可以在组件上注册的一些自定义 <code>attribute</code>。当一个值传递给一个 <code>prop attribute</code> 的时候，它就变成了那个组件实例的一个 <code>property</code>。为了给博文组件传递一个标题，我们可以用一个 <code>props</code> 选项将其包含在该组件可接受的 <code>prop</code> 列表中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>一个组件默认可以拥有任意数量的<code>prop</code>，任何值都可以传递给任何 <code>prop</code>。在上述模板中，你会发现我们能够在组件实例中访问这个值，就像访问 <code>data</code> 中的值一样。</p>
<p>一个 <code>prop</code> 被注册之后，你就可以像这样把数据作为一个自定义 <code>attribute</code> 传递进来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;blog-post title=<span class="string">&quot;My journey with Vue&quot;</span>&gt;&lt;/blog-post&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;Blogging with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;Why Vue is so fun&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>结果:</p>


<p>然而在一个典型的应用中，你可能在 <code>data</code> 里有一个博文的数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#blog-post-demo&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">posts</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&#x27;My journey with Vue&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&#x27;Blogging with Vue&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">&#x27;Why Vue is so fun&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>并想要为每篇博文渲染一个组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-<span class="keyword">for</span>=<span class="string">&quot;post in posts&quot;</span></span><br><span class="line">  v-bind:key=<span class="string">&quot;post.id&quot;</span></span><br><span class="line">  v-bind:title=<span class="string">&quot;post.title&quot;</span></span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>

<p>看起来当组件变得越来越复杂的时候，我们的博文不只需要标题和内容，还需要发布日期、评论等等。为每个相关的信息定义一个 <code>prop</code> 会变得很麻烦：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-<span class="keyword">for</span>=<span class="string">&quot;post in posts&quot;</span></span><br><span class="line">  v-bind:key=<span class="string">&quot;post.id&quot;</span></span><br><span class="line">  v-bind:title=<span class="string">&quot;post.title&quot;</span></span><br><span class="line">  v-bind:content=<span class="string">&quot;post.content&quot;</span></span><br><span class="line">  v-bind:publishedAt=<span class="string">&quot;post.publishedAt&quot;</span></span><br><span class="line">  v-bind:comments=<span class="string">&quot;post.comments&quot;</span></span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>
<p>所以是时候重构一下这个 <code>&lt;blog-post&gt;</code> 组件了，让它变成接受一个单独的 <code>post</code> <code>prop</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-<span class="keyword">for</span>=<span class="string">&quot;post in posts&quot;</span></span><br><span class="line">  v-bind:key=<span class="string">&quot;post.id&quot;</span></span><br><span class="line">  v-bind:post=<span class="string">&quot;post&quot;</span></span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;post&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;blog-post&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>==现在，不论何时为 <code>post</code> 对象添加一个新的 <code>property</code>，它都会自动地在 <code>&lt;blog-post&gt;</code> 内可用==。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JDK中的Arrays.sort排序方法</title>
    <url>/blog/posts/de5e33d7/</url>
    <content><![CDATA[<p>是这样的，我们在刚学数据结构时候，都会学什么八大排序算法乱七八糟的，但是真正在写<code>Java</code>项目时，都是直接化身<code>API</code>调用工程师，<code>Arrays.sort()</code>完事，无意间点开，其实里面的玄机另有洞天。</p>
<span id="more"></span>

<h2 id="Debug源码"><a href="#Debug源码" class="headerlink" title="Debug源码"></a><code>Debug</code>源码</h2><p>我们以最基础的方法<code>public static void sort(int[] a)</code>为例；</p>
<p>点开<code>Arrays.sort()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接进去，此处<code>Sort</code>有很多的重载，需要仔细注意</p>
<p><code>Arrays.sort()</code>重载了四类方法</p>
<ol>
<li><code>sort(T[] a)</code>：对指定T型数组按数字升序排序。</li>
<li><code>sort(T[] a,int formIndex, int toIndex)</code>：对指定<code>T</code>型数组的指定范围按数字升序排序。</li>
<li><code>sort(T[] a, Comparator&lt;? supre T&gt; c)</code>: 根据指定比较器产生的顺序对指定对象数组进行排序。</li>
<li><code>sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c)</code>: 根据指定比较器产生的顺序对指定对象数组的指定对象数组进行排序。</li>
</ol>
<img data-src="/blog/posts/de5e33d7/2022-03-13-14-55-38.png" class="">


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    如果可能合并，使用给定的工作空间数组片对数组的指定范围进行排序</span></span><br><span class="line"><span class="comment">    参数:</span></span><br><span class="line"><span class="comment">    a -要排序的数组</span></span><br><span class="line"><span class="comment">    left - 要排序的第一个元素的索引(包括第一个元素)</span></span><br><span class="line"><span class="comment">    right - 最后一个要排序的元素的下标</span></span><br><span class="line"><span class="comment">    Work -工作空间数组(片)</span></span><br><span class="line"><span class="comment">    workBase -工作数组中可用空间的来源</span></span><br><span class="line"><span class="comment">    workLen -工作数组的可用大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要排序的数组长度小于这个常量，则优先使用快速排序，而不是归并排序。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUICKSORT_THRESHOLD = <span class="number">286</span>;</span><br><span class="line"><span class="comment">//归并排序的最大运行次数。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RUN_COUNT = <span class="number">67</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right,<span class="keyword">int</span>[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 小数组使用快排，阈值为286</span></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">        <span class="comment">//快排</span></span><br><span class="line">        sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//索引运行[i]是第i次运行的开始(升序或降序)。</span></span><br><span class="line">    <span class="keyword">int</span>[] run = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_RUN_COUNT + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; run[<span class="number">0</span>] = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查数组是否接近排序 见解释 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">        <span class="comment">// 序列开头相等的项</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; right &amp;&amp; a[k] == a[k + <span class="number">1</span>])</span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">if</span> (k == right) <span class="keyword">break</span>;  <span class="comment">// 序列以相等的项结束</span></span><br><span class="line">        <span class="keyword">if</span> (a[k] &lt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// 升序</span></span><br><span class="line">            <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &lt;= a[k]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k] &gt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// 降序</span></span><br><span class="line">            <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &gt;= a[k]);</span><br><span class="line">            <span class="comment">//转换成一个升序序列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lo = run[count] - <span class="number">1</span>, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = a[lo]; </span><br><span class="line">                a[lo] = a[hi]; </span><br><span class="line">                a[hi] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并一个转换后的降序序列，后面跟着升序序列</span></span><br><span class="line">        <span class="keyword">if</span> (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - <span class="number">1</span>]) &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果count == 归并排序的最大次数说明数组不是高度结构化的，使用快速排序代替归并排序。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">            <span class="comment">//进入到快排</span></span><br><span class="line">            sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些不变量应该是正确的:</span></span><br><span class="line">    <span class="comment">//    run[0] = 0</span></span><br><span class="line">    <span class="comment">//    run[&lt;last&gt;] = right + 1; (terminator)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 单次相等跑</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span> &amp;&amp; run[count] &gt; right) &#123;</span><br><span class="line">        <span class="comment">//单个升序或转换后的降序运行。总是检查一个最终运行是一个适当的结束符，否则我们有一个未终止的尾随运行，以处理下游。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    right++;</span><br><span class="line">    <span class="keyword">if</span> (run[count] &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 极端情况:最后的运行不是终结者。</span></span><br><span class="line">        <span class="comment">//这可能发生：如果最后一次运行是一个等于运行，或有一个单元素运行在结尾。通过在末尾添加适当的终止符来解决这个问题。</span></span><br><span class="line">        <span class="comment">//注意，我们以(right + 1)结束，在前面加1。</span></span><br><span class="line">        run[++count] = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定合并的交替基</span></span><br><span class="line">    <span class="keyword">byte</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; (n &lt;&lt;= <span class="number">1</span>) &lt; count; odd ^= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用或创建临时数组b进行合并</span></span><br><span class="line">    <span class="keyword">int</span>[] b;                 <span class="comment">// temp array; alternates with a</span></span><br><span class="line">    <span class="keyword">int</span> ao, bo;              <span class="comment">// array offsets from &#x27;left&#x27;</span></span><br><span class="line">    <span class="keyword">int</span> blen = right - left; <span class="comment">// space needed for b</span></span><br><span class="line">    <span class="keyword">if</span> (work == <span class="keyword">null</span> || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">        work = <span class="keyword">new</span> <span class="keyword">int</span>[blen];</span><br><span class="line">        workBase = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (odd == <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">        b = a;</span><br><span class="line">        bo = <span class="number">0</span>;</span><br><span class="line">        a = work;</span><br><span class="line">        ao = workBase - left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = work;</span><br><span class="line">        ao = <span class="number">0</span>;</span><br><span class="line">        bo = workBase - left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归并</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> last; count &gt; <span class="number">1</span>; count = last) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = (last = <span class="number">0</span>) + <span class="number">2</span>; k &lt;= count; k += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> hi = run[k], mi = run[k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = run[k - <span class="number">2</span>], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                    b[i + bo] = a[p++ + ao];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    b[i + bo] = a[q++ + ao];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            run[++last] = hi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right, lo = run[count - <span class="number">1</span>]; --i &gt;= lo;</span><br><span class="line">                b[i + bo] = a[i + ao]</span><br><span class="line">            );</span><br><span class="line">            run[++last] = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] t = a; a = b; b = t;</span><br><span class="line">        <span class="keyword">int</span> o = ao; ao = bo; bo = o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上文快速排序入口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要排序的数组长度小于这个值常量，插入排序优先于快速排序。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSERTION_SORT_THRESHOLD = <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 按双重Povit快速排序 对数组的指定范围进行排序</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> a 待排序数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> left 待排数组左索引</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> right 待排数组右索引</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> leftmost 指示这部分是否为范围的最左边</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">boolean</span> leftmost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = right - left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于47，使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftmost) &#123;</span><br><span class="line">           <span class="comment">//传统的(没有哨兵的)插入排序，为服务器虚拟机优化，用于最左边的部分。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> ai = a[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (ai &lt; a[j]) &#123;</span><br><span class="line">                    a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                    <span class="keyword">if</span> (j-- == left) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[j + <span class="number">1</span>] = ai;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//跳过最长升序序列。</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (a[++left] &gt;= a[left - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//来自相邻部分的每一个元素都起着作用，因此这允许我们避免每次迭代的左范围检查。</span></span><br><span class="line">            <span class="comment">//此外,我们使用更优化的算法，所谓的对插入排序，它更快(在快速排序的上下文中)比传统的插入排序实现。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                <span class="keyword">int</span> a1 = a[k], a2 = a[left];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (a1 &lt; a2) &#123;</span><br><span class="line">                    a2 = a1; a1 = a[left];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (a1 &lt; a[--k]) &#123;</span><br><span class="line">                    a[k + <span class="number">2</span>] = a[k];</span><br><span class="line">                &#125;</span><br><span class="line">                a[++k + <span class="number">1</span>] = a1;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (a2 &lt; a[--k]) &#123;</span><br><span class="line">                    a[k + <span class="number">1</span>] = a[k];</span><br><span class="line">                &#125;</span><br><span class="line">                a[k + <span class="number">1</span>] = a2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> last = a[right];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (last &lt; a[--right]) &#123;</span><br><span class="line">                a[right + <span class="number">1</span>] = a[right];</span><br><span class="line">            &#125;</span><br><span class="line">            a[right + <span class="number">1</span>] = last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////以下为双轴快排</span></span><br><span class="line">    <span class="comment">// 长度/7的近似</span></span><br><span class="line">    <span class="keyword">int</span> seventh = (length &gt;&gt; <span class="number">3</span>) + (length &gt;&gt; <span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对五个均匀间隔的元素进行排序 ，在范围的中心元素。这些元素将被用于枢轴选择如下所述。</span></span><br><span class="line">    <span class="comment">//间隔的选择 根据经验，这些因素决定很好地发挥作用 各种各样的输入。</span></span><br><span class="line">    <span class="keyword">int</span> e3 = (left + right) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// The midpoint</span></span><br><span class="line">    <span class="keyword">int</span> e2 = e3 - seventh;</span><br><span class="line">    <span class="keyword">int</span> e1 = e2 - seventh;</span><br><span class="line">    <span class="keyword">int</span> e4 = e3 + seventh;</span><br><span class="line">    <span class="keyword">int</span> e5 = e4 + seventh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用插入排序对这些元素进行排序</span></span><br><span class="line">    <span class="keyword">if</span> (a[e2] &lt; a[e1]) &#123; <span class="keyword">int</span> t = a[e2]; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a[e3] &lt; a[e2]) &#123; <span class="keyword">int</span> t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[e4] &lt; a[e3]) &#123; <span class="keyword">int</span> t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[e5] &lt; a[e4]) &#123; <span class="keyword">int</span> t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; a[e3]) &#123; a[e4] = a[e3]; a[e3] = t;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">                <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pointers</span></span><br><span class="line">    <span class="keyword">int</span> less  = left;  <span class="comment">// The index of the first element of center part</span></span><br><span class="line">    <span class="keyword">int</span> great = right; <span class="comment">// The index before the first element of right part</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">        <span class="comment">//使用五个排序元素中的第二个和第四个作为枢轴。 </span></span><br><span class="line">        <span class="comment">//这些值是第一个和的廉价近似值. Note that pivot1 &lt;= pivot2.</span></span><br><span class="line">        <span class="keyword">int</span> pivot1 = a[e2];</span><br><span class="line">        <span class="keyword">int</span> pivot2 = a[e4];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * The first and the last elements to be sorted are moved to the</span></span><br><span class="line"><span class="comment">            * locations formerly occupied by the pivots. When partitioning</span></span><br><span class="line"><span class="comment">            * is complete, the pivots are swapped back into their final</span></span><br><span class="line"><span class="comment">            * positions, and excluded from subsequent sorting.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        a[e2] = a[left];</span><br><span class="line">        a[e4] = a[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Skip elements, which are less or greater than pivot values.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">while</span> (a[++less] &lt; pivot1);</span><br><span class="line">        <span class="keyword">while</span> (a[--great] &gt; pivot2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Partitioning:</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            *   left part           center part                   right part</span></span><br><span class="line"><span class="comment">            * +--------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">            * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span></span><br><span class="line"><span class="comment">            * +--------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">            *               ^                          ^       ^</span></span><br><span class="line"><span class="comment">            *               |                          |       |</span></span><br><span class="line"><span class="comment">            *              less                        k     great</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * Invariants:</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            *              all in (left, less)   &lt; pivot1</span></span><br><span class="line"><span class="comment">            *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span></span><br><span class="line"><span class="comment">            *              all in (great, right) &gt; pivot2</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * Pointer k is the first index of ?-part.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        outer:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = less - <span class="number">1</span>; ++k &lt;= great; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> ak = a[k];</span><br><span class="line">            <span class="keyword">if</span> (ak &lt; pivot1) &#123; <span class="comment">// Move a[k] to left part</span></span><br><span class="line">                a[k] = a[less];</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * Here and below we use &quot;a[i] = b; i++;&quot; instead</span></span><br><span class="line"><span class="comment">                    * of &quot;a[i++] = b;&quot; due to performance issue.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                a[less] = ak;</span><br><span class="line">                ++less;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ak &gt; pivot2) &#123; <span class="comment">// Move a[k] to right part</span></span><br><span class="line">                <span class="keyword">while</span> (a[great] &gt; pivot2) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (great-- == k) &#123;</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[great] &lt; pivot1) &#123; <span class="comment">// a[great] &lt;= pivot2</span></span><br><span class="line">                    a[k] = a[less];</span><br><span class="line">                    a[less] = a[great];</span><br><span class="line">                    ++less;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// pivot1 &lt;= a[great] &lt;= pivot2</span></span><br><span class="line">                    a[k] = a[great];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * Here and below we use &quot;a[i] = b; i--;&quot; instead</span></span><br><span class="line"><span class="comment">                    * of &quot;a[i--] = b;&quot; due to performance issue.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                a[great] = ak;</span><br><span class="line">                --great;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Swap pivots into their final positions</span></span><br><span class="line">        a[left]  = a[less  - <span class="number">1</span>]; a[less  - <span class="number">1</span>] = pivot1;</span><br><span class="line">        a[right] = a[great + <span class="number">1</span>]; a[great + <span class="number">1</span>] = pivot2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sort left and right parts recursively, excluding known pivots</span></span><br><span class="line">        sort(a, left, less - <span class="number">2</span>, leftmost);</span><br><span class="line">        sort(a, great + <span class="number">2</span>, right, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * If center part is too large (comprises &gt; 4/7 of the array),</span></span><br><span class="line"><span class="comment">            * swap internal pivot values to ends.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">if</span> (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Skip elements, which are equal to pivot values.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="keyword">while</span> (a[less] == pivot1) &#123;</span><br><span class="line">                ++less;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (a[great] == pivot2) &#123;</span><br><span class="line">                --great;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Partitioning:</span></span><br><span class="line"><span class="comment">                *</span></span><br><span class="line"><span class="comment">                *   left part         center part                  right part</span></span><br><span class="line"><span class="comment">                * +----------------------------------------------------------+</span></span><br><span class="line"><span class="comment">                * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span></span><br><span class="line"><span class="comment">                * +----------------------------------------------------------+</span></span><br><span class="line"><span class="comment">                *              ^                        ^       ^</span></span><br><span class="line"><span class="comment">                *              |                        |       |</span></span><br><span class="line"><span class="comment">                *             less                      k     great</span></span><br><span class="line"><span class="comment">                *</span></span><br><span class="line"><span class="comment">                * Invariants:</span></span><br><span class="line"><span class="comment">                *</span></span><br><span class="line"><span class="comment">                *              all in (*,  less) == pivot1</span></span><br><span class="line"><span class="comment">                *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span></span><br><span class="line"><span class="comment">                *              all in (great, *) == pivot2</span></span><br><span class="line"><span class="comment">                *</span></span><br><span class="line"><span class="comment">                * Pointer k is the first index of ?-part.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            outer:</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = less - <span class="number">1</span>; ++k &lt;= great; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> ak = a[k];</span><br><span class="line">                <span class="keyword">if</span> (ak == pivot1) &#123; <span class="comment">// Move a[k] to left part</span></span><br><span class="line">                    a[k] = a[less];</span><br><span class="line">                    a[less] = ak;</span><br><span class="line">                    ++less;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ak == pivot2) &#123; <span class="comment">// Move a[k] to right part</span></span><br><span class="line">                    <span class="keyword">while</span> (a[great] == pivot2) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (great-- == k) &#123;</span><br><span class="line">                            <span class="keyword">break</span> outer;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (a[great] == pivot1) &#123; <span class="comment">// a[great] &lt; pivot2</span></span><br><span class="line">                        a[k] = a[less];</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            * Even though a[great] equals to pivot1, the</span></span><br><span class="line"><span class="comment">                            * assignment a[less] = pivot1 may be incorrect,</span></span><br><span class="line"><span class="comment">                            * if a[great] and pivot1 are floating-point zeros</span></span><br><span class="line"><span class="comment">                            * of different signs. Therefore in float and</span></span><br><span class="line"><span class="comment">                            * double sorting methods we have to use more</span></span><br><span class="line"><span class="comment">                            * accurate assignment a[less] = a[great].</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                        a[less] = pivot1;</span><br><span class="line">                        ++less;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// pivot1 &lt; a[great] &lt; pivot2</span></span><br><span class="line">                        a[k] = a[great];</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[great] = ak;</span><br><span class="line">                    --great;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对中心部分进行递归排序</span></span><br><span class="line">        sort(a, less, great, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Partitioning with one pivot</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Use the third of the five sorted elements as pivot.</span></span><br><span class="line"><span class="comment">            * This value is inexpensive approximation of the median.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">int</span> pivot = a[e3];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Partitioning degenerates to the traditional 3-way</span></span><br><span class="line"><span class="comment">            * (or &quot;Dutch National Flag&quot;) schema:</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            *   left part    center part              right part</span></span><br><span class="line"><span class="comment">            * +-------------------------------------------------+</span></span><br><span class="line"><span class="comment">            * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span></span><br><span class="line"><span class="comment">            * +-------------------------------------------------+</span></span><br><span class="line"><span class="comment">            *              ^              ^        ^</span></span><br><span class="line"><span class="comment">            *              |              |        |</span></span><br><span class="line"><span class="comment">            *             less            k      great</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * Invariants:</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            *   all in (left, less)   &lt; pivot</span></span><br><span class="line"><span class="comment">            *   all in [less, k)     == pivot</span></span><br><span class="line"><span class="comment">            *   all in (great, right) &gt; pivot</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * Pointer k is the first index of ?-part.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = less; k &lt;= great; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[k] == pivot) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ak = a[k];</span><br><span class="line">            <span class="keyword">if</span> (ak &lt; pivot) &#123; <span class="comment">// Move a[k] to left part</span></span><br><span class="line">                a[k] = a[less];</span><br><span class="line">                a[less] = ak;</span><br><span class="line">                ++less;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// a[k] &gt; pivot - Move a[k] to right part</span></span><br><span class="line">                <span class="keyword">while</span> (a[great] &gt; pivot) &#123;</span><br><span class="line">                    --great;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[great] &lt; pivot) &#123; <span class="comment">// a[great] &lt;= pivot</span></span><br><span class="line">                    a[k] = a[less];</span><br><span class="line">                    a[less] = a[great];</span><br><span class="line">                    ++less;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// a[great] == pivot</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        * Even though a[great] equals to pivot, the</span></span><br><span class="line"><span class="comment">                        * assignment a[k] = pivot may be incorrect,</span></span><br><span class="line"><span class="comment">                        * if a[great] and pivot are floating-point</span></span><br><span class="line"><span class="comment">                        * zeros of different signs. Therefore in float</span></span><br><span class="line"><span class="comment">                        * and double sorting methods we have to use</span></span><br><span class="line"><span class="comment">                        * more accurate assignment a[k] = a[great].</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                    a[k] = pivot;</span><br><span class="line">                &#125;</span><br><span class="line">                a[great] = ak;</span><br><span class="line">                --great;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对左右部分递归排序。所有元素从中心部分是相等的，因此，已经排序。</span></span><br><span class="line">        sort(a, left, less - <span class="number">1</span>, leftmost);</span><br><span class="line">        sort(a, great + <span class="number">1</span>, right, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips： </p>
<ul>
<li>如果<code>length&lt;47</code>，那么采用插入排序算法。</li>
<li>如果<code>47&lt;=length&lt;286</code>，或者<code>286&lt;=length</code>，但数组不具备特定结构，那么使用快速排序的一种优化形式：双轴快排算法。</li>
<li>如果<code>286&lt;=length</code>，并且数组具备特定结构，那么使用归并排序算法。</li>
</ul>
<h3 id="解释1"><a href="#解释1" class="headerlink" title="解释1:"></a>解释1:</h3><p>这里主要作用是看他数组具不具备结构：实际逻辑是分组排序，每个降序序列为一个组，像<code>1,9,8,7,6,8。9</code>到<code>6</code>是降序，为一个组，然后把降序的一组排成升序：<code>1,6,7,8,9,8。</code>然后再从最后的8开始继续往后面找。</p>
<p>每遇到这样一个降序组，<code>++count</code>，当<code>count</code>大于<code>MAX_RUN_COUNT（67）</code>，被判断为这个数组不具备结构，也就是说这数据时而升时而降，波峰波谷太多，排列太过陡峭，说明不适合采用归并排序，还是使用快速排序为宜。</p>
<p>如果<code>count</code>少于<code>MAX_RUN_COUNT（67）</code>的，说明这个数组还有点结构，就继续往下走下面的归并排序。</p>
<p>参考链接 :</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaGVyaXNoLWxzLmdpdGh1Yi5pby8yMDIwLzEwLzE0L0pBVkElRTUlODYlODUlRTclQkQlQUUlRTYlOEUlOTIlRTUlQkElOEZBcnJheXMtc29ydCVFNSVBRSU5RSVFNyU4RSVCMCVFNyVBRSU4MCVFOCVCRiVCMC8=">源码讲解</span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hvbG1vZnkvYXJ0aWNsZS9kZXRhaWxzLzcxMTY4NTMw">单轴与双轴快排</span></p>
]]></content>
      <tags>
        <tag>Java面试</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>关于sql执行计划</title>
    <url>/blog/posts/60f024c8/</url>
    <content><![CDATA[<p>最近受到客服的一个反馈:某个功能长时间无反馈,响应时间达到了<code>20s</code>以上,通过调用日志发现,某条<code>sql</code>查询竟然花费了<code>12s</code>的时间,而且查询了两次,于是准备通过执行计划对此进行找方向调优.</p>
<h1 id="什么是执行计划"><a href="#什么是执行计划" class="headerlink" title="什么是执行计划"></a>什么是执行计划</h1><h2 id="1-MySQL逻辑结构先知"><a href="#1-MySQL逻辑结构先知" class="headerlink" title="1. MySQL逻辑结构先知"></a>1. <code>MySQL</code>逻辑结构先知</h2><span id="more"></span>

<p>关于<code>MySQL</code>的逻辑结构，将其理解为四层，就像项目分层一样，每一层处理不同的业务逻辑，先看图后说话：</p>
<img data-src="/blog/posts/60f024c8/2021-11-17-15-24-30.png" class="">

<p>上图概述：</p>
<ul>
<li><p>客户端：这里指连接<code>MySQL</code>各种形式，如<code>.Net</code>中使用的<code>ADO</code>连接、<code>Java</code>使用<code>JDBC</code>连接等；<code>MySQL</code>是客户端和服务器模式，前提先建立连接，才能传输数据，处理相关逻辑；</p>
</li>
<li><p>业务逻辑：在<code>MySQL</code>内部有很多模块组成，分别处理相关业务逻辑；</p>
</li>
<li><p>连接管理：负责连接认证、连接数判断、连接池处理等业务逻辑处理；</p>
</li>
<li><p>查询缓存：当一个<code>SQL</code>进来时，如果开启查询缓存功能，<code>MySQL</code>会优先去查询缓存中检查是否有数据匹配，如果匹配上，就不会再去解析对应的<code>SQL</code>啦，但如果语句中有用户自定义函数、存储函数、用户变量、临时表、<code>mysql</code>库中的系统表时，都不会走缓存； 对于查询缓存来说，在<code>MySQL8.0</code>已经去除，官方回应的是在一定场景上，查询缓存会导致性能上的瓶颈。</p>
</li>
<li><p>解析器：对于一个<code>SQL</code>语句，<code>MySql</code>根据语法规则需要对其进行解析，并生成一个内部能识别的解析树；</p>
</li>
<li><p>优化器：负责对解析器得到的解析树进行优化，<code>MySQL</code>会根据内部算法找到一个<code>MySQL</code>认为最优的执行计划，后续就按照这个执行计划执行。所以后续我们分析的就是<code>MySQL</code>针对<code>SQL</code>语句选择出来的最优执行计划，结合业务，根据规则对<code>SQL</code>进行优化，从而让<code>SQL</code>语句在<code>MySQL</code>内部达到真正的最优。</p>
</li>
<li><p>执行器：得到执行计划之后，就会找到对应的存储引擎，根据执行计划给出的指令依次执行。</p>
</li>
<li><p>存储引擎：数据的存储和提取最后是靠存储引擎；<code>MySQL</code>内部实现可插拔式的存储引擎机制，不同的存储引擎执行不同的逻辑；</p>
</li>
<li><p>物理文件：数据存储的最终位置，即磁盘上；协同存储引擎对数据进行读写操作。</p>
</li>
</ul>
<p>关于<code>MySql</code>的逻辑结构，以上只是简单描述，业务逻辑层的功能模块远不止上面提到的，小伙伴有兴趣可以专门研究一下，这里的目的就是为了体现<code>SQL</code>语句到服务器上时经过的几个关键步骤，方便后续优化的理解。</p>
<h2 id="2-SQL语句的中关键字执行顺序须知"><a href="#2-SQL语句的中关键字执行顺序须知" class="headerlink" title="2.SQL语句的中关键字执行顺序须知"></a>2.<code>SQL</code>语句的中关键字执行顺序须知</h2><p>在编写一条查询语句时，习惯性的从头到尾开始敲出来，应该都是从<code>select</code> 开始吧，但似乎没太注意它们真正的执行顺序；既然要优化，肯定需要得知道一条<code>SQL</code>语句大概的执行流程，结合执行计划，目的就更加清晰啦；上一张一看就明白的图：</p>
<img data-src="/blog/posts/60f024c8/2021-11-22-15-55-16.png" class="">

<p>关键字简述：</p>
<ul>
<li><code>FROM</code>：确定数据来源，即指定表；</li>
<li><code>JOIN...ON</code>：确定关联表和关联条件；</li>
<li><code>WHERE</code>：指定过滤条件，过滤出满足条件的数据；</li>
<li><code>GROUP BY</code>：按指定的字段对过滤后的数据进行分组；</li>
<li><code>HAVING</code>：对分组之后的数据指定过滤条件；</li>
<li><code>SELECT</code>：查找想要的字段数据；</li>
<li><code>DISTINCT</code>：针对查找出来的数据进行去重；</li>
<li><code>ORDER BY</code>：对去重后的数据指定字段进行排序；</li>
<li><code>LIMIT</code>：对去重后的数据限制获取到的条数，即分页；<br>好啦，大概了解<code>MySQL</code>的逻辑结构和<code>SQL</code>查询关键字执行顺序之后，接下来就可以好好说说执行计划啦。</li>
</ul>
<h2 id="3-好好说说执行计划"><a href="#3-好好说说执行计划" class="headerlink" title="3. 好好说说执行计划"></a>3. 好好说说执行计划</h2><p>通过上面的逻辑结构，当一个<code>SQL</code>发送到<code>MySQL</code>执行时，需要经过内部优化器进行优化，而使用<code>explain</code>关键字可以模拟优化器执行<code>SQL</code>查询语句，从而知道<code>MySQL</code>是如何处理<code>SQL</code>的，即<code>SQL</code>的执行计划；根据<code>explain</code>提供的执行计划信息分析<code>SQL</code>语句，然后进行相关优化操作。接下来的示例演示用到五张表：<code>USER(用户表)、MENU(菜单表)、ROLE(角色表)、USER_ROLE(用户角色关系表)、ROLE_MENU(角色菜单关系表)、ADDR(用户地址表，这里认为和用户一一对应)、FRIEND(朋友表，一对多关系)</code>，它们的关系这里就不详细说了吧，小伙伴肯定都明白，这是管控菜单权限的五张基础表和两个基础信息表；</p>
<p>表DDL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SQLyog Ultimate - MySQL GUI v8.2 </span></span><br><span class="line"><span class="comment">MySQL - 5.5.27 : Database - sql_optimization</span></span><br><span class="line"><span class="comment">*********************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET NAMES utf8 */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET SQL_MODE=&#x27;&#x27;*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */</span>;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span>`sql_optimization` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8 COLLATE utf8_bin */</span>;</span><br><span class="line"></span><br><span class="line">USE `sql_optimization`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `addr` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `addr`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `addr` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ADDR` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `addr` */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `friend` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `friend`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `friend` (</span><br><span class="line">  `USER_ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `FRIEND_ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  KEY `idx_user_id` (`USER_ID`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `friend` */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `menu` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `menu`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `menu` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `MENU_NAME` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `MENU_URL` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `menu` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `menu`(`ID`,`MENU_NAME`,`MENU_URL`) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;用户新增&#x27;</span>,<span class="string">&#x27;api/User/Add&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;用户删除&#x27;</span>,<span class="string">&#x27;api/User/Delete&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;用户修改&#x27;</span>,<span class="string">&#x27;api/User/Update&#x27;</span>),(<span class="number">4</span>,<span class="string">&#x27;用户查询&#x27;</span>,<span class="string">&#x27;api/User/Query&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;角色新增&#x27;</span>,<span class="string">&#x27;api/Role/Add&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;角色修改&#x27;</span>,<span class="string">&#x27;api/Role/Update&#x27;</span>),(<span class="number">7</span>,<span class="string">&#x27;角色删除&#x27;</span>,<span class="string">&#x27;api/Role/Delete&#x27;</span>),(<span class="number">8</span>,<span class="string">&#x27;角色查询&#x27;</span>,<span class="string">&#x27;api/Role/Query&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `role`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `role` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ROLE_NAME` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `role`(`ID`,`ROLE_NAME`) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;admin&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;test&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;custmor&#x27;</span>),(<span class="number">4</span>,<span class="string">&#x27;role1&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;role2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `role_menu` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `role_menu`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `role_menu` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ROLE_ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `MENU_ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `role_menu` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `role_menu`(`ID`,`ROLE_ID`,`MENU_ID`) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">1</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">1</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">1</span>,<span class="number">8</span>),(<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>),(<span class="number">10</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">11</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">12</span>,<span class="number">3</span>,<span class="number">5</span>),(<span class="number">13</span>,<span class="number">3</span>,<span class="number">6</span>),(<span class="number">14</span>,<span class="number">3</span>,<span class="number">7</span>),(<span class="number">15</span>,<span class="number">4</span>,<span class="number">1</span>),(<span class="number">16</span>,<span class="number">4</span>,<span class="number">5</span>),(<span class="number">17</span>,<span class="number">4</span>,<span class="number">8</span>),(<span class="number">18</span>,<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `user` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `USER_NAME` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `USER_PWD` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`),</span><br><span class="line">  KEY `idx_user_name` (`USER_NAME`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `user` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `<span class="keyword">user</span>`(`ID`,`USER_NAME`,`USER_PWD`) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;Zoe&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Coder&#x27;</span>,<span class="string">&#x27;23452a&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Code综艺圈&#x27;</span>,<span class="string">&#x27;231235&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `user_role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `user_role`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_role` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `USER_ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ROLE_ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `user_role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `user_role`(`ID`,`USER_ID`,`ROLE_ID`) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>),(<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */</span>;</span><br></pre></td></tr></table></figure>

<p>演示用的版本是<code>MySql5.5</code>，各版本之间会有不同，所以小伙伴用的版本测试结果不一样的时候，千万别骂我渣哦；其实重要的是查看的思路，整体是大同小异。(求原谅……)</p>
<p>通过<code>explain</code>会输出如下信息，很多小伙伴只关注红框标注部分(即索引)，但其实是不够的，接下来就一个一个好好说说。</p>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-00-46.png" class="">

<ul>
<li><p><code>id</code></p>
<p>  这个<code>id</code>和咱们平时表结构设计的主键<code>ID</code>不太一样，这里的<code>id</code>代表了每一条<code>SQL</code>语句执行计划中表加载的顺序，分为三种情况：</p>
<blockquote>
<p><code>id</code>相同的时候：这时是从上到下依次执行；</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> t.ID,t.USER_NAME,r.ROLE_NAME <span class="keyword">FROM</span> <span class="keyword">USER</span> t </span><br><span class="line">	<span class="keyword">JOIN</span> USER_ROLE tr <span class="keyword">ON</span> t.ID <span class="operator">=</span> tr.USER_ID</span><br><span class="line">	<span class="keyword">JOIN</span> ROLE r <span class="keyword">ON</span> tr.ROLE_ID <span class="operator">=</span> r.ID</span><br></pre></td></tr></table></figure></li>
</ul>
<p>执行如下语句，得如下结果：</p>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-03-34.png" class="">

<p>如上图所示，<code>id</code>一样，从上到下依次执行，所对应表加载顺序为<code>t-&gt;tr-&gt;r</code>(这里的表是别名)；</p>
<pre><code>&gt; `id`不同的时候：当`id`不同的时，`id`越大的越先执行；
</code></pre>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> t.ID,t.MENU_NAME,t.MENU_URL <span class="keyword">FROM</span> MENU t</span><br><span class="line">	<span class="keyword">WHERE</span> t.ID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> MENU_ID <span class="keyword">FROM</span> ROLE_MENU rm </span><br><span class="line">		<span class="keyword">WHERE</span> rm.ROLE_ID <span class="keyword">IN</span>(<span class="keyword">SELECT</span> ROLE_ID <span class="keyword">FROM</span> USER_ROLE ur <span class="keyword">WHERE</span> ur.USER_ID<span class="operator">=</span><span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>子查询会导致<code>id</code>递增，结果如下：</p>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-05-35.png" class="">

<p>如上图所示，<code>id</code>递增啦，所对应表的加载顺序为<code>ur-&gt;rm-&gt;t</code>(这里的表是别名)；</p>
<pre><code>&gt; `id`相同和不同同时存在时：id相同的认为是同一组，还是从上往下加载；不一样的情况还是越大越优先执行
</code></pre>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> t.ROLE_ID,m.ID,m.MENU_NAME,m.MENU_URL <span class="keyword">FROM</span> </span><br><span class="line">	(<span class="keyword">SELECT</span> ROLE_ID <span class="keyword">FROM</span> USER_ROLE <span class="keyword">WHERE</span> USER_ID<span class="operator">=</span><span class="number">3</span>) t,ROLE_MENU rm,MENU m</span><br><span class="line">	<span class="keyword">WHERE</span> t.ROLE_ID<span class="operator">=</span>rm.ROLE_ID</span><br><span class="line">	<span class="keyword">AND</span> rm.MENU_ID<span class="operator">=</span>m.ID</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-06-53.png" class="">

<p>如上图所示，<code>id</code>有一样的，也有不同的，则对应表的加载顺序为<code>USER_ROLE-&gt;derived2 (衍生表)-&gt;rm-&gt;m</code>；衍生表表名后面的<code>2</code>代表的是<code>id</code>，所以可以通过衍生表表名后面的<code>id</code>知道是哪一步产生的，即<code>derived2</code>衍生表是<code>id</code>为<code>2</code>的这一步产生的。</p>
<ul>
<li><code>select_type</code></li>
</ul>
<p><code>select_type</code> 是表示每一步的查询类型，方便分析人员很直接的看到当前步骤执行的是什么查询，有多种类型，见下图：</p>
<blockquote>
<p>1&gt; <code>SIMPLE</code>：简单的<code>SELECT</code>查询，不包含子查询或<code>UNION</code>的那种；</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-13-44.png" class="">

<blockquote>
<p>2&gt; <code>PRIMARY</code>：查询语句中包含其他子查询或<code>UNION</code>操作，那最外层的<code>SELECT</code>就被标记为该类型；</p>
</blockquote>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-15-17.png" class="">

<p>如上图所示，查询中包含子查询，最外层查询被标记为<code>PRIMARY</code>；</p>
<blockquote>
<p>3&gt; <code>SUBQUERY</code>：在<code>SELECT</code>或<code>WHERE</code>中包含的子查询会被标记为该类型；</p>
</blockquote>
<p>见<code>PRIMARY</code>图，当存在子查询时，会将子查询标记为<code>SUBQUERY</code></p>
<blockquote>
<p>4&gt; <code>MATERIALIZED</code>：被物化的子查询，即针对对应的子查询将其物化为一个临时表；</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> t.ID,t.MENU_NAME,t.MENU_URL <span class="keyword">FROM</span> MENU t</span><br><span class="line">	<span class="keyword">WHERE</span> t.ID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> MENU_ID <span class="keyword">FROM</span> ROLE_MENU rm </span><br><span class="line">		<span class="keyword">WHERE</span> rm.ROLE_ID <span class="keyword">IN</span>(<span class="keyword">SELECT</span> ROLE_ID <span class="keyword">FROM</span> USER_ROLE ur <span class="keyword">WHERE</span> ur.USER_ID<span class="operator">=</span><span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>测试物化用的是<code>MySQL8.0</code>，和<code>5.*</code>版本有所不同，输出结果如下：</p>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-16-49.png" class="">

<p>如上图所示，将子查询物化为一个临时表<code>subquery2</code>，这个功能是可以通过设置优化器对应的开关的。</p>
<blockquote>
<p>5&gt; <code>DERIVED</code>：在<code>FROM</code>之后的子查询会被标记为该类型，同样会把结果放在一个临时表中</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> tm.MENU_NAME,rm.ROLE_ID <span class="keyword">FROM</span> </span><br><span class="line">	(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MENU <span class="keyword">WHERE</span> ID <span class="operator">&gt;</span><span class="number">3</span> ) tm ,ROLE_MENU rm </span><br><span class="line">	<span class="keyword">WHERE</span> tm.ID<span class="operator">=</span>rm.MENU_ID <span class="keyword">AND</span> rm.ROLE_ID<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-17-39.png" class="">

<p>如图所示，<code>FROM</code>后面跟的子查询就被标记为<code>DERIVED</code>，对应步骤产生的衍生表为<code>derived2</code>。高版本好像对其进行了优化，<code>8.0</code>版本这种形式认为是简单查询。</p>
<blockquote>
<p>6&gt; <code>UNION：UNION</code>操作中，查询中处于内层的<code>SELECT</code>；</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> USER_ROLE T1 <span class="keyword">WHERE</span> T1.USER_ID<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> USER_ROLE T2 <span class="keyword">WHERE</span> T2.USER_ID<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-18-35.png" class="">

<p>如上图所示，将第二个<code>SELECT</code>标注为<code>UNION</code> ，即对应加载的表为<code>T2</code>。</p>
<blockquote>
<p>7&gt; <code>UNIOIN RESULT：UNION</code>操作的结果，对应的<code>id</code>为空，代表的是一个结果集；</p>
</blockquote>
<p>见<code>UNIOIN</code>图，<code>UNIOIN RESULT</code>代表的是<code>UNION</code>之后的结果，对应<code>id</code>为空。</p>
<ul>
<li><code>table</code></li>
</ul>
<p><code>table</code>代表对应步骤加载的是哪张表，中间会出现一些临时表，比如<code>subquery2、derived2</code>等这种，最后的数字代表产生该表对应步骤的<code>id</code>。</p>
<ul>
<li><code>type</code></li>
</ul>
<p>代表访问类型，<code>MySQL</code>内部将其分为多类型，常用的类型从好到差的顺序展示如下：</p>
<p><strong><code>system-&gt;const-&gt;eq_ef-&gt;ref-&gt;fulltext-&gt;ref_or_null-&gt;index_merge-&gt;unique_subquery-&gt;index_subquery-&gt;range-&gt;index-&gt;ALL;</code></strong></p>
<p>而在实际开发场景中，比较常见的几种类型如下：<code>const-&gt;eq_ref-&gt;ref-&gt;range-&gt;index-&gt;ALL</code>(顺序从好到差)，通常优化至少在<code>range</code>级别或以上，比如<code>ref</code>算是比较不错的啦；</p>
<p>上面说到的从好到差指的是查询性能。</p>
<blockquote>
<p>1&gt;<code>const</code>：表示通过索引一次就找到数据，用于比较<code>primary key</code>或者<code>unique</code>索引，很快就能找到对应的数据；</p>
</blockquote>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-21-32.png" class="">

<blockquote>
<p>2&gt;<code>eq_ref</code>：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或唯一索引扫描；</p>
</blockquote>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-22-02.png" class="">

<blockquote>
<p>3&gt;<code>ref</code>：非唯一索引扫描，返回匹配的所有行，如建立一个朋友维护表，维护用户对应的朋友，而在用户<code>ID</code>建立非唯一索引；</p>
</blockquote>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-22-32.png" class="">

<blockquote>
<p>4&gt;<code>range</code>：使用一个索引检索指定范围的行，一般在<code>where</code>语句中会出现<code>between、&lt;、&gt;、in</code>等范围查询；</p>
</blockquote>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-22-59.png" class="">

<blockquote>
<p>5&gt;<code>index</code>：全索引扫描，只遍历索引树；</p>
</blockquote>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-23-30.png" class="">

<blockquote>
<p>6&gt;<code>ALL</code>：全表扫描，找到匹配行。与<code>index</code>比较，<code>ALL</code>需要扫描磁盘数据，<code>index</code>值需要遍历索引树。</p>
</blockquote>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-23-57.png" class="">

<ul>
<li><code>possible_keys</code></li>
</ul>
<p>显示可能被用到的索引，但在实际查询中不一定能用到； 查询涉及到字段，如果存在索引，会被列出，但如果使用的是覆盖索引，只会在<code>key</code>中列出；</p>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-24-29.png" class="">

<ul>
<li><code>key</code></li>
</ul>
<p>实际使用到的索引，如果为<code>NULL</code>代表没有使用到索引；这也是平时小伙伴判断是否用上索引的关键。</p>
<ul>
<li><code>key_len</code></li>
</ul>
<p><code>key_len</code>表示索引使用的字节数，根据这个值可以判断索引的使用情况，特别是在组合索引的时候，判断该索引有多少部分被使用到，非常重要；<code>key_len</code>是根据表定义计算而得。这里测试在<code>USER</code>表中对<code>USER_NAME</code>创建一个非唯一索引，如下：</p>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-25-14.png" class="">

<p>这里<code>key_len</code>是这么计算的，前提是指定的字符串集是<code>utf8</code>，可变长 且允许为空，计算过程如下：</p>
<p><code>128(设置的可变长度)*3(utf8占3字节)+1(允许为空标识占一个字节)+2(长度信息占两个字节)=387；</code></p>
<p><code>key_len</code>针对不同类型字段的计算规则不一样，这里用<code>USER(用户表)</code>简单计算为例：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>Key_len</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ID(int，不为空)</code></td>
<td><code>4</code></td>
<td><code>int</code>为<code>4</code>个字节，不为空</td>
</tr>
<tr>
<td><code>USER_NAME(varchar(128)，utf8，可为空)</code></td>
<td><code>128*3+1+2=387</code></td>
<td>可变为<code>128，utf8</code>每个占<code>3</code>字节，<code>1</code>个字节标识可控，两个字节标识长度</td>
</tr>
</tbody></table>
<p>不同类型占用的字节不一样，字符集不一样占用的字节也不一样，允许为空的字段需要<code>1</code>个字节做标识，可变长度的字段需要<code>2</code>个字节标识长度。小伙伴照着这个思路就可以计算其他类型啦。</p>
<ul>
<li><code>ef</code></li>
</ul>
<p>显示索引的哪些列被引用了，通常是对应字段或<code>const</code>；</p>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-30-20.png" class="">
<img data-src="/blog/posts/60f024c8/2021-11-22-16-30-30.png" class="">

<ul>
<li><code>rows</code></li>
</ul>
<p>根据表统计信息和索引的使用情况，大概估算出找到所需记录数据所扫描的数据行数；不是所需数据的行数。</p>
<ul>
<li><code>Extra</code></li>
</ul>
<p>这个字段里包含一些其他信息，但也是优化<code>SQL</code>的重要参考，通常会出现以下几种信息：</p>
<blockquote>
<p><code>Using index</code>：表示查询语句中用到了覆盖索引，不访问表的数据行，查询效率比较好。</p>
</blockquote>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-31-08.png" class="">

<p>如果用<code>SELECT *</code>进行查询，就不会有<code>Using index</code>，关于索引的介绍下篇好好说说。</p>
<blockquote>
<p><code>Using filesort</code>：代表<code>MySQL</code>会使用一个外部索引对数据进行排序(文件排序)，而不是使用表内索引。这种情况在<code>SQL</code>查询需要避免，最好不要在<code>Extra</code>中出现此类型：</p>
</blockquote>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-32-01.png" class="">

<p>通常会是使用<code>ORDER BY</code>语句导致，上图中使用无索引的字段进行排序会出现，同样如果使用有索引的字段，但用法不对也会出现，比如使用组合索引不规范时。</p>
<ul>
<li><code>Using temporary</code>：产生临时表保存中间结果，这种SQL是不允许的，遇见数据量大的场景，基本就跑不动啦；</li>
</ul>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-32-30.png" class="">

<p>这种类型常常因为<code>ORDER BY</code> 和 <code>GROUP BY</code>导致，所以在进行数据排序和分组查询时，要注意索引的合理利用。</p>
<blockquote>
<p><code>Using where</code>：使用<code>where</code>过滤数据，小伙伴试一把。</p>
</blockquote>
<blockquote>
<p><code>Using join buffer</code>：表示使用到了表连接缓存； 当表数据量大，可能导致<code>buffer</code>过大，查询效率比较低，这种情况注意在表连接字段上正确使用索引。</p>
</blockquote>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-33-30.png" class="">

<p>如果表连接查询慢时，在连接字段上加个索引试试，药到病除；</p>
<blockquote>
<p><code>impossible where</code>：代表<code>where</code>后面的条件永远为<code>false</code>，匹配不到数据；</p>
</blockquote>
<img data-src="/blog/posts/60f024c8/2021-11-22-16-33-42.png" class="">




]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>执行计划</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试必问--HashMap的底层</title>
    <url>/blog/posts/52d9f7d3/</url>
    <content><![CDATA[<h2 id="jdk7-HashMap"><a href="#jdk7-HashMap" class="headerlink" title="jdk7 HashMap"></a><code>jdk7 HashMap</code></h2><blockquote>
<p>数组</p>
</blockquote>
<p>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为<code>O(1)</code>；<br>数组的特点是：寻址容易，插入和删除困难；</p>
<ul>
<li><code>HashMap</code> 里面实现一个静态内部类 <code>Entry，Entry</code> 包含四个属性：<code>key，value，hash</code>值和用于单向链表的 <code>next</code>。<code>Entry</code> 就是 <code>HashMap</code> 键值对实现的一个基础 <code>bean</code>，我们上面说到 <code>HashMap</code> 的基础就是一个线性数组，这个数组就是 <code>Entry[]，Map</code> 里面的内容都保存在 <code>Entry[]</code> 里面</li>
</ul>
<span id="more"></span>

<blockquote>
<p>链表</p>
</blockquote>
<p>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，为<code>O(N)</code>。<br>链表的特点是：寻址困难，插入和删除容易。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);   <span class="comment">// 比 hash(key)%(length -1) 更高效的方法</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>1.8</code>之前是这样的头插法: 当<code>put</code>时要插入的元素的索引有重复时，会发生<code>hash</code>冲突碰撞，此时链表发挥作用：新插入的<code>Entry</code>的<code>next</code>指针指向旧的<code>Entry</code>，并通过修改当前索引位置的引用地址指向新的<code>Entry</code>，链表向下移动从而取代旧<code>Entry</code>的位置，放在数组相应索引位置，</li>
</ul>
<p><strong>哈希表</strong> 那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表<code>（(Hash table）</code>既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。</p>
<ul>
<li>每个数据对象的<code>hash</code>对应唯一一个值，但是一个<code>hash</code>值不一定对应唯一的数据对象。如果两个不同对象的 <code>hash</code> 哈希冲突。</li>
</ul>
<p>哈希表是由数组+链表组成的，一个长度为<code>16</code>的数组中，每个数组中元素存储的是一个链表的头结点。</p>
<img data-src="/blog/posts/52d9f7d3/2022-02-21-12-14-24.png" class="">

<ul>
<li>源码解析</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="comment">// 另外3个构造方法都会调用带有2个参数的构造方法：HashMap(int initialCapacity, float loadFactor)</span></span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 另外3个构造方法都会调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>put</code>源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果put的key在map中已经存在则旧value会被覆盖，然后返回被覆盖的value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="comment">// 使用头插法的原因是：插入结点的速度比尾插法更快</span></span><br><span class="line">        <span class="comment">// 遍历当前数组索引 i 上的链表从而寻找到该链表的尾结点</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">// 如果插入当前链表的结点它的hashCode和key都相等</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;  <span class="comment">// 先取出oldValue，最后要返回该值</span></span><br><span class="line">                e.value = value;		<span class="comment">// 覆盖oldValue</span></span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);  <span class="comment">// hashMap用不到，LinkedList采用得到该方法</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;  <span class="comment">// 返回被覆盖的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++; <span class="comment">// 表示修改次数</span></span><br><span class="line">        addEntry(hash, key, value, i); <span class="comment">// 数组扩容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="put头插法的问题"><a href="#put头插法的问题" class="headerlink" title="put头插法的问题"></a><code>put</code>头插法的问题</h3><p>数据插入使用头插法，会造成一个问题：<br>在<code>resize</code>扩容时，里面有一个<code>resize</code>方法又调用了<code>transfer</code>方法，把里面一些<code>Entry</code>进行了<code>rehash</code>，在这个过程中可能造成一个链表的循环，可能导致在下一次<code>Get</code>时候出现要给死循环； 也有可能因为没有加锁，在多个线程并发情况下，不能保证数据安全，可能<code>put</code>一个值<code>get</code>出来还是那个值</p>
<ul>
<li>数组<code>table</code>容量初始化（<code>inflateTable</code>）<br>在第一个元素插入 <code>HashMap</code> 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证数组大小一定是 2 的 n 次方。</span></span><br><span class="line">    <span class="comment">// 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">// 计算扩容阈值：capacity * loadFactor</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 算是初始化数组吧</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); <span class="comment">//ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算具体数组位置（indexFor）"><a href="#计算具体数组位置（indexFor）" class="headerlink" title="计算具体数组位置（indexFor）"></a>计算具体数组位置（<code>indexFor</code>）</h3><p>取<code>hash</code> 值的低 <code>n</code> 位。如在数组长度为 <code>32</code> 的时候，其实取的就是 <code>key</code> 的 <code>hash</code> 值的低 <code>5</code> 位，作为它在数组中的下标位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> hash, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> hash &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加节点到链表中（addEntry）"><a href="#添加节点到链表中（addEntry）" class="headerlink" title="添加节点到链表中（addEntry）"></a>添加节点到链表中（<code>addEntry</code>）</h3><ul>
<li>找到数组下标后，会先进行 <code>key</code> 判重，如果没有重复，就准备将新值放入到链表的表头。</li>
<li>主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 扩容，后面会介绍一下</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">// 扩容以后，重新计算 hash 值</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 重新计算扩容后的新的下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往下看</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个很简单，其实就是将新值放到链表的表头，然后 size++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组扩容（resize）"><a href="#数组扩容（resize）" class="headerlink" title="数组扩容（resize）"></a>数组扩容（<code>resize</code>）</h3><ul>
<li>插入新值的时候，如果当前的 <code>size</code> 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 <code>2</code> 倍。</li>
<li>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</li>
<li>数组扩容是为了分散链表，让链表变短而使得<code>get</code>效率提高，加快查询效率</li>
<li>由于是双倍扩容，迁移过程中，会将原来 <code>table[i]</code> 中的链表的所有节点，分拆到新的数组的 <code>newTable[i]</code>和 <code>newTable[i + oldLength]</code> 位置上。如原来数组长度是 <code>16</code>，那么扩容后，原来 <code>table[0]</code> 处的链表中的所有元素会被分配到新数组中 <code>newTable[0]</code> 和 <code>newTable[16]</code> 这两个位置。代码比较简单，这里就不展开了。</li>
<li>毛病：在多线程扩容时有可能会出现循环链表的情况，导致在get时会循环遍历。起因是扩容时使用头插法，导致<code>next</code>在结点<code>e</code> 之前，使得数据顺序发生变化</li>
</ul>
<p>解决方法：防止<code>hash</code>扩容，具体可以控制阈值<code>threshold</code>大于所需要的数组。还可以加锁、并发安全控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将原来数组中的值迁移到新的更大的数组中  transfer()底层是通过双重循环数组直到非空元素，然后转移到新的数组相对应的索引位置</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity)); <span class="comment">// 元素转移</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a><code>get</code> 过程分析</h3><ul>
<li>根据 <code>key</code> 计算 <code>hash</code> 值。</li>
<li>找到相应的数组下标：<code>hash &amp; (length - 1)</code>。</li>
<li>遍历该数组位置处的链表，直到找到相等<code>(==或equals)</code>的 <code>key</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="comment">// 确定数组下标，然后从头开始遍历链表，直到找到为止</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];   <span class="comment">// 定位数组下标，遍历链表</span></span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;  <span class="comment">// 通过比较key和hash是否相等，相等则表示找到，返回entry</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a><strong><code>remove</code></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;  </span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>1.7的插入存储底层实现：</p>
<ul>
<li>数组(默认长度为<code>16bit</code>，源码默认容量 <code>= 1 &lt;&lt; 4</code>， 最大容量限制：<code>1 &lt;&lt; 30</code>)：</li>
</ul>
<ul>
<li>数组中还可以存放数组，每个数组中的一个存储单元存储的是 <code>Entry</code>(属性包括：<code>key, value, hash，Node&lt;K,V&gt; next</code>(数组+链表)) 结构的数据，<code>Entry</code>的实现是一个链表<code>Node</code>(属性和<code>Entry</code>相同)。其中元素在数组中的存储索引下标可以通过：(<code>hash % arr.length-1</code>) 得出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">put(key, value)&#123;  <span class="comment">// put底层伪代码</span></span><br><span class="line">	<span class="keyword">int</span> hashcode = key.hashcode();</span><br><span class="line">	<span class="keyword">int</span> index = hashcode % table.legnth;</span><br><span class="line">	table[index] = <span class="keyword">new</span> Entry(key, value, table[index]); <span class="comment">// 头插法，新结点指向数组上对应索引的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="jdk8-HashMap"><a href="#jdk8-HashMap" class="headerlink" title="jdk8 HashMap"></a><code>jdk8 HashMap</code></h2><ul>
<li><code>1.7</code>之前<code>put</code>是头插法，<code>1.8</code>之后是尾插法，头插法会出现链表循环的问题，后者不会，但都不是线程安全</li>
</ul>
<ul>
<li>数组：一段连续的存储单元来存储结构,插入慢<code>O(n)</code>查找快<code>O(1)</code>； 链表<code>Node</code>：一种物理存储单元上非连续、非顺序的存储结构，插入快<code>O(1)</code>查找慢<code>O(n)</code></li>
</ul>
<ul>
<li><code>HashMap</code>线程不安全，底层没有锁，线程安全的<code>HashMap：Collections.synchronizedMap()、new ConcurrentHashMap&lt;&gt;()</code>;</li>
</ul>
<ul>
<li><code>HashMap</code>底层是：数组+<code>Node</code>链表+的红黑树，每个数据单元都是一个<code>Node</code>结构。容量为<code>16</code>，负载因子<code>0.75</code>(即装载的内存超过容量的<code>3/4</code>会自动扩容，<code>HashMap</code>扩容为当前的<code>2</code>倍，即<code>2^(4+1)</code>，<code>ArrayList</code>扩容为原来的一半).</li>
</ul>
<ul>
<li><code>hashMap</code>的散列表，采用懒加载机制，只有第一次<code>put</code>时才会创建，而不是<code>new</code>就创建</li>
</ul>
<ul>
<li><code>Node</code>结构中包含<code>key、value、next、hash</code>字段，其中<code>next</code>字段是当发生<code>hash</code>冲突时，当前桶位中的<code>node</code>与冲突<code>node</code>连成一个链表要用的字段</li>
</ul>
<ul>
<li><code>hash</code>值是通过<code>key.hashCode()</code>二次加工得到的，加工原则是<code>key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)</code> ， 即高<code>16</code>位和低<code>16</code>位的异或。这样做主要是为了加大散列程度的散列化，也是因为<code>hash</code>寻址算法的缘故：</li>
</ul>
<ul>
<li><code>HashMap</code>可以存放<code>key</code>为空的元素：<code>map.put(null, &quot;xxx&quot;)</code> 当<code>key</code>为<code>null</code>时，<code>JVM</code>会单独分配一片空间用来存放该值，再次<code>put</code>一个<code>key</code>为<code>null</code>的值时会覆盖之前的</li>
</ul>
<ul>
<li><code>capacity</code>：当前数组容量，始终保持 <code>2^n</code>，可以扩容，扩容后数组大小为当前的 <code>2</code> 倍。</li>
</ul>
<ul>
<li><code>loadFactor</code>：负载因子，默认为<code>0.75</code>。</li>
</ul>
<ul>
<li><code>threshold</code>：扩容的阈值，等于<code>capacity * loadFactor</code>。</li>
</ul>
<blockquote>
<p> 1、扩容的数组的长度为什么保持 <code>2^n？</code></p>
</blockquote>
<p>其实这是为了保证通过hash方式获取下标的时候分布均匀。数组长度为2的<code>n</code>次幂的时候，不同的<code>key</code> 算得的 <code>index</code> 相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
<blockquote>
<p>2、为什么负载因子的值默认为 <code>0.75？</code></p>
</blockquote>
<p>加载因子是表示<code>Hash</code>表中元素的填满的程度。<br>加载因子越大，填满的元素越多，空间利用率越高，但冲突的机会加大了。<br>反之,加载因子越小，填满的元素越少，冲突的机会减小，但空间浪费多了。<br>冲突的机会越大，则查找的成本越高。反之，查找的成本越小。<br>因此,必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。</p>
<ul>
<li><code>Java7 HashMap</code> ，查找的时候，根据 <code>hash</code> 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 <code>O(n)</code>。</li>
</ul>
<p><strong>为了降低这部分的开销，在 <code>Java8</code> 中，当链表中的元素达到了 <code>8</code> 个，且散列表数组长度已经达到<code>64</code>，会将链表转换为红黑树，否则进行数组扩容，在这些位置进行查找的时候可以降低时间复杂度为 <code>O(logN)</code>。</strong></p>
<img data-src="/blog/posts/52d9f7d3/2022-02-21-17-09-33.png" class="">

<p><strong>链表转化为红黑树有两个条件：</strong></p>
<p><code>putVal</code>时进行判断，链表长度到达<code>8</code>调用<code>treeifyBin</code> 转换红黑树的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// TREEIFY_THRESHOLD 值为8</span></span><br><span class="line">     treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure>

<p>但在转换红黑树前还会进行判断：数组长度是否小于<code>64</code>，小于则散列表<code>resize</code>扩容，大于等于<code>64</code>则链表转红黑树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表转红黑树</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 但在转换红黑树前还会进行判断：数组长度是否小于64</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) <span class="comment">// MIN_TREEIFY_CAPACITY值为64</span></span><br><span class="line">        resize(); 	<span class="comment">// 散列表扩容</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; <span class="comment">// 数组长度大于64，链表转为红黑树</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>当数组其中一个索引位置上的链表长度大于<code>8</code>时，调用转换红黑树方法<code>treeifyBin</code></p>
</li>
<li><p>当前散列表数组长度已经达到<code>64</code>，两个指标都要达到，否则就算<code>slot</code>内部链表长度达到<code>8</code>也不会链转树，而是发生一次<code>resize</code>散列表扩容</p>
</li>
</ol>
<h3 id="红黑树-RB-Tree"><a href="#红黑树-RB-Tree" class="headerlink" title="红黑树 RB-Tree"></a>红黑树 <code>RB-Tree</code></h3><ul>
<li>二叉查找树是不平衡的，可能会变成链表，因此需要采用红黑树（<code>RB-Tree</code>），插入和查询的 <code>O(n) = logn</code></li>
<li>红黑树只需要保证黑色结点高度平衡，且满足以下<code>5</code>个条件</li>
</ul>
<img data-src="/blog/posts/52d9f7d3/2022-02-21-17-31-11.png" class="">

<h2 id="红黑树插入结点规律："><a href="#红黑树插入结点规律：" class="headerlink" title="红黑树插入结点规律："></a>红黑树插入结点规律：</h2><p>根结点是黑色的，不用进行调整<br>父节点是红色：</p>
<ol>
<li>叔叔的空的，旋转 + 变色(祖父结点和父节点变色)</li>
<li>叔叔的红色，父节点+叔叔节点变黑色，祖父结点变红色</li>
<li>叔叔是黑色，旋转+变色</li>
</ol>
<h2 id="红黑树主要特性"><a href="#红黑树主要特性" class="headerlink" title="红黑树主要特性"></a>红黑树主要特性</h2><ol>
<li>每个节点要么是黑色，要么是红色。（节点非黑即红）</li>
<li>根节点是黑色。</li>
<li>每个叶子节点（<code>NIL</code>）是黑色。 </li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。（也就是说父子节点不能同时为红色）</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（这一点是平衡的关键）</li>
</ol>
<h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            x.red = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123; <span class="comment">// 要插入的结点无父节点，因此设置为黑色</span></span><br><span class="line">                    x.red = <span class="keyword">false</span>; <span class="comment">// 新结点设置为黑色</span></span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)  <span class="comment">// 情况0：父节点是黑色的，或者无祖父结点，直接返回根节点</span></span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;   <span class="comment">// 如果父节点是祖父结点的左结点</span></span><br><span class="line">                    <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123; <span class="comment">// 情况2：叔叔结点不为空且是红色</span></span><br><span class="line">                        xppr.red = <span class="keyword">false</span>;  <span class="comment">// 叔叔结点变黑</span></span><br><span class="line">                        xp.red = <span class="keyword">false</span>;  <span class="comment">// 父节点变黑</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;  <span class="comment">// 祖父节点变红</span></span><br><span class="line">                        x = xpp; <span class="comment">// 递归到祖父结点，直到满足红黑树条件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;  <span class="comment">// 情况1或3：没有叔叔结点或者叔叔结点是黑色的</span></span><br><span class="line">                        <span class="keyword">if</span> (x == xp.right) &#123;  <span class="comment">// 新结点作为右节点时</span></span><br><span class="line">                            root = rotateLeft(root, x = xp);  <span class="comment">// 先左旋后，新节点变为父节点xp </span></span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent; <span class="comment">// </span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;  <span class="comment">// 新结点作为左节点时</span></span><br><span class="line">                            xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点变为黑色</span></span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateRight(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                        xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                            root = rotateRight(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>Java7</code> 中使用 <code>Entry</code> 来代表每个 <code>HashMap</code> 中的数据节点，<code>Java8</code> 中使用 <code>Node</code>，基本没有区别，都是 <code>key，value，hash</code> 和 <code>next</code> 这四个属性，不过，<code>Node</code> 只能用于链表的情况，红黑树的情况需要使用 <code>TreeNode。</code><br>我们根据数组元素中，第一个节点数据类型是 <code>Node</code> 还是 <code>TreeNode</code> 来判断该位置下是链表还是红黑树的。</p>
<h3 id="Put方法：和-Java7-稍微有点不一样的地方就是，Java7-是先扩容后插入新值的，Java8-先插值再扩容"><a href="#Put方法：和-Java7-稍微有点不一样的地方就是，Java7-是先扩容后插入新值的，Java8-先插值再扩容" class="headerlink" title="Put方法：和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容"></a><code>Put</code>方法：和 <code>Java7</code> 稍微有点不一样的地方就是，<code>Java7</code> 是先扩容后插入新值的，<code>Java8</code> 先插值再扩容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span></span><br><span class="line"><span class="comment">// 第四个参数 evict 我们这里不关心</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span></span><br><span class="line">    <span class="comment">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 数组该位置有数据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明数组该位置上是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);   <span class="comment">// 1.8改用尾插法插入链表的尾部</span></span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个，此时binCount= 8</span></span><br><span class="line">                    <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">// 树化：链表转为红黑树</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;</span></span><br><span class="line">        <span class="comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount; <span class="comment">// 每次修改+1，是一种fast-fail快速失败机制，是一种容错机制，会抛ConcurrentModification</span></span><br><span class="line">    <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)     <span class="comment">// 小于当前结点，则往左边插入</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)  <span class="comment">//大于当前结点，则往右边插入</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组扩容：resize-方法用于初始化数组或数组扩容，每次扩容后，容量为原来的-2-倍，并进行数据迁移。"><a href="#数组扩容：resize-方法用于初始化数组或数组扩容，每次扩容后，容量为原来的-2-倍，并进行数据迁移。" class="headerlink" title="数组扩容：resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。"></a>数组扩容：<code>resize()</code> 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 <code>2</code> 倍，并进行数据迁移。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 对应数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组大小扩大一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 将阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用新的数组大小初始化新的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始遍历原数组，进行数据迁移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是红黑树，具体我们就不展开了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 这块是处理链表的情况，</span></span><br><span class="line">                    <span class="comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                    <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第一条链表</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get分析过程"><a href="#get分析过程" class="headerlink" title="get分析过程"></a><code>get</code>分析过程</h3><ul>
<li>计算 <code>key</code> 的 <code>hash</code> 值，根据 <code>hash</code> 值找到对应数组下标: <code>hash &amp; (length-1)</code>.</li>
</ul>
<ul>
<li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步.</li>
</ul>
<ul>
<li>判断该元素类型是否是 <code>TreeNode</code>，如果是，用红黑树的方法取数据，如果不是，走第四步.</li>
</ul>
<ul>
<li>遍历链表，直到找到相等(<code>==</code>或<code>equals</code>)的 <code>key</code>.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是不是就是需要的</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 链表遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树退化为链表"><a href="#红黑树退化为链表" class="headerlink" title="红黑树退化为链表"></a>红黑树退化为链表</h3><ul>
<li><p><code>resize</code>的时候，对红黑树进行了拆分</p>
</li>
<li><p><code>resize</code>的时候，判断节点类型，如果是链表，则将链表拆分，如果是<code>TreeNode</code>，则执行<code>TreeNode</code>的<code>split</code>方法分割红黑树，而<code>split</code>方法中将红黑树转换为链表的分支如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在这之前的逻辑是将红黑树每个节点的hash和一个bit进行&amp;运算，</span></span><br><span class="line"><span class="comment">//根据运算结果将树划分为两棵红黑树，lc表示其中一棵树的节点数</span></span><br><span class="line"><span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">    tab[index] = loHead.untreeify(map);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    tab[index] = loHead;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">        loHead.treeify(tab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里才用到了 <code>UNTREEIFY_THRESHOLD</code> 的判断，当红黑树节点元素小于等于<code>6</code>时，才调用<code>untreeify</code>方法转换回链表</p>
<h2 id="jdk8-concurentHashMap"><a href="#jdk8-concurentHashMap" class="headerlink" title="jdk8 concurentHashMap"></a><code>jdk8 concurentHashMap</code></h2><p><strong><code>ConcurrentHashMap</code>取消了<code>segment</code>分段锁，而采用<code>CAS+synchronized</code>来保证并发安全，整个看起来就像是优化过且线程安全的<code>HashMap</code>。数据结构跟<code>HashMap1.8</code>的结构一样，<code>Node</code>数组+链表+红黑树。 <code>synchronized</code>只锁定当前链表或红黑二叉树的首节点，这样只要<code>hash</code>不冲突，就不会产生并发，效率又提升<code>N</code>倍。桶中的结构可能是链表，也可能是红黑树，红黑树是为了提高查找效率。</strong></p>
<p>容器里保存的所有<code>BeanFactory</code>创建的单例<code>bean</code> 都放在一个 <code>ConcurrentHashMap</code> 中</p>
<p><code>TreeBin</code>：红黑树节点 <code>Node</code>：链表节点</p>
<img data-src="/blog/posts/52d9f7d3/2022-02-21-17-49-35.png" class="">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// node数组最大容量：2^30=1073741824  </span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  MAXIMUM_CAPACITY =  <span class="number">1</span>  &lt;&lt;  <span class="number">30</span>    ;  </span><br><span class="line">  <span class="comment">// 默认初始值，必须是2的幂数  </span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  DEFAULT_CAPACITY =  <span class="number">16</span>    ;  </span><br><span class="line">  <span class="comment">//数组可能最大值，需要与toArray（）相关方法关联  </span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  MAX_ARRAY_SIZE = Integer.MAX_VALUE -  <span class="number">8</span>    ;  </span><br><span class="line">  <span class="comment">//并发级别，遗留下来的，为兼容以前的版本  </span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  DEFAULT_CONCURRENCY_LEVEL =  <span class="number">16</span>    ;  </span><br><span class="line">  <span class="comment">// 负载因子  </span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">float</span>  LOAD_FACTOR =  <span class="number">0</span>    <span class="number">.75f</span>;  </span><br><span class="line">  <span class="comment">// 链表转红黑树阀值,&gt; 8 链表转换为红黑树  </span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  TREEIFY_THRESHOLD =  <span class="number">8</span>    ;  </span><br><span class="line">  <span class="comment">//树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）  </span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  UNTREEIFY_THRESHOLD =  <span class="number">6</span>    ;  </span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  MIN_TREEIFY_CAPACITY =  <span class="number">64</span>    ;  </span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  MIN_TRANSFER_STRIDE =  <span class="number">16</span>    ;  </span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">int</span>  RESIZE_STAMP_BITS =  <span class="number">16</span>    ;  </span><br><span class="line">  <span class="comment">// 2^15-1，help resize的最大线程数  </span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  MAX_RESIZERS = (    <span class="number">1</span>  &lt;&lt; (    <span class="number">32</span>  - RESIZE_STAMP_BITS)) -  <span class="number">1</span>    ;  </span><br><span class="line">  <span class="comment">// 32-16=16，sizeCtl中记录size大小的偏移量  </span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  RESIZE_STAMP_SHIFT =  <span class="number">32</span>  - RESIZE_STAMP_BITS;  </span><br><span class="line">  <span class="comment">// forwarding nodes的hash值  </span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  MOVED     = -    <span class="number">1</span>    ;  </span><br><span class="line">  <span class="comment">// 树根节点的hash值  </span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  TREEBIN   = -    <span class="number">2</span>    ;  </span><br><span class="line">  <span class="comment">// ReservationNode的hash值  </span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  RESERVED  = -    <span class="number">3</span>    ;  </span><br><span class="line">  <span class="comment">// 可用处理器数量  </span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  NCPU = Runtime.getRuntime().availableProcessors();  </span><br><span class="line">  <span class="comment">//存放node的数组  </span></span><br><span class="line">  <span class="keyword">transient</span>  <span class="keyword">volatile</span>  Node&lt;K,V&gt;[] table;  </span><br><span class="line">  <span class="comment">/*控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义  </span></span><br><span class="line"><span class="comment">  *当为负数时：-    1    代表正在初始化，-N代表有N-    1    个线程正在 进行扩容  </span></span><br><span class="line"><span class="comment">  *当为    0    时：代表当时的table还没有被初始化  </span></span><br><span class="line"><span class="comment">  *当为正数时：表示初始化或者下一次进行扩容的大小  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">transient</span>  <span class="keyword">volatile</span>  <span class="keyword">int</span>  sizeCtl;  </span><br></pre></td></tr></table></figure>
<h3 id="HashMap没有的属性"><a href="#HashMap没有的属性" class="headerlink" title="HashMap没有的属性"></a><code>HashMap</code>没有的属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     hash表初始化或扩容时的一个控制位标识量。</span></span><br><span class="line"><span class="comment">     负数代表正在进行初始化或扩容操作</span></span><br><span class="line"><span class="comment">     -1代表正在初始化</span></span><br><span class="line"><span class="comment">     -N 表示有N-1个线程正在进行扩容操作</span></span><br><span class="line"><span class="comment">     正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl; </span><br><span class="line">    <span class="comment">// 以下两个是用来控制扩容的时候 单线程进入的变量</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of bits used for generation stamp in sizeCtl.</span></span><br><span class="line"><span class="comment">     * Must be at least 6 for 32bit arrays.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bit shift for recording size stamp in sizeCtl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Encodings for Node hash fields. See above for explanation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash值是-1，表示这是一个forwardNode节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash值是-2  表示这时一个TreeBin节点</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Nod</code><br><code>Node</code>是<code>ConcurrentHashMap</code>存储结构的基本单元，继承于<code>HashMap</code>中的<code>Entry</code>，用于存储数据。就是一个链表，但是只允许对数据进行查找，不允许进行修改<br><code>TreeNode</code><br><code>TreeNode</code>继承于<code>Node</code>，但是数据结构换成了二叉树结构，它是红黑树的数据的存储结构，用于红黑树中存储数据，当链表的节点数大于8时会转换成红黑树的结构，他就是通过<code>TreeNode</code>作为存储结构代替<code>Node</code>来转换成黑红树源代码如下<br><code>TreeBin</code><br><code>TreeBin</code>从字面含义中可以理解为存储树形结构的容器，而树形结构就是指<code>TreeNode</code>，所以<code>TreeBin</code>就是封装<code>TreeNode</code>的容器，它提供转换黑红树的一些条件和锁的控制，部分源码结构如下</p>
</blockquote>
<h3 id="利用CAS和Synchronized进行高效的同步更新数据。"><a href="#利用CAS和Synchronized进行高效的同步更新数据。" class="headerlink" title="利用CAS和Synchronized进行高效的同步更新数据。"></a>利用<code>CAS</code>和<code>Synchronized</code>进行高效的同步更新数据。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ConcurrentHashMap 不允许插入null键，HashMap允许插入一个null键</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//for循环的作用：因为更新元素是使用CAS机制更新，需要不断的失败重试，直到成功为止。</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f：链表或红黑二叉树头结点，向链表中添加元素时，需要synchronized获取f的锁。</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//判断Node[]数组是否初始化，没有则进行初始化操作</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//通过hash定位Node[]数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头结点），添加失败则进入下次循环。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查到内部正在移动元素（Node[] 数组扩容）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//帮助它扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//锁住链表或红黑二叉树的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//判断f是否是链表的头结点</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//如果fh&gt;=0 是链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历链表所有节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//如果节点存在，则更新value</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//不存在则在链表尾部添加新节点。</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//TreeBin是红黑二叉树节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//添加树节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                      value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果链表长度已经达到临界值8 就需要把链表转换为树结构</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前ConcurrentHashMap的size数量+1</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>判断<code>Node[]</code>数组是否初始化，没有则进行初始化操作</li>
</ul>
<ul>
<li>通过<code>hash</code>定位<code>Node[]</code>数组的索引坐标，是否有<code>Node</code>节点，如果没有则使用<code>CAS</code>进行添加（链表的头结点），添加失败则进入下次循环。</li>
</ul>
<ul>
<li>检查到内部正在扩容，如果正在扩容，就帮助它一块扩容。</li>
</ul>
<ul>
<li>如果<code>f!=null</code>，则使用<code>synchronized</code>锁住<code>f</code>元素（链表/红黑二叉树的头元素）</li>
<li>如果是<code>Node</code>(链表结构)则执行链表的添加操作。</li>
<li>如果是<code>TreeNode</code>(树型结果)则执行树添加操作。</li>
</ul>
<ul>
<li>判断链表长度已经达到临界值<code>8</code> 就需要把链表转换为树结构。</li>
</ul>
<p><code>JDK8</code>中的<code>concurrentHashMap</code> 实现是锁分离的思想，它把锁分的比<code>segment（JDK1.7）</code>更细一些，只要<code>hash</code>不冲突，就不会出现并发获得锁的情况。它首先使用无锁操作<code>CAS</code>插入头结点，如果插入失败，说明已经有别的线程插入头结点了，再次循环进行操作。如果头结点已经存在，则通过<code>synchronized</code>获得头结点锁，进行后续的操作。性能比<code>segment</code>分段锁又再次提升。</p>
<h3 id="Synchronized在1-6之后锁升级的过程"><a href="#Synchronized在1-6之后锁升级的过程" class="headerlink" title="Synchronized在1.6之后锁升级的过程"></a><code>Synchronized</code>在<code>1.6</code>之后锁升级的过程</h3><p>一个对象一开始是无锁的状态，或者说是可偏向状态，会先去判断下，再进行升级过程。锁是支持偏向锁的，当付钱获取到锁的这个线程，会优先让它再去获取到这个锁，如果没有获取到这个锁，就升级成一个轻量级的<code>CAS</code>锁，即乐观锁，乐观锁是比较有交S换的过程；如果<code>CAS</code>没有设置成功就会进行一个自旋，自旋到一定次数才会升级成一个<code>Synchronized</code>这个重量级锁，保证了性能问题</p>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><ul>
<li><p>为什么<code>HashMap</code>使用红黑树而不使用<code>AVL</code>树</p>
</li>
<li><p><code>CurrentHashMap</code>中加读写锁，实际上是读写锁，如果写冲突就会等待，如果插入时间过长必然等待时间更长，而红黑树相对<code>AVL</code>树他的插入更快！</p>
</li>
</ul>
<ul>
<li>插入和删除方面，<code>AVL</code>树速度较慢：需要更高的旋转次数才能在修改时正确地重新平衡数据结构。</li>
</ul>
<ul>
<li>两个都给<code>O（log n）</code>查找，但平衡AVL树可能需要<code>O（log n）</code>旋转，而红黑树将需要最多两次旋转使其达到平衡</li>
</ul>
<ul>
<li><code>AVL</code>树的旋转比红黑树的旋转更加难以平衡和调试。</li>
</ul>
]]></content>
      <categories>
        <category>Java面试</category>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot javax操作邮箱</title>
    <url>/blog/posts/dfc32b58/</url>
    <content><![CDATA[<h1 id="SpringBoot-javax获取邮件内容，删除邮件、根据时间段筛选邮件，筛选时间段-未读邮件"><a href="#SpringBoot-javax获取邮件内容，删除邮件、根据时间段筛选邮件，筛选时间段-未读邮件" class="headerlink" title="SpringBoot javax获取邮件内容，删除邮件、根据时间段筛选邮件，筛选时间段+未读邮件"></a><code>SpringBoot javax</code>获取邮件内容，删除邮件、根据时间段筛选邮件，筛选时间段+未读邮件</h1><p>首先需要导入依赖,由于使用的是<code>Gradle</code>,其实本质也和<code>maven</code>差不多</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="keyword">group</span>: <span class="string">&#x27;org.apache.commons&#x27;</span>, name: <span class="string">&#x27;commons-lang3&#x27;</span>, version: <span class="string">&#x27;3.11&#x27;</span></span><br><span class="line"><span class="comment">//邮件</span></span><br><span class="line">implementation <span class="keyword">group</span>: <span class="string">&#x27;javax.mail&#x27;</span>, name: <span class="string">&#x27;javax.mail-api&#x27;</span>, version: <span class="string">&#x27;1.5.5&#x27;</span></span><br><span class="line">implementation <span class="keyword">group</span>: <span class="string">&#x27;com.sun.mail&#x27;</span>, name: <span class="string">&#x27;javax.mail&#x27;</span>, version: <span class="string">&#x27;1.5.5&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2hlbnlhbmJpbi9wLzE0NjMxOTA1Lmh0bWw=">原文链接</span></h2><p>将分为两个方案 <code>pop3</code>和<code>imap</code>:</p>
<blockquote>
<p>pop3与imap区别#</p>
</blockquote>
<ol>
<li><p><code>pop3</code>允许电子邮件客户端请求下载指定邮件服务器上指定用户的邮件信息，但是在用户的客户端所做的任何操作都是不会反馈到服务器上的，也就是说，你已读了邮件在邮件服务器上的状态还是未读取的，这在很多情况下对用户来说是不方便的。这是因为pop3协议是单向协议</p>
</li>
<li><p><code>IAMP</code>协议，双向协议，用户在客户端的操作可以实时的反馈到服务器上，用户对邮件的任何操作，服务器也会做出相应的操作。</p>
<ul>
<li>同时：<code>IMAP</code>还可以指定下载邮件的某些内容。</li>
<li>所以<code>POP3</code>协议无法获取邮件状态(已读或未读)</li>
<li><code>IMAP</code>协议不支持 中文主题 或 中文内容 邮件过滤,而<code>POP3</code>完全支持</li>
</ul>
</li>
</ol>
<p><strong>同时,<code>Imap</code>关于时间筛选只能精确到日,也就是说只能默认搜索当天的所有邮件,因此,在<code>Imap</code>的协议下,想要锁定时间搜索只能另寻僻静了</strong></p>
<h2 id="筛选条件"><a href="#筛选条件" class="headerlink" title="筛选条件#"></a>筛选条件#</h2><p>　　<code>JavaMail</code>在<code>javax.mail.search</code>包中定义了一个用于创建搜索条件的<code>SearchTerm</code>类，应用程序创建<code>SearchTerm</code>类的实例对象后，就可以调用<code>Folder.Search(SearchTerm st)</code>方法搜索邮件夹中符合搜索条件的所有邮件。<code>SearchTerm</code>是一个抽象类，<code>JavaMail</code>提供了<code>22</code>个实现子类以帮助应用程序创建不同的搜索条件，这<code>22</code>个类可分为两大类型，如下所示：</p>
<ol>
<li><p>用于创建逻辑组合关系的类</p>
<ul>
<li><code>AND</code>条件（<code>AndTerm</code>类）</li>
<li> <code>OR</code>条件（<code>OrTerm</code>类）</li>
<li> <code>NOT</code>条件（<code>NotTerm</code>类）</li>
<li> <code>Comparison</code>条件（<code>ComparisonTerm</code>类）</li>
</ul>
</li>
<li><p>用于创建具体搜索条件的类</p>
<ul>
<li> <code>DATE</code>条件（<code>SentDateTerm、ReceivedDateTerm类</code>）</li>
<li> <code>CONTENT</code>条件（<code>BodyTerm</code>类）</li>
<li> <code>HEADER</code>条件（<code>FromStringTerm、RecipientStringTerm、SubjectTerm</code>类等）<br>下面通过实现来说明以上类的用法及含义：</li>
</ul>
</li>
</ol>
<ul>
<li>搜索发件人为“智联招聘“，而且邮件正文包含<code>“Java工程师“</code>的所有邮件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SearchTerm andTerm = <span class="keyword">new</span> AndTerm( <span class="keyword">new</span> FromStringTerm(<span class="string">&quot;智联招聘&quot;</span>), <span class="keyword">new</span> BodyTerm(<span class="string">&quot;java工程师&quot;</span>));</span><br><span class="line">Message[] messages = folder.search(andTerm); </span><br></pre></td></tr></table></figure></li>
<li>搜索发件人为“智联招聘“或主题包含“最新职位信息“的所有邮件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SearchTerm orTerm = <span class="keyword">new</span> OrTerm( <span class="keyword">new</span> FromStringTerm(<span class="string">&quot;智联招聘&quot;</span>), <span class="keyword">new</span> SubjectTerm(<span class="string">&quot;最新职位信息&quot;</span>));</span><br><span class="line"></span><br><span class="line">Message[] messages = folder.search(orTerm); </span><br></pre></td></tr></table></figure></li>
<li>搜索周一到今天收到的的所有邮件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();  </span><br><span class="line">calendar.set(Calendar.DAY_OF_WEEK, calendar.get(Calendar.DAY_OF_WEEK - (Calendar.DAY_OF_WEEK - <span class="number">1</span>)) - <span class="number">1</span>); </span><br><span class="line">Date mondayDate = calendar.getTime(); </span><br><span class="line">SearchTerm comparisonTermGe = <span class="keyword">new</span> SentDateTerm(ComparisonTerm.GE, mondayDate); </span><br><span class="line">SearchTerm comparisonTermLe = <span class="keyword">new</span> SentDateTerm(ComparisonTerm.LE, <span class="keyword">new</span> Date()); </span><br><span class="line">SearchTerm comparisonAndTerm = <span class="keyword">new</span> AndTerm(comparisonTermGe, comparisonTermLe); </span><br><span class="line">Message[] messages = folder.search(comparisonAndTerm); </span><br></pre></td></tr></table></figure></li>
<li>搜索大于或等<code>100KB</code>的所有邮件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mailSize = <span class="number">1024</span> * <span class="number">100</span>; SearchTerm intComparisonTerm = <span class="keyword">new</span> SizeTerm(IntegerComparisonTerm.GE, mailSize); </span><br><span class="line">Message[] messages = folder.search(intComparisonTerm); </span><br></pre></td></tr></table></figure>
<code>ComparisonTerm</code>类常用于日期和数字比较中，它使用六个常量<code>EQ（＝）、GE（&gt;=）、GT（&gt;）、LE（&lt;=）、LT（&lt;）、NE（!=）</code>来表示六种不同的比较操作。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果需要在取得邮件数后将邮件置为已读则这里需要使用READ_WRITE,否则READ_ONLY就可以</span></span><br><span class="line">    inbox.open(Folder.READ_WRITE); </span><br><span class="line">    <span class="comment">// Message messages[] = inbox.getMessages(); //获取所有邮件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立搜索条件FlagTerm，这里FlagTerm继承自SearchTerm，也就是说除了获取未读邮</span></span><br><span class="line">    <span class="comment">//件的条件还有很多其他条件同样继承了SearchTerm的条件类，像根据发件人，主题搜索等，</span></span><br><span class="line">    <span class="comment">// 还有复杂的逻辑搜索类似：</span></span><br><span class="line">    <span class="comment">//     </span></span><br><span class="line">    <span class="comment">//    SearchTerm orTerm = new OrTerm(   </span></span><br><span class="line">    <span class="comment">//            new FromStringTerm(from),   </span></span><br><span class="line">    <span class="comment">//            new SubjectTerm(subject)   </span></span><br><span class="line">    <span class="comment">//            ); </span></span><br><span class="line">    <span class="comment">//  </span></span><br><span class="line"></span><br><span class="line">    FlagTerm ft = <span class="keyword">new</span> FlagTerm(<span class="keyword">new</span> Flags(Flags.Flag.SEEN), <span class="keyword">false</span>); <span class="comment">//false代表未读，true代表已读</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Flag 类型列举如下</span></span><br><span class="line"><span class="comment">    * Flags.Flag.ANSWERED 邮件回复标记，标识邮件是否已回复。</span></span><br><span class="line"><span class="comment">    * Flags.Flag.DELETED 邮件删除标记，标识邮件是否需要删除。</span></span><br><span class="line"><span class="comment">    * Flags.Flag.DRAFT 草稿邮件标记，标识邮件是否为草稿。</span></span><br><span class="line"><span class="comment">    * Flags.Flag.FLAGGED 表示邮件是否为回收站中的邮件。</span></span><br><span class="line"><span class="comment">    * Flags.Flag.RECENT 新邮件标记，表示邮件是否为新邮件。</span></span><br><span class="line"><span class="comment">    * Flags.Flag.SEEN 邮件阅读标记，标识邮件是否已被阅读。</span></span><br><span class="line"><span class="comment">    * Flags.Flag.USER 底层系统是否支持用户自定义标记，只读。</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>
<h2 id="pop3"><a href="#pop3" class="headerlink" title="pop3"></a><code>pop3</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.InternetAddress;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMessage;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMultipart;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeUtility;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreMail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String USER = <span class="string">&quot;543210188@qq.com&quot;</span>; <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String PASSWORD = <span class="string">&quot;xxxxx&quot;</span>; <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String MAIL_SERVER_HOST = <span class="string">&quot;smtp.qq.com&quot;</span>; <span class="comment">// 邮箱服务器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个有具体连接信息的Properties对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.debug&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.store.protocol&quot;</span>, <span class="string">&quot;pop3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.pop3.host&quot;</span>, MAIL_SERVER_HOST);</span><br><span class="line">        <span class="comment">// 1、创建session</span></span><br><span class="line">        Session session = Session.getInstance(prop);</span><br><span class="line">        <span class="comment">// 2、通过session得到Store对象</span></span><br><span class="line">        Store store = session.getStore();</span><br><span class="line">        <span class="comment">// 3、连上邮件服务器</span></span><br><span class="line">        store.connect(MAIL_SERVER_HOST, USER, PASSWORD);</span><br><span class="line">        <span class="comment">// 4、获得邮箱内的邮件夹</span></span><br><span class="line">        Folder folder = store.getFolder(<span class="string">&quot;inbox&quot;</span>);</span><br><span class="line">        <span class="comment">//只读</span></span><br><span class="line">        <span class="comment">//folder.open(Folder.READ_ONLY);</span></span><br><span class="line">        <span class="comment">//读写</span></span><br><span class="line">        folder.open(Folder.READ_WRITE);</span><br><span class="line">        <span class="comment">// 获得邮件夹Folder内的所有邮件Message对象</span></span><br><span class="line">        Message[] messages = folder.getMessages();</span><br><span class="line">        <span class="comment">// 解析所有邮件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = messages.length; i &lt; count; i++) &#123;</span><br><span class="line">            MimeMessage msg = (MimeMessage) messages[i];</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------解析第&quot;</span> + msg.getMessageNumber() + <span class="string">&quot;封邮件-------------------- &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;主题: &quot;</span> + getSubject(msg));</span><br><span class="line">            System.out.println(<span class="string">&quot;发件人: &quot;</span> + getFrom(msg));</span><br><span class="line">            System.out.println(<span class="string">&quot;收件人：&quot;</span> + getReceiveAddress(msg, <span class="keyword">null</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;发送时间：&quot;</span> + getSentDate(msg, <span class="keyword">null</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;是否已读：&quot;</span> + isSeen(msg));</span><br><span class="line">            System.out.println(<span class="string">&quot;邮件优先级：&quot;</span> + getPriority(msg));</span><br><span class="line">            System.out.println(<span class="string">&quot;是否需要回执：&quot;</span> + isReplySign(msg));</span><br><span class="line">            System.out.println(<span class="string">&quot;邮件大小：&quot;</span> + msg.getSize() * <span class="number">1024</span> + <span class="string">&quot;kb&quot;</span>);</span><br><span class="line">            <span class="keyword">boolean</span> isContainerAttachment = isContainAttachment(msg);</span><br><span class="line">            System.out.println(<span class="string">&quot;是否包含附件：&quot;</span> + isContainerAttachment);</span><br><span class="line">            <span class="keyword">if</span> (isContainerAttachment) &#123;</span><br><span class="line">                saveAttachment(msg, <span class="string">&quot;f:\\mailTest\\&quot;</span>+msg.getSubject() + <span class="string">&quot;_&quot;</span>+i+<span class="string">&quot;_&quot;</span>); <span class="comment">//保存附件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//删除邮件</span></span><br><span class="line">                msg.setFlag(Flags.Flag.DELETED, <span class="keyword">true</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;删除&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuffer content = <span class="keyword">new</span> StringBuffer(<span class="number">30</span>);</span><br><span class="line">            getMailTextContent(msg, content);</span><br><span class="line">            System.out.println(<span class="string">&quot;邮件正文：&quot;</span> + content);</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------第&quot;</span> + msg.getMessageNumber() + <span class="string">&quot;封邮件解析结束-------------------- &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5、关闭</span></span><br><span class="line">        folder.close(<span class="keyword">true</span>);</span><br><span class="line">        store.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除邮件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messages 要解析的邮件列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteMessage</span><span class="params">(Message... messages)</span> <span class="keyword">throws</span> MessagingException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (messages == <span class="keyword">null</span> || messages.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MessagingException(<span class="string">&quot;未找到要解析的邮件!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析所有邮件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = messages.length; i &lt; count; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *   邮件删除</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Message message = messages[i];</span><br><span class="line">            String subject = message.getSubject();</span><br><span class="line">            <span class="comment">// set the DELETE flag to true</span></span><br><span class="line">            message.setFlag(Flags.Flag.DELETED, <span class="keyword">true</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Marked DELETE for message: &quot;</span> + subject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得邮件主题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 邮件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解码后的邮件主题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSubject</span><span class="params">(MimeMessage msg)</span> <span class="keyword">throws</span> UnsupportedEncodingException, MessagingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MimeUtility.decodeText(msg.getSubject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得邮件发件人</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 邮件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 姓名 &lt;Email地址&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFrom</span><span class="params">(MimeMessage msg)</span> <span class="keyword">throws</span> MessagingException, UnsupportedEncodingException </span>&#123;</span><br><span class="line">        String from = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Address[] froms = msg.getFrom();</span><br><span class="line">        <span class="keyword">if</span> (froms.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MessagingException(<span class="string">&quot;没有发件人!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        InternetAddress address = (InternetAddress) froms[<span class="number">0</span>];</span><br><span class="line">        String person = address.getPersonal();</span><br><span class="line">        <span class="keyword">if</span> (person != <span class="keyword">null</span>) &#123;</span><br><span class="line">            person = MimeUtility.decodeText(person) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            person = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        from = person + <span class="string">&quot;&lt;&quot;</span> + address.getAddress() + <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据收件人类型，获取邮件收件人、抄送和密送地址。如果收件人类型为空，则获得所有的收件人</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Message.RecipientType.TO  收件人&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Message.RecipientType.CC  抄送&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Message.RecipientType.BCC 密送&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg  邮件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 收件人类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 收件人1 &lt;邮件地址1&gt;, 收件人2 &lt;邮件地址2&gt;, ...</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getReceiveAddress</span><span class="params">(MimeMessage msg, Message.RecipientType type)</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        StringBuffer receiveAddress = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Address[] addresss = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            addresss = msg.getAllRecipients();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addresss = msg.getRecipients(type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (addresss == <span class="keyword">null</span> || addresss.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MessagingException(<span class="string">&quot;没有收件人!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Address address : addresss) &#123;</span><br><span class="line">            InternetAddress internetAddress = (InternetAddress) address;</span><br><span class="line">            receiveAddress.append(internetAddress.toUnicodeString()).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        receiveAddress.deleteCharAt(receiveAddress.length() - <span class="number">1</span>); <span class="comment">//删除最后一个逗号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> receiveAddress.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得邮件发送时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 邮件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> yyyy年mm月dd日 星期X HH:mm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSentDate</span><span class="params">(MimeMessage msg, String pattern)</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        Date receivedDate = msg.getSentDate();</span><br><span class="line">        <span class="keyword">if</span> (receivedDate == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(pattern))</span><br><span class="line">            pattern = <span class="string">&quot;yyyy年MM月dd日 E HH:mm &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(pattern).format(receivedDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断邮件中是否包含附件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 邮件中存在附件返回true，不存在返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContainAttachment</span><span class="params">(Part part)</span> <span class="keyword">throws</span> MessagingException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;multipart/*&quot;</span>)) &#123;</span><br><span class="line">            MimeMultipart multipart = (MimeMultipart) part.getContent();</span><br><span class="line">            <span class="keyword">int</span> partCount = multipart.getCount();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; partCount; i++) &#123;</span><br><span class="line">                BodyPart bodyPart = multipart.getBodyPart(i);</span><br><span class="line">                String disp = bodyPart.getDisposition();</span><br><span class="line">                <span class="keyword">if</span> (disp != <span class="keyword">null</span> &amp;&amp; (disp.equalsIgnoreCase(Part.ATTACHMENT) || disp.equalsIgnoreCase(Part.INLINE))) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyPart.isMimeType(<span class="string">&quot;multipart/*&quot;</span>)) &#123;</span><br><span class="line">                    flag = isContainAttachment(bodyPart);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String contentType = bodyPart.getContentType();</span><br><span class="line">                    <span class="keyword">if</span> (contentType.indexOf(<span class="string">&quot;application&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (contentType.indexOf(<span class="string">&quot;name&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;message/rfc822&quot;</span>)) &#123;</span><br><span class="line">            flag = isContainAttachment((Part) part.getContent());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断邮件是否已读</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 邮件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果邮件已读返回true, 否则返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSeen</span><span class="params">(MimeMessage msg)</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg.getFlags().contains(Flags.Flag.SEEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断邮件是否需要阅读回执</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 邮件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 需要回执返回true, 否则返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isReplySign</span><span class="params">(MimeMessage msg)</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> replySign = <span class="keyword">false</span>;</span><br><span class="line">        String[] headers = msg.getHeader(<span class="string">&quot;Disposition-Notification-To&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (headers != <span class="keyword">null</span>)</span><br><span class="line">            replySign = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> replySign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得邮件的优先级</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 邮件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 1(High):紧急  3:普通(Normal)  5:低(Low)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPriority</span><span class="params">(MimeMessage msg)</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        String priority = <span class="string">&quot;普通&quot;</span>;</span><br><span class="line">        String[] headers = msg.getHeader(<span class="string">&quot;X-Priority&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (headers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String headerPriority = headers[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (headerPriority.indexOf(<span class="string">&quot;1&quot;</span>) != -<span class="number">1</span> || headerPriority.indexOf(<span class="string">&quot;High&quot;</span>) != -<span class="number">1</span>)</span><br><span class="line">                priority = <span class="string">&quot;紧急&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (headerPriority.indexOf(<span class="string">&quot;5&quot;</span>) != -<span class="number">1</span> || headerPriority.indexOf(<span class="string">&quot;Low&quot;</span>) != -<span class="number">1</span>)</span><br><span class="line">                priority = <span class="string">&quot;低&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                priority = <span class="string">&quot;普通&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得邮件文本内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> part    邮件体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 存储邮件文本内容的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMailTextContent</span><span class="params">(Part part, StringBuffer content)</span> <span class="keyword">throws</span> MessagingException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//如果是文本类型的附件，通过getContent方法可以取到文本内容，但这不是我们需要的结果，所以在这里要做判断</span></span><br><span class="line">        <span class="keyword">boolean</span> isContainTextAttach = part.getContentType().indexOf(<span class="string">&quot;name&quot;</span>) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;text/*&quot;</span>) &amp;&amp; !isContainTextAttach) &#123;</span><br><span class="line">            content.append(part.getContent().toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;message/rfc822&quot;</span>)) &#123;</span><br><span class="line">            getMailTextContent((Part) part.getContent(), content);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;multipart/*&quot;</span>)) &#123;</span><br><span class="line">            Multipart multipart = (Multipart) part.getContent();</span><br><span class="line">            <span class="keyword">int</span> partCount = multipart.getCount();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; partCount; i++) &#123;</span><br><span class="line">                BodyPart bodyPart = multipart.getBodyPart(i);</span><br><span class="line">                getMailTextContent(bodyPart, content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存附件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> part    邮件中多个组合体中的其中一个组合体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destDir 附件保存目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveAttachment</span><span class="params">(Part part, String destDir)</span> <span class="keyword">throws</span> UnsupportedEncodingException, MessagingException,</span></span><br><span class="line"><span class="function">            FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;multipart/*&quot;</span>)) &#123;</span><br><span class="line">            Multipart multipart = (Multipart) part.getContent();    <span class="comment">//复杂体邮件</span></span><br><span class="line">            <span class="comment">//复杂体邮件包含多个邮件体</span></span><br><span class="line">            <span class="keyword">int</span> partCount = multipart.getCount();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; partCount; i++) &#123;</span><br><span class="line">                <span class="comment">//获得复杂体邮件中其中一个邮件体</span></span><br><span class="line">                BodyPart bodyPart = multipart.getBodyPart(i);</span><br><span class="line">                <span class="comment">//某一个邮件体也有可能是由多个邮件体组成的复杂体</span></span><br><span class="line">                String disp = bodyPart.getDisposition();</span><br><span class="line">                <span class="keyword">if</span> (disp != <span class="keyword">null</span> &amp;&amp; (disp.equalsIgnoreCase(Part.ATTACHMENT) || disp.equalsIgnoreCase(Part.INLINE))) &#123;</span><br><span class="line">                    InputStream is = bodyPart.getInputStream();</span><br><span class="line">                    saveFile(is, destDir, decodeText(bodyPart.getFileName()));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyPart.isMimeType(<span class="string">&quot;multipart/*&quot;</span>)) &#123;</span><br><span class="line">                    saveAttachment(bodyPart, destDir);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String contentType = bodyPart.getContentType();</span><br><span class="line">                    <span class="keyword">if</span> (contentType.indexOf(<span class="string">&quot;name&quot;</span>) != -<span class="number">1</span> || contentType.indexOf(<span class="string">&quot;application&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        saveFile(bodyPart.getInputStream(), destDir, decodeText(bodyPart.getFileName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;message/rfc822&quot;</span>)) &#123;</span><br><span class="line">            saveAttachment((Part) part.getContent(), destDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取输入流中的数据保存至指定目录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is       输入流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destDir  文件存储目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveFile</span><span class="params">(InputStream is, String destDir, String fileName)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(destDir + fileName)));</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(len);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文本解码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encodeText 解码MimeUtility.encodeText(String text)方法编码后的文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解码后的文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decodeText</span><span class="params">(String encodeText)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (encodeText == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(encodeText)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MimeUtility.decodeText(encodeText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="根据时间筛选-目前看来只支持POP3"><a href="#根据时间筛选-目前看来只支持POP3" class="headerlink" title="根据时间筛选 (目前看来只支持POP3)"></a>根据时间筛选 (目前看来只支持<code>POP3</code>)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTerm dateTerm = <span class="keyword">new</span> DateTerm(<span class="number">3</span>, <span class="keyword">new</span> Date(<span class="number">1617869155000L</span>)) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Date receivedDate = msg.getReceivedDate();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.date.before(msg.getSentDate());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Message[] messages = folder.search(dateTerm);</span><br></pre></td></tr></table></figure>
<p><code>new DateTerm</code>第一个参数，对应关系如下</p>
<img data-src="/blog/posts/dfc32b58/2022-08-16-21-46-14.png" class="">

<h2 id="imap"><a href="#imap" class="headerlink" title="imap"></a><code>imap</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.InternetAddress;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMessage;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMultipart;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeUtility;</span><br><span class="line"><span class="keyword">import</span> javax.mail.search.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreMail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String USER = <span class="string">&quot;543210188@qq.com&quot;</span>; <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String PASSWORD = <span class="string">&quot;xxxxx&quot;</span>; <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String MAIL_SERVER_HOST = <span class="string">&quot;smtp.qq.com&quot;</span>; <span class="comment">// 邮箱服务器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个有具体连接信息的Properties对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.debug&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.store.protocol&quot;</span>, <span class="string">&quot;imap&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.pop3.host&quot;</span>, MAIL_SERVER_HOST);</span><br><span class="line">        <span class="comment">// 1、创建session</span></span><br><span class="line">        Session session = Session.getInstance(prop);</span><br><span class="line">        <span class="comment">// 2、通过session得到Store对象</span></span><br><span class="line">        Store store = session.getStore();</span><br><span class="line">        <span class="comment">// 3、连上邮件服务器</span></span><br><span class="line">        store.connect(MAIL_SERVER_HOST, USER, PASSWORD);</span><br><span class="line">        <span class="comment">// 4、获得邮箱内的邮件夹</span></span><br><span class="line">        Folder folder = store.getFolder(<span class="string">&quot;inbox&quot;</span>);</span><br><span class="line">        <span class="comment">//只读</span></span><br><span class="line">        <span class="comment">//folder.open(Folder.READ_ONLY);</span></span><br><span class="line">        <span class="comment">//读写</span></span><br><span class="line">        folder.open(Folder.READ_WRITE);</span><br><span class="line">        <span class="comment">// 获得邮件夹Folder内的所有邮件Message对象</span></span><br><span class="line">        <span class="comment">//1617869155000  =====&gt; 2021-04-08 16:05:55</span></span><br><span class="line">        DateTerm dateTerm = <span class="keyword">new</span> DateTerm(<span class="number">3</span>, <span class="keyword">new</span> Date(<span class="number">1617869155000L</span>)) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.date.before(msg.getSentDate());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// FlagTerm ft = new FlagTerm(new Flags(Flags.Flag.SEEN), false); //false代表未读，true代表已读</span></span><br><span class="line">        FlagTerm flagTerm = <span class="keyword">new</span> FlagTerm(<span class="keyword">new</span> Flags(Flags.Flag.SEEN), <span class="keyword">false</span>);</span><br><span class="line">        AndTerm andTerm = <span class="keyword">new</span> AndTerm(dateTerm, flagTerm);</span><br><span class="line">        <span class="comment">//根据条件过滤</span></span><br><span class="line">        Message[] messages = folder.search(andTerm);</span><br><span class="line">        <span class="comment">//Message[] messages = folder.getMessages();</span></span><br><span class="line">        <span class="comment">// 解析所有邮件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = messages.length; i &lt; count; i++) &#123;</span><br><span class="line">            MimeMessage msg = (MimeMessage) messages[i];</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------解析第&quot;</span> + msg.getMessageNumber() + <span class="string">&quot;封邮件-------------------- &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;主题: &quot;</span> + getSubject(msg));</span><br><span class="line">            System.out.println(<span class="string">&quot;发件人: &quot;</span> + getFrom(msg));</span><br><span class="line">            System.out.println(<span class="string">&quot;收件人：&quot;</span> + getReceiveAddress(msg, <span class="keyword">null</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;发送时间：&quot;</span> + getSentDate(msg, <span class="keyword">null</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;是否已读：&quot;</span> + isSeen(msg));</span><br><span class="line">            System.out.println(<span class="string">&quot;邮件优先级：&quot;</span> + getPriority(msg));</span><br><span class="line">            System.out.println(<span class="string">&quot;是否需要回执：&quot;</span> + isReplySign(msg));</span><br><span class="line">            System.out.println(<span class="string">&quot;邮件大小：&quot;</span> + msg.getSize() * <span class="number">1024</span> + <span class="string">&quot;kb&quot;</span>);</span><br><span class="line">            <span class="keyword">boolean</span> isContainerAttachment = isContainAttachment(msg);</span><br><span class="line">            System.out.println(<span class="string">&quot;是否包含附件：&quot;</span> + isContainerAttachment);</span><br><span class="line">            <span class="comment">//设置当前邮件状态为已读</span></span><br><span class="line">            msg.setFlag(Flags.Flag.SEEN, <span class="keyword">true</span>);</span><br><span class="line">            StringBuffer content = <span class="keyword">new</span> StringBuffer(<span class="number">30</span>);</span><br><span class="line">            getMailTextContent(msg, content);</span><br><span class="line">            System.out.println(<span class="string">&quot;邮件正文：&quot;</span> + content);</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------第&quot;</span> + msg.getMessageNumber() + <span class="string">&quot;封邮件解析结束-------------------- &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5、关闭</span></span><br><span class="line">        folder.close(<span class="keyword">true</span>);</span><br><span class="line">        store.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除邮件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messages 要解析的邮件列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteMessage</span><span class="params">(Message... messages)</span> <span class="keyword">throws</span> MessagingException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (messages == <span class="keyword">null</span> || messages.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MessagingException(<span class="string">&quot;未找到要解析的邮件!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析所有邮件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = messages.length; i &lt; count; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *   邮件删除</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Message message = messages[i];</span><br><span class="line">            String subject = message.getSubject();</span><br><span class="line">            <span class="comment">// set the DELETE flag to true</span></span><br><span class="line">            message.setFlag(Flags.Flag.DELETED, <span class="keyword">true</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Marked DELETE for message: &quot;</span> + subject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得邮件主题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 邮件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解码后的邮件主题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSubject</span><span class="params">(MimeMessage msg)</span> <span class="keyword">throws</span> UnsupportedEncodingException, MessagingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MimeUtility.decodeText(msg.getSubject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得邮件发件人</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 邮件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 姓名 &lt;Email地址&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFrom</span><span class="params">(MimeMessage msg)</span> <span class="keyword">throws</span> MessagingException, UnsupportedEncodingException </span>&#123;</span><br><span class="line">        String from = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Address[] froms = msg.getFrom();</span><br><span class="line">        <span class="keyword">if</span> (froms.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MessagingException(<span class="string">&quot;没有发件人!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        InternetAddress address = (InternetAddress) froms[<span class="number">0</span>];</span><br><span class="line">        String person = address.getPersonal();</span><br><span class="line">        <span class="keyword">if</span> (person != <span class="keyword">null</span>) &#123;</span><br><span class="line">            person = MimeUtility.decodeText(person) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            person = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        from = person + <span class="string">&quot;&lt;&quot;</span> + address.getAddress() + <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据收件人类型，获取邮件收件人、抄送和密送地址。如果收件人类型为空，则获得所有的收件人</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Message.RecipientType.TO  收件人&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Message.RecipientType.CC  抄送&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Message.RecipientType.BCC 密送&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg  邮件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 收件人类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 收件人1 &lt;邮件地址1&gt;, 收件人2 &lt;邮件地址2&gt;, ...</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getReceiveAddress</span><span class="params">(MimeMessage msg, Message.RecipientType type)</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        StringBuffer receiveAddress = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Address[] addresss = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            addresss = msg.getAllRecipients();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addresss = msg.getRecipients(type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (addresss == <span class="keyword">null</span> || addresss.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MessagingException(<span class="string">&quot;没有收件人!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Address address : addresss) &#123;</span><br><span class="line">            InternetAddress internetAddress = (InternetAddress) address;</span><br><span class="line">            receiveAddress.append(internetAddress.toUnicodeString()).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        receiveAddress.deleteCharAt(receiveAddress.length() - <span class="number">1</span>); <span class="comment">//删除最后一个逗号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> receiveAddress.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得邮件发送时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 邮件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> yyyy年mm月dd日 星期X HH:mm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSentDate</span><span class="params">(MimeMessage msg, String pattern)</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        Date receivedDate = msg.getSentDate();</span><br><span class="line">        <span class="keyword">if</span> (receivedDate == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(pattern))</span><br><span class="line">            pattern = <span class="string">&quot;yyyy年MM月dd日 E HH:mm &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(pattern).format(receivedDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断邮件中是否包含附件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 邮件中存在附件返回true，不存在返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContainAttachment</span><span class="params">(Part part)</span> <span class="keyword">throws</span> MessagingException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;multipart/*&quot;</span>)) &#123;</span><br><span class="line">            MimeMultipart multipart = (MimeMultipart) part.getContent();</span><br><span class="line">            <span class="keyword">int</span> partCount = multipart.getCount();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; partCount; i++) &#123;</span><br><span class="line">                BodyPart bodyPart = multipart.getBodyPart(i);</span><br><span class="line">                String disp = bodyPart.getDisposition();</span><br><span class="line">                <span class="keyword">if</span> (disp != <span class="keyword">null</span> &amp;&amp; (disp.equalsIgnoreCase(Part.ATTACHMENT) || disp.equalsIgnoreCase(Part.INLINE))) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyPart.isMimeType(<span class="string">&quot;multipart/*&quot;</span>)) &#123;</span><br><span class="line">                    flag = isContainAttachment(bodyPart);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String contentType = bodyPart.getContentType();</span><br><span class="line">                    <span class="keyword">if</span> (contentType.indexOf(<span class="string">&quot;application&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (contentType.indexOf(<span class="string">&quot;name&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;message/rfc822&quot;</span>)) &#123;</span><br><span class="line">            flag = isContainAttachment((Part) part.getContent());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断邮件是否已读</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 邮件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果邮件已读返回true, 否则返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSeen</span><span class="params">(MimeMessage msg)</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg.getFlags().contains(Flags.Flag.SEEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断邮件是否需要阅读回执</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 邮件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 需要回执返回true, 否则返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isReplySign</span><span class="params">(MimeMessage msg)</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> replySign = <span class="keyword">false</span>;</span><br><span class="line">        String[] headers = msg.getHeader(<span class="string">&quot;Disposition-Notification-To&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (headers != <span class="keyword">null</span>)</span><br><span class="line">            replySign = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> replySign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得邮件的优先级</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 邮件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 1(High):紧急  3:普通(Normal)  5:低(Low)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPriority</span><span class="params">(MimeMessage msg)</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        String priority = <span class="string">&quot;普通&quot;</span>;</span><br><span class="line">        String[] headers = msg.getHeader(<span class="string">&quot;X-Priority&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (headers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String headerPriority = headers[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (headerPriority.indexOf(<span class="string">&quot;1&quot;</span>) != -<span class="number">1</span> || headerPriority.indexOf(<span class="string">&quot;High&quot;</span>) != -<span class="number">1</span>)</span><br><span class="line">                priority = <span class="string">&quot;紧急&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (headerPriority.indexOf(<span class="string">&quot;5&quot;</span>) != -<span class="number">1</span> || headerPriority.indexOf(<span class="string">&quot;Low&quot;</span>) != -<span class="number">1</span>)</span><br><span class="line">                priority = <span class="string">&quot;低&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                priority = <span class="string">&quot;普通&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得邮件文本内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> part    邮件体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 存储邮件文本内容的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMailTextContent</span><span class="params">(Part part, StringBuffer content)</span> <span class="keyword">throws</span> MessagingException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//如果是文本类型的附件，通过getContent方法可以取到文本内容，但这不是我们需要的结果，所以在这里要做判断</span></span><br><span class="line">        <span class="keyword">boolean</span> isContainTextAttach = part.getContentType().indexOf(<span class="string">&quot;name&quot;</span>) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;text/*&quot;</span>) &amp;&amp; !isContainTextAttach) &#123;</span><br><span class="line">            content.append(part.getContent().toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;message/rfc822&quot;</span>)) &#123;</span><br><span class="line">            getMailTextContent((Part) part.getContent(), content);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;multipart/*&quot;</span>)) &#123;</span><br><span class="line">            Multipart multipart = (Multipart) part.getContent();</span><br><span class="line">            <span class="keyword">int</span> partCount = multipart.getCount();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; partCount; i++) &#123;</span><br><span class="line">                BodyPart bodyPart = multipart.getBodyPart(i);</span><br><span class="line">                getMailTextContent(bodyPart, content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存附件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> part    邮件中多个组合体中的其中一个组合体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destDir 附件保存目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveAttachment</span><span class="params">(Part part, String destDir)</span> <span class="keyword">throws</span> UnsupportedEncodingException, MessagingException,</span></span><br><span class="line"><span class="function">            FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;multipart/*&quot;</span>)) &#123;</span><br><span class="line">            Multipart multipart = (Multipart) part.getContent();    <span class="comment">//复杂体邮件</span></span><br><span class="line">            <span class="comment">//复杂体邮件包含多个邮件体</span></span><br><span class="line">            <span class="keyword">int</span> partCount = multipart.getCount();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; partCount; i++) &#123;</span><br><span class="line">                <span class="comment">//获得复杂体邮件中其中一个邮件体</span></span><br><span class="line">                BodyPart bodyPart = multipart.getBodyPart(i);</span><br><span class="line">                <span class="comment">//某一个邮件体也有可能是由多个邮件体组成的复杂体</span></span><br><span class="line">                String disp = bodyPart.getDisposition();</span><br><span class="line">                <span class="keyword">if</span> (disp != <span class="keyword">null</span> &amp;&amp; (disp.equalsIgnoreCase(Part.ATTACHMENT) || disp.equalsIgnoreCase(Part.INLINE))) &#123;</span><br><span class="line">                    InputStream is = bodyPart.getInputStream();</span><br><span class="line">                    saveFile(is, destDir, decodeText(bodyPart.getFileName()));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyPart.isMimeType(<span class="string">&quot;multipart/*&quot;</span>)) &#123;</span><br><span class="line">                    saveAttachment(bodyPart, destDir);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String contentType = bodyPart.getContentType();</span><br><span class="line">                    <span class="keyword">if</span> (contentType.indexOf(<span class="string">&quot;name&quot;</span>) != -<span class="number">1</span> || contentType.indexOf(<span class="string">&quot;application&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        saveFile(bodyPart.getInputStream(), destDir, decodeText(bodyPart.getFileName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;message/rfc822&quot;</span>)) &#123;</span><br><span class="line">            saveAttachment((Part) part.getContent(), destDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取输入流中的数据保存至指定目录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is       输入流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destDir  文件存储目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveFile</span><span class="params">(InputStream is, String destDir, String fileName)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(destDir + fileName)));</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(len);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文本解码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encodeText 解码MimeUtility.encodeText(String text)方法编码后的文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解码后的文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decodeText</span><span class="params">(String encodeText)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (encodeText == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(encodeText)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MimeUtility.decodeText(encodeText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Email</tag>
      </tags>
  </entry>
  <entry>
    <title>23设计模式(更新中)</title>
    <url>/blog/posts/79c6d028/</url>
    <content><![CDATA[<h1 id="设计模式模块"><a href="#设计模式模块" class="headerlink" title="设计模式模块"></a>设计模式模块</h1><blockquote>
<p>设计模式的目的</p>
</blockquote>
<p>编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)，具有更好</p>
<ol>
<li>代码重用性 (即：相同功能的代码，不用多次编写)</li>
<li>可读性 (即：编程规范性,  便于其他程序员的阅读和理解)</li>
<li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li>
<li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</li>
<li>使程序呈现高内聚，低耦合的特性分享金句：</li>
<li>设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计<code>（OOA/D）</code>的精要”</li>
<li><code>Scott Mayers</code> 在其巨著<code>《Effective C++》</code>就曾经说过：<code>C++</code>老手和 <code>C++</code>新手的区别就是前者手背上有很多伤疤</li>
</ol>
<span id="more"></span>

<h2 id="1-七大原则"><a href="#1-七大原则" class="headerlink" title="1. 七大原则"></a><text style="color:red">1. 七大原则</text></h2><ul>
<li><ol>
<li>单一职责原则</li>
</ol>
</li>
<li><ol start="2">
<li>接口隔离原则</li>
</ol>
</li>
<li><ol start="3">
<li>依赖倒转(倒置)原则</li>
</ol>
</li>
<li><ol start="4">
<li>里氏替换原则</li>
</ol>
</li>
<li><ol start="5">
<li>开闭原则</li>
</ol>
</li>
<li><ol start="6">
<li>迪米特法则</li>
</ol>
</li>
<li><ol start="7">
<li>合成复用原则</li>
</ol>
</li>
</ul>
<blockquote>
<p>单一职责原则</p>
</blockquote>
<pre><code>对类来说的，即一个类应该只负责一项职责。如类 ``A`` 负责两个不同职责：职责 ``1``，职责 ``2``。当职责 ``1`` 需求变更而改变 ``A`` 时，可能造成职责 ``2`` 执行错误，所以需要将类 ``A`` 的粒度分解为 ``A1，A2``
</code></pre>
<blockquote>
<p>接口隔离原则</p>
</blockquote>
<pre><code>1. 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上
</code></pre>
 <img data-src="/blog/posts/79c6d028/2021-11-21-17-25-28.png" class="">

<pre><code>3. 类 ``A`` 通过接口 ``Interface1`` 依赖类 ``B``，类 ``C`` 通过接口 ``Interface1`` 依赖类 ``D``，如果接口 ``Interface1`` 对于类 ``A`` 和类 ``C``
来说不是最小接口，那么类 ``B`` 和类 ``D`` 必须去实现他们不需要的方法。
4. 按隔离原则应当这样处理：
将接口 ``Interface1`` 拆分为独立的几个接口(这里我们拆分成 ``3`` 个接口)，类 ``A`` 和类 ``C`` 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则
</code></pre>
<blockquote>
<pre><code>依赖倒转原则
</code></pre>
</blockquote>
<p>依赖倒转原则(<code>Dependence Inversion Principle</code>)是指：</p>
<ol>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
<li>依赖倒转(倒置)的中心思想是面向接口编程</li>
<li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 <code>java</code> 中，抽象指的是接口或抽象类，细节就是具体的实现类</li>
<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li>
</ol>
<blockquote>
<p>里氏替换原则</p>
</blockquote>
<p><strong>继承性的思考和说明</strong></p>
<ol>
<li>   继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li>
<li>   继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低， 增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</li>
<li>   问题提出：在编程中，如何正确的使用继承? =&gt; 里氏替换原则</li>
</ol>
<p><strong>基本介绍</strong></p>
<ol>
<li>   里氏替换原则(<code>Liskov Substitution Principle</code>)在 <code>1988</code> 年，由麻省理工学院的以为姓里的女士提出的。</li>
<li>   如果对每个类型为 <code>T1</code> 的对象 <code>o1</code>，都有类型为 <code>T2</code> 的对象 <code>o2</code>，使得以 <code>T1</code> 定义的所有程序 <code>P</code> 在所有的对象 <code>o1</code> 都代换成 <code>o2</code> 时，程序 <code>P</code> 的行为没有发生变化，那么类型<code>T2</code> 是类型 <code>T1</code> 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</li>
<li>   在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法</li>
<li>   里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖 来解决问题。</li>
</ol>
<blockquote>
<p>开闭原则</p>
</blockquote>
<ol>
<li>   开闭原则（<code>Open Closed Principle</code>）是编程中最基础、最重要的设计原则</li>
<li>   一个软件实体如类，模块和函数应该对**扩展开放(对提供方)<strong>，对</strong>修改关闭(对使用方)**。用抽象构建框架，用实现扩展细节。</li>
<li>   当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li>
<li>   编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li>
</ol>
<blockquote>
<p>迪米特法则</p>
</blockquote>
<ol>
<li>   一个对象应该对其他对象保持最少的了解</li>
<li>   类与类关系越密切，耦合度越大</li>
<li>   迪米特法则(<code>Demeter Principle</code>)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 <code>public</code> 方法，不对外泄露任何信息</li>
<li>   迪米特法则还有个更简单的定义：只与直接的朋友通信</li>
<li>   直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</li>
</ol>
<blockquote>
<p>合成复用原则<code>（Composite Reuse Principle）</code></p>
</blockquote>
<pre><code>原则是尽量使用合成/聚合的方式，而不是使用继承
</code></pre>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-29-13.png" class="">

<blockquote>
<p>设计原则核心思想</p>
</blockquote>
<ol>
<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。</li>
<li>为了交互对象之间的松耦合设计而努力</li>
</ol>
<blockquote>
<p><code>UML</code>图示</p>
</blockquote>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-30-08.png" class="">

<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><text style="color:yellow">设计模式</text></h1><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. <text style="color:#03a5fc">单例模式</text></h2><h3 id="1-1-单例设计模式介绍"><a href="#1-1-单例设计模式介绍" class="headerlink" title="1.1 单例设计模式介绍"></a>1.1 单例设计模式介绍</h3><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例， 并且该类只提供一个取得其对象实例的方法(静态方法)。</p>
<p>比如 <code>Hibernate</code> 的 <code>SessionFactory</code>，它充当数据存储源的代理，并负责创建 <code>Session</code> 对象。<code>SessionFactory</code> 并不是轻量级的，一般情况下，一个项目通常只需要一个 <code>SessionFactory</code> 就够，这是就会使用到单例模式。</p>
<h3 id="1-2-单例设计模式八种方式"><a href="#1-2-单例设计模式八种方式" class="headerlink" title="1.2 单例设计模式八种方式"></a>1.2 单例设计模式<code>八</code>种方式</h3><p>单例模式有<code>八</code>种方式：</p>
<ol>
<li>   饿汉式(静态常量)—先创建好了</li>
<li>   饿汉式（静态代码块）</li>
<li>   懒汉式(线程不安全)</li>
<li>   懒汉式(线程安全，同步方法)</li>
<li>   懒汉式(线程安全，同步代码块)</li>
<li>   双重检查</li>
<li>   静态内部类</li>
<li>   枚举</li>
</ol>
<h3 id="1-2-1-饿汉式（静态常量）"><a href="#1-2-1-饿汉式（静态常量）" class="headerlink" title="1.2.1 饿汉式（静态常量）"></a>1.2.1 饿汉式（静态常量）</h3><p>饿汉式（静态常量）应用实例步骤如下：</p>
<ol>
<li>   构造器私有化 (防止 <code>new</code> )</li>
<li>   类的内部创建对象</li>
<li>   向外暴露一个静态的公共方法。<code>getInstance</code></li>
<li>   代码实现<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());<span class="comment">//instance.hashCode=13648335</span></span><br><span class="line">        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());<span class="comment">//instance2.hashCode=13648335</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式（静态变量）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造器私有化, 外部不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.本类内部创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>    优缺点说明：</p>
</blockquote>
<ol>
<li><p>   优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p>
</li>
<li><p>   缺点：在类装载的时候就完成实例化，没有达到 <code>Lazy Loading</code> 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费</p>
</li>
<li><p>   这种方式基于 <code>classloder</code> 机制避免了多线程的同步问题，不过，<code>instance</code> 在类装载时就实例化，在单例模式中大多数都是调用 <code>getInstance</code> 方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 <code>instance</code> 就没有达到 <code>lazy loading</code> 的效果</p>
</li>
<li><p>   结论：这种单例模式可用，可能造成内存浪费</p>
</li>
</ol>
<h3 id="1-2-2-饿汉式（静态代码块）"><a href="#1-2-2-饿汉式（静态代码块）" class="headerlink" title="1.2.2 饿汉式（静态代码块）"></a>1.2.2 饿汉式（静态代码块）</h3><p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式（静态代码块）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造器私有化, 外部不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.本类内部创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在静态代码块中，创建单例对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>    优缺点说明：</p>
</blockquote>
<ol>
<li>   这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</li>
<li>   结论：这种单例模式可用，但是可能造成内存浪费</li>
</ol>
<hr/>

<h3 id="1-2-3-懒汉式-线程不安全"><a href="#1-2-3-懒汉式-线程不安全" class="headerlink" title="1.2.3 懒汉式(线程不安全)"></a>1.2.3 懒汉式(线程不安全)</h3><p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构造器私有化, 外部不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line">    <span class="comment">//即懒汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>    优缺点说明：</p>
</blockquote>
<ol>
<li>   起到了 <code>Lazy Loading</code> 的效果，但是只能在单线程下使用。</li>
<li>   如果在多线程下，一个线程进入了 <code>if (singleton == null)</code>判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</li>
<li>   结论：在实际开发中，不要使用这种方式.</li>
</ol>
<h3 id="1-2-4-懒汉式-线程安全，同步方法"><a href="#1-2-4-懒汉式-线程安全，同步方法" class="headerlink" title="1.2.4 懒汉式(线程安全，同步方法)"></a>1.2.4 懒汉式(线程安全，同步方法)</h3><p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2..构造器私有化, 外部不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">    <span class="comment">//即懒汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>    优缺点说明：</p>
</blockquote>
<ol>
<li>   解决了线程安全问题</li>
<li>   效率太低了，每个线程在想获得类的实例时候，执行 <code>getInstance()</code>方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 <code>return</code> 就行了。方法进行同步效率太低</li>
<li>   结论：在实际开发中，不推荐使用这种方式</li>
</ol>
<h3 id="1-2-5-懒汉式-线程安全，同步代码块"><a href="#1-2-5-懒汉式-线程安全，同步代码块" class="headerlink" title="1.2.5 懒汉式(线程安全，同步代码块)"></a>1.2.5 懒汉式(线程安全，同步代码块)</h3><p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2..构造器私有化, 外部不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，加入了同步代码块，解决线程安全问题</span></span><br><span class="line">    <span class="comment">//即懒汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  SingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleTon.class)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> SingleTon();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不推荐使用同步代码块</strong></p>
<hr/>

<h3 id="1-2-6-双重检查–使用了volatile关键字"><a href="#1-2-6-双重检查–使用了volatile关键字" class="headerlink" title="1.2.6 双重检查–使用了volatile关键字"></a>1.2.6 双重检查–使用了<code>volatile</code>关键字</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建实例,使用volatile关键字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingleTon instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2..构造器私有化, 外部不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line">    <span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleTon.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>    优缺点说明：</p>
</blockquote>
<ol>
<li>   <code>Double-Check</code> 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 <code>if (singleton == null)</code>检查，这样就可以保证线程安全了。</li>
<li>   这样，实例化代码只用执行一次，后面再次访问时，判断 <code>if (singleton == null)</code>，直接 <code>return</code> 实例化对象，也避免的反复进行方法同步.</li>
<li>   线程安全；延迟加载；效率较高</li>
<li>   结论：在实际开发中，推荐使用这种单例设计模式</li>
</ol>
<h3 id="1-2-7-静态内部类"><a href="#1-2-7-静态内部类" class="headerlink" title="1.2.7 静态内部类"></a>1.2.7 静态内部类</h3><p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造器私有化, 外部不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.写一个静态内部类,该类中有一个静态属性 Singleton </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleTon INSTANCE = <span class="keyword">new</span> SingleTon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供一个静态的公有方法，直接返回 SingletonInstance.INSTANCE</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>    优缺点说明：</p>
</blockquote>
<ol>
<li>   这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</li>
<li>   静态内部类方式在 <code>Singleton</code> 类被装载时并不会立即实例化，而是在需要实例化时，调用 <code>getInstance</code> 方法，才会装载 <code>SingletonInstance</code> 类，从而完成 <code>Singleton</code> 的实例化。</li>
<li>   类的静态属性只会在第一次加载类的时候初始化，所以在这里，<code>JVM</code> 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li>
<li>   优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li>
<li>   结论：推荐使用.</li>
</ol>
<h3 id="1-2-8-枚举"><a href="#1-2-8-枚举" class="headerlink" title="1.2.8 枚举"></a>1.2.8 枚举</h3><p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.INSTANCE;</span><br><span class="line">        Singleton instance2 = Singleton.INSTANCE;</span><br><span class="line"></span><br><span class="line">        System.out.println(instance1 == instance2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(instance1.hashCode());<span class="comment">//13648335</span></span><br><span class="line">        System.out.println(instance2.hashCode());<span class="comment">//13648335</span></span><br><span class="line"></span><br><span class="line">        instance1.sayOK();<span class="comment">//OK~</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用枚举，可以实现单例, 推荐</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OK～&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>    优缺点说明：</p>
</blockquote>
<ol>
<li>   这借助 <code>JDK1.5</code> 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</li>
<li>   这种方式是 <code>Effective Java</code> 作者 <code>Josh Bloch</code>  提倡的方式</li>
<li>   结论：推荐使用</li>
</ol>
<h3 id="1-2-9-单例模式在-JDK-应用的源码分析"><a href="#1-2-9-单例模式在-JDK-应用的源码分析" class="headerlink" title="1.2.9 单例模式在 JDK  应用的源码分析"></a>1.2.9 单例模式在 <code>JDK</code>  应用的源码分析</h3><blockquote>
<p>单例模式在<code>JDK</code> 应用的源码分析</p>
</blockquote>
<ol>
<li>   我们 <code>JDK</code> 中，<code>java.lang.Runtime</code> 就是经典的单例模式(饿汉式)</li>
<li>   代码分析+<code>Debug</code> 源码+代码说明</li>
</ol>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-44-42.png" class="">
<h3 id="1-2-10-单例模式注意事项和细节说明"><a href="#1-2-10-单例模式注意事项和细节说明" class="headerlink" title="1.2.10 单例模式注意事项和细节说明"></a>1.2.10 单例模式注意事项和细节说明</h3><ol>
<li>   单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li>
<li>   当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 <code>new</code></li>
<li>   单例模式使用的场景：需要<strong>频繁</strong>的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：<strong>重量级对象</strong>)，但又经常用到的对象、<strong>工具类对象</strong>、频繁访问数据库或文件的对象(比如<strong>数据源、session 工厂</strong>等)</li>
</ol>
<HR style="border:3 double #987cb9" width="100%" color=#84fa2a SIZE=3>



<h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2 工厂模式"></a>2 <text style="color:#fc0356">工厂模式</text></h2><h3 id="2-1-简单工厂模式"><a href="#2-1-简单工厂模式" class="headerlink" title="2.1 简单工厂模式"></a>2.1 简单工厂模式</h3><blockquote>
<p>看一个具体的需求</p>
</blockquote>
<p>看一个披萨的项目：要便于披萨种类的扩展，要便于维护</p>
<ol>
<li>   披萨的种类很多(比如 <code>GreekPizz</code>、<code>CheesePizz</code> 等)</li>
<li>   披萨的制作有 <code>prepare</code>，<code>bake</code>, <code>cut</code>, <code>box</code></li>
<li>   完成披萨店订购功能。</li>
</ol>
<h4 id="2-1-1-传统方式"><a href="#2-1-1-传统方式" class="headerlink" title="2.1.1. 传统方式"></a><text style="color:#03fca5">2.1.1. 传统方式</text></h4><ol>
<li>   思路分析(类图)</li>
</ol>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-31-01.png" class="">

<p>编写 <code>OrderPizza.java</code> 去订购需要的各种 <code>Pizza</code></p>
<p>项目结构：</p>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-33-57.png" class="">

<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Pizza.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;<span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备原材料，因为不同的披萨不一样，因此这边做成抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+ <span class="string">&quot; backing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+ <span class="string">&quot; cutting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+ <span class="string">&quot; boxing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//CheesePizza.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给制作奶酪披萨准备原材料....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//GreekPizza.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreekPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给希腊披萨制作准备原材料....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//OrderPizza.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        String orderType; <span class="comment">//订购的披萨类型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//IntelliJ IDEA 2018.2的新特性：对于一些被重新分配地址的变量或者参数，IDEA默认给它们加上下划线</span></span><br><span class="line">            orderType = GetType.getType();</span><br><span class="line">            <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">                pizza.setName(<span class="string">&quot;希腊披萨&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">                pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//输出 pizza 制作过程</span></span><br><span class="line">            pizza.prepare();</span><br><span class="line">            pizza.bake();</span><br><span class="line">            pizza.cut();</span><br><span class="line">            pizza.box();</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//GetType.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader strIn = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            System.out.println(<span class="string">&quot;input pizza type: &quot;</span>);</span><br><span class="line">            String str = strIn.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//PizzaStore.java  ---主方法类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> OrderPizza();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>传统的方式的优缺点</p>
</blockquote>
<ol>
<li>   优点是比较好理解，简单易操作。</li>
<li>   缺点是违反了设计模式的 <code>ocp</code> 原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</li>
<li>   比如我们这时要新增加一个 <code>Pizza</code> 的种类(<code>Pepper</code> 披萨)，我们需要做如下修改. 如果我们增加一个 <code>Pizza</code> 类，只要是订购 <code>Pizza</code> 的代码都需要修改.</li>
</ol>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-34-31.png" class="">

<img data-src="/blog/posts/79c6d028/2021-11-21-17-34-44.png" class="">

<ol start="4">
<li>   改进的思路分析<blockquote>
<p>分析：修改代码可以接受，但是如果我们在其它的地方也有创建 <code>Pizza</code> 的代码，就意味着，也需要修改，而创建 <code>Pizza</code>的代码，往往有多处。</p>
</blockquote>
思路：把创建 <code>Pizza</code> 对象封装到一个类中，这样我们有新的 <code>Pizza</code> 种类时，只需要修改该类就可，其它有创建到 <code>Pizza</code><br>对象的代码就不需要修改了.-&gt; 简单工厂模式</li>
</ol>
<h4 id="2-1-2-基本介绍"><a href="#2-1-2-基本介绍" class="headerlink" title="2.1.2 基本介绍"></a><text style="color:#03fca5">2.1.2 基本介绍</text></h4><ol>
<li>   简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式</li>
<li>   简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)</li>
<li>   在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.</li>
</ol>
<h4 id="2-1-3-使用简单工厂模式"><a href="#2-1-3-使用简单工厂模式" class="headerlink" title="2.1.3 使用简单工厂模式"></a><text style="color:#03fca5">2.1.3 使用简单工厂模式</text></h4><ol>
<li>   简单工厂模式的设计方案: 定义一个可以实例化 <code>Pizaa</code> 对象的类，封装创建对象的代码。</li>
</ol>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-35-00.png" class="">

<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SimpleFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 orderType 返回对应的 Pizza 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用简单工厂模式&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">            pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">            pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//-----------------------------------------------------//</span></span><br><span class="line">    <span class="comment">//使用静态方法，简单工厂也被称为静态工厂</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title">createPizza2</span><span class="params">(String orderType)</span></span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用静态工厂模式&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">            pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">            pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//OrderPizzaFac.java --- 这是使用简单工厂模式方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizzaFac</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个简单工厂对象</span></span><br><span class="line">    SimpleFactory simpleFactory;</span><br><span class="line">    Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderPizzaFac</span><span class="params">(SimpleFactory simpleFactory)</span> </span>&#123;</span><br><span class="line">        setSimpleFactory(simpleFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSimpleFactory</span><span class="params">(SimpleFactory simpleFactory)</span> </span>&#123;</span><br><span class="line">        String orderType = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.simpleFactory = simpleFactory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            orderType = GetType.getType();</span><br><span class="line">            pizza = simpleFactory.createPizza(orderType);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//输出 pizza</span></span><br><span class="line">            <span class="keyword">if</span> (pizza != <span class="keyword">null</span>) &#123; <span class="comment">//订购成功</span></span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; 订购披萨失败 &quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//OrderPizzaFac2.java --- 这是使用静态工厂模式方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizzaFac2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderPizzaFac2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String orderType = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            orderType = GetType.getType();</span><br><span class="line">            pizza = SimpleFactory.createPizza2(orderType);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//输出 pizza</span></span><br><span class="line">            <span class="keyword">if</span> (pizza != <span class="keyword">null</span>) &#123; <span class="comment">//订购成功</span></span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; 订购披萨失败 &quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//PizzaStore.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// new OrderPizza();</span></span><br><span class="line">        <span class="comment">//new OrderPizzaFac(new SimpleFactory());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> OrderPizzaFac2();</span><br><span class="line">        System.out.println(<span class="string">&quot;~退出程序~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是一般使用简单工厂，因为静态工厂的创建方式过于单一</p>
<HR style="border:1 double #987cb9" width="100%" color=#768768 SIZE=2>

<h3 id="2-2-工厂方法模式"><a href="#2-2-工厂方法模式" class="headerlink" title="2.2 工厂方法模式"></a>2.2 <text style="color:#eb0942">工厂方法模式</text></h3><blockquote>
<p>看一个新的需求</p>
</blockquote>
<p>披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 <code>pizza</code>、北京的胡椒 <code>pizza</code> 或者是伦敦的奶酪 <code>pizza</code>、伦敦的胡椒 <code>pizza</code>。</p>
<blockquote>
<p>思路 <code>1</code></p>
</blockquote>
<p>使用简单工厂模式，创建不同的简单工厂类，比如 <code>BJPizzaSimpleFactory、LDPizzaSimpleFactory</code> 等等.从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好</p>
<blockquote>
<p>思路 <code>2</code></p>
</blockquote>
<p>使用工厂方法模式</p>
<h4 id="2-2-1-工厂方法模式介绍"><a href="#2-2-1-工厂方法模式介绍" class="headerlink" title="2.2.1  工厂方法模式介绍"></a><text style="color:#03fca5">2.2.1  工厂方法模式介绍</text></h4><ol>
<li>   工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。</li>
<li>   工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</li>
</ol>
<h4 id="2-2-2-工厂方法模式应用案例"><a href="#2-2-2-工厂方法模式应用案例" class="headerlink" title="2.2.2  工厂方法模式应用案例"></a><text style="color:#03fca5">2.2.2  工厂方法模式应用案例</text></h4><ol>
<li>   披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 <code>pizza</code>、北京的胡椒 <code>pizza</code> 或者是伦敦的奶酪 <code>pizza</code>、伦敦的胡椒 <code>pizza</code></li>
<li> 思路分析图解</li>
</ol>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-35-26.png" class="">
<p>项目结构</p>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-35-36.png" class="">

<p>代码解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GetType.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader strIn = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            System.out.println(<span class="string">&quot;input pizza type: &quot;</span>);</span><br><span class="line">            String str = strIn.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//BJCheesePizza.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BJCheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setName(<span class="string">&quot;北京奶酪披萨&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;给制作北京奶酪披萨准备原材料....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//BJGreekPizza.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BJGreekPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setName(<span class="string">&quot;北京希腊披萨&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;给制作北京希腊披萨准备原材料....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//LDCheesePizza.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LDCheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setName(<span class="string">&quot;伦敦奶酪披萨&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;给制作伦敦奶酪披萨准备原材料....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//LDGreekPizza.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LDGreekPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setName(<span class="string">&quot;伦敦希腊披萨&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;给制作伦敦希腊披萨准备原材料....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//Pizza.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;<span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备原材料，因为不同的披萨不一样，因此这边做成抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+ <span class="string">&quot; backing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+ <span class="string">&quot; cutting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+ <span class="string">&quot; boxing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//OrderPizzaFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizzaFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个抽象方法，createPizza ,  让各个工厂子类自己实现</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderPizzaFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        String orderType;<span class="comment">//订购的披萨类型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            orderType = GetType.getType();</span><br><span class="line">            pizza = createPizza(orderType);</span><br><span class="line">            <span class="comment">//输出 pizza 制作过程</span></span><br><span class="line">            pizza.prepare();</span><br><span class="line">            pizza.bake();</span><br><span class="line">            pizza.cut();</span><br><span class="line">            pizza.box();</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//BJOrderPizza.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title">OrderPizzaFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> BJCheesePizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> BJGreekPizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//LDOrderPizza.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LDOrderPizza</span> <span class="keyword">extends</span> <span class="title">OrderPizzaFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(orderType.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> LDCheesePizza();</span><br><span class="line">        &#125;<span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> LDGreekPizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//PizzaStore.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//new BJOrderPizza();</span></span><br><span class="line">        <span class="keyword">new</span> LDOrderPizza();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>个人理解就是相比简单工厂模式，因为多了一个选项，原来的口味的披萨，多了一个地区的限制，因此可以理解为多加了层，原来的简单工厂<code>（OrderPizzaFactory）</code>不创建对象，多创建的一层子类(<code>LDOrderPizza,BJOrderPizza</code>)来实现创建。</p>
</blockquote>
<HR style="border:1 double #987cb9" width="100%" color=#768768 SIZE=2>

<h3 id="2-3-抽象工厂模式"><a href="#2-3-抽象工厂模式" class="headerlink" title="2.3 抽象工厂模式"></a>2.3 <text style="color:#a666ad">抽象工厂模式</text></h3><h4 id="2-3-1-基本介绍"><a href="#2-3-1-基本介绍" class="headerlink" title="2.3.1 基本介绍"></a>2.3.1 基本介绍</h4><ol>
<li>   抽象工厂模式：定义了一个 <code>interface</code> 用于创建相关或有依赖关系的对象簇，而无需指明具体的类</li>
<li>   抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</li>
<li>   从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。</li>
<li>   将工厂抽象成两层，<code>AbsFactory(抽象工厂)</code> 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。</li>
<li>   类图</li>
</ol>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-35-54.png" class="">
<h4 id="2-3-2-抽象工厂模式应用实例"><a href="#2-3-2-抽象工厂模式应用实例" class="headerlink" title="2.3.2 抽象工厂模式应用实例"></a>2.3.2 抽象工厂模式应用实例</h4><p>使用抽象工厂模式来完成披萨项目:</p>
<p>项目目录：</p>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-36-05.png" class="">
<p><strong><code>pizza</code>包代码与上面工厂方法模式一致，这边不再放出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbsFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbsFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//让下面的工厂子类来 具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//BJFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BJFactory</span> <span class="keyword">implements</span> <span class="title">AbsFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~使用的是抽象工厂模式~&quot;</span>);</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(orderType.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> BJCheesePizza();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(orderType.equals(<span class="string">&quot;greek&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> BJGreekPizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//LDFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LDFactory</span> <span class="keyword">implements</span> <span class="title">AbsFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;~使用的是抽象工厂模式~&quot;</span>);</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(orderType.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> LDCheesePizza();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(orderType.equals(<span class="string">&quot;greek&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> LDGreekPizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//OrderPizza.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AbsFactory absFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(AbsFactory absFactory)</span></span>&#123;</span><br><span class="line">        setFactory(absFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(AbsFactory absFactory)</span></span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        String orderType = <span class="string">&quot;&quot;</span>;<span class="comment">//用户输入</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.absFactory = absFactory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            orderType = GetType.getType();</span><br><span class="line">            <span class="comment">// factory  可能是北京的工厂子类，也可能是伦敦的工厂子类</span></span><br><span class="line">            pizza = absFactory.createPizza(orderType);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pizza != <span class="keyword">null</span>) &#123; <span class="comment">// 订 购 ok</span></span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;订购失败！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;<span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//StorePizzaAbs.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStoreAbs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new OrderPizza(new BJFactory());</span></span><br><span class="line">        <span class="keyword">new</span> OrderPizza(<span class="keyword">new</span> LDFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<HR style="border:1 double #987cb9" width="100%" color=#768768 SIZE=2>

<h3 id="2-4-工厂模式在-JDK-Calendar-应用的源码分析"><a href="#2-4-工厂模式在-JDK-Calendar-应用的源码分析" class="headerlink" title="2.4 工厂模式在 JDK-Calendar 应用的源码分析"></a>2.4 <text style="color:#3f7a0f">工厂模式在 <code>JDK-Calendar</code> 应用的源码分析</text></h3><ol>
<li>   <code>JDK</code> 中的 <code>Calendar</code> 类中，就使用了简单工厂模式</li>
<li>   源码分析+<code>Debug</code> 源码+说明</li>
</ol>
<p>实例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// getInstance 是 Calendar 静态方法</span></span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 注 意 月 份 下 标 从 0 开 始 ， 所 以 取 月 份 要 +1</span></span><br><span class="line">        System.out.println(<span class="string">&quot; 年 :&quot;</span> + cal.get(Calendar.YEAR));</span><br><span class="line">        System.out.println(<span class="string">&quot; 月 :&quot;</span> + (cal.get(Calendar.MONTH) + <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;日:&quot;</span> + cal.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">        System.out.println(<span class="string">&quot; 时 :&quot;</span> + cal.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">        System.out.println(<span class="string">&quot; 分 :&quot;</span> + cal.get(Calendar.MINUTE));</span><br><span class="line">        System.out.println(<span class="string">&quot;秒:&quot;</span> + cal.get(Calendar.SECOND));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getInstance()</code>方法</p>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-36-26.png" class="">

<p><code>createCalendar()</code>方法</p>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-36-37.png" class="">
<HR style="border:1 double #987cb9" width="100%" color=#768768 SIZE=2>

<h3 id="2-5-工厂模式小结"><a href="#2-5-工厂模式小结" class="headerlink" title="2.5 工厂模式小结"></a>2.5 <text style="color:#3f7a0f">工厂模式小结</text></h3><ol>
<li>   工厂模式的意义</li>
</ol>
<pre><code>将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。
</code></pre>
<ol start="2">
<li>   三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)</li>
<li>   设计模式的依赖抽象原则</li>
</ol>
<ul>
<li>创建对象实例时，不要直接 <code>new</code> 类, 而是把这个 <code>new</code>  类的动作放在一个工厂的方法中，并返回。有的书上说， 变量不要直接持有具体类的引用。</li>
<li>不要让类继承具体类，而是继承抽象类或者是实现 <code>interface</code>(接口)</li>
<li>不要覆盖基类中已经实现的方法。</li>
</ul>
<HR style="border:3 double #987cb9" width="100%" color=#84fa2a SIZE=3>



<h2 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3 原型模式"></a>3 <text style="color:#15fa00">原型模式</text></h2><blockquote>
<p>克隆羊问题</p>
</blockquote>
<p>现在有一只羊 <code>tom</code>，姓名为: <code>tom</code>, 年龄为：<code>1</code>，颜色为：白色，请编写程序创建和 <code>tom</code> 羊 属性完全相同的 <code>10</code>只羊。</p>
<blockquote>
<p>传统方式解决克隆羊问题</p>
</blockquote>
<ol>
<li>   思路分析(图解)</li>
</ol>
   <img data-src="/blog/posts/79c6d028/2021-11-21-17-49-12.png" class="">

<p>传统方法使用不断<code>new</code>的方法，实现该需求。</p>
<blockquote>
<p>传统的方式的优缺点</p>
</blockquote>
<ol>
<li>   优点是比较好理解，简单易操作。</li>
<li>   在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</li>
<li>   总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活</li>
<li>   改进的思路分析</li>
</ol>
<p>思路：<code>Java</code> 中 <code>Object</code> 类是所有类的根类，<code>Object</code> 类提供了一个 <code>clone()</code>方法，该方法可以将一个 <code>Java</code> 对象复制一份，但是需要实现 <code>clone</code> 的<code>Java</code> 类必须要实现一个接口<code>Cloneable</code>，该接口表示该类能够复制且具有复制的能力  <code>=&gt;</code>  原型模式</p>
<h3 id="3-1-原型模式-基本介绍"><a href="#3-1-原型模式-基本介绍" class="headerlink" title="3.1 原型模式-基本介绍"></a>3.1 <text style="color:#749171">原型模式-基本介绍</text></h3><ol>
<li>   原型模式(<code>Prototype</code> 模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</li>
<li>   原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</li>
<li>   工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 <code>对象.clone()</code></li>
<li>   形象的理解：孙大圣拔出猴毛， 变出其它孙大圣</li>
</ol>
<h3 id="3-2-原型模式原理结构图-uml-类图"><a href="#3-2-原型模式原理结构图-uml-类图" class="headerlink" title="3.2 原型模式原理结构图-uml 类图"></a>3.2 <text style="color:#1e9412">原型模式原理结构图-<code>uml</code> 类图</text></h3><img data-src="/blog/posts/79c6d028/2021-11-21-17-39-37.png" class="">
<blockquote>
<p>    原理结构图说明</p>
</blockquote>
<ol>
<li>   <code>Prototype</code> : 原型类，声明一个克隆自己的接口</li>
<li>   <code>ConcretePrototype</code>: 具体的原型类,  实现一个克隆自己的操作</li>
<li>   <code>Client</code>: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样）</li>
</ol>
<h3 id="3-3-原型模式解决克隆羊问题的应用实例"><a href="#3-3-原型模式解决克隆羊问题的应用实例" class="headerlink" title="3.3   原型模式解决克隆羊问题的应用实例"></a>3.3 <text style="color:#1e9460">  原型模式解决克隆羊问题的应用实例</text></h3><p>使用原型模式改进传统方式，让程序具有更高的效率和扩展性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sheep.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Sheep&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//克隆该实例，使用默认的 clone 方法来完成</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sheep = (Sheep) <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Sheep sheep1 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep sheep2 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep sheep3 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep sheep4 = (Sheep) sheep.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sheep1: &quot;</span>+sheep1+<span class="string">&quot; ---- &quot;</span>+ <span class="string">&quot;sheep.hashCode: &quot;</span>+ sheep1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;sheep2: &quot;</span>+sheep2+<span class="string">&quot; ---- &quot;</span>+ <span class="string">&quot;sheep.hashCode: &quot;</span>+ sheep2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;sheep3: &quot;</span>+sheep3+<span class="string">&quot; ---- &quot;</span>+ <span class="string">&quot;sheep.hashCode: &quot;</span>+ sheep3.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;sheep4: &quot;</span>+sheep4+<span class="string">&quot; ---- &quot;</span>+ <span class="string">&quot;sheep.hashCode: &quot;</span>+ sheep4.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-39-58.png" class="">

<p>可以观察到哈希值不一致，实现了深拷贝。</p>
<HR style="border:3 double #987cb9" width="100%" color=#84fa2a SIZE=3>

<p>🌟<br><strong>但是，原生的<code>Object</code> 方法只能实现基本数据类型以及 <code>String</code> 方法的 深拷贝，所以，在实体类中引用一些其他一些引用类型时，需要通过别的方法实现深拷贝</strong><br>🌟</p>
<p>我们在<code>Sheep</code>中新添一个 <code>Sheep</code>引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age; </span><br><span class="line"><span class="keyword">private</span> String color;</span><br><span class="line"><span class="keyword">public</span> Sheep friend; <span class="comment">//是对象,  克隆是会如何处理,  默认是浅拷贝</span></span><br></pre></td></tr></table></figure>
<p>进行上述测试</p>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-40-34.png" class="">

<p>可以看到，<code>jdk</code>默认的<code>Clone</code>方法只能复制基本数据类型以及<code>String</code>类型的变量，对于其他的引用类型变量，都是只是新增一个引用。所以默认<code>Clone </code>只是浅拷贝，所以只能使用其他办法实现深拷贝。</p>
<h3 id="3-4-原型模式在-Spring-框架中源码分析"><a href="#3-4-原型模式在-Spring-框架中源码分析" class="headerlink" title="3.4 原型模式在 Spring 框架中源码分析"></a>3.4 <text style="color:#4e9946">原型模式在 <code>Spring</code> 框架中源码分析</text></h3><ol>
<li>   <code>Spring</code> 中原型 <code>bean</code> 的创建，就是原型模式的应用</li>
<li>   代码分析 + <code>Debug</code> 源码</li>
</ol>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-40-46.png" class="">
<h3 id="3-5-深入讨论-浅拷贝和深拷贝"><a href="#3-5-深入讨论-浅拷贝和深拷贝" class="headerlink" title="3.5 深入讨论-浅拷贝和深拷贝"></a>3.5 <text style="color:#3c5d75">深入讨论-浅拷贝和深拷贝</text></h3><blockquote>
<p>浅拷贝的介绍</p>
</blockquote>
<ol>
<li><p>   对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</p>
</li>
<li><p>   对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</p>
</li>
<li><p>   前面我们克隆羊就是浅拷贝</p>
</li>
<li><p>浅拷贝是使用默认的 <code>clone()</code>方法来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sheep = (Sheep) <span class="keyword">super</span>.clone();</span><br></pre></td></tr></table></figure>
<h3 id="3-6-深拷贝基本介绍"><a href="#3-6-深拷贝基本介绍" class="headerlink" title="3.6 深拷贝基本介绍"></a>3.6 <text style="color:#403e59">深拷贝基本介绍</text></h3></li>
<li><p>   复制对象的所有基本数据类型的成员变量值</p>
</li>
<li><p>   为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝</p>
</li>
<li><p>   深拷贝实现方式 <code>1</code>：重写 <code>clone</code> 方法来实现深拷贝</p>
</li>
<li><p>   深拷贝实现方式 <code>2</code>：通过对象序列化实现深拷贝(推荐)</p>
</li>
</ol>
<h3 id="3-7-深拷贝应用实例"><a href="#3-7-深拷贝应用实例" class="headerlink" title="3.7 深拷贝应用实例"></a>3.7 <text style="color:#8e8bb0">深拷贝应用实例</text></h3><ol>
<li>   使用 重写 <code>clone</code> 方法实现深拷贝</li>
<li>   使用序列化来实现深拷贝</li>
<li>   代码演示</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DeepCloneableTarget.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneableTarget</span> <span class="keyword">implements</span> <span class="title">Serializable</span>,<span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cloneName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cloneClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneableTarget</span><span class="params">(String cloneName, String cloneClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cloneName = cloneName;</span><br><span class="line">        <span class="keyword">this</span>.cloneClass = cloneClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为该类的属性，都是 String ,  因此我们这里使用默认的 clone 完成即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//DeepProtoType.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>,<span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name; <span class="comment">//String 属 性</span></span><br><span class="line">    <span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深拷贝 - 方式 1  使用 clone 方法</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    protected Object clone() throws CloneNotSupportedException &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        Object deep = null;</span></span><br><span class="line"><span class="comment">//        //这里完成对基本数据类型(属性)和 String 的克隆</span></span><br><span class="line"><span class="comment">//        deep = super.clone();</span></span><br><span class="line"><span class="comment">//        //对引用类型的属性，进行单独处理</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        DeepProtoType deepProtoType = (DeepProtoType) deep;</span></span><br><span class="line"><span class="comment">//        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        return deepProtoType;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//深拷贝 - 方式 2 通过对象的序列化实现 (推荐)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        DeepProtoType deepProtoType = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.第一步</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span>(ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);)&#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.第二步</span></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        <span class="keyword">try</span>(ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis)) &#123;</span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            deepProtoType  = (DeepProtoType) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deepProtoType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        DeepProtoType p = <span class="keyword">new</span> DeepProtoType();</span><br><span class="line">        p.name = <span class="string">&quot;李三&quot;</span>;</span><br><span class="line">        p.deepCloneableTarget = <span class="keyword">new</span> DeepCloneableTarget(<span class="string">&quot;大牛&quot;</span>,<span class="string">&quot;小牛&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DeepProtoType p2 = (DeepProtoType) p.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;p.name=&quot;</span> + p.name + <span class="string">&quot;---------&quot;</span> +<span class="string">&quot;p.deepCloneableTarget=&quot;</span> + p.deepCloneableTarget.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;p2.name=&quot;</span> + p.name + <span class="string">&quot;---------&quot;</span> + <span class="string">&quot;p2.deepCloneableTarget=&quot;</span> + p2.deepCloneableTarget.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/79c6d028/2021-11-21-17-40-59.png" class="">
<p>通过两种办法实现了深拷贝，一般来说，第一种方法比较方便，第二种方法比较通用，但是写起来会有一点点麻烦，根据情况选择即可。</p>
<h3 id="3-8-原型模式的注意事项和细节"><a href="#3-8-原型模式的注意事项和细节" class="headerlink" title="3.8 原型模式的注意事项和细节"></a>3.8 <text style="color:#8e8bb0">原型模式的注意事项和细节</text></h3><ol>
<li>   创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</li>
<li>   不用重新初始化对象，而是动态地获得对象运行时的状态</li>
<li>   如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</li>
<li>   在实现深克隆的时候可能需要比较复杂的代码</li>
<li>   缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 <code>ocp</code> 原则，这点请同学们注意.</li>
</ol>
<HR style="border:3 double #987cb9" width="100%" color=#84fa2a SIZE=3>



<h2 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4 建造者模式"></a>4 <text style="color:#15fa00">建造者模式</text></h2><blockquote>
<p>盖房项目需求</p>
</blockquote>
<ol>
<li>   需要建房子：这一过程为打桩、砌墙、封顶</li>
<li>   房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.</li>
<li>   请编写程序，完成需求.</li>
</ol>
<blockquote>
<p>传统方式解决盖房需求</p>
</blockquote>
<ol>
<li>   思路分析(图解)</li>
</ol>
<pre><code> &#123;% asset_img 2021-11-21-17-41-12.png %&#125;
</code></pre>
<ol start="2">
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractHouse.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHouse</span> </span>&#123;</span><br><span class="line">    <span class="comment">//打地基</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//砌墙</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//封顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        buildBasic();</span><br><span class="line">        buildWalls();</span><br><span class="line">        roofed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//CommonHouse.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">AbstractHouse</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子打地基 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子砌墙 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子封顶 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line">        commonHouse.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>传统方式的问题分析</p>
</blockquote>
<ol>
<li>   优点是比较好理解，简单易操作。</li>
<li>   设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产品(即：房子) 和 创建产品的过程(即：建房子流程) 封装在一起，耦合性增强了。</li>
<li>   解决方案：将产品和产品建造过程解耦  =&gt;    建造者模式.</li>
</ol>
<h3 id="4-1-建造者模式基本介绍"><a href="#4-1-建造者模式基本介绍" class="headerlink" title="4.1 建造者模式基本介绍"></a>4.1 <text style="color:#622866">建造者模式基本介绍</text></h3><ol>
<li>   建造者模式（<code>Builder Pattern</code>） 又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</li>
<li>   建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们， 用户不需要知道内部的具体构建细节。</li>
</ol>
<h3 id="4-2-建造者模式的四个角色"><a href="#4-2-建造者模式的四个角色" class="headerlink" title="4.2 建造者模式的四个角色"></a>4.2 <text style="color:#73203d">建造者模式的四个角色</text></h3><ol>
<li><p>   <code>Product</code>（产品角色）： 一个具体的产品对象。</p>
</li>
<li><p>   <code>Builder</code>（抽象建造者）： 创建一个 <code>Product</code> 对象的各个部件指定的 接口/抽象类。</p>
</li>
<li><p>   <code>ConcreteBuilder（具体建造者）：</code> 实现接口，构建和装配各个部件。</p>
</li>
<li><p>   <code>Director（指挥者）：</code> 构建一个使用 <code>Builder</code> 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</p>
</li>
</ol>
<h3 id="4-3-建造者模式原理类图"><a href="#4-3-建造者模式原理类图" class="headerlink" title="4.3 建造者模式原理类图"></a>4.3 <text style="color:#781d61">建造者模式原理类图</text></h3><img data-src="/blog/posts/79c6d028/2021-11-21-17-41-25.png" class="">
<h3 id="4-4-建造者模式解决盖房需求应用实例"><a href="#4-4-建造者模式解决盖房需求应用实例" class="headerlink" title="4.4 建造者模式解决盖房需求应用实例"></a>4.4 <text style="color:#33a151">建造者模式解决盖房需求应用实例</text></h3><ol>
<li>   需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都需要经历这些过程，下面我们使用建造者模式(<code>Builder Pattern</code>)来完成</li>
<li>   思路分析图解(类图)</li>
</ol>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-41-32.png" class="">
<ol start="3">
<li>代码实现</li>
</ol>
<p>目录结构</p>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-41-41.png" class="">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//House.java</span></span><br><span class="line"><span class="comment">// 产 品 -&gt;Product</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String basis;</span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="keyword">private</span> String roofed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//HouseBuilder.java</span></span><br><span class="line"><span class="comment">//抽象的建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> House house = <span class="keyword">new</span> House();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将建造的流程写好, 抽象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造房子好， 将产品(房子) 返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">buildHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//HouseDirector.java</span></span><br><span class="line"><span class="comment">//指挥者，这里去指定制作流程，返回产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> </span>&#123;</span><br><span class="line">    HouseBuilder houseBuilder = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造器传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过setter传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何处理建造房子的流程，交给指挥者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">constructHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        houseBuilder.buildBasis();</span><br><span class="line">        houseBuilder.buildWalls();</span><br><span class="line">        houseBuilder.roofed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//CommonHouse.java   --- 具体的建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子打地基 5 米 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子砌墙 10cm &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 普通房子屋顶 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//HighBuildingHouse.java   --- 具体的建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighBuildingHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 高楼的打地基 100 米 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 高楼的砌墙 20cm &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 高楼的透明屋顶 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//建造普通房子</span></span><br><span class="line">        CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line">        <span class="comment">//准备创建房子的指挥者</span></span><br><span class="line">        HouseDirector houseDirector = <span class="keyword">new</span> HouseDirector(commonHouse);</span><br><span class="line">        <span class="comment">//完成盖房子，返回产品(普通房子)</span></span><br><span class="line">        houseDirector.constructHouse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot; 输 出 流 程 &quot;);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; ------------------ &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//盖高楼</span></span><br><span class="line">        HighBuildingHouse highBuildingHouse = <span class="keyword">new</span> HighBuildingHouse();</span><br><span class="line">        <span class="comment">//重置建造者</span></span><br><span class="line">        houseDirector.setHouseBuilder(highBuildingHouse);</span><br><span class="line">        <span class="comment">//完成盖房子，返回产品(高楼)</span></span><br><span class="line">        houseDirector.constructHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-建造者模式在JDK-的应用和源码分析"><a href="#4-5-建造者模式在JDK-的应用和源码分析" class="headerlink" title="4.5 建造者模式在JDK 的应用和源码分析"></a>4.5 <text style="color:#c2f571">建造者模式在<code>JDK</code> 的应用和源码分析</text></h3><ol>
<li>   <code>java.lang.StringBuilder</code> 中的建造者模式</li>
<li>   代码说明+<code>Debug</code> 源码</li>
</ol>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-41-54.png" class="">
<ol start="3">
<li>   源码中建造者模式角色分析</li>
</ol>
<ul>
<li><pre><code>``Appendable`` 接口定义了多个 ``append`` 方法(抽象方法), 即 ``Appendable`` 为抽象建造者, 定义了抽象方法
</code></pre>
</li>
<li>  <code>AbstractStringBuilder</code>  实现了  <code>Appendable</code>  接口方法，这里的  <code>AbstractStringBuilder</code>    已经是建造者，只是不能实例化</li>
<li>  <code>StringBuilder</code> 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由 <code>AbstractStringBuilder</code> 完成 , 而 <code>StringBuilder</code>    继承了 <code>AbstractStringBuilder</code></li>
</ul>
<h3 id="4-6-建造者模式的注意事项和细节"><a href="#4-6-建造者模式的注意事项和细节" class="headerlink" title="4.6 建造者模式的注意事项和细节"></a>4.6 <text style="color:#3f4a2f">建造者模式的注意事项和细节</text></h3><ol>
<li>   客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li>
<li>   每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象</li>
<li>   可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰， 也更方便使用程序来控制创建过程</li>
<li>   增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”</li>
<li>   建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
<li>   如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.</li>
<li><blockquote>
<p>抽象工厂模式 VS 建造者模式</p>
</blockquote>
</li>
</ol>
<p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品</p>
<HR style="border:3 double #987cb9" width="100%" color=#84fa2a SIZE=3>



<h2 id="5-适配器设计模式"><a href="#5-适配器设计模式" class="headerlink" title="5 适配器设计模式"></a>5 <text style="color:#15fa00">适配器设计模式</text></h2><blockquote>
<p>现实生活中的适配器例子</p>
</blockquote>
<p>泰国插座用的是两孔的（欧标），可以买个多功能转换插头 (适配器) ，这样就可以使用了。</p>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-42-05.png" class="">
<h3 id="5-1-基本介绍"><a href="#5-1-基本介绍" class="headerlink" title="5.1 基本介绍"></a>5.1 <text style="color:#8a7c74">基本介绍</text></h3><ol>
<li>   适配器模式(<code>Adapter Pattern</code>)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(<code>Wrapper</code>)</li>
<li>   适配器模式属于结构型模式</li>
<li>   主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</li>
</ol>
<h3 id="5-2-工作原理"><a href="#5-2-工作原理" class="headerlink" title="5.2 工作原理"></a>5.2 <text style="color:#524640">工作原理</text></h3><ol>
<li>   适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</li>
<li>   从用户的角度看不到被适配者，是解耦的</li>
<li>   用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</li>
<li>   用户收到反馈结果，感觉只是和目标接口交互，如图</li>
</ol>
<pre><code>&#123;% asset_img 2021-11-21-17-42-14.png %&#125;
</code></pre>
<h3 id="5-3-类适配器模式"><a href="#5-3-类适配器模式" class="headerlink" title="5.3 类适配器模式"></a>5.3 <text style="color:#995f42">类适配器模式</text></h3><h4 id="5-3-1-类适配器模式介绍"><a href="#5-3-1-类适配器模式介绍" class="headerlink" title="5.3.1     类适配器模式介绍"></a>5.3.1     类适配器模式介绍</h4><blockquote>
<p>基本介绍</p>
</blockquote>
<p><code>Adapter</code> 类，通过继承 <code>src</code> 类，实现 <code>dst</code>  类接口，完成 <code>src-&gt;dst</code> 的适配。</p>
<h4 id="5-3-2-类适配器模式应用实例"><a href="#5-3-2-类适配器模式应用实例" class="headerlink" title="5.3.2 类适配器模式应用实例"></a>5.3.2 类适配器模式应用实例</h4><ol>
<li>应用实例说明<br>以生活中充电器的例子来讲解适配器，充电器本身相当于 <code>Adapter</code>，<code>220V</code> 交流电相当于 <code>src</code> (即被适配者)，我们的目 <code>dst</code>(即 目标)是 <code>5V</code> 直流电</li>
<li>思路分析(类图)<img data-src="/blog/posts/79c6d028/2021-11-21-17-42-26.png" class=""> </li>
<li>代码实现</li>
</ol>
<p>目录结构: </p>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-42-37.png" class="">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//适配接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//被适配的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出220V的电压</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;电压=&quot;</span> + src + <span class="string">&quot;伏&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//作用类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//充电</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (iVoltage5V.output5V() == <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电压为 5V, 可以充电~~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电压大于 5V, 不能充电~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取到220V的电压</span></span><br><span class="line">        <span class="keyword">int</span> srcV = output220V();</span><br><span class="line">        <span class="keyword">int</span> dstV = srcV / <span class="number">44</span>;</span><br><span class="line">        <span class="keyword">return</span> dstV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; === 类适配器模式 ====&quot;</span>);</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-42-50.png" class=""> 

<h4 id="5-3-3-类适配器模式注意事项和细节"><a href="#5-3-3-类适配器模式注意事项和细节" class="headerlink" title="5.3.3 类适配器模式注意事项和细节"></a>5.3.3 类适配器模式注意事项和细节</h4><ol>
<li><code>Java</code> 是单继承机制，所以类适配器需要继承 <code>src</code> 类这一点算是一个缺点, 因为这要求 <code>dst</code> 必须是接口，有一定局限性;</li>
<li><code>src</code> 类的方法在 <code>Adapter</code> 中都会暴露出来，也增加了使用的成本。</li>
<li>由于其继承了 <code>src</code> 类，所以它可以根据需求重写 <code>src</code> 类的方法，使得 <code>Adapter</code> 的灵活性增强了。</li>
</ol>
<HR style="border:1 double #987cb9" width="100%" color=#768768 SIZE=2>

<h3 id="5-4-对象适配器模式"><a href="#5-4-对象适配器模式" class="headerlink" title="5.4 对象适配器模式"></a>5.4 <text style="color:#702e0c">对象适配器模式</text></h3><h4 id="5-4-1-对象适配器模式介绍"><a href="#5-4-1-对象适配器模式介绍" class="headerlink" title="5.4.1 对象适配器模式介绍"></a>5.4.1 对象适配器模式介绍</h4><ol>
<li>基本思路和类的适配器模式相同，只是将 <code>Adapter</code> 类作修改，不是继承 <code>src</code> 类，而是持有 <code>src</code> 类的实例，以解决兼容性的问题。 即：持有 <code>src</code> 类，实现 dst  类接口，完成 <code>src-&gt;dst</code> 的适配</li>
<li>根据“合成复用原则”，在系统中尽量使用关联关系（聚合）来替代继承关系。</li>
<li>对象适配器模式是适配器模式常用的一种</li>
</ol>
<h4 id="5-4-2-对象适配器模式应用实例"><a href="#5-4-2-对象适配器模式应用实例" class="headerlink" title="5.4.2 对象适配器模式应用实例"></a>5.4.2 对象适配器模式应用实例</h4><ol>
<li>应用实例说明<br>以生活中充电器的例子来讲解适配器，充电器本身相当于 <code>Adapter，220V</code> 交流电相当于 <code>src</code> (即被适配者)，我们的目 <code>dst</code>(即目标)是 <code>5V</code> 直流电，使用对象适配器模式完成。</li>
<li>思路分析(类图)：只需修改适配器即可, 如下:</li>
</ol>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-43-02.png" class="">  

<ol start="3">
<li>代码实现</li>
</ol>
<p>对象适配器主要的不同点在于适配器类采用了类的聚合以及构造器传入的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关联关系-聚合</span></span><br><span class="line">    <span class="keyword">private</span> Voltage220V voltage220V;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造器，传入一个 Voltage220V 实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage220V = voltage220V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != voltage220V) &#123;</span><br><span class="line">            <span class="keyword">int</span> src = voltage220V.output220V();</span><br><span class="line">            System.out.println(<span class="string">&quot;使用对象适配器，进行适配~~&quot;</span>);</span><br><span class="line">            dst = src / <span class="number">44</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;适配完成，输出的电压为=&quot;</span> + dst);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-43-10.png" class="">  


<h4 id="5-4-3-对象适配器模式注意事项和细节"><a href="#5-4-3-对象适配器模式注意事项和细节" class="headerlink" title="5.4.3 对象适配器模式注意事项和细节"></a>5.4.3 对象适配器模式注意事项和细节</h4><ol>
<li>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 <code>src</code> 的局限性问题，也不再要求 <code>dst</code><br>必须是接口。</li>
<li>使用成本更低，更灵活。</li>
</ol>
<HR style="border:1 double #987cb9" width="100%" color=#768768 SIZE=2>


<h3 id="5-5-接口适配器模式"><a href="#5-5-接口适配器模式" class="headerlink" title="5.5 接口适配器模式"></a>5.5 <text style="color:#cecf99">接口适配器模式</text></h3><h4 id="5-5-1-接口适配器模式介绍"><a href="#5-5-1-接口适配器模式介绍" class="headerlink" title="5.5.1 接口适配器模式介绍"></a>5.5.1 接口适配器模式介绍</h4><ol>
<li>一些书籍称为：适配器模式<code>(Default Adapter Pattern)</code>或缺省适配器模式。</li>
<li>核心思路：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</li>
<li>适用于一个接口不想使用其所有的方法的情况。</li>
</ol>
<h4 id="5-5-2-接口适配器模式应用实例"><a href="#5-5-2-接口适配器模式应用实例" class="headerlink" title="5.5.2 接口适配器模式应用实例"></a>5.5.2 接口适配器模式应用实例</h4><img data-src="/blog/posts/79c6d028/2021-11-21-17-43-17.png" class="">
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">InterfaceAdapter</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只需要去覆盖我们 需要使用 接口方法</span></span><br><span class="line">        AbsAdapter adapter = <span class="keyword">new</span> AbsAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;使用了m1的方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        adapter.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<img data-src="/blog/posts/79c6d028/2021-11-21-17-43-26.png" class=""> 


<HR style="border:3 double #987cb9" width="100%" color=#84fa2a SIZE=3>


<h2 id="6-桥接模式"><a href="#6-桥接模式" class="headerlink" title="6 桥接模式"></a>6 <text style="color:#15fa00">桥接模式</text></h2>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>速查表</title>
    <url>/blog/posts/1b392612/</url>
    <content><![CDATA[<p>this is a cheatsheet, is used for get help quickly.</p>
<img data-src="/blog/posts/1b392612/2022-08-01-21-43-59.png" class="">

<h1 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a><code>Bash</code></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 常用快捷键（默认使用 Emacs 键位）</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">CTRL+A              <span class="comment"># 移动到行首，同 &lt;Home&gt;</span></span><br><span class="line">CTRL+B              <span class="comment"># 向后移动，同 &lt;Left&gt;</span></span><br><span class="line">CTRL+C              <span class="comment"># 结束当前命令</span></span><br><span class="line">CTRL+D              <span class="comment"># 删除光标前的字符，同 &lt;Delete&gt; ，或者没有内容时，退出会话</span></span><br><span class="line">CTRL+E              <span class="comment"># 移动到行末，同 &lt;End&gt;</span></span><br><span class="line">CTRL+F              <span class="comment"># 向前移动，同 &lt;Right&gt;</span></span><br><span class="line">CTRL+G              <span class="comment"># 退出当前编辑（比如正在 CTRL+R 搜索历史时）</span></span><br><span class="line">CTRL+H              <span class="comment"># 删除光标左边的字符，同 &lt;Backspace&gt;</span></span><br><span class="line">CTRL+K              <span class="comment"># 删除光标位置到行末的内容</span></span><br><span class="line">CTRL+L              <span class="comment"># 清屏并重新显示</span></span><br><span class="line">CTRL+N              <span class="comment"># 移动到命令历史的下一行，同 &lt;Down&gt;</span></span><br><span class="line">CTRL+O              <span class="comment"># 类似回车，但是会显示下一行历史</span></span><br><span class="line">CTRL+P              <span class="comment"># 移动到命令历史的上一行，同 &lt;Up&gt;</span></span><br><span class="line">CTRL+R              <span class="comment"># 历史命令反向搜索，使用 CTRL+G 退出搜索</span></span><br><span class="line">CTRL+S              <span class="comment"># 历史命令正向搜索，使用 CTRL+G 退出搜索</span></span><br><span class="line">CTRL+T              <span class="comment"># 交换前后两个字符</span></span><br><span class="line">CTRL+U              <span class="comment"># 删除字符到行首</span></span><br><span class="line">CTRL+V              <span class="comment"># 输入字符字面量，先按 CTRL+V 再按任意键</span></span><br><span class="line">CTRL+W              <span class="comment"># 删除光标左边的一个单词</span></span><br><span class="line">CTRL+X              <span class="comment"># 列出可能的补全</span></span><br><span class="line">CTRL+Y              <span class="comment"># 粘贴前面 CTRL+u/k/w 删除过的内容</span></span><br><span class="line">CTRL+Z              <span class="comment"># 暂停前台进程返回 bash，需要时可用 fg 将其切换回前台</span></span><br><span class="line">CTRL+_              <span class="comment"># 撤销（undo），有的终端将 CTRL+_ 映射为 CTRL+/ 或 CTRL+7</span></span><br><span class="line"></span><br><span class="line">ALT+b               <span class="comment"># 向后（左边）移动一个单词</span></span><br><span class="line">ALT+d               <span class="comment"># 删除光标后（右边）一个单词</span></span><br><span class="line">ALT+f               <span class="comment"># 向前（右边）移动一个单词</span></span><br><span class="line">ALT+t               <span class="comment"># 交换字符</span></span><br><span class="line">ALT+BACKSPACE       <span class="comment"># 删除光标前面一个单词，类似 CTRL+W，但不影响剪贴板</span></span><br><span class="line"></span><br><span class="line">CTRL+X CTRL+X       <span class="comment"># 连续按两次 CTRL+X，光标在当前位置和行首来回跳转 </span></span><br><span class="line">CTRL+X CTRL+E       <span class="comment"># 用你指定的编辑器，编辑当前命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># BASH 基本操作</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>                <span class="comment"># 退出当前登陆</span></span><br><span class="line">env                 <span class="comment"># 显示环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span>         <span class="comment"># 显示你在使用什么 SHELL</span></span><br><span class="line"></span><br><span class="line">bash                <span class="comment"># 使用 bash，用 exit 返回</span></span><br><span class="line"><span class="built_in">which</span> bash          <span class="comment"># 搜索 $PATH，查找哪个程序对应命令 bash</span></span><br><span class="line">whereis bash        <span class="comment"># 搜索可执行，头文件和帮助信息的位置，使用系统内建数据库</span></span><br><span class="line">whatis bash         <span class="comment"># 查看某个命令的解释，一句话告诉你这是干什么的</span></span><br><span class="line"></span><br><span class="line">clear               <span class="comment"># 清初屏幕内容</span></span><br><span class="line">reset               <span class="comment"># 重置终端（当你不小心 cat 了一个二进制，终端状态乱掉时使用）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 目录操作</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span>                  <span class="comment"># 返回自己 $HOME 目录</span></span><br><span class="line"><span class="built_in">cd</span> &#123;dirname&#125;        <span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">pwd</span>                 <span class="comment"># 显示当前所在目录</span></span><br><span class="line">mkdir &#123;dirname&#125;     <span class="comment"># 创建目录</span></span><br><span class="line">mkdir -p &#123;dirname&#125;  <span class="comment"># 递归创建目录</span></span><br><span class="line"><span class="built_in">pushd</span> &#123;dirname&#125;     <span class="comment"># 目录压栈并进入新目录</span></span><br><span class="line"><span class="built_in">popd</span>                <span class="comment"># 弹出并进入栈顶的目录</span></span><br><span class="line"><span class="built_in">dirs</span> -v             <span class="comment"># 列出当前目录栈</span></span><br><span class="line"><span class="built_in">cd</span> -                <span class="comment"># 回到之前的目录</span></span><br><span class="line"><span class="built_in">cd</span> -&#123;N&#125;             <span class="comment"># 切换到目录栈中的第 N个目录，比如 cd -2 将切换到第二个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 文件操作</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">ls                  <span class="comment"># 显示当前目录内容，后面可接目录名：ls &#123;dir&#125; 显示指定目录</span></span><br><span class="line">ls -l               <span class="comment"># 列表方式显示目录内容，包括文件日期，大小，权限等信息</span></span><br><span class="line">ls -1               <span class="comment"># 列表方式显示目录内容，只显示文件名称，减号后面是数字 1</span></span><br><span class="line">ls -a               <span class="comment"># 显示所有文件和目录，包括隐藏文件（.开头的文件/目录名）</span></span><br><span class="line">ln -s &#123;fn&#125; &#123;link&#125;   <span class="comment"># 给指定文件创建一个软链接</span></span><br><span class="line">cp &#123;src&#125; &#123;dest&#125;     <span class="comment"># 拷贝文件，cp -r dir1 dir2 可以递归拷贝（目录）</span></span><br><span class="line">rm &#123;fn&#125;             <span class="comment"># 删除文件，rm -r 递归删除目录，rm -f 强制删除</span></span><br><span class="line">mv &#123;src&#125; &#123;dest&#125;     <span class="comment"># 移动文件，如果 dest 是目录，则移动，是文件名则覆盖</span></span><br><span class="line">touch &#123;fn&#125;          <span class="comment"># 创建或者更新一下制定文件</span></span><br><span class="line">cat &#123;fn&#125;            <span class="comment"># 输出文件原始内容</span></span><br><span class="line">any_cmd &gt; &#123;fn&#125;      <span class="comment"># 执行任意命令并将标准输出重定向到指定文件</span></span><br><span class="line">more &#123;fn&#125;           <span class="comment"># 逐屏显示某文件内容，空格翻页，q 退出</span></span><br><span class="line">less &#123;fn&#125;           <span class="comment"># 更高级点的 more，更多操作，q 退出</span></span><br><span class="line">head &#123;fn&#125;           <span class="comment"># 显示文件头部数行，可用 head -3 abc.txt 显示头三行</span></span><br><span class="line">tail &#123;fn&#125;           <span class="comment"># 显示文件尾部数行，可用 tail -3 abc.txt 显示尾部三行</span></span><br><span class="line">tail -f &#123;fn&#125;        <span class="comment"># 持续显示文件尾部数据，可用于监控日志</span></span><br><span class="line">nano &#123;fn&#125;           <span class="comment"># 使用 nano 编辑器编辑文件</span></span><br><span class="line">vim &#123;fn&#125;            <span class="comment"># 使用 vim 编辑文件</span></span><br><span class="line">diff &#123;f1&#125; &#123;f2&#125;      <span class="comment"># 比较两个文件的内容</span></span><br><span class="line">wc &#123;fn&#125;             <span class="comment"># 统计文件有多少行，多少个单词</span></span><br><span class="line">chmod 644 &#123;fn&#125;      <span class="comment"># 修改文件权限为 644，可以接 -R 对目录循环改权限</span></span><br><span class="line">chgrp group &#123;fn&#125;    <span class="comment"># 修改文件所属的用户组</span></span><br><span class="line">chown user1 &#123;fn&#125;    <span class="comment"># 修改文件所有人为 user1, chown user1:group1 fn 可以修改组</span></span><br><span class="line">file &#123;fn&#125;           <span class="comment"># 检测文件的类型和编码</span></span><br><span class="line">basename &#123;fn&#125;       <span class="comment"># 查看文件的名字（不包括路径）</span></span><br><span class="line">dirname &#123;fn&#125;        <span class="comment"># 查看文件的路径（不包括名字）</span></span><br><span class="line">grep &#123;pat&#125; &#123;fn&#125;     <span class="comment"># 在文件中查找出现过 pat 的内容</span></span><br><span class="line">grep -r &#123;pat&#125; .     <span class="comment"># 在当前目录下递归查找所有出现过 pat 的文件内容</span></span><br><span class="line"><span class="built_in">stat</span> &#123;fn&#125;           <span class="comment"># 显示文件的详细信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 用户管理</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">whoami              <span class="comment"># 显示我的用户名</span></span><br><span class="line">who                 <span class="comment"># 显示已登陆用户信息，w / who / users 内容略有不同</span></span><br><span class="line">w                   <span class="comment"># 显示已登陆用户信息，w / who / users 内容略有不同</span></span><br><span class="line">users               <span class="comment"># 显示已登陆用户信息，w / who / users 内容略有不同</span></span><br><span class="line">passwd              <span class="comment"># 修改密码，passwd &#123;user&#125; 可以用于 root 修改别人密码</span></span><br><span class="line">finger &#123;user&#125;       <span class="comment"># 显示某用户信息，包括 id, 名字, 登陆状态等</span></span><br><span class="line">adduser &#123;user&#125;      <span class="comment"># 添加用户</span></span><br><span class="line">deluser &#123;user&#125;      <span class="comment"># 删除用户</span></span><br><span class="line">w                   <span class="comment"># 查看谁在线</span></span><br><span class="line">su                  <span class="comment"># 切换到 root 用户</span></span><br><span class="line">su -                <span class="comment"># 切换到 root 用户并登陆（执行登陆脚本）</span></span><br><span class="line">su &#123;user&#125;           <span class="comment"># 切换到某用户</span></span><br><span class="line">su -&#123;user&#125;          <span class="comment"># 切换到某用户并登陆（执行登陆脚本）</span></span><br><span class="line">id &#123;user&#125;           <span class="comment"># 查看用户的 uid，gid 以及所属其他用户组</span></span><br><span class="line">id -u &#123;user&#125;        <span class="comment"># 打印用户 uid</span></span><br><span class="line">id -g &#123;user&#125;        <span class="comment"># 打印用户 gid</span></span><br><span class="line">write &#123;user&#125;        <span class="comment"># 向某用户发送一句消息</span></span><br><span class="line">last                <span class="comment"># 显示最近用户登陆列表</span></span><br><span class="line">last &#123;user&#125;         <span class="comment"># 显示登陆记录</span></span><br><span class="line">lastb               <span class="comment"># 显示失败登陆记录</span></span><br><span class="line">lastlog             <span class="comment"># 显示所有用户的最近登陆记录</span></span><br><span class="line">sudo &#123;<span class="built_in">command</span>&#125;      <span class="comment"># 以 root 权限执行某命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 进程管理</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">ps                        <span class="comment"># 查看当前会话进程</span></span><br><span class="line">ps ax                     <span class="comment"># 查看所有进程，类似 ps -e</span></span><br><span class="line">ps aux                    <span class="comment"># 查看所有进程详细信息，类似 ps -ef</span></span><br><span class="line">ps auxww                  <span class="comment"># 查看所有进程，并且显示进程的完整启动命令</span></span><br><span class="line">ps -u &#123;user&#125;              <span class="comment"># 查看某用户进程</span></span><br><span class="line">ps axjf                   <span class="comment"># 列出进程树</span></span><br><span class="line">ps xjf -u &#123;user&#125;          <span class="comment"># 列出某用户的进程树</span></span><br><span class="line">ps -eo pid,user,<span class="built_in">command</span>   <span class="comment"># 按用户指定的格式查看进程</span></span><br><span class="line">ps aux | grep httpd       <span class="comment"># 查看名为 httpd 的所有进程</span></span><br><span class="line">ps --ppid &#123;pid&#125;           <span class="comment"># 查看父进程为 pid 的所有进程</span></span><br><span class="line">pstree                    <span class="comment"># 树形列出所有进程，pstree 默认一般不带，需安装</span></span><br><span class="line">pstree &#123;user&#125;             <span class="comment"># 进程树列出某用户的进程</span></span><br><span class="line">pstree -u                 <span class="comment"># 树形列出所有进程以及所属用户</span></span><br><span class="line">pgrep &#123;procname&#125;          <span class="comment"># 搜索名字匹配的进程的 pid，比如 pgrep apache2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> &#123;pid&#125;                <span class="comment"># 结束进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 &#123;pid&#125;             <span class="comment"># 强制结束进程，9/SIGKILL 是强制不可捕获结束信号</span></span><br><span class="line"><span class="built_in">kill</span> -KILL &#123;pid&#125;          <span class="comment"># 强制执行进程，kill -9 的另外一种写法</span></span><br><span class="line"><span class="built_in">kill</span> -l                   <span class="comment"># 查看所有信号</span></span><br><span class="line"><span class="built_in">kill</span> -l TERM              <span class="comment"># 查看 TERM 信号的编号</span></span><br><span class="line">killall &#123;procname&#125;        <span class="comment"># 按名称结束所有进程</span></span><br><span class="line">pkill &#123;procname&#125;          <span class="comment"># 按名称结束进程，除名称外还可以有其他参数</span></span><br><span class="line"></span><br><span class="line">top                       <span class="comment"># 查看最活跃的进程</span></span><br><span class="line">top -u &#123;user&#125;             <span class="comment"># 查看某用户最活跃的进程</span></span><br><span class="line"></span><br><span class="line">any_command &amp;             <span class="comment"># 在后台运行某命令，也可用 CTRL+Z 将当前进程挂到后台</span></span><br><span class="line"><span class="built_in">jobs</span>                      <span class="comment"># 查看所有后台进程（jobs）</span></span><br><span class="line"><span class="built_in">bg</span>                        <span class="comment"># 查看后台进程，并切换过去</span></span><br><span class="line"><span class="built_in">fg</span>                        <span class="comment"># 切换后台进程到前台</span></span><br><span class="line"><span class="built_in">fg</span> &#123;job&#125;                  <span class="comment"># 切换特定后台进程到前台</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> cmd sig1 sig2        <span class="comment"># 在脚本中设置信号处理命令</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;&quot;</span> sig1 sig2         <span class="comment"># 在脚本中屏蔽某信号</span></span><br><span class="line"><span class="built_in">trap</span> - sig1 sig2          <span class="comment"># 恢复默认信号处理行为</span></span><br><span class="line"></span><br><span class="line">nohup &#123;<span class="built_in">command</span>&#125;           <span class="comment"># 长期运行某程序，在你退出登陆都保持它运行</span></span><br><span class="line">nohup &#123;<span class="built_in">command</span>&#125; &amp;         <span class="comment"># 在后台长期运行某程序</span></span><br><span class="line"><span class="built_in">disown</span> &#123;PID|JID&#125;          <span class="comment"># 将进程从后台任务列表（jobs）移除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span>                      <span class="comment"># 等待所有后台进程任务结束</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 常用命令：SSH / 系统信息 / 网络</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">ssh user@host             <span class="comment"># 以用户 user 登陆到远程主机 host</span></span><br><span class="line">ssh -p &#123;port&#125; user@host   <span class="comment"># 指定端口登陆主机</span></span><br><span class="line">ssh-copy-id user@host     <span class="comment"># 拷贝你的 ssh key 到远程主机，避免重复输入密码</span></span><br><span class="line">scp &#123;fn&#125; user@host:path   <span class="comment"># 拷贝文件到远程主机</span></span><br><span class="line">scp user@host:path dest   <span class="comment"># 从远程主机拷贝文件回来</span></span><br><span class="line">scp -P &#123;port&#125; ...         <span class="comment"># 指定端口远程拷贝文件</span></span><br><span class="line"></span><br><span class="line">uname -a                  <span class="comment"># 查看内核版本等信息</span></span><br><span class="line">man &#123;<span class="built_in">help</span>&#125;                <span class="comment"># 查看帮助</span></span><br><span class="line">man -k &#123;keyword&#125;          <span class="comment"># 查看哪些帮助文档里包含了该关键字</span></span><br><span class="line">info &#123;<span class="built_in">help</span>&#125;               <span class="comment"># 查看 info pages，比 man 更强的帮助系统</span></span><br><span class="line">uptime                    <span class="comment"># 查看系统启动时间</span></span><br><span class="line">date                      <span class="comment"># 显示日期</span></span><br><span class="line">cal                       <span class="comment"># 显示日历</span></span><br><span class="line">vmstat                    <span class="comment"># 显示内存和 CPU 使用情况</span></span><br><span class="line">vmstat 10                 <span class="comment"># 每 10 秒打印一行内存和 CPU情况，CTRL+C 退出</span></span><br><span class="line">free                      <span class="comment"># 显示内存和交换区使用情况</span></span><br><span class="line">df                        <span class="comment"># 显示磁盘使用情况</span></span><br><span class="line">du                        <span class="comment"># 显示当前目录占用，du . --max-depth=2 可以指定深度</span></span><br><span class="line">uname                     <span class="comment"># 显示系统版本号</span></span><br><span class="line">hostname                  <span class="comment"># 显示主机名称</span></span><br><span class="line">showkey -a                <span class="comment"># 查看终端发送的按键编码</span></span><br><span class="line"></span><br><span class="line">ping &#123;host&#125;               <span class="comment"># ping 远程主机并显示结果，CTRL+C 退出</span></span><br><span class="line">ping -c N &#123;host&#125;          <span class="comment"># ping 远程主机 N 次</span></span><br><span class="line">traceroute &#123;host&#125;         <span class="comment"># 侦测路由连通情况</span></span><br><span class="line">mtr &#123;host&#125;                <span class="comment"># 高级版本 traceroute</span></span><br><span class="line">host &#123;domain&#125;             <span class="comment"># DNS 查询，&#123;domain&#125; 前面可加 -a 查看详细信息</span></span><br><span class="line">whois &#123;domain&#125;            <span class="comment"># 取得域名 whois 信息</span></span><br><span class="line">dig &#123;domain&#125;              <span class="comment"># 取得域名 dns 信息</span></span><br><span class="line">route -n                  <span class="comment"># 查看路由表</span></span><br><span class="line">netstat -a                <span class="comment"># 列出所有端口</span></span><br><span class="line">netstat -an               <span class="comment"># 查看所有连接信息，不解析域名</span></span><br><span class="line">netstat -anp              <span class="comment"># 查看所有连接信息，包含进程信息（需要 sudo）</span></span><br><span class="line">netstat -l                <span class="comment"># 查看所有监听的端口</span></span><br><span class="line">netstat -t                <span class="comment"># 查看所有 TCP 链接</span></span><br><span class="line">netstat -lntu             <span class="comment"># 显示所有正在监听的 TCP 和 UDP 信息</span></span><br><span class="line">netstat -lntup            <span class="comment"># 显示所有正在监听的 socket 及进程信息</span></span><br><span class="line">netstat -i                <span class="comment"># 显示网卡信息</span></span><br><span class="line">netstat -rn               <span class="comment"># 显示当前系统路由表，同 route -n</span></span><br><span class="line">ss -an                    <span class="comment"># 比 netstat -an 更快速更详细</span></span><br><span class="line">ss -s                     <span class="comment"># 统计 TCP 的 established, wait 等</span></span><br><span class="line"></span><br><span class="line">wget &#123;url&#125;                <span class="comment"># 下载文件，可加 --no-check-certificate 忽略 ssl 验证</span></span><br><span class="line">wget -qO- &#123;url&#125;           <span class="comment"># 下载文件并输出到标准输出（不保存）</span></span><br><span class="line">curl -sL &#123;url&#125;            <span class="comment"># 同 wget -qO- &#123;url&#125; 没有 wget 的时候使用</span></span><br><span class="line"></span><br><span class="line">sz &#123;file&#125;                 <span class="comment"># 发送文件到终端，zmodem 协议</span></span><br><span class="line">rz                        <span class="comment"># 接收终端发送过来的文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 变量操作</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">varname=value             <span class="comment"># 定义变量</span></span><br><span class="line">varname=value <span class="built_in">command</span>     <span class="comment"># 定义子进程变量并执行子进程</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$varname</span>             <span class="comment"># 查看变量内容</span></span><br><span class="line"><span class="built_in">echo</span> $$                   <span class="comment"># 查看当前 shell 的进程号</span></span><br><span class="line"><span class="built_in">echo</span> $!                   <span class="comment"># 查看最近调用的后台任务进程号</span></span><br><span class="line"><span class="built_in">echo</span> $?                   <span class="comment"># 查看最近一条命令的返回码</span></span><br><span class="line"><span class="built_in">export</span> VARNAME=value      <span class="comment"># 设置环境变量（将会影响到子进程）</span></span><br><span class="line"></span><br><span class="line">array[0]=valA             <span class="comment"># 定义数组</span></span><br><span class="line">array[1]=valB</span><br><span class="line">array[2]=valC</span><br><span class="line">array=([0]=valA [1]=valB [2]=valC)   <span class="comment"># 另一种方式</span></span><br><span class="line">array=(valA valB valC)               <span class="comment"># 另一种方式</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;array[i]&#125;</span>               <span class="comment"># 取得数组中的元素</span></span><br><span class="line"><span class="variable">$&#123;#array[@]&#125;</span>              <span class="comment"># 取得数组的长度</span></span><br><span class="line"><span class="variable">$&#123;#array[i]&#125;</span>              <span class="comment"># 取得数组中某个变量的长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> -a                <span class="comment"># 查看所有数组</span></span><br><span class="line"><span class="built_in">declare</span> -f                <span class="comment"># 查看所有函数</span></span><br><span class="line"><span class="built_in">declare</span> -F                <span class="comment"># 查看所有函数，仅显示函数名</span></span><br><span class="line"><span class="built_in">declare</span> -i                <span class="comment"># 查看所有整数</span></span><br><span class="line"><span class="built_in">declare</span> -r                <span class="comment"># 查看所有只读变量</span></span><br><span class="line"><span class="built_in">declare</span> -x                <span class="comment"># 查看所有被导出成环境变量的东西</span></span><br><span class="line"><span class="built_in">declare</span> -p varname        <span class="comment"># 输出变量是怎么定义的（类型+值）</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;varname:-word&#125;</span>          <span class="comment"># 如果变量不为空则返回变量，否则返回 word</span></span><br><span class="line"><span class="variable">$&#123;varname:=word&#125;</span>          <span class="comment"># 如果变量不为空则返回变量，否则赋值成 word 并返回</span></span><br><span class="line"><span class="variable">$&#123;varname:?message&#125;</span>       <span class="comment"># 如果变量不为空则返回变量，否则打印错误信息并退出</span></span><br><span class="line"><span class="variable">$&#123;varname:+word&#125;</span>          <span class="comment"># 如果变量不为空则返回 word，否则返回 null</span></span><br><span class="line"><span class="variable">$&#123;varname:offset:len&#125;</span>     <span class="comment"># 取得字符串的子字符串</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;variable#pattern&#125;</span>       <span class="comment"># 如果变量头部匹配 pattern，则删除最小匹配部分返回剩下的</span></span><br><span class="line"><span class="variable">$&#123;variable##pattern&#125;</span>      <span class="comment"># 如果变量头部匹配 pattern，则删除最大匹配部分返回剩下的</span></span><br><span class="line"><span class="variable">$&#123;variable%pattern&#125;</span>       <span class="comment"># 如果变量尾部匹配 pattern，则删除最小匹配部分返回剩下的</span></span><br><span class="line"><span class="variable">$&#123;variable%%pattern&#125;</span>      <span class="comment"># 如果变量尾部匹配 pattern，则删除最大匹配部分返回剩下的</span></span><br><span class="line"><span class="variable">$&#123;variable/pattern/str&#125;</span>   <span class="comment"># 将变量中第一个匹配 pattern 的替换成 str，并返回</span></span><br><span class="line"><span class="variable">$&#123;variable//pattern/str&#125;</span>  <span class="comment"># 将变量中所有匹配 pattern 的地方替换成 str 并返回</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;#varname&#125;</span>               <span class="comment"># 返回字符串长度</span></span><br><span class="line"></span><br><span class="line">*(patternlist)            <span class="comment"># 零次或者多次匹配</span></span><br><span class="line">+(patternlist)            <span class="comment"># 一次或者多次匹配</span></span><br><span class="line">?(patternlist)            <span class="comment"># 零次或者一次匹配</span></span><br><span class="line">@(patternlist)            <span class="comment"># 单词匹配</span></span><br><span class="line">!(patternlist)            <span class="comment"># 不匹配</span></span><br><span class="line"></span><br><span class="line">array=(<span class="variable">$text</span>)             <span class="comment"># 按空格分隔 text 成数组，并赋值给变量</span></span><br><span class="line">IFS=<span class="string">&quot;/&quot;</span> array=(<span class="variable">$text</span>)     <span class="comment"># 按斜杆分隔字符串 text 成数组，并赋值给变量</span></span><br><span class="line">text=<span class="string">&quot;<span class="variable">$&#123;array[*]&#125;</span>&quot;</span>        <span class="comment"># 用空格链接数组并赋值给变量</span></span><br><span class="line">text=$(IFS=/; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;array[*]&#125;</span>&quot;</span>)  <span class="comment"># 用斜杠链接数组并赋值给变量</span></span><br><span class="line"></span><br><span class="line">A=( foo bar <span class="string">&quot;a  b c&quot;</span> 42 ) <span class="comment"># 数组定义</span></span><br><span class="line">B=(<span class="string">&quot;<span class="variable">$&#123;A[@]:1:2&#125;</span>&quot;</span>)         <span class="comment"># 数组切片：B=( bar &quot;a  b c&quot; )</span></span><br><span class="line">C=(<span class="string">&quot;<span class="variable">$&#123;A[@]:1&#125;</span>&quot;</span>)           <span class="comment"># 数组切片：C=( bar &quot;a  b c&quot; 42 )</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;B[@]&#125;</span>&quot;</span>            <span class="comment"># bar a  b c</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;B[1]&#125;</span>&quot;</span>            <span class="comment"># a  b c</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;C[@]&#125;</span>&quot;</span>            <span class="comment"># bar a  b c 42</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;C[@]: -2:2&#125;</span>&quot;</span>      <span class="comment"># a  b c 42  减号前的空格是必须的</span></span><br><span class="line"></span><br><span class="line">$(UNIX <span class="built_in">command</span>)           <span class="comment"># 运行命令，并将标准输出内容捕获并返回</span></span><br><span class="line">varname=$(id -u user)     <span class="comment"># 将用户名为 user 的 uid 赋值给 varname 变量</span></span><br><span class="line"></span><br><span class="line">num=$(expr 1 + 2)         <span class="comment"># 兼容 posix sh 的计算，使用 expr 命令计算结果</span></span><br><span class="line">num=$(expr <span class="variable">$num</span> + 1)      <span class="comment"># 数字自增</span></span><br><span class="line">expr 2 \* \( 2 + 3 \)     <span class="comment"># 兼容 posix sh 的复杂计算，输出 10</span></span><br><span class="line"></span><br><span class="line">num=$((<span class="number">1</span> + <span class="number">2</span>))            <span class="comment"># 计算 1+2 赋值给 num，使用 bash 独有的 $((..)) 计算</span></span><br><span class="line">num=$((<span class="variable">$num</span> + <span class="number">1</span>))         <span class="comment"># 变量递增</span></span><br><span class="line">num=$((num + <span class="number">1</span>))          <span class="comment"># 变量递增，双括号内的 $ 可以省略</span></span><br><span class="line">num=$((<span class="number">1</span> + (<span class="number">2</span> + <span class="number">3</span>) * <span class="number">2</span>))  <span class="comment"># 复杂计算</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 事件指示符</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">!!                  <span class="comment"># 上一条命令</span></span><br><span class="line">!^                  <span class="comment"># 上一条命令的第一个单词</span></span><br><span class="line">!:n                 <span class="comment"># 上一条命令的第n个单词</span></span><br><span class="line">!:n-$               <span class="comment"># 上一条命令的第n个单词到最后一个单词</span></span><br><span class="line">!$                  <span class="comment"># 上一条命令的最后一个单词</span></span><br><span class="line">!-n:$               <span class="comment"># 上n条命令的最后一个单词</span></span><br><span class="line">!string             <span class="comment"># 最近一条包含string的命令</span></span><br><span class="line">!^string1^string2   <span class="comment"># 最近一条包含string1的命令, 快速替换string1为string2</span></span><br><span class="line">!<span class="comment">#                  # 本条命令之前所有的输入内容</span></span><br><span class="line">!<span class="comment">#:n                # 本条命令之前的第n个单词, 快速备份cp /etc/passwd !#:1.bak</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个新函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">myfunc</span></span>() &#123;</span><br><span class="line">    <span class="comment"># $1 代表第一个参数，$N 代表第 N 个参数</span></span><br><span class="line">    <span class="comment"># $# 代表参数个数</span></span><br><span class="line">    <span class="comment"># $0 代表被调用者自身的名字</span></span><br><span class="line">    <span class="comment"># $@ 代表所有参数，类型是个数组，想传递所有参数给其他命令用 cmd &quot;$@&quot; </span></span><br><span class="line">    <span class="comment"># $* 空格链接起来的所有参数，类型是字符串</span></span><br><span class="line">    &#123;shell commands ...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myfunc                    <span class="comment"># 调用函数 myfunc </span></span><br><span class="line">myfunc arg1 arg2 arg3     <span class="comment"># 带参数的函数调用</span></span><br><span class="line">myfunc <span class="string">&quot;<span class="variable">$@</span>&quot;</span>               <span class="comment"># 将所有参数传递给函数</span></span><br><span class="line">myfunc <span class="string">&quot;<span class="variable">$&#123;array[@]&#125;</span>&quot;</span>      <span class="comment"># 将一个数组当作多个参数传递给函数</span></span><br><span class="line"><span class="built_in">shift</span>                     <span class="comment"># 参数左移</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> -f myfunc           <span class="comment"># 删除函数</span></span><br><span class="line"><span class="built_in">declare</span> -f                <span class="comment"># 列出函数定义</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 条件判断（兼容 posix sh 的条件判断）：man test</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">statement1 &amp;&amp; statement2  <span class="comment"># and 操作符</span></span><br><span class="line">statement1 || statement2  <span class="comment"># or 操作符</span></span><br><span class="line"></span><br><span class="line">exp1 -a exp2              <span class="comment"># exp1 和 exp2 同时为真时返回真（POSIX XSI扩展）</span></span><br><span class="line">exp1 -o exp2              <span class="comment"># exp1 和 exp2 有一个为真就返回真（POSIX XSI扩展）</span></span><br><span class="line">( expression )            <span class="comment"># 如果 expression 为真时返回真，输入注意括号前反斜杆</span></span><br><span class="line">! expression              <span class="comment"># 如果 expression 为假那返回真</span></span><br><span class="line"></span><br><span class="line">str1 = str2               <span class="comment"># 判断字符串相等，如 [ &quot;$x&quot; = &quot;$y&quot; ] &amp;&amp; echo yes</span></span><br><span class="line">str1 != str2              <span class="comment"># 判断字符串不等，如 [ &quot;$x&quot; != &quot;$y&quot; ] &amp;&amp; echo yes</span></span><br><span class="line">str1 &lt; str2               <span class="comment"># 字符串小于，如 [ &quot;$x&quot; \&lt; &quot;$y&quot; ] &amp;&amp; echo yes</span></span><br><span class="line">str2 &gt; str2               <span class="comment"># 字符串大于，注意 &lt; 或 &gt; 是字面量，输入时要加反斜杆</span></span><br><span class="line">-n str1                   <span class="comment"># 判断字符串不为空（长度大于零）</span></span><br><span class="line">-z str1                   <span class="comment"># 判断字符串为空（长度等于零）</span></span><br><span class="line"></span><br><span class="line">-a file                   <span class="comment"># 判断文件存在，如 [ -a /tmp/abc ] &amp;&amp; echo &quot;exists&quot;</span></span><br><span class="line">-d file                   <span class="comment"># 判断文件存在，且该文件是一个目录</span></span><br><span class="line">-e file                   <span class="comment"># 判断文件存在，和 -a 等价</span></span><br><span class="line">-f file                   <span class="comment"># 判断文件存在，且该文件是一个普通文件（非目录等）</span></span><br><span class="line">-r file                   <span class="comment"># 判断文件存在，且可读</span></span><br><span class="line">-s file                   <span class="comment"># 判断文件存在，且尺寸大于0</span></span><br><span class="line">-w file                   <span class="comment"># 判断文件存在，且可写</span></span><br><span class="line">-x file                   <span class="comment"># 判断文件存在，且执行</span></span><br><span class="line">-N file                   <span class="comment"># 文件上次修改过后还没有读取过</span></span><br><span class="line">-O file                   <span class="comment"># 文件存在且属于当前用户</span></span><br><span class="line">-G file                   <span class="comment"># 文件存在且匹配你的用户组</span></span><br><span class="line">file1 -nt file2           <span class="comment"># 文件1 比 文件2 新</span></span><br><span class="line">file1 -ot file2           <span class="comment"># 文件1 比 文件2 旧</span></span><br><span class="line"></span><br><span class="line">num1 -eq num2             <span class="comment"># 数字判断：num1 == num2</span></span><br><span class="line">num1 -ne num2             <span class="comment"># 数字判断：num1 != num2</span></span><br><span class="line">num1 -lt num2             <span class="comment"># 数字判断：num1 &lt; num2</span></span><br><span class="line">num1 -le num2             <span class="comment"># 数字判断：num1 &lt;= num2</span></span><br><span class="line">num1 -gt num2             <span class="comment"># 数字判断：num1 &gt; num2</span></span><br><span class="line">num1 -ge num2             <span class="comment"># 数字判断：num1 &gt;= num2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 分支控制：if 和经典 test，兼容 posix sh 的条件判断语句</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> &#123;expression&#125;         <span class="comment"># 判断条件为真的话 test 程序返回0 否则非零</span></span><br><span class="line">[ expression ]            <span class="comment"># 判断条件为真的话返回0 否则非零</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> <span class="string">&quot;abc&quot;</span> = <span class="string">&quot;def&quot;</span>        <span class="comment"># 查看返回值 echo $? 显示 1，因为条件为假</span></span><br><span class="line"><span class="built_in">test</span> <span class="string">&quot;abc&quot;</span> != <span class="string">&quot;def&quot;</span>       <span class="comment"># 查看返回值 echo $? 显示 0，因为条件为真</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> -a /tmp; <span class="built_in">echo</span> $?     <span class="comment"># 调用 test 判断 /tmp 是否存在，并打印 test 的返回值</span></span><br><span class="line">[ -a /tmp ]; <span class="built_in">echo</span> $?      <span class="comment"># 和上面完全等价，/tmp 肯定是存在的，所以输出是 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> cond &amp;&amp; cmd1         <span class="comment"># 判断条件为真时执行 cmd1</span></span><br><span class="line">[ cond ] &amp;&amp; cmd1          <span class="comment"># 和上面完全等价</span></span><br><span class="line">[ cond ] &amp;&amp; cmd1 || cmd2  <span class="comment"># 条件为真执行 cmd1 否则执行 cmd2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断 /etc/passwd 文件是否存在</span></span><br><span class="line"><span class="comment"># 经典的 if 语句就是判断后面的命令返回值为0的话，认为条件为真，否则为假</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -e /etc/passwd; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;alright it exists ... &quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;it doesn&#x27;t exist ... &quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和上面完全等价，[ 是个和 test 一样的可执行程序，但最后一个参数必须为 ]</span></span><br><span class="line"><span class="comment"># 这个名字为 &quot;[&quot; 的可执行程序一般就在 /bin 或 /usr/bin 下面，比 test 优雅些</span></span><br><span class="line"><span class="keyword">if</span> [ -e /etc/passwd ]; <span class="keyword">then</span>   </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;alright it exists ... &quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;it doesn&#x27;t exist ... &quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和上面两个完全等价，其实到 bash 时代 [ 已经是内部命令了，用 enable 可以看到</span></span><br><span class="line">[ -e /etc/passwd ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;alright it exists&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;it doesn&#x27;t exist&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断变量的值</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$varname</span>&quot;</span> = <span class="string">&quot;foo&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;this is foo&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$varname</span>&quot;</span> = <span class="string">&quot;bar&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;this is bar&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;neither&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复杂条件判断，注意 || 和 &amp;&amp; 是完全兼容 POSIX 的推荐写法</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$x</span> -gt 10 ] &amp;&amp; [ <span class="variable">$x</span> -lt 20 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;yes, between 10 and 20&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用 &amp;&amp; 命令连接符来做和上面完全等价的事情</span></span><br><span class="line">[ <span class="variable">$x</span> -gt 10 ] &amp;&amp; [ <span class="variable">$x</span> -lt 20 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes, between 10 and 20&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 小括号和 -a -o 是 POSIX XSI 扩展写法，小括号是字面量，输入时前面要加反斜杆</span></span><br><span class="line"><span class="keyword">if</span> [ \( <span class="variable">$x</span> -gt 10 \) -a \( <span class="variable">$x</span> -lt 20 \) ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;yes, between 10 and 20&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样可以用 &amp;&amp; 命令连接符来做和上面完全等价的事情</span></span><br><span class="line">[ \( <span class="variable">$x</span> -gt 10 \) -a \( <span class="variable">$x</span> -lt 20 \) ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes, between 10 and 20&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断程序存在的话就执行</span></span><br><span class="line">[ -x /bin/ls ] &amp;&amp; /bin/ls -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不考虑兼容 posix sh 和 dash 这些的话，可用 bash 独有的 ((..)) 和 [[..]]:</span></span><br><span class="line">https://www.ibm.com/developerworks/library/l-bash-test/index.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 流程控制：while / for / case / until </span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># while 循环</span></span><br><span class="line"><span class="keyword">while</span> condition; <span class="keyword">do</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 10 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span>; </span><br><span class="line">    i=$(expr <span class="variable">$i</span> + 1)</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for 循环：上面的 while 语句等价</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10&#125;; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name [<span class="keyword">in</span> list]; <span class="keyword">do</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for 列举某目录下面的所有文件</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> /home/*; <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$f</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bash 独有的 (( .. )) 语句，更接近 C 语言，但是不兼容 posix sh</span></span><br><span class="line"><span class="keyword">for</span> (( initialisation ; ending condition ; update )); <span class="keyword">do</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和上面的写法等价</span></span><br><span class="line"><span class="keyword">for</span> ((i = 0; i &lt; 10; i++)); <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># case 判断</span></span><br><span class="line"><span class="keyword">case</span> expression <span class="keyword">in</span> </span><br><span class="line">    pattern1 )</span><br><span class="line">        statements ;;</span><br><span class="line">    pattern2 )</span><br><span class="line">        statements ;;</span><br><span class="line">    * )</span><br><span class="line">        otherwise ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># until 语句</span></span><br><span class="line">until condition; <span class="keyword">do</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># select 语句</span></span><br><span class="line">select name [<span class="keyword">in</span> list]; <span class="keyword">do</span></span><br><span class="line">  statements that can use <span class="variable">$name</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 命令处理</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> ls                         <span class="comment"># 忽略 alias 直接执行程序或者内建命令 ls</span></span><br><span class="line"><span class="built_in">builtin</span> <span class="built_in">cd</span>                         <span class="comment"># 忽略 alias 直接运行内建的 cd 命令</span></span><br><span class="line"><span class="built_in">enable</span>                             <span class="comment"># 列出所有 bash 内置命令，或禁止某命令</span></span><br><span class="line"><span class="built_in">help</span> &#123;builtin_command&#125;             <span class="comment"># 查看内置命令的帮助（仅限 bash 内置命令）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span> <span class="variable">$script</span>                       <span class="comment"># 对 script 变量中的字符串求值（执行）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 输出/输入 重定向</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">cmd1 | cmd2                        <span class="comment"># 管道，cmd1 的标准输出接到 cmd2 的标准输入</span></span><br><span class="line">&lt; file                             <span class="comment"># 将文件内容重定向为命令的标准输入</span></span><br><span class="line">&gt; file                             <span class="comment"># 将命令的标准输出重定向到文件，会覆盖文件</span></span><br><span class="line">&gt;&gt; file                            <span class="comment"># 将命令的标准输出重定向到文件，追加不覆盖</span></span><br><span class="line">&gt;| file                            <span class="comment"># 强制输出到文件，即便设置过：set -o noclobber</span></span><br><span class="line">n&gt;| file                           <span class="comment"># 强制将文件描述符 n的输出重定向到文件</span></span><br><span class="line">&lt;&gt; file                            <span class="comment"># 同时使用该文件作为标准输入和标准输出</span></span><br><span class="line">n&lt;&gt; file                           <span class="comment"># 同时使用文件作为文件描述符 n 的输出和输入</span></span><br><span class="line">n&gt; file                            <span class="comment"># 重定向文件描述符 n 的输出到文件</span></span><br><span class="line">n&lt; file                            <span class="comment"># 重定向文件描述符 n 的输入为文件内容</span></span><br><span class="line">n&gt;&amp;                                <span class="comment"># 将标准输出 dup/合并 到文件描述符 n</span></span><br><span class="line">n&lt;&amp;                                <span class="comment"># 将标准输入 dump/合并 定向为描述符 n</span></span><br><span class="line">n&gt;&amp;m                               <span class="comment"># 文件描述符 n 被作为描述符 m 的副本，输出用</span></span><br><span class="line">n&lt;&amp;m                               <span class="comment"># 文件描述符 n 被作为描述符 m 的副本，输入用</span></span><br><span class="line">&amp;&gt;file                             <span class="comment"># 将标准输出和标准错误重定向到文件</span></span><br><span class="line">&lt;&amp;-                                <span class="comment"># 关闭标准输入</span></span><br><span class="line">&gt;&amp;-                                <span class="comment"># 关闭标准输出</span></span><br><span class="line">n&gt;&amp;-                               <span class="comment"># 关闭作为输出的文件描述符 n</span></span><br><span class="line">n&lt;&amp;-                               <span class="comment"># 关闭作为输入的文件描述符 n</span></span><br><span class="line">diff &lt;(cmd1) &lt;(cmd2)               <span class="comment"># 比较两个命令的输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 文本处理 - cut</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">cut -c 1-16                        <span class="comment"># 截取每行头16个字符</span></span><br><span class="line">cut -c 1-16 file                   <span class="comment"># 截取指定文件中每行头 16个字符</span></span><br><span class="line">cut -c3-                           <span class="comment"># 截取每行从第三个字符开始到行末的内容</span></span><br><span class="line">cut -d<span class="string">&#x27;:&#x27;</span> -f5                      <span class="comment"># 截取用冒号分隔的第五列内容</span></span><br><span class="line">cut -d<span class="string">&#x27;;&#x27;</span> -f2,10                   <span class="comment"># 截取用分号分隔的第二和第十列内容</span></span><br><span class="line">cut -d<span class="string">&#x27; &#x27;</span> -f3-7                    <span class="comment"># 截取空格分隔的三到七列</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> | cut -c1-3           <span class="comment"># 显示 hel</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello sir&quot;</span> | cut -d<span class="string">&#x27; &#x27;</span> -f2   <span class="comment"># 显示 sir</span></span><br><span class="line">ps | tr -s <span class="string">&quot; &quot;</span> | cut -d <span class="string">&quot; &quot;</span> -f 2,3,4  <span class="comment"># cut 搭配 tr 压缩字符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 文本处理 - awk / sed </span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> file              <span class="comment"># 打印文件中以空格分隔的第五列</span></span><br><span class="line">awk -F <span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> file       <span class="comment"># 打印文件中以逗号分隔的第五列</span></span><br><span class="line">awk <span class="string">&#x27;/str/ &#123;print $2&#125;&#x27;</span> file        <span class="comment"># 打印文件中包含 str 的所有行的第二列</span></span><br><span class="line">awk -F <span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> file      <span class="comment"># 打印逗号分隔的文件中的每行最后一列 </span></span><br><span class="line">awk <span class="string">&#x27;&#123;s+=$1&#125; END &#123;print s&#125;&#x27;</span> file   <span class="comment"># 计算所有第一列的合</span></span><br><span class="line">awk <span class="string">&#x27;NR%3==1&#x27;</span> file                 <span class="comment"># 从第一行开始，每隔三行打印一行</span></span><br><span class="line"></span><br><span class="line">sed <span class="string">&#x27;s/find/replace/&#x27;</span> file         <span class="comment"># 替换文件中首次出现的字符串并输出结果 </span></span><br><span class="line">sed <span class="string">&#x27;10s/find/replace/&#x27;</span> file       <span class="comment"># 替换文件第 10 行内容</span></span><br><span class="line">sed <span class="string">&#x27;10,20s/find/replace/&#x27;</span> file    <span class="comment"># 替换文件中 10-20 行内容</span></span><br><span class="line">sed -r <span class="string">&#x27;s/regex/replace/g&#x27;</span> file    <span class="comment"># 替换文件中所有出现的字符串</span></span><br><span class="line">sed -i <span class="string">&#x27;s/find/replace/g&#x27;</span> file     <span class="comment"># 替换文件中所有出现的字符并且覆盖文件</span></span><br><span class="line">sed -i <span class="string">&#x27;/find/i\newline&#x27;</span> file      <span class="comment"># 在文件的匹配文本前插入行</span></span><br><span class="line">sed -i <span class="string">&#x27;/find/a\newline&#x27;</span> file      <span class="comment"># 在文件的匹配文本后插入行</span></span><br><span class="line">sed <span class="string">&#x27;/line/s/find/replace/&#x27;</span> file   <span class="comment"># 先搜索行特征再执行替换</span></span><br><span class="line">sed -e <span class="string">&#x27;s/f/r/&#x27;</span> -e <span class="string">&#x27;s/f/r&#x27;</span> file    <span class="comment"># 执行多次替换</span></span><br><span class="line">sed <span class="string">&#x27;s#find#replace#&#x27;</span> file         <span class="comment"># 使用 # 替换 / 来避免 pattern 中有斜杆</span></span><br><span class="line">sed -i -r <span class="string">&#x27;s/^\s+//g&#x27;</span> file         <span class="comment"># 删除文件每行头部空格</span></span><br><span class="line">sed <span class="string">&#x27;/^$/d&#x27;</span> file                   <span class="comment"># 删除文件空行并打印</span></span><br><span class="line">sed -i <span class="string">&#x27;s/\s\+$//&#x27;</span> file            <span class="comment"># 删除文件每行末尾多余空格</span></span><br><span class="line">sed -n <span class="string">&#x27;2p&#x27;</span> file                   <span class="comment"># 打印文件第二行</span></span><br><span class="line">sed -n <span class="string">&#x27;2,5p&#x27;</span> file                 <span class="comment"># 打印文件第二到第五行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 排序 - sort</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">sort file                          <span class="comment"># 排序文件</span></span><br><span class="line">sort -r file                       <span class="comment"># 反向排序（降序）</span></span><br><span class="line">sort -n file                       <span class="comment"># 使用数字而不是字符串进行比较</span></span><br><span class="line">sort -t: -k 3n /etc/passwd         <span class="comment"># 按 passwd 文件的第三列进行排序</span></span><br><span class="line">sort -u file                       <span class="comment"># 去重排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 快速跳转 - https://github.com/rupa/z</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /path/to/z.sh               <span class="comment"># .bashrc 中初始化 z.sh</span></span><br><span class="line">z                                  <span class="comment"># 列出所有历史路径以及他们的权重</span></span><br><span class="line">z foo                              <span class="comment"># 跳到历史路径中匹配 foo 的权重最大的目录</span></span><br><span class="line">z foo bar                          <span class="comment"># 跳到历史路径中匹配 foo 和 bar 权重最大的目录</span></span><br><span class="line">z -l foo                           <span class="comment"># 列出所有历史路径中匹配 foo 的目录及权重</span></span><br><span class="line">z -r foo                           <span class="comment"># 按照最高访问次数优先进行匹配跳转</span></span><br><span class="line">z -t foo                           <span class="comment"># 按照最近访问优先进行匹配跳转</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 键盘绑定</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bind</span> <span class="string">&#x27;&quot;\eh&quot;:&quot;\C-b&quot;&#x27;</span>                <span class="comment"># 绑定 ALT+h 为光标左移，同 CTRL+b / &lt;Left&gt;</span></span><br><span class="line"><span class="built_in">bind</span> <span class="string">&#x27;&quot;\el&quot;:&quot;\C-f&quot;&#x27;</span>                <span class="comment"># 绑定 ALT+l 为光标右移，同 CTRL+f / &lt;Right&gt;</span></span><br><span class="line"><span class="built_in">bind</span> <span class="string">&#x27;&quot;\ej&quot;:&quot;\C-n&quot;&#x27;</span>                <span class="comment"># 绑定 ALT+j 为下条历史，同 CTRL+n / &lt;Down&gt;</span></span><br><span class="line"><span class="built_in">bind</span> <span class="string">&#x27;&quot;\ek&quot;:&quot;\C-p&quot;&#x27;</span>                <span class="comment"># 绑定 ALT+k 为上条历史，同 CTRL+p / &lt;Up&gt;</span></span><br><span class="line"><span class="built_in">bind</span> <span class="string">&#x27;&quot;\eH&quot;:&quot;\eb&quot;&#x27;</span>                 <span class="comment"># 绑定 ALT+H 为光标左移一个单词，同 ALT-b </span></span><br><span class="line"><span class="built_in">bind</span> <span class="string">&#x27;&quot;\eL&quot;:&quot;\ef&quot;&#x27;</span>                 <span class="comment"># 绑定 ALT+L 为光标右移一个单词，同 ALT-f </span></span><br><span class="line"><span class="built_in">bind</span> <span class="string">&#x27;&quot;\eJ&quot;:&quot;\C-a&quot;&#x27;</span>                <span class="comment"># 绑定 ALT+J 为移动到行首，同 CTRL+a / &lt;Home&gt;</span></span><br><span class="line"><span class="built_in">bind</span> <span class="string">&#x27;&quot;\eK&quot;:&quot;\C-e&quot;&#x27;</span>                <span class="comment"># 绑定 ALT+K 为移动到行末，同 CTRL+e / &lt;End&gt;</span></span><br><span class="line"><span class="built_in">bind</span> <span class="string">&#x27;&quot;\e;&quot;:&quot;ls -l\n&quot;&#x27;</span>             <span class="comment"># 绑定 ALT+; 为执行 ls -l 命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 网络管理：ip / ifconfig / nmap ...</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">ip a                               <span class="comment"># 显示所有网络地址，同 ip address</span></span><br><span class="line">ip a show eth1                     <span class="comment"># 显示网卡 IP 地址</span></span><br><span class="line">ip a add 172.16.1.23/24 dev eth1   <span class="comment"># 添加网卡 IP 地址</span></span><br><span class="line">ip a del 172.16.1.23/24 dev eth1   <span class="comment"># 删除网卡 IP 地址</span></span><br><span class="line">ip link show dev eth0              <span class="comment"># 显示网卡设备属性</span></span><br><span class="line">ip link <span class="built_in">set</span> eth1 up                <span class="comment"># 激活网卡</span></span><br><span class="line">ip link <span class="built_in">set</span> eth1 down              <span class="comment"># 关闭网卡</span></span><br><span class="line">ip link <span class="built_in">set</span> eth1 address &#123;mac&#125;     <span class="comment"># 修改 MAC 地址</span></span><br><span class="line">ip neighbour                       <span class="comment"># 查看 ARP 缓存</span></span><br><span class="line">ip route                           <span class="comment"># 查看路由表</span></span><br><span class="line">ip route add 10.1.0.0/24 via 10.0.0.253 dev eth0    <span class="comment"># 添加静态路由</span></span><br><span class="line">ip route del 10.1.0.0/24           <span class="comment"># 删除静态路由</span></span><br><span class="line"></span><br><span class="line">ifconfig                           <span class="comment"># 显示所有网卡和接口信息</span></span><br><span class="line">ifconfig -a                        <span class="comment"># 显示所有网卡（包括开机没启动的）信息</span></span><br><span class="line">ifconfig eth0                      <span class="comment"># 指定设备显示信息</span></span><br><span class="line">ifconfig eth0 up                   <span class="comment"># 激活网卡</span></span><br><span class="line">ifconfig eth0 down                 <span class="comment"># 关闭网卡</span></span><br><span class="line">ifconfig eth0 192.168.120.56       <span class="comment"># 给网卡配置 IP 地址</span></span><br><span class="line">ifconfig eth0 10.0.0.8 netmask 255.255.255.0 up     <span class="comment"># 配置 IP 并启动</span></span><br><span class="line">ifconfig eth0 hw ether 00:aa:bb:cc:dd:ee            <span class="comment"># 修改 MAC 地址</span></span><br><span class="line"></span><br><span class="line">nmap 10.0.0.12                     <span class="comment"># 扫描主机 1-1000 端口</span></span><br><span class="line">nmap -p 1024-65535 10.0.0.12       <span class="comment"># 扫描给定端口</span></span><br><span class="line">nmap 10.0.0.0/24                   <span class="comment"># 给定网段扫描局域网内所有主机</span></span><br><span class="line">nmap -O -sV 10.0.0.12              <span class="comment"># 探测主机服务和操作系统版本</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 有趣的命令</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">man hier                           <span class="comment"># 查看文件系统的结构和含义</span></span><br><span class="line">man <span class="built_in">test</span>                           <span class="comment"># 查看 posix sh 的条件判断帮助</span></span><br><span class="line">man ascii                          <span class="comment"># 显示 ascii 表</span></span><br><span class="line">getconf LONG_BIT                   <span class="comment"># 查看系统是 32 位还是 64 位</span></span><br><span class="line"><span class="built_in">bind</span> -P                            <span class="comment"># 列出所有 bash 的快捷键</span></span><br><span class="line">mount | column -t                  <span class="comment"># 漂亮的列出当前加载的文件系统</span></span><br><span class="line">curl ip.cn                         <span class="comment"># 取得外网 ip 地址和服务商信息</span></span><br><span class="line"><span class="built_in">disown</span> -a &amp;&amp; <span class="built_in">exit</span>                  <span class="comment"># 关闭所有后台任务并退出</span></span><br><span class="line">cat /etc/issue                     <span class="comment"># 查看 Linux 发行版信息</span></span><br><span class="line">lsof -i port:80                    <span class="comment"># 哪个程序在使用 80 端口？</span></span><br><span class="line">showkey -a                         <span class="comment"># 取得按键的 ASCII 码</span></span><br><span class="line">svn diff | view -                  <span class="comment"># 使用 Vim 来显示带色彩的 diff 输出</span></span><br><span class="line">mv filename.&#123;old,new&#125;              <span class="comment"># 快速文件改名</span></span><br><span class="line">time <span class="built_in">read</span>                          <span class="comment"># 使用 CTRL-D 停止，最简单的计时功能</span></span><br><span class="line">cp file.txt&#123;,.bak&#125;                 <span class="comment"># 快速备份文件</span></span><br><span class="line">sudo touch /forcefsck              <span class="comment"># 强制在下次重启时扫描磁盘</span></span><br><span class="line">find ~ -mmin 60 -<span class="built_in">type</span> f            <span class="comment"># 查找 $HOME 目录中，60 分钟内修改过的文件</span></span><br><span class="line">curl wttr.in/~beijing              <span class="comment"># 查看北京的天气预报</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;SSH_CLIENT%% *&#125;</span>             <span class="comment"># 取得你是从什么 IP 链接到当前主机上的</span></span><br><span class="line"><span class="built_in">echo</span> $[RANDOM%X+1]                 <span class="comment"># 取得 1 到 X 之间的随机数</span></span><br><span class="line"><span class="built_in">bind</span> -x <span class="string">&#x27;&quot;\C-l&quot;:ls -l&#x27;</span>             <span class="comment"># 设置 CTRL+l 为执行 ls -l 命令</span></span><br><span class="line">find / -<span class="built_in">type</span> f -size +5M           <span class="comment"># 查找大于 5M 的文件</span></span><br><span class="line">chmod --reference f1 f2            <span class="comment"># 将 f2 的权限设置成 f1 一模一样的</span></span><br><span class="line">curl -L cheat.sh                   <span class="comment"># 速查表大全</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 常用技巧</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出最常使用的命令</span></span><br><span class="line"><span class="built_in">history</span> | awk <span class="string">&#x27;&#123;a[$2]++&#125;END&#123;for(i in a)&#123;print a[i] &quot; &quot; i&#125;&#125;&#x27;</span> | sort -rn | head</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有网络状态：ESTABLISHED / TIME_WAIT / FIN_WAIT1 / FIN_WAIT2 </span></span><br><span class="line">netstat -n | awk <span class="string">&#x27;/^tcp/ &#123;++tt[$NF]&#125; END &#123;for (a in tt) print a, tt[a]&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 SSH 来 mount 文件系统</span></span><br><span class="line">sshfs name@server:/path/to/folder /path/to/mount/point</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示前十个运行的进程并按内存使用量排序</span></span><br><span class="line">ps aux | sort -nk +4 | tail</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在右上角显示时钟</span></span><br><span class="line"><span class="keyword">while</span> sleep 1;<span class="keyword">do</span> tput sc;tput cup 0 $(($(tput cols)-<span class="number">29</span>));date;tput rc;<span class="keyword">done</span>&amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从网络上的压缩文件中解出一个文件来，并避免保存中间文件</span></span><br><span class="line">wget -qO - <span class="string">&quot;http://www.tarball.com/tarball.gz&quot;</span> | tar zxvf -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 性能测试：测试处理器性能</span></span><br><span class="line">python -c <span class="string">&quot;import test.pystone;print(test.pystone.pystones())&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 性能测试：测试内存带宽</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/dev/null bs=1M count=32768</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux 下挂载一个 iso 文件</span></span><br><span class="line">mount /path/to/file.iso /mnt/cdrom -oloop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过主机 A 直接 ssh 到主机 B</span></span><br><span class="line">ssh -t hostA ssh hostB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个网站的所有图片</span></span><br><span class="line">wget -r -l1 --no-parent -nH -nd -P/tmp -A<span class="string">&quot;.gif,.jpg&quot;</span> http://example.com/images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速创建项目目录</span></span><br><span class="line">mkdir -p work/&#123;project1,project2&#125;/&#123;src,bin,bak&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按日期范围查找文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -newermt <span class="string">&quot;2010-01-01&quot;</span> ! -newermt <span class="string">&quot;2010-06-01&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前正在使用网络的进程</span></span><br><span class="line">lsof -P -i -n | cut -f 1 -d <span class="string">&quot; &quot;</span>| uniq | tail -n +2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Vim 中保存一个没有权限的文件</span></span><br><span class="line">:w !sudo tee &gt; /dev/null %</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 .bashrc / .bash_profile 中加载另外一个文件（比如你保存在 github 上的配置）</span></span><br><span class="line"><span class="built_in">source</span> ~/github/profiles/my_bash_init.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向代理：将外网主机（202.115.8.1）端口（8443）转发到内网主机 192.168.1.2:443</span></span><br><span class="line">ssh -CqTnN -R 0.0.0.0:8443:192.168.1.2:443  user@202.115.8.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正向代理：将本地主机的 8443 端口，通过 192.168.1.3 转发到 192.168.1.2:443 </span></span><br><span class="line">ssh -CqTnN -L 0.0.0.0:8443:192.168.1.2:443  user@192.168.1.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># socks5 代理：把本地 1080 端口的 socks5 的代理请求通过远程主机转发出去</span></span><br><span class="line">ssh -CqTnN -D localhost:1080  user@202.115.8.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终端下正确设置 ALT 键和 BackSpace 键</span></span><br><span class="line">http://www.skywind.me/blog/archives/2021</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 有用的函数</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动解压：判断文件后缀名并调用相应解压命令</span></span><br><span class="line"><span class="keyword">function</span> q-<span class="function"><span class="title">extract</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="variable">$1</span> ] ; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        *.tar.bz2)   tar -xvjf <span class="variable">$1</span>    ;;</span><br><span class="line">        *.tar.gz)    tar -xvzf <span class="variable">$1</span>    ;;</span><br><span class="line">        *.tar.xz)    tar -xvJf <span class="variable">$1</span>    ;;</span><br><span class="line">        *.bz2)       bunzip2 <span class="variable">$1</span>     ;;</span><br><span class="line">        *.rar)       rar x <span class="variable">$1</span>       ;;</span><br><span class="line">        *.gz)        gunzip <span class="variable">$1</span>      ;;</span><br><span class="line">        *.tar)       tar -xvf <span class="variable">$1</span>     ;;</span><br><span class="line">        *.tbz2)      tar -xvjf <span class="variable">$1</span>    ;;</span><br><span class="line">        *.tgz)       tar -xvzf <span class="variable">$1</span>    ;;</span><br><span class="line">        *.zip)       unzip <span class="variable">$1</span>       ;;</span><br><span class="line">        *.Z)         uncompress <span class="variable">$1</span>  ;;</span><br><span class="line">        *.7z)        7z x <span class="variable">$1</span>        ;;</span><br><span class="line">        *)           <span class="built_in">echo</span> <span class="string">&quot;don&#x27;t know how to extract &#x27;<span class="variable">$1</span>&#x27;...&quot;</span> ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$1</span>&#x27; is not a valid file!&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动压缩：判断后缀名并调用相应压缩程序</span></span><br><span class="line"><span class="keyword">function</span> q-<span class="function"><span class="title">compress</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">        FILE=<span class="variable">$1</span></span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$FILE</span> <span class="keyword">in</span></span><br><span class="line">        *.tar) <span class="built_in">shift</span> &amp;&amp; tar -cf <span class="variable">$FILE</span> $* ;;</span><br><span class="line">        *.tar.bz2) <span class="built_in">shift</span> &amp;&amp; tar -cjf <span class="variable">$FILE</span> $* ;;</span><br><span class="line">        *.tar.xz) <span class="built_in">shift</span> &amp;&amp; tar -cJf <span class="variable">$FILE</span> $* ;;</span><br><span class="line">        *.tar.gz) <span class="built_in">shift</span> &amp;&amp; tar -czf <span class="variable">$FILE</span> $* ;;</span><br><span class="line">        *.tgz) <span class="built_in">shift</span> &amp;&amp; tar -czf <span class="variable">$FILE</span> $* ;;</span><br><span class="line">        *.zip) <span class="built_in">shift</span> &amp;&amp; zip <span class="variable">$FILE</span> $* ;;</span><br><span class="line">        *.rar) <span class="built_in">shift</span> &amp;&amp; rar <span class="variable">$FILE</span> $* ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;usage: q-compress &lt;foo.tar.gz&gt; ./foo ./bar&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 漂亮的带语法高亮的 color cat ，需要先 pip install pygments</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ccat</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> style=<span class="string">&quot;monokai&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        pygmentize -P style=<span class="variable">$style</span> -P tabsize=4 -f terminal256 -g</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> NAME <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span></span><br><span class="line">            pygmentize -P style=<span class="variable">$style</span> -P tabsize=4 -f terminal256 -g <span class="string">&quot;<span class="variable">$NAME</span>&quot;</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># 好玩的配置</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 放到你的 ~/.bashrc 配置文件中，给 man 增加漂亮的色彩高亮</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_mb=$<span class="string">&#x27;\E[1m\E[32m&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_mh=$<span class="string">&#x27;\E[2m&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_mr=$<span class="string">&#x27;\E[7m&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_md=$<span class="string">&#x27;\E[1m\E[36m&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_ZW=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_us=$<span class="string">&#x27;\E[4m\E[1m\E[37m&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_me=$<span class="string">&#x27;\E(B\E[m&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_ue=$<span class="string">&#x27;\E[24m\E(B\E[m&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_ZO=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_ZN=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_se=$<span class="string">&#x27;\E[27m\E(B\E[m&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_ZV=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_so=$<span class="string">&#x27;\E[1m\E[33m\E[44m&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ALT+hjkl/HJKL 快速移动光标，将下面内容添加到 ~/.inputrc 中可作用所有工具，</span></span><br><span class="line"><span class="comment"># 包括 bash/zsh/python/lua 等使用 readline 的工具，帮助见：info rluserman</span></span><br><span class="line"><span class="string">&quot;\eh&quot;</span>: backward-char</span><br><span class="line"><span class="string">&quot;\el&quot;</span>: forward-char</span><br><span class="line"><span class="string">&quot;\ej&quot;</span>: next-history</span><br><span class="line"><span class="string">&quot;\ek&quot;</span>: previous-history</span><br><span class="line"><span class="string">&quot;\eH&quot;</span>: backward-word</span><br><span class="line"><span class="string">&quot;\eL&quot;</span>: forward-word</span><br><span class="line"><span class="string">&quot;\eJ&quot;</span>: beginning-of-line</span><br><span class="line"><span class="string">&quot;\eK&quot;</span>: end-of-line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"><span class="comment"># References</span></span><br><span class="line"><span class="comment">##############################################################################</span></span><br><span class="line"></span><br><span class="line">https://github.com/Idnan/bash-guide</span><br><span class="line">http://www.linuxstall.com/linux-command-line-tips-that-every-linux-user-should-know/</span><br><span class="line">https://ss64.com/bash/syntax-keyboard.html</span><br><span class="line">http://wiki.bash-hackers.org/commands/classictest</span><br><span class="line">https://www.ibm.com/developerworks/library/l-bash-test/index.html</span><br><span class="line">https://www.cyberciti.biz/faq/bash-loop-over-file/</span><br><span class="line">https://linuxconfig.org/bash-scripting-tutorial</span><br><span class="line">https://github.com/LeCoupa/awesome-cheatsheets/blob/master/languages/bash.sh</span><br><span class="line">https://devhints.io/bash</span><br><span class="line">https://github.com/jlevy/the-art-of-command-line</span><br><span class="line">https://yq.aliyun.com/articles/68541</span><br><span class="line"></span><br><span class="line"><span class="comment"># vim: set ts=4 sw=4 tw=0 et :</span></span><br></pre></td></tr></table></figure>

<h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a><code>Go</code></h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * Golang CHEATSHEET (中文速查表)  -  by chlins (created on 2018/02/14)</span></span><br><span class="line"><span class="comment"> * Version: 3, Last Modified: 2018/03/07 19:51</span></span><br><span class="line"><span class="comment"> * https://github.com/skywind3000/awesome-cheatsheets</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">  * Go 编译器命令</span></span><br><span class="line"><span class="comment">  *****************************************************************************/</span></span><br><span class="line"><span class="keyword">go</span> command [arguments]                              <span class="comment">// go 命令 [参数]</span></span><br><span class="line"><span class="keyword">go</span> build                                            <span class="comment">// 编译包和依赖包</span></span><br><span class="line"><span class="keyword">go</span> clean                                            <span class="comment">// 移除对象和缓存文件</span></span><br><span class="line"><span class="keyword">go</span> doc                                              <span class="comment">// 显示包的文档</span></span><br><span class="line"><span class="keyword">go</span> env                                              <span class="comment">// 打印go的环境变量信息</span></span><br><span class="line"><span class="keyword">go</span> bug                                              <span class="comment">// 报告bug</span></span><br><span class="line"><span class="keyword">go</span> fix                                              <span class="comment">// 更新包使用新的api</span></span><br><span class="line"><span class="keyword">go</span> fmt                                              <span class="comment">// 格式规范化代码</span></span><br><span class="line"><span class="keyword">go</span> generate                                         <span class="comment">// 通过处理资源生成go文件</span></span><br><span class="line"><span class="keyword">go</span> get                                              <span class="comment">// 下载并安装包及其依赖</span></span><br><span class="line"><span class="keyword">go</span> install                                          <span class="comment">// 编译和安装包及其依赖</span></span><br><span class="line"><span class="keyword">go</span> list                                             <span class="comment">// 列出所有包</span></span><br><span class="line"><span class="keyword">go</span> run                                              <span class="comment">// 编译和运行go程序</span></span><br><span class="line"><span class="keyword">go</span> test                                             <span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">go</span> tool                                             <span class="comment">// 运行给定的go工具</span></span><br><span class="line"><span class="keyword">go</span> version                                          <span class="comment">// 显示go当前版本</span></span><br><span class="line"><span class="keyword">go</span> vet                                              <span class="comment">// 发现代码中可能的错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * Hello World</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main                                        <span class="comment">// 包名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>                                        <span class="comment">// 导入fmt包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                                       <span class="comment">// 主函数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World&quot;</span>)                      <span class="comment">// 打印输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// go run main.go                                   // 直接运行</span></span><br><span class="line"><span class="comment">// go build &amp;&amp; ./main                               // 先编译成二进制文件再运行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * 操作符</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">// 算数操作符</span></span><br><span class="line">+ - * / %                                           <span class="comment">// 加 减 乘 除 取余</span></span><br><span class="line">&amp; | ^ &amp;^                                            <span class="comment">// 位与 位或 位异或 位与非</span></span><br><span class="line">&lt;&lt; &gt;&gt;                                               <span class="comment">// 左移 右移</span></span><br><span class="line"><span class="comment">// 比较操作</span></span><br><span class="line">== !=                                               <span class="comment">// 等于 不等于</span></span><br><span class="line">&lt; &lt;=                                                <span class="comment">// 小于 小于等于</span></span><br><span class="line">&gt; &gt;=                                                <span class="comment">// 大于 大于等于</span></span><br><span class="line"><span class="comment">// 逻辑操作</span></span><br><span class="line">&amp;&amp; || !                                             <span class="comment">// 逻辑与 逻辑或 逻辑非</span></span><br><span class="line"><span class="comment">// 其他</span></span><br><span class="line">&amp; * &lt;-                                              <span class="comment">// 地址 指针引用 通道操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * 声明</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line">a := <span class="number">1</span>                                              <span class="comment">// 直接给一个未声明的变量赋值</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span>                                           <span class="comment">// var 变量名 数据类型 来声明</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float64</span></span><br><span class="line"><span class="comment">// 注意：使用var声明过的变量不可再使用 := 赋值</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="number">1</span>                                         <span class="comment">// 常量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * 数据类型</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line">s := <span class="string">&quot;hello&quot;</span>                                       <span class="comment">// 字符</span></span><br><span class="line">a := <span class="number">1</span>                                             <span class="comment">// int</span></span><br><span class="line">b := <span class="number">1.2</span>                                           <span class="comment">// float64</span></span><br><span class="line">c := <span class="number">1</span> + <span class="number">5i</span>                                        <span class="comment">// complex128</span></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">arr1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;                           <span class="comment">// 手动指定长度</span></span><br><span class="line">arr2 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;                         <span class="comment">// 由golang自动计算长度</span></span><br><span class="line"><span class="comment">// 切片</span></span><br><span class="line">sliceInt := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;                           <span class="comment">// 不指定长度</span></span><br><span class="line">sliceByte := []<span class="keyword">byte</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line">a := <span class="number">1</span></span><br><span class="line">point := &amp;a                                      <span class="comment">// 将a的地址赋给point</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * 流程控制</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">// for</span></span><br><span class="line">i := <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(i--)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if else</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;i == 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;i != 10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;i == 10&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;i != 10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * 函数</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">// 以func关键字声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="built_in">println</span>(<span class="string">&quot;Lambdas function&quot;</span>)&#125;     <span class="comment">// 匿名函数</span></span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span> <span class="params">(a,b <span class="keyword">string</span>)</span></span> &#123;                    <span class="comment">// 函数多返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := get()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * 结构体</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">// golang中没有class只有struct</span></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">  Age <span class="keyword">int</span>                                  <span class="comment">// 大写开头的变量在包外可以访问</span></span><br><span class="line">  name <span class="keyword">string</span>                              <span class="comment">// 小写开头的变量仅可在本包内访问</span></span><br><span class="line">&#125;</span><br><span class="line">p1 := People&#123;<span class="number">25</span>, <span class="string">&quot;Kaven&quot;</span>&#125;                 <span class="comment">// 必须按照结构体内部定义的顺序</span></span><br><span class="line">p2 := People&#123;name: <span class="string">&quot;Kaven&quot;</span>, age: <span class="number">25</span>&#125;      <span class="comment">// 若不按顺序则需要指定字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以先不赋值</span></span><br><span class="line">p3 := <span class="built_in">new</span>(People)</span><br><span class="line">p3.Age = <span class="number">25</span></span><br><span class="line">p3.name = <span class="string">&quot;Kaven&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * 方法</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">// 方法通常是针对一个结构体来说的</span></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">                                        <span class="comment">// 值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">  f.a = <span class="number">1</span>                              <span class="comment">// 不会改变原来的值</span></span><br><span class="line">&#125;</span><br><span class="line">                                      <span class="comment">// 指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Foo)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">  f.a = <span class="number">1</span>                            <span class="comment">// 会改变原值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * go 协程</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;()                                <span class="comment">// 不会阻塞代码的运行 代码会直接向下运行</span></span><br><span class="line"><span class="comment">// channel 通道</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 两个协程间可以通过chan通信</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;c &lt;- <span class="number">1</span>&#125;()              <span class="comment">// 此时c会被阻塞 直到值被取走前都不可在塞入新值</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="built_in">println</span>(&lt;-c)&#125;()</span><br><span class="line"><span class="comment">// 带缓存的channel</span></span><br><span class="line">bc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;c &lt;- <span class="number">1</span>; c &lt;<span class="number">-2</span>&#125;()      <span class="comment">// c中可以存储声明时所定义的缓存大小的数据，这里是2个</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="built_in">println</span>(&lt;-c)&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * 接口</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">// go的接口为鸭子类型，即只要你实现了接口中的方法就实现了该接口</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reading()                  <span class="comment">// 仅需实现Reading方法就实现了该接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> As <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a As)</span> <span class="title">Reading</span><span class="params">()</span></span> &#123;&#125;      <span class="comment">// 实现了Reader接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bs <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bs)</span> <span class="title">Reading</span><span class="params">()</span></span> &#123;&#125;      <span class="comment">// 也实现了Reader接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bs)</span> <span class="title">Closing</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * 一些推荐</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">// 入门书籍</span></span><br><span class="line">《Go学习笔记》                <span class="comment">// 雨痕的</span></span><br><span class="line">《Go语言实战》                <span class="comment">// 强烈推荐</span></span><br><span class="line"><span class="comment">// 网上资料</span></span><br><span class="line">https:<span class="comment">//github.com/astaxie/build-web-application-with-golang    // 谢大的</span></span><br><span class="line">https:<span class="comment">//github.com/Unknwon/the-way-to-go_ZH_CN                  // 无闻</span></span><br><span class="line">https:<span class="comment">//github.com/Unknwon/go-fundamental-programming           // 无闻教学视频</span></span><br><span class="line"><span class="comment">// 第三方类库</span></span><br><span class="line">https:<span class="comment">//golanglibs.com/</span></span><br><span class="line"><span class="comment">// 大杂烩</span></span><br><span class="line">https:<span class="comment">//github.com/avelino/awesome-go</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * References</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line">https:<span class="comment">//github.com/a8m/go-lang-cheat-sheet</span></span><br><span class="line">https:<span class="comment">//github.com/LeCoupa/awesome-cheatsheets</span></span><br></pre></td></tr></table></figure>

<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a><code>Python</code></h1><p>===</p>
<ul>
<li>本手册是 <span class="exturl" data-url="aHR0cDovL2RhdGFzY2llbmNlZnJlZS5jb20vcHl0aG9uLnBkZg==">Python cheat sheet</span> 的中文翻译版。原作者：Arianne Colton and Sean Chen(<span class="exturl" data-url="bWFpbHRvOiYjeDY0OyYjeDYxOyYjMTE2OyYjeDYxOyYjNDY7JiN4NzM7JiN4NjM7JiN4Njk7JiN4NjU7JiN4NmU7JiMxMTY7JiMxMDU7JiN4NzM7JiN4NzQ7JiM0NjsmI3g2OTsmIzExMDsmIzEwMjsmI3g2ZjsmI3g0MDsmIzEwMzsmI3g2ZDsmI3g2MTsmI3g2OTsmI3g2YzsmIzQ2OyYjeDYzOyYjMTExOyYjeDZkOw==">&#x64;&#x61;&#116;&#x61;&#46;&#x73;&#x63;&#x69;&#x65;&#x6e;&#116;&#105;&#x73;&#x74;&#46;&#x69;&#110;&#102;&#x6f;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;</span>)</li>
</ul>
<h2 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h2><ul>
<li>Python 对大小写敏感</li>
<li>Python 的索引从 0 开始</li>
<li>Python 使用空白符（制表符或空格）来缩进代码，而不是使用花括号</li>
</ul>
<h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><ul>
<li>获取主页帮助：<code>help()</code></li>
<li>获取函数帮助：<code>help(str.replace)</code></li>
<li>获取模块帮助：<code>help(re)</code></li>
</ul>
<h3 id="模块-库"><a href="#模块-库" class="headerlink" title="模块(库)"></a>模块(库)</h3><p>Python的模块只是一个简单地以 <code>.py</code> 为后缀的文件。</p>
<ul>
<li>列出模块内容：<code>dir(module1)</code></li>
<li>导入模块：<code>import module</code></li>
<li>调用模块中的函数：<code>module1.func1()</code></li>
</ul>
<blockquote>
<p><strong>注</strong>：<code>import</code>语句会创建一个新的命名空间(namespace)，并且在该命名空间内执行<code>.py</code>文件中的所有语句。如果你想把模块内容导入到当前命名空间，请使用<code>from module1 import *</code>语句。</p>
</blockquote>
<h2 id="数值类类型"><a href="#数值类类型" class="headerlink" title="数值类类型"></a>数值类类型</h2><p>查看变量的数据类型：<code>type(variable)</code></p>
<h3 id="六种经常使用的数据类型"><a href="#六种经常使用的数据类型" class="headerlink" title="六种经常使用的数据类型"></a>六种经常使用的数据类型</h3><ol>
<li><p><strong>int/long</strong>：过大的 <code>int</code> 类型会被自动转化为 <code>long</code> 类型</p>
</li>
<li><p><strong>float</strong>：64 位，Python 中没有 <code>double</code> 类型</p>
</li>
<li><p><strong>bool</strong>：真或假</p>
</li>
<li><p><strong>str</strong>：在 Python 2 中默认以 ASCII 编码，而在 Python 3 中默认以 Unicode 编码</p>
<ul>
<li><p>字符串可置于单/双/三引号中</p>
</li>
<li><p>字符串是字符的序列，因此可以像处理其他序列一样处理字符串</p>
</li>
<li><p>特殊字符可通过 <code>\</code> 或者前缀 <code>r</code> 实现：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">r&#x27;this\f?ff&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符串可通过多种方式格式化：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">template = <span class="string">&#x27;%.2f %s haha $%d&#x27;</span>;</span><br><span class="line">str1 = template % (<span class="number">4.88</span>, <span class="string">&#x27;hola&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>NoneType(None)<strong>：Python “null”值（<code>None</code>对象</strong>只</strong>存在一个实例）</p>
<ul>
<li><p><code>None</code>不是一个保留关键字，而是<code>NoneType</code>的一个唯一实例</p>
</li>
<li><p><code>None</code>通常是可选函数参数的默认值：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">a, b, c=<span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>None</code>的常见用法：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> variable <span class="keyword">is</span> <span class="literal">None</span> :</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>datetime</strong>：Python内置的<code>datetime</code>模块提供了<code>datetime</code>、<code>data</code>以及<code>time</code>类型。</p>
<ul>
<li><code>datetime</code>组合了存储于<code>date</code>和<code>time</code>中的信息</li>
</ul>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从字符串中创建 datetime</span></span><br><span class="line">dt1 = datetime.strptime(<span class="string">&#x27;20091031&#x27;</span>, <span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取 date 对象</span></span><br><span class="line">dt1.date()</span><br><span class="line"><span class="comment"># 获取 time 对象</span></span><br><span class="line">dt1.time()</span><br><span class="line"><span class="comment"># 将 datetime 格式化为字符串</span></span><br><span class="line">dt1.strftime(<span class="string">&#x27;%m/%d/%Y%H:%M&#x27;</span>)</span><br><span class="line"><span class="comment"># 更改字段值</span></span><br><span class="line">dt2 = dt1.replace(minute=<span class="number">0</span>, second=<span class="number">30</span>)</span><br><span class="line"><span class="comment"># 做差, diff 是一个 datetime.timedelta 对象</span></span><br><span class="line">diff = dt1 - dt2</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>注</strong>：</p>
<ul>
<li><code>str</code>、<code>bool</code>、<code>int</code>和<code>float</code>同时也是显式类型转换函数。</li>
<li>除字符串和元组外，Python 中的绝大多数对象都是可变的。</li>
</ul>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote>
<p><strong>注</strong>：所有的“非只读(non-Get)”函数调用，比如下面例子中的<code>list1.sort()</code>，除非特别声明，都是原地操作(不会创建新的对象)。</p>
</blockquote>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组是 Python 中任何类型的对象的一个一维、固定长度、<strong>不可变</strong>的序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建元组</span></span><br><span class="line">tup1 = <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line">tup1 = (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment"># 创建嵌套元组</span></span><br><span class="line">tup1 = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment"># 将序列或迭代器转化为元组</span></span><br><span class="line"><span class="built_in">tuple</span>([<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 连接元组</span></span><br><span class="line">tup1 + tup2</span><br><span class="line"><span class="comment"># 解包元组</span></span><br><span class="line">a, b, c = tup1</span><br></pre></td></tr></table></figure>

<p><strong>元组应用</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 交换两个变量的值</span></span><br><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表是 Python 中任何类型的对象的一个一维、非固定长度、<strong>可变</strong>（比如内容可以被修改）的序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建列表</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>]</span><br><span class="line">list1 = <span class="built_in">list</span>(tup1)</span><br><span class="line"><span class="comment"># 连接列表</span></span><br><span class="line">list1 + list2</span><br><span class="line">list1.extend(list2)</span><br><span class="line"><span class="comment"># 追加到列表的末尾</span></span><br><span class="line">list1.append(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment"># 插入指定位置</span></span><br><span class="line">list1.insert(PosIndex, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># 反向插入，即弹出给定位置的值/删除</span></span><br><span class="line">ValueAtIdx = list1.pop(PosIndex)</span><br><span class="line"><span class="comment"># 移除列表中的第一个值, a 必须是列表中第一个值</span></span><br><span class="line">list1.remove(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># 检查成员</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> list1 =&gt; <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># 对列表进行排序</span></span><br><span class="line">list1.sort()</span><br><span class="line"><span class="comment"># 按特定方式排序</span></span><br><span class="line">list1.sort(key=<span class="built_in">len</span>) <span class="comment"># 按长度排序</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>使用 + 连接列表会有比较大的开支，因为这个过程中会创建一个新的列表，然后复制对象。因此，使用<code>extend()</code>是更明智的选择。</li>
<li><code>insert</code>和<code>append</code>相比会有更大的开支（时间/空间）。</li>
<li>在列表中检查是否包含一个值会比在字典和集合中慢很多，因为前者需要进行线性扫描，而后者是基于哈希表的，所以只需要花费常数时间。</li>
</ul>
</blockquote>
<h4 id="内置的bisect模块"><a href="#内置的bisect模块" class="headerlink" title="内置的bisect模块"></a>内置的<code>bisect</code>模块</h4><ul>
<li><p>对一个排序好的列表进行二分查找或插入</p>
</li>
<li><p><code>bisect.bisect</code>找到元素在列表中的位置，<code>bisect.insort</code>将元素插入到相应位置。</p>
</li>
<li><p>用法：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">list1 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="comment">#找到 5 在 list1 中的位置，从 1 开始，因此 position = index + 1</span></span><br><span class="line">bisect.bisect(list1, <span class="number">5</span>)</span><br><span class="line"><span class="comment">#将 3.5 插入 list1 中合适位置</span></span><br><span class="line">bisect.insort(list1, <span class="number">3.5</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>注</strong>：<code>bisect</code> 模块中的函数并不会去检查列表是否排序好，因为这会花费很多时间。所以，对未排序好的列表使用这些函数也不会报错，但可能会返回不正确的结果。</p>
</blockquote>
<h3 id="针对序列类型的切片"><a href="#针对序列类型的切片" class="headerlink" title="针对序列类型的切片"></a>针对序列类型的切片</h3><blockquote>
<p>序列类型包括<code>str</code>、<code>array</code>、<code>tuple</code>、<code>list</code>等。</p>
</blockquote>
<p>用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1[start:stop]</span><br><span class="line"><span class="comment"># 如果使用 step</span></span><br><span class="line">list1[start:stop:step]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：</p>
<ul>
<li>切片结果包含 <code>start</code> 索引，但不包含 <code>stop</code> 索引</li>
<li><code>start/stop</code> 索引可以省略，如果省略，则默认为序列从开始到结束，如 <code>list1 == list1[:]</code> 。</li>
</ul>
</blockquote>
<p><code>step</code> 的应用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取出奇数位置的元素</span></span><br><span class="line">list1[::<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 反转字符串</span></span><br><span class="line">str1[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="字典（哈希表）"><a href="#字典（哈希表）" class="headerlink" title="字典（哈希表）"></a>字典（哈希表）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>, <span class="number">2</span>: [<span class="number">3</span>, <span class="number">2</span>]&#125;</span><br><span class="line"><span class="comment"># 从序列创建字典</span></span><br><span class="line"><span class="built_in">dict</span>(<span class="built_in">zip</span>(KeyList, ValueList))</span><br><span class="line"><span class="comment"># 获取/设置/插入元素</span></span><br><span class="line">dict1[<span class="string">&#x27;key1&#x27;</span>]</span><br><span class="line">dict1[<span class="string">&#x27;key1&#x27;</span>] = <span class="string">&#x27;NewValue&#x27;</span></span><br><span class="line"><span class="comment"># get 提供默认值</span></span><br><span class="line">dict1.get(<span class="string">&#x27;key1&#x27;</span>, DefaultValue)</span><br><span class="line"><span class="comment"># 检查键是否存在</span></span><br><span class="line"><span class="string">&#x27;key1&#x27;</span> <span class="keyword">in</span> dict1</span><br><span class="line"><span class="comment"># 获取键列表</span></span><br><span class="line">dict1.keys()</span><br><span class="line"><span class="comment"># 获取值列表</span></span><br><span class="line">dict1.values()</span><br><span class="line"><span class="comment"># 更新值</span></span><br><span class="line">dict1.update(dict2)  <span class="comment"># dict1 的值被 dict2 替换</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>如果键不存在，则会出现 <code>KeyError Exception</code> 。</li>
<li>当键不存在时，如果 <code>get()</code>不提供默认值则会返回 <code>None</code> 。</li>
<li>以相同的顺序返回键列表和值列表，但顺序不是特定的，也就是说极大可能非排序。</li>
</ul>
</blockquote>
<h4 id="有效字典键类型"><a href="#有效字典键类型" class="headerlink" title="有效字典键类型"></a>有效字典键类型</h4><ul>
<li>键必须是不可变的，比如标量类型(<code>int</code>、<code>float</code>、<code>string</code>)或者元组（元组中的所有对象也必须是不可变的）。</li>
<li>这儿涉及的技术术语是“可哈希(hashability)”。可以用函数<code>hash()</code>来检查一个对象是否是可哈希的，比如 <code>hash(&#39;This is a string&#39;)</code>会返回一个哈希值，而<code>hash([1,2])</code>则会报错（不可哈希）。</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li><p>一个集合是一些<strong>无序</strong>且唯一的元素的聚集；</p>
</li>
<li><p>你可以把它看成只有键的字典；</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建集合</span></span><br><span class="line"><span class="built_in">set</span>([<span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>])</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 子集测试</span></span><br><span class="line">set1.issubset(set2)</span><br><span class="line"><span class="comment"># 超集测试</span></span><br><span class="line">set1.issuperset(set2)</span><br><span class="line"><span class="comment"># 测试两个集合中的元素是否完全相同</span></span><br><span class="line">set1 == set2</span><br></pre></td></tr></table></figure></li>
<li><p><strong>集合操作</strong></p>
<ul>
<li>并（或）：<code>set1 | set2</code></li>
<li>交（与）：<code>set1 &amp; set2</code></li>
<li>差：<code>set1 - set2</code></li>
<li>对称差（异或）：<code>set1 ^ set2</code></li>
</ul>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Python 的函数参数传递是通过<strong>引用传递</strong>。</p>
<ul>
<li><p>基本形式</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">posArg1, keywordArg1=<span class="number">1</span>, ..</span>)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：</p>
<ul>
<li>关键字参数必须跟在位置参数的后面；</li>
<li>默认情况下，Python 不会“延迟求值”，表达式的值会立刻求出来。</li>
</ul>
</blockquote>
</li>
<li><p>函数调用机制</p>
<ol>
<li>所有函数均位于模块内部作用域。见“模块”部分。</li>
<li>在调用函数时，参数被打包成一个元组和一个字典，函数接收一个元组<code>args</code>和一个字典<code>kwargs</code>，然后在函数内部解包。</li>
</ol>
</li>
<li><p>“函数是对象”的常见用法：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">ops = [<span class="built_in">str</span>.strip, user_define_func, ..], ..</span>):</span></span><br><span class="line">    <span class="keyword">for</span> function <span class="keyword">in</span> ops:</span><br><span class="line">        value = function(value)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><p>如果函数直到结束都没有<code>return</code>语句，则返回<code>None</code>。</p>
</li>
<li><p>如果有多个返回值则通过<strong>一个</strong>元组来实现。</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (value1, value2)</span><br><span class="line">value1, value2 = func1(..)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="匿名函数（又称-LAMBDA-函数）"><a href="#匿名函数（又称-LAMBDA-函数）" class="headerlink" title="匿名函数（又称 LAMBDA 函数）"></a>匿名函数（又称 LAMBDA 函数）</h3><ul>
<li><p>什么是匿名函数？</p>
<p>  匿名函数是一个只包含一条语句的简单函数。</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x : x * <span class="number">2</span></span><br><span class="line"><span class="comment"># def func1(x) : return x * 2</span></span><br></pre></td></tr></table></figure></li>
<li><p>匿名函数的应用：“柯里化(curring)”，即利用已存在函数的部分参数来派生新的函数。</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ma60 = <span class="keyword">lambda</span> x : pd.rolling_mean(x, <span class="number">60</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="一些有用的函数（针对数据结构）"><a href="#一些有用的函数（针对数据结构）" class="headerlink" title="一些有用的函数（针对数据结构）"></a>一些有用的函数（针对数据结构）</h3><ol>
<li><p><strong>Enumerate</strong> 返回一个序列<code>(i, value)</code>元组，<code>i</code> 是当前 <code>item</code> 的索引。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(collection):</span><br></pre></td></tr></table></figure>

<ul>
<li>应用：创建一个序列中值与其在序列中的位置的字典映射（假设每一个值都是唯一的）。</li>
</ul>
</li>
<li><p><strong>Sorted</strong> 可以从任意序列中返回一个排序好的序列。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sorted</span>([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]) =&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>应用：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(<span class="built_in">set</span>(<span class="string">&#x27;abc bcd&#x27;</span>)) =&gt; [<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="comment"># 返回一个字符串排序后无重复的字母序列</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Zip</strong> 函数可以把许多列表、元组或其他序列的元素配对起来创建一系列的元组。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">zip</span>(seq1, seq2) =&gt; [(<span class="string">&#x27;seq1_1&#x27;</span>, <span class="string">&#x27;seq2_1&#x27;</span>), (..), ..]</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>zip()</code>可以接收任意数量的序列作为参数，但是产生的元素的数目取决于最短的序列。</p>
</li>
<li><p>应用：多个序列同时迭代：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(seq1, seq2)):</span><br></pre></td></tr></table></figure></li>
<li><p><code>unzip</code>：另一种思考方式是把一些行转化为一些列：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq1, seq2 = unzip(zipOutput)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Reversed</strong> 将一个序列的元素以逆序迭代。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>reversed()</code> 会返回一个迭代器，<code>list()</code> 使之成为一个列表。</p>
</blockquote>
</li>
</ol>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><ol>
<li><p>用于 <code>if-else</code> 条件中的操作符：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var1 <span class="keyword">is</span> var2  <span class="comment"># 检查两个变量是否是相同的对象</span></span><br><span class="line"></span><br><span class="line">var1 <span class="keyword">is</span> <span class="keyword">not</span> var2  <span class="comment"># 检查两个变量是否是不同的对象</span></span><br><span class="line"></span><br><span class="line">var1 == var2  <span class="comment"># 检查两个变量的值是否相等</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：Python 中使用 <code>and</code>、<code>or</code>、<code>not</code> 来组合条件，而不是使用 <code>&amp;&amp;</code>、<code>||</code>、<code>!</code> 。</p>
</blockquote>
</li>
<li><p><code>for</code>循环的常见用法：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> iterator:  <span class="comment"># 可迭代对象（list、tuple）或迭代器</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a, b, c <span class="keyword">in</span> iterator:  <span class="comment"># 如果元素是可以解包的序列</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>pass</code>：无操作语句，在不需要进行任何操作的块中使用。</p>
</li>
<li><p>三元表达式，又称简洁的 <code>if-else</code>，基本形式：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = true-expr <span class="keyword">if</span> condition <span class="keyword">else</span> false-expr</span><br></pre></td></tr></table></figure></li>
<li><p>Python 中没有 <code>switch/case</code> 语句，请使用 <code>if/elif</code>。</p>
</li>
</ol>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><ol>
<li><p><strong>对象</strong>是 Python 中所有类型的根。</p>
</li>
<li><p>万物（数字、字符串、函数、类、模块等）皆为对象，每个对象均有一个“类型(type)”。对象变量是一个指向变量在内存中位置的指针。</p>
</li>
<li><p>所有对象均会被<strong>引用计数</strong>。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.getrefcount(<span class="number">5</span>) =&gt; x</span><br><span class="line">a = <span class="number">5</span>, b = a</span><br><span class="line"><span class="comment"># 上式会在等号的右边创建一个对象的引用，因此 a 和 b 均指向 5</span></span><br><span class="line">sys.getrefcount(<span class="number">5</span>)</span><br><span class="line">=&gt; x + <span class="number">2</span></span><br><span class="line"><span class="keyword">del</span>(a); sys.getrefcount(<span class="number">5</span>) =&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>类的基本形式：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># &#x27;self&#x27; 等价于 Java/C++ 中的 &#x27;this&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">memberFunc1</span>(<span class="params">self, arg1</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">classFunc2</span>(<span class="params">arg1</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">obj1 = MyObject(<span class="string">&#x27;name1&#x27;</span>)</span><br><span class="line">obj1.memberFunc1(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">MyObject.classFunc2(<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>有用的交互式工具：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span>(variable1)  <span class="comment"># 列出对象的所有可用方法</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常见字符串操作"><a href="#常见字符串操作" class="headerlink" title="常见字符串操作"></a>常见字符串操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过分隔符连接列表/元组</span></span><br><span class="line"><span class="string">&#x27;, &#x27;</span>.join([ <span class="string">&#x27;v1&#x27;</span>, <span class="string">&#x27;v2&#x27;</span>, <span class="string">&#x27;v3&#x27;</span>]) =&gt; <span class="string">&#x27;v1, v2, v3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化字符串</span></span><br><span class="line">string1 = <span class="string">&#x27;My name is &#123;0&#125;　&#123;name&#125;&#x27;</span></span><br><span class="line">newString1 = string1.<span class="built_in">format</span>(<span class="string">&#x27;Sean&#x27;</span>, name =　<span class="string">&#x27;Chen&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分裂字符串</span></span><br><span class="line">sep = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">stringList1 =　string1.split(sep)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取子串</span></span><br><span class="line">start = <span class="number">1</span>;</span><br><span class="line">string1[start:<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 补 &#x27;0&#x27; 向右对齐字符串</span></span><br><span class="line">month = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">month.zfill(<span class="number">2</span>) =&gt; <span class="string">&#x27;05&#x27;</span></span><br><span class="line">month = <span class="string">&#x27;12&#x27;</span>;</span><br><span class="line">month.zfill(<span class="number">2</span>) =&gt; <span class="string">&#x27;12&#x27;</span></span><br><span class="line">month.zfill(<span class="number">3</span>) =&gt; <span class="string">&#x27;012&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ol>
<li><p>基本形式：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span> e</span><br><span class="line"><span class="keyword">except</span> (TypeError, AnotherError):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 清理，比如 close db;</span></span><br></pre></td></tr></table></figure></li>
<li><p>手动引发异常：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> AssertionError  <span class="comment"># 断言失败</span></span><br><span class="line"><span class="keyword">raise</span> SystemExit</span><br><span class="line"><span class="comment"># 请求程序退出</span></span><br><span class="line"><span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;错误信息 :..&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="列表、字典以及元组的推导表达式"><a href="#列表、字典以及元组的推导表达式" class="headerlink" title="列表、字典以及元组的推导表达式"></a>列表、字典以及元组的推导表达式</h2><p>使代码更加易读易写的语法糖。</p>
<ol>
<li><p><strong>列表推导</strong></p>
<ul>
<li><p>用一个简练的表达式，通过筛选一个数据集并且转换经过筛选的元素的方式来简明地生成新列表。</p>
</li>
<li><p>基本形式：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[expr <span class="keyword">for</span> val <span class="keyword">in</span> collection <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure></li>
</ul>
<p> 等价于</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> collection:</span><br><span class="line">    <span class="keyword">if</span> condition:</span><br><span class="line">        result.append(expr)</span><br></pre></td></tr></table></figure>

<p> 可以省略过滤条件，只留下表达式。</p>
</li>
<li><p><strong>字典推导</strong></p>
<ul>
<li><p>基本形式：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;key-expr : value-expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>集合推导</strong></p>
<ul>
<li>基本形式：和列表推导一样，不过是用 <code>()</code> 而不是 <code>[]</code> 。</li>
</ul>
</li>
<li><p><strong>嵌套列表</strong></p>
<ul>
<li><p>基本形式：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[expr <span class="keyword">for</span> val <span class="keyword">in</span> collection <span class="keyword">for</span> innerVal <span class="keyword">in</span> val <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>Python自带<code>unittest</code>模块，可供我们编写单元测试。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br></pre></td></tr></table></figure>

<p>我们可以编写继承于<code>unittest.TestCase</code>测试类的子类，并在子类中编写具体的测试函数。测试函数命必须以<code>test_</code>开头，否则不会被识别为测试函数，进而不会在运行单元测试时被运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSubclass</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_func</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertEqual(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 可以通过msg关键字参数提供测试失败时的提示消息</span></span><br><span class="line">        self.assertEqual(<span class="number">0</span>, <span class="number">0</span>, msg=<span class="string">&#x27;modified message&#x27;</span>)</span><br><span class="line">        self.assertGreater(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        self.assertIn(<span class="number">0</span>, [<span class="number">0</span>])</span><br><span class="line">        self.assertTrue(<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 测试是否会抛出异常</span></span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(KeyError):</span><br><span class="line">            _ = <span class="built_in">dict</span>()[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 被@unittest.skip装饰器装饰的测试类或测试函数会被跳过</span></span><br><span class="line"><span class="meta">    @unittest.skip(<span class="params">reason=<span class="string">&#x27;just skip&#x27;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_skip</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;I shall never be tested&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>另外，<code>unittest.TestCase</code>中还有两个特殊的成员函数，他们分别会在调用每一个测试函数的前后运行。在测试前连接数据库并在测试完成后断开连接是一种常见的使用场景。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="comment"># To do: connect to the database</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="comment"># To do: release the connection</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_database</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="comment"># To do: test the database</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>测试类编写完毕后，可以通过添加以下代码来将当前文件当成正常的Python脚本使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  unittest.main()</span><br></pre></td></tr></table></figure>

<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a><code>Git</code></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##############################################################################</span><br><span class="line"># 配置</span><br><span class="line">##############################################################################</span><br><span class="line">git config --global &quot;Your Name&quot;</span><br><span class="line">git config --global &quot;Email Address&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 初始化</span><br><span class="line">##############################################################################</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 提交修改</span><br><span class="line">##############################################################################</span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git add -u 提交work directory中所有已track的文件至staging area</span><br><span class="line">git commit -m &quot;descriptions&quot;</span><br><span class="line">git commit --amend 对最近一次的提交做内容修改</span><br><span class="line">git commit --amend --author &quot;user_name &lt;user_email&gt;&quot; 修改最近提交用户名和邮箱</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 查看状态、比对</span><br><span class="line">##############################################################################</span><br><span class="line">git status</span><br><span class="line">git status -s 文件状态缩略信息, 常见 A:新增; M:文件变更; ?:未track; D:删除</span><br><span class="line">git diff &lt;file&gt;</span><br><span class="line">git diff HEAD -- &lt;file&gt;		查看工作区和版本库里面最新版本的区别</span><br><span class="line">git diff --check &lt;file&gt;     检查是否有空白错误(regex:&#x27; \&#123;1,\&#125;$&#x27;)</span><br><span class="line">git diff --cached &lt;file&gt;    查看已add的内容(绿M)</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 查看历史版本、历史操作</span><br><span class="line">##############################################################################</span><br><span class="line">git log</span><br><span class="line">git reflog</span><br><span class="line">git log -n                  最近n条的提交历史</span><br><span class="line">git log &lt;branch_name&gt; -n    分支branch_name最近n条的提交历史</span><br><span class="line">git log --stat              历次commit的文件变化</span><br><span class="line">git log lhs_hash..rhs_hash  对比两次commit的变化(增删的主语为lhs, 如git log HEAD~2..HEAD == git log HEAD -3)</span><br><span class="line">git log -p                  历次commit的内容增删</span><br><span class="line">git log -p -W               历次commit的内容增删, 同时显示变更内容的上下文</span><br><span class="line">git log origin/EI-1024 -1 --stat -p -W 查看远端分支EI-1024前一次修改的详细内容</span><br><span class="line">git log origin/master..dev --stat -p -W 查看本地dev分支比远端master分支变化(修改)的详细内容</span><br><span class="line"></span><br><span class="line">git log &lt;branch_name&gt; --oneline   对提交历史单行排列</span><br><span class="line">git log &lt;branch_name&gt; --graph     对提交历史图形化排列</span><br><span class="line">git log &lt;branch_name&gt; --decorate  对提交历史关联相关引用, 如tag, 本地远程分支等</span><br><span class="line">git log &lt;branch_name&gt; --oneline --graph --decorate 拼接一下, 树形化显示历史</span><br><span class="line">git log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen%ai(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit 同上, 建议alais保存</span><br><span class="line"></span><br><span class="line">git log --since --after     显示时间之后的提交</span><br><span class="line">git log --until --before    显示时间之前的提交</span><br><span class="line">git --author                显示指定作者的提交</span><br><span class="line">git --committer             显示指定committer的提交(注:committer不一定是author)</span><br><span class="line">git log origin/b3.3/master --author=yx-ren --since=&quot;2019-10-01&quot; --before=&quot;2019-11-01&quot; 查看某作者在某发布版本最近一个月的提交, 常见于线上背锅</span><br><span class="line">git log origin/b3.0/master --author=some_leave --since=&quot;1 month ago&quot; 查看某刚离职同事过去一个月的提交, 常见于背锅</span><br><span class="line">git log --since=1.weeks     过去一周的提交(写周报的时候可以看看我这一周干了啥)</span><br><span class="line">git log --since=1.days      过去一天的提交(下班的时候可以看看我这一天干了啥)</span><br><span class="line">git log --since=&quot;1 weeks 2 days 3 hours 40 minutes 50 seconds ago&quot; 过去1周2天3小时40分50秒之内的提交</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 版本回退、前进</span><br><span class="line">##############################################################################</span><br><span class="line">git reset --hard HEAD^		回退到上1版本</span><br><span class="line">git reset --hard HEAD~5		回退到上5个版本</span><br><span class="line">git reset --hard id		回退到指定版本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 撤销修改</span><br><span class="line">##############################################################################</span><br><span class="line">git checkout -- &lt;file&gt;		撤销修改：误修改工作区文件，未git add/commit</span><br><span class="line">git restore &lt;file&gt;		撤销修改：误修改工作区文件，未git add/commit</span><br><span class="line">git reset HEAD &lt;file&gt;		撤销git add：误将文件加入暂存区（git add），未git commit</span><br><span class="line">git reset --hard HEAD^		撤销git commit：误将文件提交（一旦提交，只能通过版本回退进行撤销）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 删除与恢复</span><br><span class="line">##############################################################################</span><br><span class="line">git rm/add &lt;file&gt;</span><br><span class="line">git commit -m &quot;remove &lt;file&gt;&quot;	删除版本库中的&lt;file&gt;：删除工作区文件后，继续删除版本库中相应的文件</span><br><span class="line">git checkout -- &lt;file&gt;		根据版本库中的&lt;file&gt;恢复工作区&lt;file&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 关联GitHub远程仓库（本地到远程）</span><br><span class="line">##############################################################################</span><br><span class="line">git remote add origin &lt;remote address&gt;	在本地工作区目录下按照 GitHub 提示进行关联</span><br><span class="line">git remote rm origin			解除错误关联</span><br><span class="line">git push -u origin master		第一次将本地仓库推送至远程仓库（每次在本地提交后进行操作）</span><br><span class="line">git push origin master			以后每次将本地仓库推送至远程仓库（每次在本地提交后进行操作）</span><br><span class="line">&lt;remote address&gt;:</span><br><span class="line">	git@github.com:&lt;username&gt;/&lt;repository&gt;.git</span><br><span class="line">	https://github.com/&lt;username&gt;/&lt;repository&gt;.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 克隆GitHub远程仓库（远程到本地）</span><br><span class="line">##############################################################################</span><br><span class="line">git clone &lt;remote address&gt;	git协议速度更快但通常公司内网不允许，https协议速度慢</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 分支管理：创建、切换、查看、合并、删除</span><br><span class="line">##############################################################################</span><br><span class="line">git branch &lt;branch name&gt;	创建&lt;branch name&gt;分支</span><br><span class="line">git checkout &lt;branch name&gt;	切换至&lt;branch name&gt;分支</span><br><span class="line">git switch &lt;branch name&gt;	切换至&lt;branch name&gt;分支</span><br><span class="line">git checkout -b &lt;branch name&gt;	创建并切换至&lt;branch name&gt;分支</span><br><span class="line">git switch -c &lt;branch name&gt;	创建并切换至&lt;branch name&gt;分支</span><br><span class="line">git branch			查看已有分支（* 表示当前分支）</span><br><span class="line">git merge &lt;branch name&gt;		合并&lt;branch name&gt;到当前分支（通常在master分支下操作）</span><br><span class="line">git branch -d &lt;branch name&gt;	删除分支</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 解决合并冲突</span><br><span class="line">##############################################################################</span><br><span class="line">合并时报错“分支发生冲突”，首先vim相应文件，修改冲突位置，然后按照git add/commit重新提交，最后删除多余分支即可。</span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">git log --graph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 分支管理：合并后删除分支也在 log 中保留分支记录</span><br><span class="line">##############################################################################</span><br><span class="line">git merge --no-ff -m &quot;descriptions&quot; &lt;branch name&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 开发流程：</span><br><span class="line">##############################################################################</span><br><span class="line">master分支		发布稳定版本</span><br><span class="line">dev分支			发布开发版本</span><br><span class="line">&lt;developer name&gt;分支	个人开发分支（个人开发完成将该分支并入dev，同时保留该分支，继续开发）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># Bug分支管理（建立单独分支进行bug修复）</span><br><span class="line">##############################################################################</span><br><span class="line">软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</span><br><span class="line">git stash			保存当前工作现场（在dev未完成开发，但master有bug需要修复）</span><br><span class="line">git stash pop			回到dev分支后恢复工作现场（list中的现场会同时被删除）</span><br><span class="line">git stash list			查看当前存储的工作现场</span><br><span class="line">git stash apply stash@&#123;#&#125;	回到指定工作现场（list中的现场不会被删除，需要用git stash drop）</span><br><span class="line">git stash drop stash@&#123;#&#125;	删除指定工作现场</span><br><span class="line">git cherry-pick &lt;id&gt;		在master修复好bug后，在dev复制一遍bug修复流程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># Feature分支管理（建立单独分支添加新功能）</span><br><span class="line">##############################################################################</span><br><span class="line">软件开发中，总有无穷无尽的新的功能要不断添加进来。添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</span><br><span class="line">git branch -D &lt;branch name&gt;	强制删除分支（丢弃未合并分支）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 协作与分支推送</span><br><span class="line">##############################################################################</span><br><span class="line">User 1:</span><br><span class="line">git remote [-v]						查看远程库信息（-v 查看详细信息）</span><br><span class="line">git push origin [master/dev/...]			推送指定分支到远程</span><br><span class="line">User 2:</span><br><span class="line">git clone &lt;remote address&gt;				克隆到本地（只能克隆master）</span><br><span class="line">git checkout -b dev origin/dev				本地新建分支并关联远程</span><br><span class="line">git add/commit/push					添加、提交、推送更新</span><br><span class="line">User 1:</span><br><span class="line">git add/commit/push					推送时报错（与user 2推送的更新冲突）</span><br><span class="line">git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line">git branch --set-upstream-to=origin/&lt;branch&gt; &lt;branch&gt;	本地与远程关联</span><br><span class="line">git pull						拉取远程文件（并解决冲突）</span><br><span class="line">git commit/push						重新提交并推送</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 标签管理（常用于版本管理）：查看、创建、操作</span><br><span class="line">##############################################################################</span><br><span class="line">git tag								查看标签</span><br><span class="line">git show &lt;tag name&gt;						查看指定标签</span><br><span class="line">git log --pretty=oneline --abbrev-commit --decorate=full	在log中显示标签</span><br><span class="line">git tag &lt;tag name&gt;						为上次commit位置打标签</span><br><span class="line">git tag &lt;tag name&gt; &lt;commit id&gt;					为指定commit位置打标签</span><br><span class="line">git tag -a &lt;tag name&gt; -m &quot;descriptions&quot; &lt;commit id&gt;		为指定commit打标并添加描述</span><br><span class="line">git tag -d &lt;tag name&gt;						删除本地标签</span><br><span class="line">git push origin &lt;tag name&gt;					推送指定标签到远程</span><br><span class="line">git push origin --tags						推送所有本地标签到远程</span><br><span class="line">git push origin :refs/tags/&lt;tag name&gt;				删除远程标签（先删除本地标签）</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># rebase(换基)</span><br><span class="line">##############################################################################</span><br><span class="line"># rebase 在日常中常用功能主要是两个, 多人协同开发定期rebase master以及压缩某分支多个commit</span><br><span class="line">git rebase master 常见于多人开发, 每个开发人员从master checkout出自己的分支, 开发一段时间后提交至master之前最好rebase一下, 防止冲突,</span><br><span class="line">              就算真有冲突在本地解决好过强制提交, 开发流程中尽量保证master的干净整洁</span><br><span class="line">git rebase -i HEAD~n 压缩当前分支的n个commit并合并为1个commit, 常见第一行为pick, 剩下的n-1行为squash</span><br><span class="line"></span><br><span class="line">git rebase --abort # rebase过程中发生错误, 可以利用该命令终止整个rebase过程</span><br><span class="line">git rebase --continue # rebase过程中发生冲突, 在解决冲突后可以利用该命令进行后续过程</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 打patch(补丁)</span><br><span class="line">##############################################################################</span><br><span class="line"># 生成diff patch文件(git可以识别diff文件)</span><br><span class="line">git &lt;branch&gt; log -n -p &gt; diff.patch # 生成某分支过去n个commit的文件diff信息至单个diff文件</span><br><span class="line">git diff &lt;--cached&gt; diff.patch # 针对当前缓存区的内容生成diff文件</span><br><span class="line"></span><br><span class="line"># 利用apply打patch</span><br><span class="line">git apply --check diff.patch    #检查是否可以正常应用, 无回显证明无冲突</span><br><span class="line">git apply --stat diff.patch     #查看应用diff文件后的文件变化</span><br><span class="line">git apply diff.patch            #打patch, 仅仅改变文件信息, 无commit信息, 仍然需要add, commit</span><br><span class="line"></span><br><span class="line"># 利用--format-patch生成patch, 带commit信息</span><br><span class="line">git format-patch &lt;branch&gt; -n 　 #生成分支&lt;branch&gt;最近的n次commit的patch</span><br><span class="line">git format-patch &lt;r1&gt;..&lt;r2&gt;     #生成两个commit间的修改的patch（包含两个commit. &lt;r1&gt;和&lt;r2&gt;都是具体的commit号)</span><br><span class="line">git format-patch -1 &lt;r1&gt;        #生成单个commit的patch</span><br><span class="line">git format-patch &lt;r1&gt;           #生成某commit以来的修改patch（不包含该commit）</span><br><span class="line">git format-patch --root &lt;r1&gt;　　#生成从根到r1提交的所有patch</span><br><span class="line"></span><br><span class="line"># 利用am打patch</span><br><span class="line">git apply --check 0001-update-bash.sh.patch #检查patch是否冲突可用</span><br><span class="line">git apply --stat 0001-update-bash.sh.patch  #检查patch文件变更情况, 无回显证明无冲突</span><br><span class="line">git am 0001-update-bash.sh.patch            #将该patch打上到当前分支, 带commit信息</span><br><span class="line">git am ./*.patch                            #将当前路径下的所有patch按照先后顺序打上</span><br><span class="line">git am --abort                              #终止整个打patch的过程, 类似rebase --abort</span><br><span class="line">git am --resolved                           #解决冲突后, 可以执行该命令进行后续的patch, 类似rebase --continue</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 使用GitHub</span><br><span class="line">##############################################################################</span><br><span class="line">fork --&gt; clone --&gt; add/commit/push --&gt; pull request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 其他配置</span><br><span class="line">##############################################################################</span><br><span class="line">git config --global color.ui true	显示颜色</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 配置.gitignore文件</span><br><span class="line">##############################################################################</span><br><span class="line">/&lt;dir name&gt;/			忽略文件夹</span><br><span class="line">*.zip				忽略.zip文件</span><br><span class="line">/&lt;dir name&gt;/&lt;file name&gt;		忽略指定文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 文件.gitignore生效后</span><br><span class="line">##############################################################################</span><br><span class="line">git add -f &lt;file&gt;		强制添加</span><br><span class="line">git check-ignore -v &lt;file&gt;	查看生效规则</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># 配置别名</span><br><span class="line">##############################################################################</span><br><span class="line">git config [--global] alias.&lt;alias&gt; &#x27;&lt;original command&gt;&#x27;	为所有工作区/当前工作区配置别名</span><br><span class="line">.git/config			当前工作区的配置文件</span><br><span class="line">~/.gitconfig			当前用户的配置文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############################################################################</span><br><span class="line"># References</span><br><span class="line">##############################################################################</span><br><span class="line">https://www.liaoxuefeng.com/wiki/896043488029600</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cheatsheet</category>
      </categories>
      <tags>
        <tag>cheatsheet</tag>
      </tags>
  </entry>
  <entry>
    <title>赛可出行面试</title>
    <url>/blog/posts/3eb5e557/</url>
    <content><![CDATA[<p>以下为本人面试经历汇总。。</p>
<h1 id="在平时使用mysql时，需要有哪些注意点"><a href="#在平时使用mysql时，需要有哪些注意点" class="headerlink" title="在平时使用mysql时，需要有哪些注意点"></a>在平时使用<code>mysql</code>时，需要有哪些注意点</h1><ul>
<li>数据库的范式  第一范式要求最低，只要求表中字段不可用在拆分。<br>  第二范式在第一范式的基础上要求每条记录由主键唯一区分，记录中所有属性都依赖于主键。<br>  第三范式在第二范式的基础上，要求所有属性必须直接依赖主键，不允许间接依赖。<br>  一般说来，数据库只需满足第三范式就可以了。</li>
</ul>
<span id="more"></span>

<ul>
<li><p>数据库事务特性</p>
<p>  数据库的特性是面试时考察频率非常高的题目，共4个特性：</p>
<p>  原子性：是指事务由原子的操作序列组成，所有操作要么全部成功，要么全部失败回滚。</p>
<p>  一致性：是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处以一致性状态。比如在做多表操作时，多个表要么都是事务后新的值，要么都是事务前的旧值。</p>
<p>  隔离性：是指多个用户并发访问数据库时，数据库为每个用户执行的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。事务的隔离级别我们稍后介绍。</p>
<p>  持久性：是指一个事务一旦提交并执行成功，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
</li>
</ul>
<img data-src="/blog/posts/3eb5e557/2022-02-16-00-03-40.png" class="">



<img data-src="/blog/posts/3eb5e557/2022-02-16-00-03-48.png" class="">

<blockquote>
<p>3.MySQL中主要的存储引擎</p>
</blockquote>
<p>MyISAM是MySQL官方提供的存储引擎，其特点是支持全文索引，查询效率比较高，缺点是不支持事务、使用表级锁。InnoDB在5.5版本后成为了Mysql的默认存储引擎，特点是支持ACID事务、支持外键、支持行级锁提高了并发效率。TokuDB是第三方开发的开源存储引擎，有非常快的写速度，支持数据的压缩存储、可以在线添加索引而不影响读写操作。但是因为压缩的原因，TokuDB非常适合访问频率不高的数据或历史数据归档，不适合大量读取的场景。</p>
<blockquote>
<p>4.MySQL中的锁</p>
</blockquote>
<p>MyIASAM使用表级锁，InnoDB使用行级锁。表锁开销小，加锁快，不会出现死锁；但是锁的粒度大，发生锁冲突的概率高，并发访问效率比较低。行级锁开销大，加锁慢，有可能会出现死锁，不过因为锁定粒度最小，发生锁冲突的概率低，并发访问效率比较高。</p>
<p>注：</p>
<p>共享锁也就是读锁，其他事务可以读，但不能写。MySQL可以通过Lock In Share Mode语句显示使用共享锁。<br>排他锁就是写锁，其他事务不能读取，也不能写。对于Update、Delete和INSERT语句，InnoDB会自动给涉及的数据集加排他锁，或者使用<code>select for update显示使用排他锁</code>。</p>
<blockquote>
<p>6.MySQL的存储过程与函数</p>
</blockquote>
<p>存储过程和函数都可以避免开发人员重复编写相同的SQL语句，并且存储过程和函数都是在MySQL服务器中执行的，可以减少客户端和服务器端的数据传输。</p>
<p>存储过程能够实现更复杂的功能，而函数一般用来实现针对性比较强的功能，例如特殊策略求和等。存储过程可以执行包括修改表等一系列数据库操作，而用户定义函数不能用于执行修改全局数据库状态的操作。</p>
<p>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用。SQL语句中不能使用存储过程，但可以使用函数。</p>
<p>不过存储过程一般与数据库实现绑定，使用存储过程会降低程序的可移植性，应谨慎使用。</p>
<blockquote>
<p>7.新特性</p>
</blockquote>
<p>可以了解MySQL8.0的一些新特性，例如默认字符集格式改为了UTF8；增加了隐藏索引的功能，隐藏后的索引不会被查询优化器使用，可以使用这个特性用于性能调试；支持了通用表表达式，使复杂查询中的嵌入表语句更加清晰；新增了窗口函数的概念，它可以用来实现新的查询方式。窗口函数与 SUM、COUNT等集合函数类似，但不会将多行查询结果合并，而是将结果放在多行中。即窗口函数不需要GROUP BY。</p>
<img data-src="/blog/posts/3eb5e557/2022-02-16-00-04-02.png" class="">

<p>索引可以大幅增加数据库的查询的性能，在实际业务场景中，或多或少都会使用到。</p>
<p>但是索引是有如下2个代价的:</p>
<p>a.需要额外的磁盘空间来保存索引</p>
<p>b.对于插入、更新、删除等操作由于更新索引会增加额外的开销</p>
<p>因此索引比较适合用在读多写少的场景。</p>
<h2 id="1-MySQL索引类型"><a href="#1-MySQL索引类型" class="headerlink" title="1.MySQL索引类型"></a>1.MySQL索引类型</h2><p>如左面的模块，共分为5类：</p>
<p>唯一索引：就是索引列中的值必须是唯一的，但是允许出现空值。这种索引一般用来保证数据的唯一性，比如保存账户信息的表，每个账户的id必须保证唯一，如果重复插入相同的账户id时会MySQL返回异常。</p>
<p>主键索引：是一种特殊的唯一索引，但是它不允许出现空值。</p>
<p>普通索引：与唯一索引不同，它允许索引列中存在相同的值。例如学生的成绩表，各个学科的分数是允许重复的，就可以使用普通索引。</p>
<p>联合索引：就是由多个列共同组成的索引。一个表中含有多个单列的索引并不是联合索引，联合索引是对多个列字段按顺序共同组成一个索引。应用联合索引时需要注意最左原则，就是Where查询条件中的字段必须与索引字段从左到右进行匹配。比如，一个用户信息表，用姓名和年龄组成了联合索引，如果查询条件是姓名等于张三，那么满足最左原则；如果查询条件是年龄大于20，由于索引中最左的字段是姓名不是年龄，所以不能使用这个索引。</p>
<p>全文索引：前面提到了，MyISAM引擎中实现了这个索引，在5.6版本后InnoDB引擎也支持了全文索引，并且在5.7.6版本后支持了中文索引。全文索引只能在CHAR,VARCHAR,TEXT类型字段上使用，底层使用倒排索引实现。要注意对于大数据量的表，生成全文索引会非常消耗时间也非常消耗磁盘空间。</p>
<h2 id="2-索引实现"><a href="#2-索引实现" class="headerlink" title="2.索引实现"></a>2.索引实现</h2><p>如右面的模块，索引实现共分4种形式：</p>
<p>B+树实现：b+树比较适合用作’&gt;’或’&lt;’这样的范围查询，是MySQL中最常使用的一种索引实现。<br>R-tree：是一种用于处理多维数据的数据结构，可以对地理数据进行空间索引。不过实际业务场景中使用的比较少。<br>Hash：是使用散列表来对数据进行索引，Hash方式不像Btree那样需要多次查询才能定位到记录，因此Hash索引的效率高于B-tree，但是不支持范围查找和排序等功能.实际使用的也比较少。<br>FullText：就是我们前面提到的全文索引，是一种记录关键字与对应文档关系的倒排索引。</p>
<img data-src="/blog/posts/3eb5e557/2022-02-16-00-04-18.png" class="">

<p>一般MySQL调优有图中的4个纬度：</p>
<p>针对数据库设计、表结构设计以及索引设置纬度进行的优化；</p>
<p>对业务中使用的SQL语句进行优化，例如调整Where查询条件；</p>
<p>对mysql服务的配置进行优化，例如对链接数的管理，对索引缓存、查询缓存、排序缓存等各种缓存大小进行优化;</p>
<p>对硬件设备和操作系统设置进行优化，例如调整操作系统参数、禁用Swap、增加内存、升级固态硬盘等等。</p>
<img data-src="/blog/posts/3eb5e557/2022-02-16-00-04-41.png" class="">

<h2 id="1-表结构和索引的优化"><a href="#1-表结构和索引的优化" class="headerlink" title="1.表结构和索引的优化"></a>1.表结构和索引的优化</h2><p>如左面的模块，应该掌握如下6个原则：</p>
<p>第1个原则：要在设计表结构时，考虑数据库的水平与垂直扩展能力，提前规划好未来1年的数据量、读写量的增长，规划好分库分表方案。比如设计用户信息表，预计1年后用户数据10亿条，写QPS约5000，读QPS30000，可以设计按UID纬度进行散列，分为4个库每个库32张表，单表数据量控制在KW级别；</p>
<p>第2个原则：要为字段选择合适的数据类型，在保留扩展能力的前提下，优先选用较小的数据结构。例如保存年龄的字段，要使用TINYINT而不要使用INT；</p>
<p>第3个原则：可以将字段多的表分解成多个表，必要时增加中间表进行关联。假如一张表有4、50个字段显然不是一个好的设计；</p>
<p>第4个原则：是设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度；</p>
<p>第5个原则：要擅用索引，比如为经常作为查询条件的字段创建索引、创建联合索引时要根据最左原则考虑索引的复用能力，不要重复创建索引；要为保证数据不能重复的字段创建唯一索引等等。不过要注意索引对插入、更新等写操作是有代价的，不要滥用索引。比如像性别这样唯一很差的字段就不适合建立索引；</p>
<p>第6个原则：列字段尽量设置为Not Null，MySQL难以对使用Null的列进行查询优化，允许Null会使索引、索引统计和值更加复杂。允许Null值的列需要更多的存储空间，还需要MySQL内部进行特殊处理。</p>
<h2 id="2-SQL语句进行优化的原则"><a href="#2-SQL语句进行优化的原则" class="headerlink" title="2.SQL语句进行优化的原则"></a>2.SQL语句进行优化的原则</h2><p>如右面的模块，共分5个原则：</p>
<p>第1个原则：要找的最需要优化的SQL语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询MySQL的慢查询日志来发现需要进行优化的SQL语句；</p>
<p>第2个原则：要学会利用MySQL提供的分析工具。例如使用Explain来分析语句的执行计划，看看是否使用了索引，使用了哪个索引，扫描了多少记录，是否使用文件排序等等。或者利用Profile命令来分析某个语句执行过程中各个分步的耗时；</p>
<p>第3个原则：要注意使用查询语句是要避免使用Select *，而是应该指定具体需要获取的字段。原因一是可以避免查询出不需要使用的字段，二是可以避免查询列字段的元信息；</p>
<p>第4个原则：是尽量使用Prepared Statements，一个是性能更好，另一个是可以防止SQL注入；</p>
<p>第5个原则：是尽量使用索引扫描来进行排序，也就是尽量在有索引的字段上进行排序操作。</p>
<p>以上为数据库操作须掌握的内容，可以进行差缺补漏，希望对研发人员有一定的帮助。</p>
<p>面试考察点</p>
<p>1.必须了解数据库的基本原理、使用场景以及常用队列、数据库的特点。MySQL提供了多种引擎可以支持事务型与非事务型的关系对象库服务等等。</p>
<p>2.要深刻理解数据库事务的ACID特性，了解并发事务可能导致的并发问题和不同的数据库隔离级别如何解决这些并发问题。</p>
<p>3.要掌握常用的MySQL语句，比如WHERE条件查询语句、JOIN关联语句、ORDER BY排序语句等等。还要熟悉常用的自带函数，例如SUM、COUNT等等。</p>
<p>4.要了解MySQL数据库不同引擎的特点及不同类型的索引实现。比如最长使用的InnoDB非常擅长事务处理，MyISAM比较适合非事务的简单查询场景。比如知道MySQL的唯一索引、联合索引、全文索引等不同索引类型，以及最长使用等B+树索引实现等等。</p>
<p>面试加分项</p>
<p>1.要了解新特性，例如MySQL8.0中提供了窗口函数来支持新的查询方式；支持通用表表达式，使复杂查询中的嵌入表语句更加清晰等等。</p>
<p>2.要知道数据库表设计原则，如果有过线上业务数据库的设计经验就更好了，你能够知道如何对容量进行评估，也知道适当分库分表来保证未来服务的可扩展性，这会对面试起到积极的影响。</p>
<p>3.最好有过数据库调优经验，例如明明建立了索引的语句，但是查询效率还是很慢，通过Explain分析发现表中有多个索引，MySQL的优化器选用了错误的索引，导致查询效率偏低，然后通过在SQL语句中使用Use Index来指定索引解决。</p>
<h1 id="使用过哪些Juc中类"><a href="#使用过哪些Juc中类" class="headerlink" title="使用过哪些Juc中类"></a>使用过哪些Juc中类</h1><p>JUC中常用类汇总</p>
<p>JUC的atomic包下运用了CAS的<code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicReference</code>等原子变量类</p>
<p><code>JUC</code>的<code>locks</code>包下的<code>AbstractQueuedSynchronizer（AQS）</code>以及使用<code>AQS</code>的<code>ReentantLock（显式锁）</code>、<code>ReentrantReadWriteLock</code></p>
<p>附：运用了<code>AQS</code>的类还有：<code>Semaphore</code>、<code>CountDownLatch</code>、<code>ReentantLock（显式锁）</code>、<code>ReentrantReadWriteLock</code></p>
<p><code>JUC</code>下的一些同步工具类：<code>CountDownLatch（闭锁）</code>、<code>Semaphore（信号量）</code>、<code>CyclicBarrier（栅栏）</code>、<code>FutureTask</code></p>
<p><code>JUC</code>下的一些并发容器类：<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code></p>
<p><code>JUC</code>下的一些<code>Executor</code>框架的相关类： 线程池的工厂类-&gt;<code>Executors</code>  线程池的实现类-&gt;<code>ThreadPoolExecutor/ForkJoinPool</code></p>
<p><code>JUC</code>下的一些阻塞队列实现类：<code>ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue</code></p>
<p>附：<code>ForkJoinPool</code>：使用<code>work-stealing</code>的工作方式运行</p>
<h1 id="Juc相关面试题"><a href="#Juc相关面试题" class="headerlink" title="Juc相关面试题"></a><code>Juc</code>相关面试题</h1><blockquote>
<p>什么是 CAS 吗？</p>
</blockquote>
<p>CAS（Compare And Swap）指比较并交换。CAS算法CAS(V, E, N)包含 3 个参数，V 表示要更新的变量，E 表示预期的值，N 表示新值。在且仅在 V 值等于 E值时，才会将 V 值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，当前线程什么都不做。最后，CAS 返回当前 V 的真实值。Concurrent包下所有类底层都是依靠CAS操作来实现，而sun.misc.Unsafe为我们提供了一系列的CAS操作。</p>
<blockquote>
<p>CAS 有什么缺点？</p>
</blockquote>
<ul>
<li>ABA问题</li>
<li>自旋问题</li>
<li>范围不能灵活控制</li>
</ul>
<blockquote>
<p>对 CAS 中的 ABA 产生有解决方案吗？</p>
</blockquote>
<p>什么是 ABA 问题呢？多线程环境下。线程 1 从内存的V位置取出 A ，线程 2 也从内存中取出 A，并将 V 位置的数据首先修改为 B，接着又将 V 位置的数据修改为 A，线程 1 在进行CAS操作时会发现在内存中仍然是 A，线程 1 操作成功。尽管从线程 1 的角度来说，CAS操作是成功的，但在该过程中其实 V 位置的数据发生了变化，线程 1 没有感知到罢了，这在某些应用场景下可能出现过程数据不一致的问题。</p>
<p>可以版本号（version）来解决 ABA 问题的，在 atomic 包中提供了 AtomicStampedReference 这个类，它是专门用来解决 ABA 问题的。</p>
<p>直达链接： AtomicStampedReference ABA 案例链接</p>
<blockquote>
<p>CAS 自旋导致的问题？</p>
</blockquote>
<p>由于单次 CAS 不一定能执行成功，所以 CAS 往往是配合着循环来实现的，有的时候甚至是死循环，不停地进行重试，直到线程竞争不激烈的时候，才能修改成功。</p>
<p>CPU 资源也是一直在被消耗的，这会对性能产生很大的影响。所以这就要求我们，要根据实际情况来选择是否使用 CAS，在高并发的场景下，通常 CAS 的效率是不高的。</p>
<blockquote>
<p>CAS 范围不能灵活控制</p>
</blockquote>
<p>不能灵活控制线程安全的范围。只能针对某一个，而不是多个共享变量的，不能针对多个共享变量同时进行 CAS 操作，因为这多个变量之间是独立的，简单的把原子操作组合到一起，并不具备原子性。</p>
<blockquote>
<p>什么是 AQS 吗？</p>
</blockquote>
<p>AbstractQueuedSynchronizer抽象同步队列简称AQS，它是实现同步器的基础组件，并发包中锁的底层就是使用AQS实现的。AQS定义了一套多线程访问共享资源的同步框架，许多同步类的实现都依赖于它，例如常用的Synchronized、ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch等。该框架下的锁会先尝试以CAS乐观锁去获取锁，如果获取不到，则会转为悲观锁（如RetreenLock）。</p>
<blockquote>
<p>了解 AQS 共享资源的方式吗？</p>
</blockquote>
<ul>
<li>独占式：只有一个线程能执行，具体的Java实现有ReentrantLock。</li>
<li>共享式：多个线程可同时执行，具体的Java实现有Semaphore和CountDownLatch。</li>
</ul>
<blockquote>
<p>Atomic 原子更新</p>
</blockquote>
<p>Java 从 JDK1.5 开始提供了 java.util.concurrent.atomic 包，方便程序员在多线程环 境下，无锁的进行原子操作。在 Atomic 包里一共有 12 个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新引用和原子更新字段。在 JDK 1.8 之后又新增几个原子类。如下如：</p>
<img data-src="/blog/posts/3eb5e557/2022-02-16-00-05-01.png" class="">

<h1 id="列举几个AtomicLong-的常用方法"><a href="#列举几个AtomicLong-的常用方法" class="headerlink" title="列举几个AtomicLong 的常用方法"></a>列举几个AtomicLong 的常用方法</h1><ul>
<li>long getAndIncrement() ：以原子方式将当前值加1，注意，返回的是旧值。（i++)</li>
<li>long incrementAndGet() ：以原子方式将当前值加1，注意，返回的是新值。（++i）</li>
<li>long getAndDecrement() ：以原子方式将当前值减 1，注意，返回的是旧值 。(i–)</li>
<li>long decrementAndGet() ：以原子方式将当前值减 1，注意，返回的是新值 。(–i)</li>
<li>long addAndGet（int delta） ：以原子方式将输入的数值与实例中的值（AtomicLong里的value）相加，并返回结果</li>
</ul>
<h1 id="说说-AtomicInteger-和-synchronized-的异同点？"><a href="#说说-AtomicInteger-和-synchronized-的异同点？" class="headerlink" title="说说 AtomicInteger 和 synchronized 的异同点？"></a>说说 <code>AtomicInteger</code> 和 <code>synchronized</code> 的异同点？</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p> 都是线程安全</p>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><ul>
<li><p>1、背后原理<br>  synchronized 背后的 monitor 锁。在执行同步代码之前，需要首先获取到 monitor 锁，执行完毕后，再释放锁。原子类，线程安全的原理是利用了 CAS 操作。</p>
</li>
<li><p>2、使用范围</p>
<p>  原子类使用范围是比较局限的,一个原子类仅仅是一个对象，不够灵活。而 synchronized 的使用范围要广泛得多。比如说 synchronized 既可以修饰一个方法，又可以修饰一段代码，相当于可以根据我们的需要，非常灵活地去控制它的应用范围</p>
</li>
<li><p>3、粒度</p>
<p>  原子变量的粒度是比较小的，它可以把竞争范围缩小到变量级别。通常情况下，synchronized 锁的粒度都要大于原子变量的粒度。</p>
</li>
<li><p>4、性能<br>  <code>synchronized</code> 是一种典型的悲观锁，而原子类恰恰相反，它利用的是乐观锁。</p>
</li>
</ul>
<h1 id="原子类和-volatile-有什么异同？"><a href="#原子类和-volatile-有什么异同？" class="headerlink" title="原子类和 volatile 有什么异同？"></a>原子类和 volatile 有什么异同？</h1><ul>
<li><code>volatile</code> 可见性问题</li>
<li>解决原子性问题</li>
</ul>
<h1 id="AtomicLong-可否被-LongAdder-替代？"><a href="#AtomicLong-可否被-LongAdder-替代？" class="headerlink" title="AtomicLong 可否被 LongAdder 替代？"></a><code>AtomicLong</code> 可否被 <code>LongAdder</code> 替代？</h1><p>有了更高效的 LongAdder，那 AtomicLong 可否不使用了呢？是否凡是用到 AtomicLong 的地方，都可以用 LongAdder 替换掉呢？答案是不是的，这需要区分场景。</p>
<p>LongAdder 只提供了 add、increment 等简单的方法，适合的是统计求和计数的场景，场景比较单一，而 AtomicLong 还具有 compareAndSet 等高级方法，可以应对除了加减之外的更复杂的需要 CAS 的场景。</p>
<p>结论：如果我们的场景仅仅是需要用到加和减操作的话，那么可以直接使用更高效的 LongAdder，但如果我们需要利用 CAS 比如compareAndSet 等操作的话，就需要使用 AtomicLong 来完成。</p>
<h1 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h1><h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>ReentrantLock支持公平锁和非公平锁两种方式。公平锁指锁的分配和竞争机制是公平的，即遵循先到先得原则。非公平锁指JVM遵循随机、就近原则分配锁的机制。ReentrantLock通过在构造函数ReentrantLock(boolean fair)中传递不同的参数来定义不同类型的锁，默认的实现是非公平锁。这是因为，非公平锁虽然放弃了锁的公平性，但是执行效率明显高于公平锁。如果系统没有特殊的要求，一般情况下建议使用非公平锁。</p>
<h2 id="synchronized-和-lock-有什么区别？"><a href="#synchronized-和-lock-有什么区别？" class="headerlink" title="synchronized 和 lock 有什么区别？"></a><code>synchronized</code> 和 <code>lock</code> 有什么区别？</h2><ul>
<li>synchronized 可以给类，方法，代码块加锁，而 lock 只能给代码块加锁。</li>
<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁，而 lock 需要手动自己加锁和释放锁，如果使用不当没有 unLock 去释放锁，就会造成死锁。</li>
<li>通过 lock 可以知道有没有成功获取锁，而 synchronized 无法办到。</li>
</ul>
<h2 id="synchronized-和-Lock-如何选择？"><a href="#synchronized-和-Lock-如何选择？" class="headerlink" title="synchronized 和 Lock 如何选择？"></a><code>synchronized</code> 和 <code>Lock</code> 如何选择？</h2><ul>
<li><code>synchronized</code> 和 <code>Lock</code> 都是用来保护资源线程安全的。<br>都保证了可见性和互斥性。</li>
<li><code>synchronized</code> 和 <code>ReentrantLock</code> 都拥有可重入的特点。</li>
</ul>
<p>不同点：</p>
<ul>
<li>用法（lock 需要配合finally ）</li>
<li>ReentrantLock可响应中断、可轮回，为处理锁提供了更多的灵活性</li>
<li>ReentrantLock通过Condition可以绑定多个条件</li>
<li>加解锁顺序（）</li>
<li>synchronized 锁不够灵活</li>
<li>是否可以设置公平/非公平</li>
<li>二者的底层实现不一样：synchronized是同步阻塞，采用的是悲观并发策略；Lock是同步非阻塞，采用的是乐观并发策略。</li>
</ul>
<p>使用</p>
<ul>
<li>如果能不用最好既不使用 Lock 也不使用 synchronized。</li>
<li>如果 synchronized 关键字适合你的程序，这样可以减少编写代码的数量，减少出错的概率</li>
<li>如果特别需要 Lock 的特殊功能，比如尝试获取锁、可中断、超时功能等，才使用 Lock。</li>
</ul>
<h2 id="Lock接口的主要方法"><a href="#Lock接口的主要方法" class="headerlink" title="Lock接口的主要方法"></a>Lock接口的主要方法</h2><ul>
<li>void lock():获取锁，调用该方法当前线程将会获取锁，当锁获得后，从该方法返回</li>
<li>void lockInterruptibly() throws InterruptedException:可中断地获取锁，和lock方法地不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程</li>
<li>boolean tryLock(): 尝试非阻塞地获取锁，调用该方法后立刻返回，如果能够获取则返回 true 否则 返回false</li>
<li>boolean tryLock(long time, TimeUnit unit):超时地获取锁，当前线程在以下 3 种情况下会返回：<ul>
<li>当前线程在超时时间内获得了锁</li>
<li>当前线程在超时时间被中断</li>
<li>超时时间结束后，返回 false</li>
</ul>
</li>
<li>void unlock(): 释放锁</li>
<li>Condition newCondition():获取锁等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的 wait() 方法，而调用后，当前线程将释放锁。</li>
</ul>
<h2 id="tryLock、lock和lockInterruptibly的区别"><a href="#tryLock、lock和lockInterruptibly的区别" class="headerlink" title="tryLock、lock和lockInterruptibly的区别"></a>tryLock、lock和lockInterruptibly的区别</h2><pre><code>tryLock、lock和lockInterruptibly的区别如下。
</code></pre>
<ul>
<li>tryLock若有可用锁，则获取该锁并返回true，否则返回false，不会有延迟或等待；tryLock(long timeout, TimeUnit unit)可以增加时间限制，如果超过了指定的时间还没获得锁，则返回 false。</li>
<li>lock若有可用锁，则获取该锁并返回true，否则会一直等待直到获取可用锁。</li>
<li>在锁中断时lockInterruptibly会抛出异常，lock不会。<br>突击并发编程JUC系列-ReentrantLock</li>
</ul>
<h2 id="ReentrantReadWriteLock-读写锁的获取规则"><a href="#ReentrantReadWriteLock-读写锁的获取规则" class="headerlink" title="ReentrantReadWriteLock 读写锁的获取规则"></a>ReentrantReadWriteLock 读写锁的获取规则</h2><p>要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现。也可以总结为：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥）</p>
<p>ReentrantLock 适用于一般场合，ReadWriteLock 适用于读多写少的情况，合理使用可以进一步提高并发效率。</p>
<h2 id="读锁应该插队吗？什么是读写锁的升降级？"><a href="#读锁应该插队吗？什么是读写锁的升降级？" class="headerlink" title="读锁应该插队吗？什么是读写锁的升降级？"></a>读锁应该插队吗？什么是读写锁的升降级？</h2><p>ReentrantReadWriteLock 的实现选择了“不允许插队”的策略，这就大大减小了发生“饥饿”的概率。</p>
<p>插队策略</p>
<ul>
<li>公平策略下，只要队列里有线程已经在排队，就不允许插队。</li>
<li>非公平策略下：<ul>
<li>如果允许读锁插队，那么由于读锁可以同时被多个线程持有，所以可能造成源源不断的后面的线程一直插队成功，导致读锁一直不能完全释放，从而导致写锁一直等待，为了防止“饥饿”，在等待队列的头结点是尝试获取写锁的线程的时候，不允许读锁插队。</li>
<li>写锁可以随时插队，因为写锁并不容易插队成功，写锁只有在当前没有任何其他线程持有读锁和写锁的时候，才能插队成功，同时写锁一旦插队失败就会进入等待队列，所以很难造成“饥饿”的情况，允许写锁插队是为了提高效率。</li>
</ul>
</li>
</ul>
<p>升降级策略：只能从写锁降级为读锁，不能从读锁升级为写锁。</p>
<h2 id="怎么防止死锁？"><a href="#怎么防止死锁？" class="headerlink" title="怎么防止死锁？"></a>怎么防止死锁？</h2><ul>
<li>尽量使用 tryLock(long timeout,TimeUnit unit) 的方法（ReentrantLock 、ReenttranReadWriteLock）设置超时时间，超时可以退出防止死锁。</li>
<li>尽量使用 java.util.concurrent 并发类代替手写锁。</li>
<li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li>
<li>尽量减少同步的代码块。</li>
</ul>
<h2 id="Condition-类和-Object-类锁方法区别区别"><a href="#Condition-类和-Object-类锁方法区别区别" class="headerlink" title="Condition 类和 Object 类锁方法区别区别"></a>Condition 类和 Object 类锁方法区别区别</h2><ul>
<li>Condition 类的 awiat 方法和 Object 类的 wait 方法等效</li>
<li>Condition 类的 signal 方法和 Object 类的 notify 方法等效</li>
<li>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效</li>
<li>ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的</li>
</ul>
<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="为什么-ConcurrentHashMap-比-HashTable-效率要高？"><a href="#为什么-ConcurrentHashMap-比-HashTable-效率要高？" class="headerlink" title="为什么 ConcurrentHashMap 比 HashTable 效率要高？"></a>为什么 <code>ConcurrentHashMap</code> 比 <code>HashTable</code> 效率要高？</h2><ul>
<li>HashTable 使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞；</li>
<li>ConcurrentHashMap<ul>
<li>JDK 1.7 中使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于 Segment，包含多个 HashEntry。</li>
<li>JDK 1.8 中使用 CAS + synchronized + Node + 红黑树。锁粒度：Node（首结点）（实现 Map.Entry）。锁粒度降低了。</li>
</ul>
</li>
</ul>
<h2 id="ConcurrentHashMap-JDK-1-7-JDK-1-8"><a href="#ConcurrentHashMap-JDK-1-7-JDK-1-8" class="headerlink" title="ConcurrentHashMap JDK 1.7/JDK 1.8"></a>ConcurrentHashMap JDK 1.7/JDK 1.8</h2><blockquote>
<p>JDK 1.7 结构</p>
</blockquote>
<img data-src="/blog/posts/3eb5e557/2022-02-16-00-05-20.png" class="">

<p>JDK 1.7 中的ConcurrentHashMap 内部进行了 Segment分段，Segment 继承了 ReentrantLock，可以理解为一把锁，各个 Segment 之间都是相互独立上锁的，互不影响。</p>
<p>相比于之前的 Hashtable 每次操作都需要把整个对象锁住而言，大大提高了并发效率。因为它的锁与锁之间是独立的，而不是整个对象只有一把锁。</p>
<p>每个 Segment 的底层数据结构与 HashMap 类似，仍然是数组和链表组成的拉链法结构。默认有 0~15 共 16 个 Segment，所以最多可以同时支持 16 个线程并发操作（操作分别分布在不同的 Segment 上）。16 这个默认值可以在初始化的时候设置为其他值，但是一旦确认初始化以后，是不可以扩容的。</p>
<blockquote>
<p>JDK 1.8 结构</p>
</blockquote>
<img data-src="/blog/posts/3eb5e557/2022-02-16-00-05-29.png" class="">

<p>图中的节点有三种类型： </p>
<ul>
<li>第一种是最简单的，空着的位置代表当前还没有元素来填充。</li>
<li>第二种就是和 HashMap 非常类似的拉链法结构，在每一个槽中会首先填入第一个节点，但是后续如果计算出相同的 Hash 值，就用链表的形式往后进行延伸。</li>
<li>第三种结构就是红黑树结构，这是 Java 7 的 ConcurrentHashMap 中所没有的结构，在此之前我们可能也很少接触这样的数据结构</li>
</ul>
<p>链表长度大于某一个阈值<code>**（默认为 8）**</code>，满足容量从链表的形式转化为红黑树的形式。<br>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色，红黑树的本质是对二叉查找树 BST 的一种平衡策略，我们可以理解为是一种平衡二叉查找树，查找效率高，会自动平衡，防止极端不平衡从而影响查找效率的情况发生，红黑树每个节点要么是红色，要么是黑色，但根节点永远是黑色的。</p>
<h2 id="ConcurrentHashMap-中-get-的过程"><a href="#ConcurrentHashMap-中-get-的过程" class="headerlink" title="ConcurrentHashMap 中 get 的过程"></a><code>ConcurrentHashMap</code> 中 get 的过程</h2><ul>
<li>计算 Hash 值，并由此值找到对应的槽点；</li>
<li>如果数组是空的或者该位置为 null，那么直接返回 null 就可以了；</li>
<li>如果该位置处的节点刚好就是我们需要的，直接返回该节点的值；</li>
<li>如果该位置节点是红黑树或者正在扩容，就用 find 方法继续查找；</li>
<li>否则那就是链表，就进行遍历链表查找</li>
</ul>
<h2 id="ConcurrentHashMap-中-put-的过程"><a href="#ConcurrentHashMap-中-put-的过程" class="headerlink" title="ConcurrentHashMap 中 put 的过程"></a><code>ConcurrentHashMap</code> 中 put 的过程</h2><ul>
<li>判断 Node[] 数组是否初始化，没有则进行初始化操作</li>
<li>通过 hash 定位数组的索引坐标，是否有 Node 节点，如果没有则使用 CAS 进行添加（链表的头节点），添加失败则进入下次循环。</li>
<li>检查到内部正在扩容，就帮助它一块扩容。</li>
<li>如果 f != null ，则使用 synchronized 锁住 f 元素（链表/红黑二叉树的头元素）<ul>
<li>如果是 Node （链表结构）则执行链表的添加操作</li>
<li>如果是 TreeNode （树形结构）则执行树添加操作。</li>
</ul>
</li>
<li>判断链表长度已经达到临界值 8 ，当然这个 8 是默认值，大家也可以去做调整，当节点数超过这个值就需要把链表转换为树结构。</li>
</ul>
<h2 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列?"></a>什么是阻塞队列?</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p>
<p>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。<br>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。<br>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p>
<h2 id="列举几个常见的阻塞队列"><a href="#列举几个常见的阻塞队列" class="headerlink" title="列举几个常见的阻塞队列"></a>列举几个常见的阻塞队列</h2><ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="使用线程池的优势"><a href="#使用线程池的优势" class="headerlink" title="使用线程池的优势"></a>使用线程池的优势</h2><p><code>Java</code> 中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。</p>
<ul>
<li>降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。 当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。 线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。</li>
</ul>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>当提交一个新任务到线程池时，线程池的处理流程如下：</p>
<ul>
<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li>
<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li>
<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li>
</ul>
<img data-src="/blog/posts/3eb5e557/2022-02-16-00-05-47.png" class="">

<p><code>ThreadPoolExecutor</code>执行<code>execute()</code>方法的示意图 如下:</p>
<img data-src="/blog/posts/3eb5e557/2022-02-16-00-05-55.png" class="">

<p><code>ThreadPoolExecutor</code>执行<code>execute</code>方法分下面 4 种情况:</p>
<ul>
<li>1、如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</li>
<li>2、如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li>
<li>3、如果无法将任务加入<code>BlockingQueue（队列已满）</code>，则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</li>
<li>4、如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li>
</ul>
<p><code>ThreadPoolExecutor</code>采取上述步骤的总体设计思路，是为了在执行<code>execute()</code>方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在<code>ThreadPoolExecutor</code>完成预热之后（当前运行的线程数大于等于<code>corePoolSize</code>），几乎所有的<code>execute()</code>方法调用都是执行步骤 2，而步骤2不需要获取全局锁。</p>
<h2 id="创建线程有三种方式："><a href="#创建线程有三种方式：" class="headerlink" title="创建线程有三种方式："></a>创建线程有三种方式：</h2><ol>
<li>继承 <code>Thread</code> 重写 <code>run</code> 方法</li>
<li>实现 <code>Runnable</code> 接口</li>
<li>实现 <code>Callable</code> 接口 （有返回值）</li>
</ol>
<h2 id="线程有哪些状态？"><a href="#线程有哪些状态？" class="headerlink" title="线程有哪些状态？"></a>线程有哪些状态？</h2><ul>
<li><code>NEW（初始）</code>，新建状态，线程被创建出来，但尚未启动时的线程状态；</li>
<li><code>RUNNABLE（就绪状态）</code>，表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配 CPU 资源；</li>
<li><code>BLOCKED（阻塞）</code>，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行 synchronized 代码块或者使用 synchronized 标记的方法；</li>
<li><code>WAITING（等待）</code>，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了 Object.wait() 方法，那它就在等待另一个线程调用 Object.notify() 或 Object.notifyAll() 方法；</li>
<li><code>TIMED_WAITING（超时等待）</code>，计时等待状态，和等待状态（WAITING）类似，它只是多了超时时间，比如调用了有超时时间设置的方法 Object.wait(long timeout) 和 Thread.join(long timeout) 等这些方法时，它才会进入此状态；</li>
<li><code>TERMINATED</code>，终止状态，表示线程已经执行完成。</li>
</ul>
<img data-src="/blog/posts/3eb5e557/2022-02-16-00-06-07.png" class="">

<h2 id="线程池的状态有那些？"><a href="#线程池的状态有那些？" class="headerlink" title="线程池的状态有那些？"></a>线程池的状态有那些？</h2><ul>
<li><code>running</code> ：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li>
<li><code>shutdown：</code>不接受新的任务提交，但是会继续处理等待队列中的任务。</li>
<li><code>stop：</code>不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li>
<li><code>tidying：</code>所有的任务都销毁了，workcount 为 0，线程池的状态再转换 tidying 状态时，会执行钩子方法 terminated()。</li>
<li><code>terminated：</code> terminated() 方法结束后，线程池的状态就会变成这个。</li>
</ul>
<img data-src="/blog/posts/3eb5e557/2022-02-16-00-06-17.png" class="">

<h2 id="线程池中-sumbit-和-execute-方法有什么区别？"><a href="#线程池中-sumbit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 sumbit() 和 execute() 方法有什么区别？"></a>线程池中 <code>sumbit()</code> 和 <code>execute()</code> 方法有什么区别？</h2><ul>
<li><code>execute():</code> 只能执行 <code>Runable</code> 类型的任务。</li>
<li><code>submit()</code> 可以执行 <code>Runable</code> 和 <code>Callable</code> 类型的任务。</li>
</ul>
<p>​ <code>Callable</code> 类型的任务可以获取执行的返回值，而 <code>Runnable</code> 执行无返回值。</p>
<h2 id="线程池创建的方式"><a href="#线程池创建的方式" class="headerlink" title="线程池创建的方式"></a>线程池创建的方式</h2><ul>
<li><code>newSingleThreadExecutor():</code> 他的特点是在于线程数目被限制位1：操作一个无界的工作队列，所以它保证了所有的任务的都是顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</li>
<li><code>newCachedThreadPool():</code>它是一种用来处理大量短时间工作任务的线程，具有几个鲜明的特点，它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程，如果线程闲置的时间超过 60 秒，则被终止并移除缓存；长时间闲置时，这种线程池不会消耗什么资源，其内部使用 synchronousQueue 作为工作队列。</li>
<li><code>newFixedThreadPool(int nThreads) </code>：重用指定数目 nThreads 的线程，其背后使用的无界的工作队列，任何时候最后有 nThreads 个工作线程活动的，这意味着 如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现，如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。</li>
<li><code>newSingleThreadScheduledExecutor():</code> 创建单线程池，返回ScheduleExecutorService 可以进行定时或周期性的工作强度。</li>
<li><code>newScheduleThreadPool(int corePoolSize):</code> 和 newSingleThreadSceduleExecutor() 类似，创建的ScheduledExecutorService可以进行定时或周期的工作调度，区别在于单一工作线程还是工作线程。</li>
<li><code>newWorkStrealingPool(int parallelism):</code>这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool利用 work-strealing 算法 并行的处理任务，不保证处理顺序。</li>
<li><code>ThreadPollExecutor ：</code> 是最原始的线程池创建，上面 1-3 创建方式 都是对ThreadPoolExecutor 的封装。</li>
</ul>
<p>上面 7 种创建方式中，前 6 种 通过<code>Executors</code>工厂方法创建，<code>ThreadPoolExecutor</code> 手动创建。</p>
<h2 id="ThreadPollExecutor-构造方法"><a href="#ThreadPollExecutor-构造方法" class="headerlink" title="ThreadPollExecutor 构造方法"></a><code>ThreadPollExecutor</code> 构造方法</h2><p>下面介绍下 <code>ThreadPoolExecutor</code> 接收 7 个参数的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//线程池的核心线程数量</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> maximumPoolSize,//线程池的最大线程数</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span></span><br><span class="line"><span class="params"><span class="function">        TimeUnit unit,//时间单位</span></span></span><br><span class="line"><span class="params"><span class="function">        BlockingQueue&lt;Runnable&gt; workQueue,//任务队列</span></span></span><br><span class="line"><span class="params"><span class="function">        ThreadFactory threadFactory,//线程工厂</span></span></span><br><span class="line"><span class="params"><span class="function">        RejectedExecutionHandler handler//拒绝策略</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function">```                            </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">- ``corePoolSize`` : 核心线程数线程数定义了最小可以同时运行的线程数量。</span></span><br><span class="line"><span class="function">- ``maximumPoolSize`` : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</span></span><br><span class="line"><span class="function">- ``workQueue``: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，信任就会被存放在队列中。</span></span><br><span class="line"><span class="function">- ``keepAliveTime``:线程活动保持时间,当线程池中的线程数量大于 ``corePoolSize`` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 ``keepAliveTime``才会被回收销毁；</span></span><br><span class="line"><span class="function">- ``unit`` : ``keepAliveTime`` 参数的时间单位。</span></span><br><span class="line"><span class="function">- ``threadFactory`` : 任务队列，用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</span></span><br><span class="line"><span class="function">    - ``ArrayBlockingQueue：``是一个基于数组结构的有界阻塞队列，此队列按 ``FIFO``（先进先出）原则对元素进行排序。</span></span><br><span class="line"><span class="function">    - ``LinkedBlockingQueue：``一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于``ArrayBlockingQueue``。静态工厂方法``Executors.<span class="title">newFixedThreadPool</span><span class="params">()</span>``使用了这个队列。</span></span><br><span class="line"><span class="function">    - ``SynchronousQueue：``一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于``Linked-BlockingQueue``，静态工厂方法``Executors.newCachedThreadPool``使用了这个队列。</span></span><br><span class="line"><span class="function">    - ``PriorityBlockingQueue：``一个具有优先级的无限阻塞队列。</span></span><br><span class="line"><span class="function">- ``handler`` :饱和策略<span class="params">(又称拒绝策略)</span>。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是``AbortPolicy``，表示无法处理新任务时抛出异常。在``JDK 1.5`` 中 ``Java`` 线程池框架提供了以下4种策略。</span></span><br><span class="line"><span class="function">    - ``AbortPolicy：``直接抛出异常。</span></span><br><span class="line"><span class="function">    - ``CallerRunsPolicy``：只用调用者所在线程来运行任务。</span></span><br><span class="line"><span class="function">    - ``DiscardOldestPolicy``：丢弃队列里最近的一个任务，并执行当前任务。</span></span><br><span class="line"><span class="function">    - ``DiscardPolicy：``不处理，丢弃掉</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># hashmap的底层</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用<span class="keyword">null</span>值和<span class="keyword">null</span>键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;% asset_img <span class="number">2022</span>-<span class="number">02</span>-<span class="number">16</span>-<span class="number">00</span>-<span class="number">06</span>-<span class="number">31.</span>png %&#125;</span><br><span class="line"></span><br><span class="line">从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。</span><br><span class="line"></span><br><span class="line">可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表</span><br><span class="line"></span><br><span class="line">```<span class="function">java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// HashMap允许存放null键和null值。 </span></span><br><span class="line">    <span class="comment">// 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。 if (key == null) return putForNullKey(value);</span></span><br><span class="line">     <span class="comment">// 根据key的keyCode重新计算hash值。 int hash = hash(key.hashCode()); </span></span><br><span class="line">     <span class="comment">// 搜索指定hash值在对应table中的索引。 int i = indexFor(hash, table.length); </span></span><br><span class="line">     <span class="comment">// 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。 for (Entry e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; </span></span><br><span class="line">         <span class="comment">// 如果发现已有该键值，则存储新的值，并返回原始值 V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; </span></span><br><span class="line">         <span class="comment">// 如果i索引处的Entry为null，表明此处还没有Entry。 modCount++; </span></span><br><span class="line">     <span class="comment">// 将key、value添加到i索引处。 addEntry(hash, key, value, i); return null;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p>
<p>hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。</p>
<p><strong>HashMap中的两个重要的参数：<code>HashMap</code>中有两个重要的参数：初始容量大小和加载因子，初始容量大小是创建时给数组分配的容量大小，默认值为<code>16</code>，用数组容量大小乘以加载因子得到一个值，一旦数组中存储的元素个数超过该值就会调用<code>rehash</code>方法将数组容量增加到<code>原来的两倍</code>，专业术语叫做扩容。</strong></p>
<h2 id="TreeMap的底层实现原理"><a href="#TreeMap的底层实现原理" class="headerlink" title="TreeMap的底层实现原理"></a>TreeMap的底层实现原理</h2><p>基于红黑树实现的排序<code>Map</code></p>
<p><code>TreeMap</code>增删改查的时间复杂度<br><code>TreeMap</code>的增删改查和统计相关的操作的时间复杂度都为 <code>O(logn)</code></p>
<p><code>TreeMap</code>的<code>key</code>和<code>value</code>的要求<br>由于实现了<code>Map</code>接口，则<code>key</code>的值不允许重复（重复则覆盖），也不允许为<code>null</code>，按照<code>key</code>的自然顺序排序或者<code>Comparator</code>接口指定的排序方法进行排序。<br><code>value</code>允许重复，也允许为<code>null</code>，当<code>key</code>重复时，会覆盖此<code>value</code>值。<br>2- TreeMap的使用场景<br>考虑如下场景：</p>
<ul>
<li><p>需要基于排序的统计功能：</p>
<ul>
<li>由于TreeMap是基于红黑树的实现的排序Map，对于增删改查以及统计的时间复杂度都控制在<code>O(logn)</code>的级别上，相对于<code>HashMap</code>和Liked<code>HashMap</code>的统计操作的(最大的key，最小的key，大于某一个key的所有Entry等等)时间复杂度O(n)具有较高时间效率。</li>
</ul>
</li>
<li><p>需要快速增删改查的存储功能：</p>
<ul>
<li>相对于<code>HashMap</code>和<code>LikedHashMap</code> 这些 hash表的时间复杂度O(1)（不考虑冲突情况），TreeMap的增删改查的时间复杂度为<code>O(logn)</code>就显得效率较低。</li>
</ul>
</li>
<li><p>需要快速增删改查而且需要保证遍历和插入顺序一致的存储功能：</p>
<ul>
<li>相对于<code>HashMap</code>和<code>LikedHashMap</code> 这些 hash表的时间复杂度O(1)（不考虑冲突情况），TreeMap的增删改查的时间复杂度为<code>O(logn)</code>就显得效率较低。但是<code>HashMap</code>并不保证任何顺序性。<code>LikedHashMap</code>额外保证了Map的遍历顺序与put顺序一致的有序性。</li>
</ul>
</li>
</ul>
<p>综上：场景1适合使用<code>TreeMap</code>，场景2适合使用<code>HashMap</code>，场景3适合使用<code>LikedHashMap</code>，需要注意它们都是非线程安全的，当在并发场景下可以使用其他并发集合或者调用者在调用层去控制并发使得操作串行执行。</p>
<h1 id="ArrayList底层原理"><a href="#ArrayList底层原理" class="headerlink" title="ArrayList底层原理"></a><code>ArrayList</code>底层原理</h1><p><strong><code>ArrayList</code>、<code>LinkedList</code> 和 <code>Vector</code> 的区别。</strong></p>
<ol>
<li><code>ArrayList</code>非线程安全的，<code>Vector</code>是线程安全的。</li>
<li><code>ArrayList</code>扩容时按照50%增加，<code>Vector</code>按照100%增加。</li>
<li><code>ArrayList</code>的性能要高于<code>Vector</code></li>
<li><code>LinkedList</code>是链表实现的，因此查询慢，增删快。</li>
<li><code>LinkedList</code>提供了List接口没有提供的方法，方便数据的头尾操作。</li>
</ol>
<h2 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a><code>ArrayList</code>简介</h2><p>　　<code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 <code>Java</code> 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p>
<p>它继承于 <code>AbstractList</code>，实现了 <code>List, RandomAccess, Cloneable, java.io.Serializable</code> 这些接口。</p>
<p>在我们学数据结构的时候就知道了线性表的顺序存储，插入删除元素的时间复杂度为<code>O（n）</code>,求表长以及增加元素，取第 <code>i</code> 元素的时间复杂度为<code>O（1）</code></p>
<p>　 <code>ArrayList</code> 继承了<code>AbstractList</code>，实现了<code>List</code>。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p>
<p>　　<code>ArrayList</code> 实现了<code>RandomAccess</code> 接口， <code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</p>
<p>　　<code>ArrayList</code> 实现了<code>Cloneable</code> 接口，即覆盖了函数 <code>clone()</code>，能被克隆。</p>
<p>　　<code>ArrayList</code> 实现<code>java.io.Serializable</code> 接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</p>
<p>　　和 <code>Vector</code> 不同，<code>ArrayList</code> 中的操作不是线程安全的！所以，建议在单线程中才使用 <code>ArrayList</code>，而在多线程中可以选择 <code>Vector</code> 或者 <code>CopyOnWriteArrayList</code>。</p>
<h2 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a><code>ArrayList</code>源码分析</h2><p><code>System.arraycopy()</code>和<code>Arrays.copyOf()</code>方法</p>
<p>通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面<code>add(int index, E element)</code>方法就很巧妙的用到了<code>arraycopy()</code>方法让数组自己复制自己实现让<code>index</code>开始之后的所有成员后移一个位置:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class="line"><span class="comment">    *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">    *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又如<code>toArray()</code>方法中用到了<code>copyOf()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class="line"><span class="comment">    *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">    *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"><span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>两者联系与区别</p>
</blockquote>
<p>联系： 看两者源代码可以发现<code>copyOf()</code>内部调用了<code>System.arraycopy()</code>方法 区别：</p>
<ol>
<li><code>arraycopy()</code>需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li>
<li><code>copyOf()</code>是系统自动在内部新建一个数组，并返回该数组。</li>
</ol>
<blockquote>
<p><code>ArrayList</code> 核心扩容技术</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否需要扩容,上面两个方法都要调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。</span></span><br><span class="line">    <span class="comment">//这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//elementData为保存ArrayList数据的数组</span></span><br><span class="line">    <span class="comment">///elementData.length求数组长度elementData.size是求数组中的元素个数</span></span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">    <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);  <span class="comment">// 扩容方法copyOf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：<strong>移位运算符</strong> 　简介：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:&lt;&lt;(左移)、&gt;&gt;(带符号右移)和&gt;&gt;&gt;(无符号右移)。 　　<strong>作用：对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</strong> 　比如这里：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。</p>
<blockquote>
<p>另外需要注意的是：</p>
</blockquote>
<ol>
<li>java 中的length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>
<li>java 中的length()方法是针对字 符串String说的,如果想看这个字符串的长度则用到 length()这个方法.</li>
<li>.java 中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>
</ol>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><code>CopyOnWriteArrayList</code></h2><p>原理是读写分离，写时复制的思想，即先拷贝一份副本然后加锁，在副本写数据完成后，将集合的应用指向刚写完的副本，代替原来的集合，这种集合适合多写少读的情况</p>
<ul>
<li><code>add</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line"> lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">// 数组扩容</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring框架的设计目标，设计理念，和核心是什么"><a href="#Spring框架的设计目标，设计理念，和核心是什么" class="headerlink" title="Spring框架的设计目标，设计理念，和核心是什么?"></a>Spring框架的设计目标，设计理念，和核心是什么?</h2><ul>
<li><p><code>Spring</code>设计目标：<code>Spring</code>为开发者提供一个一站式轻量级应用开发平台；</p>
</li>
<li><p><code>Spring</code>设计理念：在<code>JavaEE</code>开发中，支持<code>POJO</code>和<code>JavaBean</code>开发方式，使应用面向接口开发，充分支持<code>OO（面向对象）</code>设计方法；<code>Spring</code>通过<code>IoC</code>容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给<code>IoC</code>容器，实现解耦；</p>
</li>
<li><p><code>Spring</code>框架的核心：<code>IoC</code>容器和AOP模块。通过<code>IoC</code>容器管理<code>POJO</code>对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。</p>
</li>
</ul>
<p><code>IoC</code>让相互协作的组件保持松散的耦合，而<code>AOP</code>编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p>
<h2 id="Spring的优缺点是什么？"><a href="#Spring的优缺点是什么？" class="headerlink" title="Spring的优缺点是什么？"></a>Spring的优缺点是什么？</h2><p>优点</p>
<ul>
<li><p>方便解耦，简化开发</p>
</li>
<li><p>Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。</p>
</li>
<li><p>AOP编程的支持</p>
<p>  Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>
</li>
<li><p>声明式事务的支持</p>
<p>  只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>
</li>
<li><p>方便程序的测试</p>
<p>  Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p>
</li>
<li><p>方便集成各种优秀框架</p>
<p>  Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</p>
</li>
<li><p>降低JavaEE API的使用难度</p>
<p>  Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li>Spring明明一个很轻量级的框架，却给人感觉大而全</li>
<li>Spring依赖反射，反射影响性能</li>
<li>使用门槛升高，入门Spring需要较长时间</li>
</ul>
<h2 id="Spring由哪些模块组成？"><a href="#Spring由哪些模块组成？" class="headerlink" title="Spring由哪些模块组成？"></a>Spring由哪些模块组成？</h2><p><code>Spring</code> 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器<code>（Core Container）</code> 、<code> AOP（Aspect Oriented Programming）</code>和设备支持<code>（Instrmentation）</code> 、数据访问与集成<code>（Data Access/Integeration）</code> 、 <code>Web</code>、<code> 消息（Messaging）</code> 、 <code>Test</code>等 6 个模块中。 以下是 <code>Spring</code> 5 的模块结构图：</p>
<img data-src="/blog/posts/3eb5e557/2022-02-16-00-06-51.png" class="">

<ul>
<li><code>spring core</code>：提供了框架的基本组成部分，包括控制反转（<code>Inversion of Control，IOC</code>）和依赖注入（<code>Dependency Injection，DI</code>）功能。</li>
<li><code>spring beans</code>：提供了<code>BeanFactory</code>，是工厂模式的一个经典实现，<code>Spring</code>将管理对象称为Bean。</li>
<li><code>spring context</code>：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li>
<li><code>spring jdbc</code>：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。</li>
<li><code>spring aop</code>：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li>
<li><code>spring Web</code>：提供了针对 <code>Web</code> 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 <code>Web</code> 的 <code>ApplicationContext</code>。</li>
<li><code>spring test</code>：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</li>
</ul>
<h2 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a><code>Spring</code> 框架中都用到了哪些设计模式？</h2><ul>
<li>工厂模式：<code>BeanFactory</code>就是简单工厂模式的体现，用来创建对象的实例；</li>
<li>单例模式：<code>Bean</code>默认为单例模式。</li>
<li>代理模式：<code>Spring</code>的AOP功能用到了<code>JDK</code>的动态代理和CGLIB字节码生成技术；</li>
<li>模板方法：用来解决代码重复的问题。比如. <code>RestTemplate</code>, <code>JmsTemplate</code>, <code>JpaTemplate</code>。</li>
<li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如<code>Spring</code>中<code>listener</code>的实现–<code>ApplicationListener</code>。</li>
</ul>
<h2 id="Spring控制反转-IOC"><a href="#Spring控制反转-IOC" class="headerlink" title="Spring控制反转(IOC)"></a><code>Spring</code>控制反转<code>(IOC)</code></h2><h3 id="什么是Spring-IOC-容器？"><a href="#什么是Spring-IOC-容器？" class="headerlink" title="什么是Spring IOC 容器？"></a>什么是Spring IOC 容器？</h3><p>控制反转即<code>IoC (Inversion of Control)</code>，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p>
<p><code>Spring IOC</code> 负责创建对象，管理对象<code>（通过依赖注入（DI）</code>，装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
<h3 id="控制反转-IoC-有什么作用"><a href="#控制反转-IoC-有什么作用" class="headerlink" title="控制反转(IoC)有什么作用"></a>控制反转<code>(IoC)</code>有什么作用</h3><ul>
<li><p>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的</p>
</li>
<li><p>解耦，由容器去维护具体的对象</p>
</li>
<li><p>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</p>
</li>
</ul>
<h3 id="IOC的优点是什么？"><a href="#IOC的优点是什么？" class="headerlink" title="IOC的优点是什么？"></a>IOC的优点是什么？</h3><ul>
<li><code>IOC</code> 或 依赖注入把应用的代码量降到最低。</li>
<li>它使应用容易测试，单元测试不再需要单例和<code>JNDI</code>查找机制。</li>
<li>最小的代价和最小的侵入性使松散耦合得以实现。</li>
<li><code>IOC</code>容器支持加载服务时的饿汉式初始化和懒加载。</li>
</ul>
<h2 id="Spring-的-IoC支持哪些功能"><a href="#Spring-的-IoC支持哪些功能" class="headerlink" title="Spring 的 IoC支持哪些功能"></a><code>Spring</code> 的 <code>IoC</code>支持哪些功能</h2><p><code>Spring</code> 的 <code>IoC</code> 设计支持以下功能：</p>
<ul>
<li>依赖注入</li>
<li>依赖检查</li>
<li>自动装配</li>
<li>支持集合</li>
<li>指定初始化方法和销毁方法</li>
<li>支持回调某些方法（但是需要实现 <code>Spring</code> 接口，略有侵入）</li>
</ul>
<p>其中，最重要的就是依赖注入，从 <code>XML</code> 的配置上说，即 <code>ref</code> 标签。对应 <code>Spring</code> <code>RuntimeBeanReference</code> 对象。</p>
<p>对于 <code>IoC</code> 来说，最重要的就是容器。容器管理着 <code>Bean</code> 的生命周期，控制着 <code>Bean</code> 的依赖注入。</p>
<h3 id="BeanFactory-和-ApplicationContext有什么区别？"><a href="#BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="BeanFactory 和 ApplicationContext有什么区别？"></a><code>BeanFactory</code> 和 <code>ApplicationContext</code>有什么区别？</h3><p><code>BeanFactory</code>和<code>ApplicationContext</code>是<code>Spring</code>的两大核心接口，都可以当做<code>Spring</code>的容器。其中<code>ApplicationContext</code>是<code>BeanFactory</code>的子接口。</p>
<blockquote>
<p>依赖关系</p>
</blockquote>
<p><code>BeanFactory</code>：是<code>Spring</code>里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>
<p><code>ApplicationContext</code>接口作为<code>BeanFactory</code>的派生，除了提供<code>BeanFactory</code>所具有的功能外，还提供了更完整的框架功能：</p>
<ul>
<li><p>继承<code>MessageSource</code>，因此支持国际化。</p>
</li>
<li><p>统一的资源文件访问方式。</p>
</li>
<li><p>提供在监听器中注册bean的事件。</p>
</li>
<li><p>同时加载多个配置文件。</p>
</li>
<li><p>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p>
</li>
</ul>
<blockquote>
<p>加载方式</p>
</blockquote>
<p><code>BeanFactroy</code>采用的是延迟加载形式来注入<code>Bean</code>的，即只有在使用到某个<code>Bean</code>时(调用<code>getBean()</code>)，才对该<code>Bean</code>进行加载实例化。这样，我们就不能发现一些存在的<code>Spring</code>的配置问题。如果<code>Bean</code>的某一个属性没有注入，<code>BeanFacotry</code>加载后，直至第一次使用调用<code>getBean</code>方法才会抛出异常。</p>
<p><code>ApplicationContext</code>，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现<code>Spring</code>中存在的配置错误，这样有利于检查所依赖属性是否注入。 <code>ApplicationContext</code>启动后预载入所有的单实例<code>Bean</code>，通过预载入单实例<code>bean</code> ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>
<p>相对于基本的<code>BeanFactory</code>，<code>ApplicationContext</code> 唯一的不足是占用内存空间。当应用程序配置<code>Bean</code>较多时，程序启动较慢。</p>
<blockquote>
<p>创建方式</p>
</blockquote>
<p><code>BeanFactory</code>通常以编程的方式被创建，<code>ApplicationContext</code>还能以声明的方式创建，如使用<code>ContextLoader</code>。</p>
<blockquote>
<p>注册方式</p>
</blockquote>
<p><code>BeanFactory</code>和<code>ApplicationContext</code>都支持<code>BeanPostProcessor</code>、<code>BeanFactoryPostProcessor</code>的使用，但两者之间的区别是：<code>BeanFactory</code>需要手动注册，而<code>ApplicationContext</code>则是自动注册。</p>
<h2 id="有哪些不同类型的依赖注入实现方式？"><a href="#有哪些不同类型的依赖注入实现方式？" class="headerlink" title="有哪些不同类型的依赖注入实现方式？"></a>有哪些不同类型的依赖注入实现方式？</h2><p>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（<code>Interface Injection</code>），<code>Setter</code>方法注入<code>（Setter Injection）</code>和构造器注入<code>（Constructor Injection）</code>三种方式。其中接口注入由于在灵活性和易用性比较差，现在从<code>Spring4</code>开始已被废弃。</p>
<ul>
<li><p><strong>构造器依赖注入</strong>: 构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>
</li>
<li><p><strong>Setter方法注入</strong>：<code>Setter</code>方法注入是容器通过调用无参构造器或无参<code>static</code>工厂 方法实例化<code>bean</code>之后，调用该<code>bean</code>的<code>setter</code>方法，即实现了基于<code>setter</code>的依赖注入。</p>
</li>
</ul>
<p>构造器依赖注入和 <code>Setter</code>方法注入的区别</p>
<table>
<thead>
<tr>
<th>构造函数注入</th>
<th><code>setter</code> 注入</th>
</tr>
</thead>
<tbody><tr>
<td>没有部分注入</td>
<td>有部分注入</td>
</tr>
<tr>
<td>不会覆盖 <code>setter</code> 属性</td>
<td>会覆盖 <code>setter</code> 属性</td>
</tr>
<tr>
<td>任意修改都会创建一个新实例</td>
<td>任意修改不会创建一个新实例</td>
</tr>
<tr>
<td>适用于设置很多属性</td>
<td>适用于设置少量属性</td>
</tr>
</tbody></table>
<p>两种依赖方式都可以使用，构造器注入和<code>Setter</code>方法注入。最好的解决方案是用构造器参数实现强制依赖，<code>setter</code>方法实现可选依赖。</p>
<h2 id="Spring-Beans（19）"><a href="#Spring-Beans（19）" class="headerlink" title="Spring Beans（19）"></a><code>Spring Beans</code>（19）</h2><h2 id="什么是Spring-beans？"><a href="#什么是Spring-beans？" class="headerlink" title="什么是Spring beans？"></a>什么是<code>Spring beans？</code></h2><p><code>Spring beans</code> 是那些形成<code>Spring</code>应用的主干的<code>java</code>对象。它们被<code>Spring IOC</code>容器初始化，装配，和管理。这些<code>beans</code>通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。</p>
<h2 id="一个-Spring-Bean-定义-包含什么？"><a href="#一个-Spring-Bean-定义-包含什么？" class="headerlink" title="一个 Spring Bean 定义 包含什么？"></a>一个 <code>Spring Bean</code> 定义 包含什么？</h2><p>一个<code>Spring Bean</code> 的定义包含容器必知的所有配置元数据，包括如何创建一个<code>bean</code>，它的生命周期详情及它的依赖。</p>
<h2 id="如何给Spring-容器提供配置元数据？Spring有几种配置方式"><a href="#如何给Spring-容器提供配置元数据？Spring有几种配置方式" class="headerlink" title="如何给Spring 容器提供配置元数据？Spring有几种配置方式"></a>如何给<code>Spring</code> 容器提供配置元数据？<code>Spring</code>有几种配置方式</h2><p>这里有三种重要的方法给<code>Spring</code> 容器提供配置元数据。</p>
<ul>
<li><code>XML</code>配置文件。</li>
<li>基于注解的配置。</li>
<li>基于<code>java</code>的配置。<h2 id="Spring配置文件包含了哪些信息"><a href="#Spring配置文件包含了哪些信息" class="headerlink" title="Spring配置文件包含了哪些信息"></a><code>Spring</code>配置文件包含了哪些信息</h2><code>Spring</code>配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</li>
</ul>
<h2 id="Spring基于xml注入bean的几种方式"><a href="#Spring基于xml注入bean的几种方式" class="headerlink" title="Spring基于xml注入bean的几种方式"></a><code>Spring</code>基于xml注入bean的几种方式</h2><ul>
<li><code>Set</code>方法注入；</li>
<li>构造器注入：①通过<code>index</code>设置参数的位置；②通过<code>type</code>设置参数类型；</li>
<li>静态工厂注入；</li>
<li>实例工厂；</li>
</ul>
<h2 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h2><p>当定义一个 在<code>Spring</code>里，我们还能给这个<code>bean</code>声明一个作用域。它可以通过<code>bean</code> 定义中的scope属性来定义。如，当<code>Spring</code>要在需要的时候每次生产一个新的<code>bean</code>实例，<code>bean</code>的scope属性被指定为prototype。另一方面，一个<code>bean</code>每次使用的时候必须返回同一个实例，这个<code>bean</code>的scope 属性 必须设为 singleton。</p>
<h2 id="解释Spring支持的几种bean的作用域"><a href="#解释Spring支持的几种bean的作用域" class="headerlink" title="解释Spring支持的几种bean的作用域"></a>解释<code>Spring</code>支持的几种<code>bean</code>的作用域</h2><p><code>Spring</code>框架支持以下五种<code>bean</code>的作用域：</p>
<ul>
<li><code>singleton</code> : <code>bean</code>在每个<code>Spring ioc</code> 容器中只有一个实例。</li>
<li><code>prototype</code>：一个<code>bean</code>的定义可以有多个实例。</li>
<li><code>request：</code>每次<code>http</code>请求都会创建一个<code>bean</code>，该作用域仅在基于<code>web</code>的<code>Spring ApplicationContext</code>情形下有效。</li>
<li><code>session</code>：在一个<code>HTTP Session</code>中，一个<code>bean</code>定义对应一个实例。该作用域仅在基于<code>web</code>的<code>Spring ApplicationContext</code>情形下有效。</li>
<li><code>global-session</code>：在一个全局的<code>HTTP Session</code>中，一个<code>bean</code>定义对应一个实例。该作用域仅在基于<code>web</code>的<code>Spring ApplicationContext</code>情形下有效。</li>
</ul>
<p><strong>注意：</strong> 缺省的<code>Spring bean </code>的作用域是<code>Singleton</code>。使用 <code>prototype</code> 作用域需要慎重的思考，因为频繁创建和销毁 <code>bean</code> 会带来很大的性能开销。</p>
<h2 id="解释Spring框架中bean的生命周期"><a href="#解释Spring框架中bean的生命周期" class="headerlink" title="解释Spring框架中bean的生命周期"></a>解释<code>Spring</code>框架中<code>bean</code>的生命周期</h2><p>在传统的<code>Java</code>应用中，<code>bean</code>的生命周期很简单。使用<code>Java</code>关键字<code>new</code>进行<code>bean</code>实例化，然后该<code>bean</code>就可以使用了。一旦该<code>bean</code>不再被使用，则由<code>Java</code>自动进行垃圾回收。相比之下，<code>Spring</code>容器中的<code>bean</code>的生命周期就显得相对复杂多了。正确理解<code>Spring</code> <code>bean</code>的生命周期非常重要，因为你或许要利用<code>Spring</code>提供的扩展点来自定义<code>bean</code>的创建过程。下图展示了<code>bean</code>装载到<code>Spring</code>应用上下文中的一个典型的生命周期过程。</p>
<img data-src="/blog/posts/3eb5e557/2022-02-16-00-07-14.png" class="">

<p>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。</p>
<p>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。</p>
<p>我们对上图进行详细描述：</p>
<p>Spring对bean进行实例化；</p>
<p>Spring将值和bean的引用注入到bean对应的属性中；</p>
<p>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</p>
<p>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</p>
<p>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</p>
<p>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</p>
<p>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p>
<p>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p>
<p>现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。</p>
<h2 id="什么是bean装配？"><a href="#什么是bean装配？" class="headerlink" title="什么是bean装配？"></a>什么是<code>bean</code>装配？</h2><p>装配，或<code>bean</code> 装配是指在<code>Spring</code> 容器中把<code>bean</code>组装到一起，前提是容器需要知道<code>bean</code>的依赖关系，如何通过依赖注入来把它们装配到一起。</p>
<h2 id="什么是bean的自动装配？"><a href="#什么是bean的自动装配？" class="headerlink" title="什么是bean的自动装配？"></a>什么是<code>bean</code>的自动装配？</h2><p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p>
<h2 id="解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？"><a href="#解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？" class="headerlink" title="解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？"></a>解释不同方式的自动装配，<code>spring</code> 自动装配 <code>bean</code> 有哪些方式？</h2><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p>
<p>在Spring框架xml配置中共有5种自动装配：</p>
<ul>
<li><p>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</p>
</li>
<li><p>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</p>
</li>
<li><p>byType：通过参数的数据类型进行自动装配。</p>
</li>
<li><p>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</p>
</li>
<li><p>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p>
</li>
</ul>
<h2 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用<code>@Autowired</code>注解自动装配的过程是怎样的？</h2><p>使用<code>@Autowired</code>注解来自动装配指定的<code>bean</code>。在使用<code>@Autowired</code>注解之前需要在<code>Spring</code>配置文件进行配置，<code>&lt;context:annotation-config /&gt;</code>。</p>
<p>在启动<code>spring IoC</code>时，容器自动装载了一个<code>AutowiredAnnotationBeanPostProcessor</code>后置处理器，当容器扫描到<code>@Autowied</code>、<code>@Resource</code>或<code>@Inject</code>时，就会在<code>IoC</code>容器自动查找需要的<code>bean</code>，并装配给该对象的属性。在使用<code>@Autowired</code>时，首先在容器中查询对应类型的<code>bean</code>：</p>
<p>如果查询结果刚好为一个，就将该<code>bean</code>装配给<code>@Autowired</code>指定的数据；</p>
<p>如果查询的结果不止一个，那么<code>@Autowired</code>会根据名称来查找；</p>
<p>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用<code>required=false。</code></p>
<h2 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h2><p>自动装配的局限性是：</p>
<ul>
<li><p>重写：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。</p>
</li>
<li><p>基本数据类型：你不能自动装配简单的属性，如基本数据类型，<code>String</code>字符串，和类。</p>
</li>
<li><p>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p>
</li>
</ul>
<h2 id="你可以在Spring中注入一个null-和一个空字符串吗？"><a href="#你可以在Spring中注入一个null-和一个空字符串吗？" class="headerlink" title="你可以在Spring中注入一个null 和一个空字符串吗？"></a>你可以在<code>Spring</code>中注入一个<code>null</code> 和一个空字符串吗？</h2><p>可以。</p>
<h2 id="Spring支持的事务管理类型，-spring-事务实现方式有哪些？"><a href="#Spring支持的事务管理类型，-spring-事务实现方式有哪些？" class="headerlink" title="Spring支持的事务管理类型， spring 事务实现方式有哪些？"></a>Spring支持的事务管理类型， spring 事务实现方式有哪些？</h2><p><code>Spring</code>支持两种类型的事务管理：</p>
<ul>
<li><p>编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p>
</li>
<li><p>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p>
</li>
</ul>
<h1 id="说一下Spring的事务传播行为-问过"><a href="#说一下Spring的事务传播行为-问过" class="headerlink" title="说一下Spring的事务传播行为(问过)"></a>说一下<code>Spring</code>的事务传播行为(问过)</h1><p><code>spring</code>事务的传播行为说的是，当多个事务同时存在的时候，<code>spring</code>如何处理这些事务的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</span><br><span class="line"></span><br><span class="line">② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</span><br><span class="line"></span><br><span class="line">③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</span><br><span class="line"></span><br><span class="line">④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</span><br><span class="line"></span><br><span class="line">⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</span><br><span class="line"></span><br><span class="line">⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</span><br><span class="line"></span><br><span class="line">⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="说一下-spring-的事务隔离？-问过"><a href="#说一下-spring-的事务隔离？-问过" class="headerlink" title="说一下 spring 的事务隔离？(问过)"></a>说一下 <code>spring</code> 的事务隔离？(问过)</h1><p>spring 有五大隔离级别，默认值为 <code>ISOLATION_DEFAULT</code>（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
<ol>
<li><p><code>ISOLATION_DEFAULT</code>：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p>
</li>
<li><p><code>ISOLATION_READ_UNCOMMITTED</code>：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p>
</li>
<li><p><code>ISOLATION_READ_COMMITTED</code>：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），<code>SQL server</code> 的默认级别；</p>
</li>
<li><p><code>ISOLATION_REPEATABLE_READ</code>：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p>
</li>
<li><p><code>ISOLATION_SERIALIZABLE</code>：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
</li>
</ol>
<p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p>不可重复读 ：是指在一个事务内，多次读同一数据。</p>
<p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h2 id="Spring框架的事务管理有哪些优点？"><a href="#Spring框架的事务管理有哪些优点？" class="headerlink" title="Spring框架的事务管理有哪些优点？"></a>Spring框架的事务管理有哪些优点？</h2><ul>
<li>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</li>
<li>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API</li>
<li>支持声明式事务管理。</li>
<li>和Spring各种数据访问抽象层很好得集成。</li>
</ul>
<h1 id="SpringMVC-部分"><a href="#SpringMVC-部分" class="headerlink" title="SpringMVC 部分"></a>SpringMVC 部分</h1><h2 id="什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？"><a href="#什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？" class="headerlink" title="什么是Spring MVC？简单介绍下你对Spring MVC的理解？"></a>什么是<code>Spring MVC</code>？简单介绍下你对<code>Spring MVC</code>的理解？</h2><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p>
<h2 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h2><p>（1）可以支持各种视图技术,而不仅仅局限于<code>JSP</code>；</p>
<p>（2）与<code>Spring</code>框架集成（如<code>IoC</code>容器、<code>AOP</code>等）；</p>
<p>（3）清晰的角色分配：前端控制器(<code>dispatcherServlet</code>) , <code>请求到处理器映射（handlerMapping</code>), <code>处理器适配器（HandlerAdapter</code>), <code>视图解析器（ViewResolver）。</code></p>
<p>（4） 支持各种请求资源的映射策略。</p>
<h2 id="Spring-MVC的主要组件？"><a href="#Spring-MVC的主要组件？" class="headerlink" title="Spring MVC的主要组件？"></a>Spring MVC的主要组件？</h2><p>（1）前端控制器 <code>DispatcherServlet</code>（不需要程序员开发）</p>
<p>作用：接收请求、响应结果，相当于转发器，有了<code>DispatcherServlet</code> 就减少了其它组件之间的耦合度。</p>
<p>（2）处理器映射器``HandlerMapping`（不需要程序员开发）</p>
<p>作用：根据请求的<code>URL</code>来查找<code>Handler</code></p>
<p>（3）处理器适配器<code>HandlerAdapter</code></p>
<p>注意：在编写<code>Handler</code>的时候要按照<code>HandlerAdapter</code>要求的规则去编写，这样适配器<code>HandlerAdapter</code>才可以正确的去执行<code>Handler</code>。</p>
<p>（4）处理器<code>Handler</code>（需要程序员开发）</p>
<p>（5）视图解析器 <code>ViewResolver</code>（不需要程序员开发）</p>
<p>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（<code>view</code>）</p>
<p>（6）视图<code>View</code>（需要程序员开发jsp）</p>
<p><code>View</code>是一个接口， 它的实现类支持不同的视图类型（<code>jsp，freemarker，pdf</code>等等）</p>
<h2 id="什么是DispatcherServlet"><a href="#什么是DispatcherServlet" class="headerlink" title="什么是DispatcherServlet"></a>什么是DispatcherServlet</h2><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p>
<h2 id="什么是Spring-MVC框架的控制器？"><a href="#什么是Spring-MVC框架的控制器？" class="headerlink" title="什么是Spring MVC框架的控制器？"></a>什么是Spring MVC框架的控制器？</h2><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</p>
<h2 id="Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><a href="#Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？" class="headerlink" title="Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？"></a>Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h2><p>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</p>
<h2 id="请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？"><a href="#请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？" class="headerlink" title="请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？"></a>请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</h2><p>（1）用户发送请求至前端控制器DispatcherServlet；<br>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；<br>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；<br>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；<br>（6）Handler执行完成返回ModelAndView；<br>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；<br>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>（9）ViewResolver解析后返回具体View；<br>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）<br>（11）DispatcherServlet响应用户。</p>
<img data-src="/blog/posts/3eb5e557/2022-02-16-00-07-31.png" class="">

<h2 id="Spring-MVC常用的注解有哪些？"><a href="#Spring-MVC常用的注解有哪些？" class="headerlink" title="Spring MVC常用的注解有哪些？"></a>Spring MVC常用的注解有哪些？</h2><ul>
<li><p><code>@RequestMapping：</code>用于处理请求 <code>url</code> 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
</li>
<li><p><code>@RequestBody：</code>注解实现接收<code>http</code>请求的<code>json</code>数据，将<code>json</code>转换为<code>java</code>对象。</p>
</li>
<li><p><code>@ResponseBody：</code>注解实现将<code>conreoller</code>方法返回对象转化为<code>json</code>对象响应给客户。</p>
</li>
</ul>
<h3 id="SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？"><a href="#SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？" class="headerlink" title="SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？"></a><code>SpingMvc</code>中的控制器的注解一般用哪个,有没有别的注解可以替代？</h3><p>答：一般用@Controller注解,也可以使用@RestController,@RestController注解相当于@ResponseBody ＋ @Controller,表示是表现层,除此之外，一般不用别的注解代替。</p>
<h4 id="Controller注解的作用"><a href="#Controller注解的作用" class="headerlink" title="@Controller注解的作用"></a><code>@Controller</code>注解的作用</h4><p>在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在Spring MVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p>
<p>@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是Spring MVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：</p>
<ul>
<li>在Spring MVC 的配置文件中定义MyController 的bean 对象。</li>
<li>在Spring MVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。<h4 id="RequestMapping注解的作用"><a href="#RequestMapping注解的作用" class="headerlink" title="@RequestMapping注解的作用"></a><code>@RequestMapping</code>注解的作用</h4>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</li>
</ul>
<p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。</p>
<p><code>value， method</code></p>
<ul>
<li><p>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p>
</li>
<li><p>method： 指定请求的method类型， GET、POST、PUT、DELETE等；</p>
</li>
</ul>
<p><code>consumes，produces</code></p>
<ul>
<li><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p>
</li>
<li><p>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p>
</li>
</ul>
<p><code>params，headers</code></p>
<ul>
<li><p>params： 指定request中必须包含某些参数值是，才让该方法处理。</p>
</li>
<li><p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
</li>
</ul>
<h4 id="ResponseBody注解的作用"><a href="#ResponseBody注解的作用" class="headerlink" title="@ResponseBody注解的作用"></a><code>@ResponseBody</code>注解的作用</h4><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p>
<p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p>
<h4 id="PathVariable和-RequestParam的区别"><a href="#PathVariable和-RequestParam的区别" class="headerlink" title="@PathVariable和@RequestParam的区别"></a><code>@PathVariable</code>和<code>@RequestParam</code>的区别</h4><p>请求路径上有个<code>id</code>的变量值，可以通过<code>@PathVariable</code>来获取 <code>@RequestMapping(value = “/page/&#123;id&#125;”, method = RequestMethod.GET)</code></p>
<p><code>@RequestParam</code>用来获得静态的URL请求入参 <code>spring</code>注解时<code>action</code>里用到。</p>
<h2 id="关于一些算法题"><a href="#关于一些算法题" class="headerlink" title="关于一些算法题"></a>关于一些算法题</h2><p>问了我一些比较基础的题目</p>
<blockquote>
<p>数组和链表的应用场景,也就是问数组和链表的区别和各自的优势?</p>
</blockquote>
<ul>
<li><p>数组是将元素在内存中连续存储的；</p>
<ul>
<li><p>优点：因为数据是连续存储的，内存地址连续，所以在查找数据的时候效 率比较高；</p>
</li>
<li><p>缺点：在存储之前，我们需要申请一块连续的内存空间，并且在编译的时候就必须确定好它的空间的大小。在运行的时候空间的大小是无法随着你的需要进行增加和减少而改变的，当数据两比较大的时候，有可能会出现越界的情况，数据比较小的时候，又有可能会浪费掉内存空间。在改变数据个数时，增加、插入、删除数据效率比较低链表是动态申请内存空间，不需要像数组需要提前申请好内存的大小，</p>
</li>
</ul>
</li>
<li><p>链表只需在用的时候申请就可以，根据需要来动态申请或者删除内存空间，对于数据增加和删除以及插入比数组灵活。还有就是链表中数据在内存中可以在任意的位置，通过应用来关联数据（就是通过存在元素的指针来联系）。</p>
</li>
</ul>
<ul>
<li><p>数组应用场景：数据比较少；经常做的运算是按序号访问数据元素；数组更容易实现，任何高级语言都支持；构建的线性表较稳定。</p>
</li>
<li><p>链表应用场景：对线性表的长度或者规模难以估计；频繁做插入删除操作；构建动态性比较强的线性表。</p>
</li>
</ul>
<blockquote>
<p>现在要实现一个栈结构,要频繁的进行<code>push</code>和<code>pop</code>操作,如果用数组或者链表这两个基本数据结构,哪个比较合适?</p>
</blockquote>
<p>个人感觉这个题目就是看对这两个基本数据结构的理解了,一方面要求频繁插入删除,优先级的肯定是链表好一点,因为制定了频繁插入删除…但是吧,又考虑到,数组的…反正吧,我不是很拿捏的定,但是你可以根据数组以及链表各自的优势然后进行阐述就可以了吧,估计就是看你一个思想.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9pYW1qb2hubnl6aHVhbmcuZ2l0aHViLmlvL2phdmEvMjAxNi8wNy8xMi9KYXZhJUU1JUEwJTg2JUU1JTkyJThDJUU2JUEwJTg4JUU3JTlDJThCJUU4JUJGJTk5JUU3JUFGJTg3JUU1JUIwJUIxJUU1JUE0JTlGLmh0bWw=">文章链接</span></p>
<blockquote>
<p>常见的排序算法?</p>
</blockquote>
<p>这边你就扯一下就好了,什么冒泡啊,插入啊,选择啊,快排,归并啥的….</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv">文章链接</span></p>
<p>但是一定要搞清楚你所了解的排序算法的实现已经各自的区别,然后扯一扯就可以了,我这边是详细给讲了冒泡排序,然后他的优劣势.</p>
<blockquote>
<p>一般这个算法问的也挺多的,计算根号8,并保留到小数点后面四位,请写出你的实现算法?</p>
</blockquote>
<p>核心思想是采用二分法:</p>
<p>设置开始的区间为[0.8],</p>
<p>迭代方法为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> (8+0)/2 = 4</span><br><span class="line">         =&gt; 4*4 = 16 &gt; 8 , 所以4 为值的右边界,</span><br><span class="line"> (4+0)/2 = 2</span><br><span class="line">         =&gt; 2*2 = 4  &lt; 8 , 所以 2 为值的左边界,</span><br><span class="line"> (4+2)/2 = 3 </span><br><span class="line">         =&gt; 3*3 = 9  &gt; 8 , 所以 3 为值的右边界,</span><br><span class="line"> (3+2)/2 = 2.5</span><br><span class="line">         =&gt; 2.5*2.5 = 6.25 &lt; 8 ,所以 2.5 为 值的左边界,</span><br><span class="line"> (3+2.5)/2 = 2.75</span><br><span class="line">         =&gt; 7.5625 &lt; 8 , 所以 2.75 为 值的左边界</span><br><span class="line"> (2.75+3)/2 = 2.875 </span><br><span class="line">         =&gt; 8.19375 &gt; 8 , 所以 2.875 为右边界 </span><br><span class="line">         ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         以此类推即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">时间复杂度为 log N ,因为是二分法 !</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>现有一个<code>hashmap</code>,里面存了类似于 (a,2),(b,10),(c,8)….  等等 , 如何根据<code>value</code>值大小从小到大排列输出</p>
</blockquote>
<p>HashMap的value值没有排序功能，若要进行较轻松的排序，可改写Comparator接口方法compare进行排序，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">map.put(<span class="string">&quot;d&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>);</span><br><span class="line">List&lt;Map.Entry&lt;String, Integer&gt;&gt; infoIds = <span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;String, Integer&gt;&gt;(map.entrySet());</span><br><span class="line"><span class="comment">//排序前</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; infoIds.size(); i++) &#123;</span><br><span class="line">    String id = infoIds.get(i).toString();</span><br><span class="line">    System.out.println(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据value排序</span></span><br><span class="line">Collections.sort(infoIds, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> (o2.getValue() - o1.getValue()); </span><br><span class="line">        <span class="comment">//return (o1.getKey()).toString().compareTo(o2.getKey());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">//排序后</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; infoIds.size(); i++) &#123;</span><br><span class="line">    String id = infoIds.get(i).toString();</span><br><span class="line">    System.out.println(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据key排序</span></span><br><span class="line"><span class="comment">//a 3</span></span><br><span class="line"><span class="comment">//b 1</span></span><br><span class="line"><span class="comment">//c 1</span></span><br><span class="line"><span class="comment">//d 2</span></span><br><span class="line"><span class="comment">//根据value排序</span></span><br><span class="line"><span class="comment">//a 3</span></span><br><span class="line"><span class="comment">//d 2</span></span><br><span class="line"><span class="comment">//b 1</span></span><br><span class="line"><span class="comment">//c 1</span></span><br></pre></td></tr></table></figure>

<HR style="border:3 double #987cb9" width="100%" color=#987cb9 SIZE=3>

<p><strong>写在前面:</strong></p>
<p>这是公司内部的题库,仅供参考</p>
<h1 id="java面试问题-低阶版"><a href="#java面试问题-低阶版" class="headerlink" title="java面试问题-低阶版"></a><code>java</code>面试问题-低阶版</h1><h2 id="1-java-ConcurrentHashMap-get-方法会加锁吗"><a href="#1-java-ConcurrentHashMap-get-方法会加锁吗" class="headerlink" title="1.  java ConcurrentHashMap get 方法会加锁吗"></a>1.  <code>java ConcurrentHashMap get</code> 方法会加锁吗</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">答： 不会加锁；<span class="number">1</span> 分 </span><br><span class="line"></span><br><span class="line">通过<span class="keyword">volatile</span>刷新get后的值；<span class="number">2</span> 分</span><br><span class="line"></span><br><span class="line">假设有 ConcurrentHashMap&lt;<span class="keyword">String</span>,Long&gt; A</span><br><span class="line"></span><br><span class="line">线程<span class="number">1</span> ：A.<span class="built_in">put</span>(<span class="string">&quot;K&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">线程<span class="number">1</span> ：Long num1 = A.<span class="built_in">get</span>(<span class="string">&quot;K&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> n1 = num1;</span><br><span class="line"></span><br><span class="line">线程<span class="number">2</span> ：A.<span class="built_in">put</span>(<span class="string">&quot;K&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">线程<span class="number">1</span> ：打印 num1  = ？ n1 = ?</span><br><span class="line"></span><br><span class="line">答：num1 = <span class="number">2</span>； <span class="number">1</span>分 n1 = <span class="number">1</span> ；<span class="number">1</span>分</span><br></pre></td></tr></table></figure>

<h2 id="2-jvm内存区域分为哪几个？"><a href="#2-jvm内存区域分为哪几个？" class="headerlink" title="2. jvm内存区域分为哪几个？"></a>2. jvm内存区域分为哪几个？</h2><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">答：heap区和非heap区 <span class="number">1</span> 分</span><br><span class="line"></span><br><span class="line">heap区又分为 Eden Space（伊甸园）、Survivor Space(幸存者区)、<span class="keyword">Old</span> Gen（老年代）。 <span class="number">3</span>分</span><br><span class="line"></span><br><span class="line">Code Cache(代码缓存区)，Perm Gen（永久代），Jvm Stack(java虚拟机栈)，Local <span class="function"><span class="keyword">Method</span> <span class="title">Statck</span><span class="params">(本地方法栈)</span>； 1分</span></span><br></pre></td></tr></table></figure>

<h2 id="3-现有Comparator："><a href="#3-现有Comparator：" class="headerlink" title="3. 现有Comparator："></a>3. 现有<code>Comparator</code>：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.value &lt; n ? -<span class="number">1</span> : (<span class="keyword">this</span>.value == n ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; lst = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">lst.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">lst.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">lst.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">lst.sort(MyComparator::myCompare);</span><br><span class="line"></span><br><span class="line">System.out.println(lst);</span><br></pre></td></tr></table></figure>
<p>输出结果为？</p>
<p>5分  答案：1，2，3<br>(该方法实现，实际为Integer.compareTo方法)</p>
<h2 id="4-线程的三种基本状态？Java-Thread-sleep-1000，1005毫秒后可能的线程状态？Thread-sleep-0-有什么作用？"><a href="#4-线程的三种基本状态？Java-Thread-sleep-1000，1005毫秒后可能的线程状态？Thread-sleep-0-有什么作用？" class="headerlink" title="4. 线程的三种基本状态？Java Thread.sleep 1000，1005毫秒后可能的线程状态？Thread.sleep 0 有什么作用？"></a>4. 线程的三种基本状态？<code>Java Thread.sleep 1000，1005</code>毫秒后可能的线程状态？<code>Thread.sleep 0</code> 有什么作用？</h2><p>基本状态：就绪、执行、阻塞  2分</p>
<p>可能的状态：就绪，执行  2分</p>
<p><code>Thread.Sleep(0)</code>的作用 ：“触发操作系统立刻重新进行一次<code>CPU</code>竞争，重新计算优先级”。 1分</p>
<p>在未来的<code>1000</code>毫秒内，线程不想再参与到<code>CPU</code>竞争。那么<code>1000</code>毫秒过去之后，这时候也许另外一个线程正在使用<code>CPU</code>，那么这时候操作系统是不会重新分配<code>CPU</code>的，直到那个线程挂起或结束；</p>
<p>况且，即使这个时候恰巧轮到操作系统进行<code>CPU </code>分配，那么当前线程也不一定就是总优先级最高的那个，<code>CPU</code>还是可能被其他线程抢占去。</p>
<h1 id="java-面试问题"><a href="#java-面试问题" class="headerlink" title="java 面试问题"></a><code>java</code> 面试问题</h1><h2 id="1-ArrayList和LinkedList有什么区别，各适合什么场景-支持并发的List是什么类"><a href="#1-ArrayList和LinkedList有什么区别，各适合什么场景-支持并发的List是什么类" class="headerlink" title="1) ArrayList和LinkedList有什么区别，各适合什么场景? 支持并发的List是什么类"></a>1) <code>ArrayList</code>和<code>LinkedList</code>有什么区别，各适合什么场景? 支持并发的<code>List</code>是什么类</h2><p>答题标准：</p>
<p><code>ArrayList</code> 底层是数组，适合随机读写数据，只适合尾部插入和删除 得2分<br><code>LinkedList</code>底层是链表，不适合随机读写数据，插入删除数据成本低 得2分<br><code>CopyOnWriteList</code> 得1分</p>
<h2 id="2-用过哪些Map类，都有什么区别"><a href="#2-用过哪些Map类，都有什么区别" class="headerlink" title="2) 用过哪些Map类，都有什么区别?"></a>2) 用过哪些<code>Map</code>类，都有什么区别?</h2><p>答题标准：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">HashMap  得<span class="number">2</span>分</span><br><span class="line"><span class="function"><span class="title">ConcurrentHashMap</span><span class="params">(支持并发)</span></span> +<span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">LinkedHashMap</span><span class="params">(保持插入顺序)</span></span> + <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">TreeMap</span><span class="params">(按key排序)</span></span> +<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="3-juc-下有哪些并发类"><a href="#3-juc-下有哪些并发类" class="headerlink" title="3) juc 下有哪些并发类?"></a>3) <code>juc</code> 下有哪些并发类?</h2><p>答题标准：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">Lock,CountDownLatch等 <span class="number">1</span>分</span><br><span class="line">原子类 <span class="number">1</span>分</span><br><span class="line">并发集合类(map,list,set) <span class="number">1</span>分</span><br><span class="line">阻塞式队列 <span class="number">1</span>分</span><br><span class="line">线程池 <span class="number">1</span>分</span><br></pre></td></tr></table></figure>
<h2 id="4-ThreadLocal-可以用来做什么-和-Transactional注解有什么关系"><a href="#4-ThreadLocal-可以用来做什么-和-Transactional注解有什么关系" class="headerlink" title="4) ThreadLocal 可以用来做什么, 和@Transactional注解有什么关系"></a>4) <code>ThreadLocal</code> 可以用来做什么, 和<code>@Transactional</code>注解有什么关系</h2><p>答题标准：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1）线程安全的变量 1分</span><br><span class="line">2）隐式传递数据 1分</span><br><span class="line">事务开始获取连接放在ThreadLocal里并开启事务，结束时提交或回滚并清除ThreadLocal里存的连接 3分</span><br></pre></td></tr></table></figure>
<h2 id="5-java虚拟机：解释虚拟机参数的含义-Xms-Xmx-Xss-jdk-8下-老年代-常用的垃圾回收器是什么-查看线程的栈信息有哪些方法"><a href="#5-java虚拟机：解释虚拟机参数的含义-Xms-Xmx-Xss-jdk-8下-老年代-常用的垃圾回收器是什么-查看线程的栈信息有哪些方法" class="headerlink" title="5) java虚拟机：解释虚拟机参数的含义-Xms -Xmx -Xss, jdk 8下 老年代 常用的垃圾回收器是什么? 查看线程的栈信息有哪些方法"></a>5) <code>java</code>虚拟机：解释虚拟机参数的含义<code>-Xms -Xmx -Xss, jdk 8</code>下 老年代 常用的垃圾回收器是什么? 查看线程的栈信息有哪些方法</h2><p>答题标准：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">答对<span class="keyword">ms</span> <span class="title">mx</span>得<span class="number">1</span>分, 答对ss得<span class="number">1</span>分</span><br><span class="line">cms/g1 答对各得<span class="number">1</span>分</span><br><span class="line">jstack  答对 得<span class="number">1</span>分</span><br></pre></td></tr></table></figure>

<h2 id="6-spring-Autowired是做什么用的-PostConstruct是做什么用的-Configuration是做什么用的？-Bean注解是做什么用的-BeanFactoryAware-ApplicationContextAware-接口是做什么用的"><a href="#6-spring-Autowired是做什么用的-PostConstruct是做什么用的-Configuration是做什么用的？-Bean注解是做什么用的-BeanFactoryAware-ApplicationContextAware-接口是做什么用的" class="headerlink" title="6) spring @Autowired是做什么用的? @PostConstruct是做什么用的?  @Configuration是做什么用的？@Bean注解是做什么用的?  BeanFactoryAware/ApplicationContextAware 接口是做什么用的?"></a>6) <code>spring @Autowired</code>是做什么用的? <code>@PostConstruct</code>是做什么用的?  <code>@Configuration</code>是做什么用的？<code>@Bean</code>注解是做什么用的?  <code>BeanFactoryAware/ApplicationContextAware</code> 接口是做什么用的?</h2><p>答题标准：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Autowired</span> 注入对象 得<span class="number">1</span>分</span><br><span class="line"><span class="variable">@PostConstruct</span> 指定init方法 得<span class="number">1</span>分</span><br><span class="line"><span class="variable">@Configuration</span> java config的配置类注解 得<span class="number">1</span>分</span><br><span class="line"><span class="variable">@Bean</span> java config通过代码创建bean 得<span class="number">1</span>分</span><br><span class="line">BeanFactoryAware/ApplicationContextAware 获取容器本身的引用 得<span class="number">1</span>分</span><br></pre></td></tr></table></figure>

<h2 id="7-http请求报文格式-；有哪些常见header；-host头存的是什么，服务端用host做什么；有哪些常见的http状态码"><a href="#7-http请求报文格式-；有哪些常见header；-host头存的是什么，服务端用host做什么；有哪些常见的http状态码" class="headerlink" title="7) http请求报文格式 ；有哪些常见header； host头存的是什么，服务端用host做什么；有哪些常见的http状态码?"></a>7) <code>http</code>请求报文格式 ；有哪些常见<code>header； host</code>头存的是什么，服务端用<code>host</code>做什么；有哪些常见的<code>http</code>状态码?</h2><p>答题标准：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">method</span> + <span class="title">url</span> + <span class="title">version</span> +  <span class="title">headers</span> + <span class="title">body</span> 正确回答得1分</span></span><br><span class="line"><span class="function"><span class="title">content</span>-<span class="title">type</span> <span class="title">content</span>-<span class="title">length</span> 回答中提到这2个得1分</span></span><br><span class="line"><span class="function"><span class="title">host</span> 存请求域名，服务端用来区分站点 正确回答得1分</span></span><br><span class="line"><span class="function">状态码：200 201 301 302 404 500 共2分, 仅回答出200不得分</span></span><br></pre></td></tr></table></figure>

<h2 id="8-数据库事务隔离级别有哪些，mysql默认隔离级别是什么-spring-的事务传播机制是什么，列举几种"><a href="#8-数据库事务隔离级别有哪些，mysql默认隔离级别是什么-spring-的事务传播机制是什么，列举几种" class="headerlink" title="8) 数据库事务隔离级别有哪些，mysql默认隔离级别是什么? spring 的事务传播机制是什么，列举几种"></a>8) 数据库事务隔离级别有哪些，<code>mysql</code>默认隔离级别是什么? <code>spring</code> 的事务传播机制是什么，列举几种</h2><p>答题标准：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">读未提交 读已提交 可重复读 串行化 得2分</span><br><span class="line">mysql默认可重复读 得 1分</span><br><span class="line"></span><br><span class="line">传播机制： 答对任意2个得2分</span><br></pre></td></tr></table></figure>

<img data-src="/blog/posts/3eb5e557/2022-02-16-00-08-27.png" class="">

<h2 id="9-linux-命令行-如何查本机某个端口是否已监听-探测对方端口是否可连接-访问一个url-查找一个日志文件（不变化的）的最后10行ERROR"><a href="#9-linux-命令行-如何查本机某个端口是否已监听-探测对方端口是否可连接-访问一个url-查找一个日志文件（不变化的）的最后10行ERROR" class="headerlink" title="9) linux 命令行: 如何查本机某个端口是否已监听 探测对方端口是否可连接  访问一个url   查找一个日志文件（不变化的）的最后10行ERROR "></a>9) <code>linux</code> 命令行: 如何查本机某个端口是否已监听 探测对方端口是否可连接  访问一个<code>url</code>   查找一个日志文件（不变化的）的最后<code>10</code>行<code>ERROR </code></h2><p>答题标准：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">netstat</span> 或 telnet localhost<span class="number">1</span>分</span><br><span class="line"><span class="attribute">telnet</span> <span class="number">1</span>分</span><br><span class="line"><span class="attribute">curl</span> <span class="number">2</span>分</span><br><span class="line"></span><br><span class="line"><span class="attribute">grep</span> ERROR xxx |tail <span class="number">1</span>分</span><br></pre></td></tr></table></figure>

<h2 id="10-redis-支持哪些数据结构-redis-cluster-key是如何分布到各个节点的？可以只取key的部分来计算slot吗？"><a href="#10-redis-支持哪些数据结构-redis-cluster-key是如何分布到各个节点的？可以只取key的部分来计算slot吗？" class="headerlink" title="10) redis 支持哪些数据结构? redis cluster key是如何分布到各个节点的？可以只取key的部分来计算slot吗？"></a>10) <code>redis</code> 支持哪些数据结构? <code>redis cluster key</code>是如何分布到各个节点的？可以只取<code>key</code>的部分来计算<code>slot</code>吗？</h2><p>答题标准：</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>,hash,list,<span class="built_in">set</span>,zset 得<span class="number">2</span>分</span><br><span class="line">分成 <span class="number">16384</span>  slot，  CRC16(<span class="built_in">key</span>) <span class="built_in">mod</span> <span class="number">16384</span> 共<span class="number">2</span>分</span><br><span class="line"><span class="built_in">key</span>中的&#123;xxx&#125;有特殊含义 得<span class="number">1</span>分</span><br></pre></td></tr></table></figure>
<h2 id="11-消息队列主要用在什么场景？知道哪些消息队列-消费时若发生重复消费如何保证幂等？"><a href="#11-消息队列主要用在什么场景？知道哪些消息队列-消费时若发生重复消费如何保证幂等？" class="headerlink" title="11) 消息队列主要用在什么场景？知道哪些消息队列? 消费时若发生重复消费如何保证幂等？"></a>11) 消息队列主要用在什么场景？知道哪些消息队列? 消费时若发生重复消费如何保证幂等？</h2><p>答题标准：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">生产端和消费端解耦 得2分</span><br><span class="line">rabbitmq activemq rocketmq kafka 任意2个得2分</span><br><span class="line">根据某个唯一标识检查数据是否已处理过，如已处理过则忽略 得1分</span><br></pre></td></tr></table></figure>

<p>答题标准：</p>
<pre><code>描述的是  线程可见性 问题 得2分
</code></pre>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span>个基本规则，每答对<span class="number">1</span>个得<span class="number">1</span>分，任意答对<span class="number">3</span>个即可</span><br><span class="line"></span><br><span class="line">单线程happen-<span class="keyword">before</span>原则：在同一个线程中，书写在前面的操作happen-<span class="keyword">before</span>后面的操作。</span><br><span class="line">锁的happen-<span class="keyword">before</span>原则：同一个锁的unlock操作happen-<span class="keyword">before</span>此锁的<span class="keyword">lock</span>操作。</span><br><span class="line"><span class="keyword">volatile</span>的happen-<span class="keyword">before</span>原则：对一个<span class="keyword">volatile</span>变量的写操作happen-<span class="keyword">before</span>对此变量的任意操作(当然也包括写操作了)。</span><br><span class="line">happen-<span class="keyword">before</span>的传递性原则：如果A操作 happen-<span class="keyword">before</span> B操作，B操作happen-<span class="keyword">before</span> C操作，那么A操作happen-<span class="keyword">before</span> C操作。</span><br><span class="line">线程启动的happen-<span class="keyword">before</span>原则：同一个线程的<span class="keyword">start</span>方法happen-<span class="keyword">before</span>此线程的其它方法。</span><br><span class="line">线程中断的happen-<span class="keyword">before</span>原则：对线程interrupt方法的调用happen-<span class="keyword">before</span>被中断线程的检测到中断发送的代码。</span><br><span class="line">线程终结的happen-<span class="keyword">before</span>原则：线程中的所有操作都happen-<span class="keyword">before</span>线程的终止检测。</span><br><span class="line">对象创建的happen-<span class="keyword">before</span>原则：一个对象的初始化完成先于他的finalize方法调用。</span><br></pre></td></tr></table></figure>

<p>===========  以下为可选问题 ===========================================================</p>
<h2 id="13-spring-boot-下如何做优雅关闭；-优雅关闭的关闭顺序是怎样的？-linux-下-kill-会导致异常关闭吗？"><a href="#13-spring-boot-下如何做优雅关闭；-优雅关闭的关闭顺序是怎样的？-linux-下-kill-会导致异常关闭吗？" class="headerlink" title="13) spring boot 下如何做优雅关闭；  优雅关闭的关闭顺序是怎样的？ linux 下 kill 会导致异常关闭吗？"></a>13) <code>spring boot</code> 下如何做优雅关闭；  优雅关闭的关闭顺序是怎样的？ <code>linux</code> 下 <code>kill</code> 会导致异常关闭吗？</h2><p>答题标准：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">监听spring 容器关闭事件， 使用@PreDestroy注解 申明清理方法  <span class="number">2</span>分</span><br><span class="line"></span><br><span class="line">关闭顺序： 关闭对外<span class="keyword">listen</span>端口，继续完成内部处理，关闭内部线程池，关闭资源等等 <span class="number">2</span>分</span><br><span class="line"></span><br><span class="line"><span class="keyword">kill</span> 不会, spring boot监听了<span class="keyword">kill</span> 信号，是正常关闭；  <span class="keyword">kill</span> -<span class="number">9</span> 才会异常关闭  <span class="number">1</span>分</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="14-java-nio-底层是基于什么原理？linux-下的多路复用机制是什么？java-最常用的nio框架是什么？netty-4的线程模型是怎样的？"><a href="#14-java-nio-底层是基于什么原理？linux-下的多路复用机制是什么？java-最常用的nio框架是什么？netty-4的线程模型是怎样的？" class="headerlink" title="14) java nio 底层是基于什么原理？linux 下的多路复用机制是什么？java 最常用的nio框架是什么？netty 4的线程模型是怎样的？"></a>14) <code>java nio</code> 底层是基于什么原理？<code>linux</code> 下的多路复用机制是什么？<code>java</code> 最常用的<code>nio</code>框架是什么？<code>netty</code> 4的线程模型是怎样的？</h2><p>答题标准：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">多路复用， 得<span class="number">1</span>分</span><br><span class="line"></span><br><span class="line">epoll 得<span class="number">1</span>分</span><br><span class="line"></span><br><span class="line">netty 得<span class="number">1</span>分</span><br><span class="line"></span><br><span class="line">boss 线程池监听  worker线程池处理；  socket 和某个固定的worker线程绑定，<span class="keyword">handler</span>在单线程中执行，无需考虑并发问题   得<span class="number">2</span>分</span><br></pre></td></tr></table></figure>
<ol start="15">
<li> 某个查询接口慢，可以从哪些可能角度分析问题?</li>
</ol>
<p>答题标准：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">先定位到进程： 是client  是 nginx 是 网关 是 服务 ?   得<span class="number">2</span>分</span><br><span class="line"></span><br><span class="line">服务内： 业务线程数；业务同步还是异步执行, 有无队列等待； 是否数据层慢？ 数据库连接数；  有没有慢<span class="keyword">sql</span> ； <span class="keyword">full</span> gc；   共<span class="number">3</span>分，酌情给分</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="mysql-in-最多支持多少条？"><a href="#mysql-in-最多支持多少条？" class="headerlink" title="mysql in 最多支持多少条？"></a><code>mysql in</code> 最多支持多少条？</h2><p>答：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">受max_allowed_packet 这个参数的限制</span><br><span class="line"></span><br><span class="line">mysql --<span class="keyword">help</span> | <span class="keyword">grep</span> <span class="built_in">max</span>-allowed-packet </span><br><span class="line"></span><br><span class="line">另：</span><br><span class="line"></span><br><span class="line">mysql在in大量数据时会出现不走索引，大量数据的概念为 in后面的数据在数据表中超过<span class="number">30</span>%</span><br><span class="line"></span><br><span class="line">in 查询的列是char类型，必须加<span class="string">&quot;&quot;</span>号才可走索引，否则导致全表扫描，会随着表的增大而变得更慢</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java面试</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试小册子</title>
    <url>/blog/posts/a5258aa2/</url>
    <content><![CDATA[<h2 id="问题手册："><a href="#问题手册：" class="headerlink" title="问题手册："></a>问题手册：</h2><p>现在开始做最完整的总结。</p>
<h3 id="一：JAVA基础相关"><a href="#一：JAVA基础相关" class="headerlink" title="一：JAVA基础相关"></a>一：JAVA基础相关</h3><ol>
<li><p><strong>Object的九大方法.</strong></p>
<p>九大方法分别是:</p>
<ul>
<li><code>clone()</code></li>
<li><code>equals()</code></li>
<li><code>finalize()</code></li>
<li><code>getClass()</code></li>
<li><code>hashCode()</code></li>
<li><code>notify()</code></li>
<li><code>notifyAll()</code></li>
<li><code>toString()</code></li>
<li><code>wait()</code></li>
</ul>
</li>
</ol>
<span id="more"></span>

<ol start="2">
<li><p><strong>重载与重写的区别？以及构造器是否能被<code>override</code>？</strong></p>
<ol>
<li><p>重写是子类和父类之间的关系，是垂直关系，而重载是同一个类中方法之间的关系，是水平关系。</p>
<p>重写要求参数列表相同，而重载要求参数列表不同。</p>
</li>
<li><p>构造器不能被继承，方法也不能被重写，但是在同一个类中，构造器可以被重载。</p>
</li>
</ol>
</li>
<li><p><strong><code>String StringBuffer</code>和<code>String StringBuilder</code>的区别，以及。<code>String</code>为什么是不可变的，<code>final</code>关键字的原理（深入内存模型理解）？</strong></p>
<ol>
<li><p><code>String Buffer</code>与<code>String Builder</code>的区别？</p>
<ol>
<li><p>区别1：线程安全</p>
<p><code>StringBuffer</code> 是线程安全，<code>StringBuilder</code>是线程不安全的，<code>StringBuffer</code>所有公开的方法都是通过<code>synchronized</code>关键字修饰。</p>
</li>
<li><p>区别2：缓冲区</p>
<p><code>StringBuffer</code>每次获取<code>toString</code>都会直接使用缓存区的<code>toStringCache</code>值来构造一个字符串。</p>
<p><code>StringBuilder</code>每次都需要复制一个字符数组，再来构造一个字符串。</p>
</li>
<li><p>区别3：性能</p>
<p><code>String Builder</code>由于不是同步的，没有加锁的操作，所以性能高于<code>String Buffer</code>。</p>
</li>
</ol>
</li>
<li><p><code>String</code>为什么是不可变的？</p>
<p>通过阅读<code>String</code>的源代码，可以发现其在类上和成员变量上使用<code>final</code>关键字修饰，而一旦将引用声明为<code>final</code>，就不能改变这个引用，即被<code>final</code>修饰的变量只能被赋值一次。</p>
<ol>
<li><p>修饰类、方法</p>
<ol>
<li><code>final</code>修饰方法</li>
</ol>
<p>​    把方法锁定，以防止任何继承类修改它的含义，不能被重写。</p>
<p>​    <code>final</code>方法比非<code>final</code>方法速度快，在编译的时候就已经静态绑定了。</p>
<ol>
<li><code>final</code>修饰类</li>
</ol>
<p>​    表明类不能被继承。</p>
<p>​    <code>final</code>类中的成员变量可以根据需要设为<code>final</code>，但是<code>final</code>类中的成员方法都会被隐式地指定为<code>final</code>方法。</p>
</li>
<li><p><code>final</code>的底层原理？</p>
<p>对于<code>final</code>域，编译器和处理器需要遵守两个重排序规则。</p>
<ol>
<li><p>在构造函数内对一个<code>final</code>域的写入，与随后把这个被构造对象的引用值给一个引用变量，这两个操作之间不能重排序。</p>
<p>（先写入<code>final</code>变量，后调用该对象引用）</p>
<p>原因：编译器会在<code>final</code>域的写之后，插入一个<code>StoreStore</code>屏障</p>
</li>
<li><p>初次读一个包含<code>final</code>域的对象的引用，与随后初次读这个<code>final</code>域，这两个操作之间不能重排序。</p>
<p>（先读对象的引用，后读<code>final</code>变量）</p>
<p>原因：编译器会在读<code>final</code>域操作的前面插入一个<code>LoadLoad</code>屏障 </p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>接口和抽象类的区别？</strong></p>
<ol start="2">
<li>接口不能有方法的实现，抽象类可以有方法体。</li>
<li>接口中的成员变量默认为<code>public static final</code>。而抽象类中的成员变量默认为<code>default</code>.</li>
<li>接口中的所有的方法都是<code>public、abstract</code>的,而抽象类中的方法可以在子类中被重新定义与复制，抽象方法被<code>abstract</code>修饰。</li>
<li>一个类可以通过<code>implements</code>实现多个接口，但一个类只能只能通过<code>extends</code>实现一个抽象类。接口强调特定功能的实现，而抽象类强调所属关系。</li>
</ol>
</li>
<li><p><strong><code>==</code>与<code>equals</code>比较？</strong></p>
<ol>
<li>第一种情况没有重写<code>equals</code>方法时，<code>==</code>比较的是对象的地址，以及基本数据类型的值。<code>equals</code>方法与==作用相同。</li>
<li>第二种情况，重写<code>equals</code>方法后，<code>equals</code>方法比较的是对象的值。</li>
</ol>
</li>
<li><p><strong><code>hashCode</code> 与 <code>equals</code>，为什么重写<code>equals</code>时，必须重写<code>hashCode</code>方法？</strong></p>
<ol>
<li>相同的对象必须有相同的哈希值，不同的对象，哈希值不一定不同。</li>
<li>以<code>hashSet</code>为例，将对象加入<code>HashSet</code>时，<code>HashSet</code>会先计算对象的<code>HashCode</code>来判断对象加入的位置，同时也会与该位置的已存在对象的<code>hashCode</code>值作比较，如果没有相同的<code>hashCode</code>，<code>HashSet</code>会假设对象没有重复出现，如果有相同值的<code>Hash Code</code>，这时会调用<code>equals</code>方法来检查<code>hashCode</code>相同的对象是否相同，如果两者相同，<code>hashSet</code>加不会让其操作成功，如果不同的会啊，就会重新散列到其他的位置，这样就可以减少比较的次数，提高执行速度。</li>
</ol>
<p>总结：根据规定，相同的对象就需要有相同的<code>hashCode</code>的值</p>
<p>​            当<code>hashCode</code> 相同时，对象不一定相同，当<code>equals</code>为<code>true</code>是，<code>hashCode</code>一定相同。</p>
</li>
<li><p><strong>浅拷贝与深拷贝？</strong></p>
<p>浅拷贝拷贝的是对象的引用，而深拷贝拷贝的是对象本身。</p>
</li>
<li><p><strong><code>BIO、NIO、AIO</code>有什么区别？</strong></p>
<ol>
<li><p><code>BIO：（Bolking I/O）</code>同步阻塞<code>I/O</code>模式，数据的读入与写入阻塞在同一个线程内完成，在活动连接数不是特别高的情况下，这种模型的效果不错，但是面对十万甚至百万连接时，传统的<code>BIO</code>模式就无能为力了。</p>
</li>
<li><p><code>NIO：（New I/O）</code>同步非阻塞<code>I/O</code>模型，是一种基于通道技术的<code>I/O</code>操作方法，对于高负载、高并发的应用，可以使用<code>NIO</code>来开发。</p>
</li>
</ol>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-25-34.png" class="">

<pre><code>  1. 多路复用：
</code></pre>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-25-47.png" class="">

<pre><code>     ​    多路复用采用的是操作系统底层的模型，``select poll epoll``模型，相比于传统的``NIO``模式，多路复用调用底层的``select\poll\epoll``等操作,将轮询的过程交给操作系统,这样的好处是一个单线程就能调度很多``IO``请求业务.

  2. ``Netty``：是由``JBOSS``提供的一个``Java``开源框架，是基于``NIO``的客户、服务器编程框架。``Netty``提供异步的、事件驱动的网络应用程序框架和工具，可以简化应用开发过程。
</code></pre>
<ol start="3">
<li><p><code>AIO：（Asynchronous　I/O）````AIO</code>时<code>NIO</code>的升级版，它是异步阻塞的<code>I/O</code>模型，基于事件和回调机制实现，当应用操作结束后直接返回，不会阻塞在那里。但是该技术应用不是很广泛。</p>
</li>
<li><p>多路复用机制之<code>select poll epoll</code>之间的区别,以及使用场景.（待补充）</p>
<ol>
<li><p><code>select</code>的时间复杂度为<code>O(n)</code></p>
<p>无差别轮询所有流,通过遍历<code>fdset（位图</code>）找,到有文件描述符(fd)就绪的,再进行后续操作.其中,文件描述符最大的数量一般为1024实际使用只有1021左右 .</p>
</li>
<li><p><code>poll</code>的时间复杂度为<code>O(n)</code></p>
<p>在 本质上与<code>select</code>是一样的操作,但是,<code>poll</code>使用的是链表存储,所以就没有数量的限制.</p>
</li>
<li><p><code>epoll</code>的时间复杂度为<code>O(1)</code></p>
<p>通过在内存上开辟一块事件列表空间，用来管理存储的信息，这快空间的结构式红黑树的结构，通过<code>epoll_ctl</code>函数，将<code>socket</code>信息注册到该空间中。还有一个是就绪列表空间，存储就绪信息，用<code>epoll_wait</code>函数访问，将就绪列表中就绪的<code>socket</code>接连，拷贝到用户态，唤醒用户态进程进行读取。</p>
<p>有两种工作模式：</p>
<ol>
<li><code>LT</code>水平触发：事件就绪后，用户可以选择处理或者不处理，如果用户本次不处理，那么下次调用<code>epoll_wait</code>时仍然将未处理的事件打包给用户态。</li>
<li><code>ET</code>边缘触发：事件就绪后，用户必须处理，ET模式在很大程度上减少了<code>epoll</code>事件被重复触发的次数，效率高于<code>LT</code>。</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>序列化？</strong></p>
</li>
<li><p>什么是对象序列化，反序列化。</p>
<p>对象序列化就是将对象以<strong>二进制的形式保存在硬盘</strong>上，而反序列化就是<strong>将二进制文件转化为对象读取</strong>。</p>
</li>
<li><p>在实现序列化接口的时候一般生成一个<code>serialVersionUID</code>，有什么作用。</p>
<p>通过声明<code>serialVersionUID</code>的字段，显式声明自己类的<code>serialVersionUID</code>。来标注类的序列号。</p>
</li>
<li><p>反射机制?</p>
</li>
<li><p> 获取<code>Class</code>对象方式一:<code>Class.forName()</code>;</p>
</li>
<li><p> 获取<code>Class</code>对象方式二:<code>TargetClass.newInstance()</code>;</p>
</li>
<li><p> 静态编译与动态编译:静态编译在编译时确定对象,动态编译在运行时确定对象.</p>
</li>
<li><p><code>Spring</code> 框架的<code>IOC</code>以及<code>AOP</code>功能都与反射有关系.</p>
</li>
<li><p>设计模式的问题合集？</p>
<p>设计模式共有23种，分为三大类：创建型模式、结构型模式、行为型模式。这里就介绍主要的几种模式。</p>
<ol>
<li><p><strong>单例模式</strong>？ </p>
<p>单例模式保证单例对象的类只有一个实例的存在。整个系统只有一个实例。优点：不会频繁的创建和销毁对象，浪费系统的资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在开始代码之前，需要知道静态方法的加载顺序，首先是静态代码块（随类的加载而执行）-&gt;构造器-&gt;静态方法调用.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//单例模式的代码实现</span></span><br><span class="line"><span class="comment">//饿汉模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单例模式的调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lesson7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton1 = Singleton.getInstance();</span><br><span class="line">        Singleton singleton2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//单例模式的延迟加载代码</span></span><br><span class="line"><span class="comment">//懒汉模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用synchronized+方法来保证线程安全的单例模式延迟加载</span></span><br><span class="line"><span class="comment">//懒汉模式优化1，单锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用synchronized+代码块实现线程安全的单例模式延迟加载</span></span><br><span class="line"><span class="comment">//懒汉模式优化2，单锁,双重校验</span></span><br><span class="line">Class SingletonLazy&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> staic SingletonLazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(SingletonLazy.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用reentrantLock+代码块进行单例模式的实现</span></span><br><span class="line"><span class="comment">//相当于懒汉优化2，单锁，双重校验</span></span><br><span class="line">Class SingletonLazy&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance = <span class="keyword">null</span>;</span><br><span class="line">    Private <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title">instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法内部类方法实现</span></span><br><span class="line">Class SingletonLazy&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazy</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLAzy2</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonLazy instance = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonLazy2.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举实现单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Persion1</span></span>&#123;</span><br><span class="line">    person1;</span><br><span class="line">    String name = <span class="keyword">new</span> String(<span class="string">&quot;ssss&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person1 person1 =Person1.person1;  </span><br><span class="line">        Person1 person2=Person1.person1 ;  </span><br><span class="line">        person1.setName(<span class="string">&quot;aaa&quot;</span>);  </span><br><span class="line">        person2.setName(<span class="string">&quot;bbb&quot;</span>);  </span><br><span class="line">        System.out.println(person1.getName());   </span><br><span class="line">        System.out.println(person2.getName());   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> bbb bbb</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><strong>工厂模式</strong>？</li>
</ol>
<p>工厂模式又称静态工厂方法模式，建立一个工厂，把实现了同一接口的一些类进行实例的创建。例如饮料机可以理解为工厂模式，你需要的饮料如咖啡，奶茶，可乐，他就会按你的要求进行生产。</p>
<p><strong>优点</strong>：工厂类含有必要的逻辑判断，可以决定在什么时候创建哪一个产品类的实例。</p>
<p>   <strong>缺点</strong>：不易扩展，一旦添加新的类型就需要修改类的逻辑。</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//工厂模式的代码实现</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">         String result = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">switch</span> (product) &#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&quot;Mocca&quot;</span>:</span><br><span class="line">                 result = <span class="string">&quot;摩卡&quot;</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&quot;Latte&quot;</span>:</span><br><span class="line">                 result = <span class="string">&quot;拿铁&quot;</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">default</span>:</span><br><span class="line">                 result = <span class="string">&quot;其他&quot;</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>抽象工厂模式</strong>？</li>
</ol>
<p>抽象工厂模式是基于简单的工厂模式，将未来需要修改的代码抽象出来，通过继承的方式让子类去做决定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 通过抽象工厂的方式创建实例</span></span><br><span class="line">           String result = (<span class="keyword">new</span> CoffeeFactory()).createProduct(<span class="string">&quot;Latte&quot;</span>);</span><br><span class="line">           System.out.println(result); <span class="comment">// output:拿铁</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象工厂（相当于一个模板，一个集团公司的入口）</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">createProduct</span><span class="params">(String product)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 啤酒工厂(子公司)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BeerFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">createProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">           String result = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">switch</span> (product) &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;Hans&quot;</span>:</span><br><span class="line">                   result = <span class="string">&quot;汉斯&quot;</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;Yanjing&quot;</span>:</span><br><span class="line">                   result = <span class="string">&quot;燕京&quot;</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   result = <span class="string">&quot;其他啤酒&quot;</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//咖啡工厂（子公司）</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CoffeeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">createProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">           String result = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">switch</span> (product) &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;Mocca&quot;</span>:</span><br><span class="line">                   result = <span class="string">&quot;摩卡&quot;</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;Latte&quot;</span>:</span><br><span class="line">                   result = <span class="string">&quot;拿铁&quot;</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   result = <span class="string">&quot;其他咖啡&quot;</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>观察者模式：观察者模式是定义对象间的一种一对多依赖关系，是的每当一个对象状态发生改变时，其相关依赖对象皆得到通知并自动更新。（<code>Tomcat</code>）</li>
</ol>
<p>优点：观察者模式可以实现表示层与数据层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，是的可以有各种各样不同            的表示层作为具体观察者角色。</p>
<p>缺点：如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</p>
<p>​            如果在观察者和观察目标之间有循环依赖的话，观察目标会触发他们之间进行循环调用，导致系统奔溃。</p>
<ol>
<li>装饰器模式：指动态地给一个对象增加一些额外的功能，同时又不改变其结构。（I/O流）</li>
<li>代理模式：给某一个对象提供一个dialing，并由代理对象控制原对象的引用。（AOP）</li>
<li>适配器模式：将一个类的接口变成客户端所期望的另一个接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。（I/O流）</li>
<li>原型模式：用于创建重复对象，同时又能保证性能。当创建对象的代价比较大时，可以采用这种模式（Clone）。</li>
</ol>
</li>
</ol>
<h3 id="二：JVM相关"><a href="#二：JVM相关" class="headerlink" title="二：JVM相关"></a>二：JVM相关</h3><ol>
<li><p><strong>内存区域？</strong></p>
<p>根据JVM规范，定义了<code>JVM</code>内存的5个部分，<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>程序计数器</strong>、<strong>方法区</strong>、<strong>堆</strong>。这五个区域也称为运行时数据区。其中，程序计数器是唯一一个不会出现内存溢出的情况，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-26-08.png" class="">

<ol>
<li><p>在<code>JDK1.8</code>之前，线程共享的是：堆、方法区、直接内存。而线程私有的是：虚拟机栈、本地方法栈、程序计数器。</p>
<ol>
<li>1.8之后，方法区由元空间来实现，存储<code>.class</code>信息、类的信息、方法的定义、静态变量等，而常量池移到了堆中。</li>
</ol>
</li>
<li><p><strong>堆与栈的区别？以及堆的结构</strong>。</p>
<ol>
<li><code>Java</code>虚拟机中的堆结构。</li>
</ol>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-26-18.png" class="">

<pre><code>  在JDK1.8之前，Java虚拟机将内存划分为新生代、老年代和永久代，永久代是HotSpot虚拟机特有的概念，其实是方法区的实现，只不过方法区的叫法是JVM规范中定义的。在JDK1.8中，使用元空间（``metaspace``）代替了永久代。

  1. 新生代

     ``HotSpot``虚拟机将新生代分为三块，一块是较大的``Eden``空间和两块较小的``Survivor``空间，默认比例为``8：1：1``。当``Eden``区内存空间不够时，虚拟机将发起一次``Minor GC``。

     ``HotSpot``新生代的垃圾回收算法采用的是复制算法。``GC``开始时，对象只会存在``Eden``区和``From Survivor``区，``To Survivor``区是空的。``GC``进行时，``Eden``区中所有存活的对象,会被复制到``To Survivor``区，而在``From Survivor``区中，根据存活对象的年龄来决定去留，当对象的年龄达到年龄阈值，（默认为``15``，每熬过一次``minor GC``，存活对象的年龄就会``+1``），就会被移到老年代中，没有达到阈值的对象就复制到``To Survivor``区中。接着清空``Eden``区和``From Survivor``区。接着，调换``From Survivor``区和``To Survivor``区的角色。若``To Survivor``区存放不下所有的存活对象，则会将剩下的对象放在老年代中。

  2. 老年代

     在新生代中经历了多次``GC``后任然存活下来的对象会进入老年代中，老年代的对象生命周期较长，存活率比较高，采用``Full GC``（标记整理算法）来回收对象。

  3. 永久代

     永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，其垃圾回收是与老年代及进行绑定，无论谁的内存满了，都会进行垃圾回收。

  4. 元空间

     ``JDK１.８``之后的产物，存储类信息、静态变量、常量、编译后的代码等。
     
     ``Metaspace``的内存管理：
     
     ​    与永久代不同，在``metaspace``中，类和其元素的生命周期与其对应的类加载器相同，只要类的加载器是存活的，``Metaspace``中的类元素也是存活的，不能被回收。当``GC``发现某个类加载器不再存活，就会把对应的整个空间回收。
</code></pre>
<ol start="2">
<li><p><code>Java</code>虚拟机中堆与栈的主要区别？</p>
<ol>
<li>存储：栈存储的是变量、对象的引用；而堆存储的是实例对象。</li>
<li>速度：栈的存取速度快；堆的存储速度慢。</li>
<li>数据结构：栈的数据结构就是栈，而堆的数据结构是一颗完全二叉树。</li>
</ol>
</li>
<li><p>对象创建的过程？</p>
<ol>
<li><p>对象创建过程分为5个步骤。类加载检查-&gt;分配内存-&gt;初始化零值-&gt;设置对象头-&gt;执行<code>init</code>方法。</p>
<ol>
<li><p><strong>类加载检查</strong>：虚拟机遇到一条<code>new</code>指令时，首先检查这个指令的参数是否在常量池中定位到这个类的引用，并且检查这个引用代表的类是否已经被加载过、解析过、初始化过，如果没有，那必须先执行相应的类加载过程。</p>
</li>
<li><p><strong>分配内存</strong>：在类加载检查之后，接下来虚拟机将为新生对象分配内存，为对象分配空间的任务等同于把一块确定大小的内存从<code>java</code>堆中划分出来。分配的方式有两种：指针碰撞和空闲列表，选择哪种方式有<code>Java</code>堆是否规整决定，而<code>Java</code>堆时否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<ol>
<li><p>指针碰撞：适用场合：堆内存规整的情况下。</p>
</li>
<li><p>空闲列表：使用场合：堆内存不规整的情况下。</p>
</li>
<li><p><strong>内存分配并发问题</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong><code>CAS</code>+失败重试：</strong> <code>CAS</code> 是乐观锁的一种实现方式。<strong>虚拟机采用 <code>CAS</code> 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong><code>TLAB</code>：</strong> 为每一个线程预先在 <code>Eden</code> 区分配一块儿内存，<code>JVM</code> 在给线程中的对象分配内存时，首先在 <code>TLAB</code> 分配，当对象大于 <code>TLAB</code> 中的剩余内存或 <code>TLAB</code> 的内存已用尽时，再采用上述的<code> CAS</code> 进行内存分配。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>初始化零值</strong>：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 <code>Java</code> 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
</li>
<li><p><strong>设置对象头</strong>：初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 <code>GC</code> 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
</li>
<li><p><strong>执行<code>init</code>方法</strong>：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 <code>new</code> 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>对象访问定位的两种方式？</p>
<ol>
<li><strong>句柄</strong>：如果使用句柄的话，那么 <code>Java</code> 堆中将会划分出一块内存来作为句柄池，<code>reference</code> 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li>
<li><strong>直接指针：</strong> 如果使用直接指针访问，那么 <code>Java</code> 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 <code>reference</code> 中存储的直接就是对象的地址。</li>
</ol>
</li>
<li><p>如何判断对象是否死亡？</p>
<ol>
<li>引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。<strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 <code>objA</code> 和 <code>objB</code> 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 <code>GC</code> 回收器回收他们。</li>
<li>可达性分析法：这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 <code>GC Roots</code> 没有任何引用链相连的话，则证明此对象是不可用的。</li>
</ol>
</li>
<li><p><strong>强引用、软引用、弱引用、虚引用？</strong></p>
<p>Reference源码:</p>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-28-01.png" class="">

<p>   软引用\弱引用\虚引用都继承自<code>java.lang.ref.Reference</code>,是直接子类.但引用对象是与垃圾收集器紧密协作而实现的,所以不能自定义引用类型.</p>
<p>   <code>Reference</code>有四种状态:</p>
<p>   <code>Active:</code>    引用刚被创建时的状态,如果GC检测到该实例引用的对象的可达性发生了改变,状态则会变成<code>Pending</code>或者<code>Enqueued</code>.如果,<code>reference</code>在创建引用时注册了引用队列,则会进入<code>Pending</code>的状态,并将<code>Reference</code>加入到<code>pending-Reference</code>链表中,如果没有,则会进入<code>Enqueued</code>的状态.</p>
<p>   <code>Pending</code>:    当引用实例被放置在<code>pending-Reference</code>链表中时,该实例等待一个叫<code>Reference-handler</code>的线程进行<code>enqueued</code>操作.</p>
<p>   <code>Enqueued</code>:    当<code>Reference</code>从队列中移除的时候,就会进入此状态.</p>
<p>   <code>Inactive</code>:    一旦某个<code>Reference</code>处于此状态,他的状态将不会改变,同时说明该引用实例所执行放入实际对象一定会被<code>GC</code>回收.</p>
<ol>
<li><p><strong>强引用</strong></p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，<code>Java</code> 虚拟机宁愿抛出 <code>OutOfMemoryError</code> 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
</li>
<li><p><strong>软引用（<code>SoftReference</code>）</strong></p>
<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。<em>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存</em>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果软引用所引用的对象被垃圾回收，<code>JAVA </code>虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
</li>
<li><p><strong>弱引用（<code>WeakReference</code>）</strong></p>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。 不会活过下个垃圾回收。引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>实例:<code>weakHashMap</code>,触发GC之后,就没有了值.</p>
</li>
<li><p><strong>虚引用（PhantomReference）</strong></p>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用不能单独使用,也不能通过它访问对象,必须和引用队列(<code>RefenceQueue</code>)联合使用.</p>
<p>虚引用的主要作用是跟踪对象垃圾回收的状态,设置虚引用的唯一目的就是在这个对象被回收器回收的时候收到一个系统通知或者后续添加进一步的处理.</p>
<ol>
<li><p>引用队列<code>(ReferenceQueue)</code></p>
<p>用来配合引用工作的,没有引用队列一样可以运行.创建引用的时候,可以指定关联的队列,当<code>GC</code>释放对象内存的时候,将引用加入到引用队列中,如果发现某个虚引用已经被加入到引用队列中,那么就可以在所引用的对象的内存被回收之前采取必要的行动,这相当于一种通知机制.</p>
</li>
</ol>
</li>
<li><p><strong>垃圾收集算法</strong>。</p>
<ol>
<li><p><strong>标记清除</strong></p>
<p>该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
<p>缺点：</p>
<ol>
<li>效率问题</li>
<li>空间问题（标记清除后会产生大量不连续的碎片）</li>
</ol>
</li>
</ol>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-28-16.png" class="">

<ol start="2">
<li><p><strong>复制算法</strong></p>
<p>解决效率问题，将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。</p>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-28-30.png" class="">

<ol start="3">
<li><p><strong>标记整理</strong></p>
<p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-28-42.png" class="">

<ol start="4">
<li><p><strong>分代收集算法</strong></p>
<p>当前虚拟机的垃圾收集都采用分代收集算法，根据对象存活周期的不同将内存分为几块。一般将 <code>java</code> 堆分为新生代和老年代，根据各个年代的特点选择合适的垃圾收集算法。<strong>比如在新生代中，每次收集都会有大量对象死去，选择复制算法。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>
</li>
<li><p><strong>垃圾收集器</strong>？</p>
<ol>
<li><p><strong><code>Serial</code>收集器</strong>：</p>
<p><code>Serial（串行）</code>收集器。是一个单线程收集器了。使用一条垃圾收集线程去完成垃圾收集工作，该线程进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong><code>&quot;Stop The World&quot;</code></strong> ），直到收集结束。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong> </p>
</li>
</ol>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-29-02.png" class="">

<pre><code>  ``Serial`` 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。
</code></pre>
<ol start="2">
<li><p><strong><code>PerNew</code>收集器</strong>：</p>
<p><code>ParNew</code> 收集器其实就是 <code>Serial</code> 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 <code>Serial</code> 收集器完全一样。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong> <img data-src="/blog/posts/a5258aa2/2022-02-16-00-29-16.png" class=""><br><strong>并行和并发概念补充：</strong></p>
<ul>
<li><strong>并行（<code>Parallel</code>）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li><strong>并发（<code>Concurrent</code>）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 <code>CPU</code> 上。</li>
</ul>
</li>
<li><p><strong><code>CMS</code>收集器</strong>：</p>
<p><code>CMS（Concurrent Mark Sweep）</code>收集器是 第一款真正意义上的并发收集器，实现了让垃圾收集线程与用户线程同时工作。</p>
<p><code>CMS</code> 收集器是一种 <strong>“标记-清除”算法</strong>实现的。整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 <code>root</code> 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 <code>GC</code> 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 <code>GC</code> 线程无法保证可达性分析的实时性。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 <code>GC</code> 线程开始对为标记的区域做清扫。</li>
</ul>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-29-24.png" class="">

<pre><code>  从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

  - **对 CPU 资源敏感；**
  - **无法处理浮动垃圾；**
  - **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**
</code></pre>
<ol start="4">
<li><p><strong><code>G1</code>收集器：</strong></p>
<p><code>G1 (Garbage-First)</code> 是一款面向服务器的垃圾收集器。</p>
<p>它具备一下特点：</p>
<ul>
<li><p>并行与并发：<code>G1</code> 能充分利用 <code>CPU</code>、多核环境下的硬件优势，使用多个 <code>CPU</code>来缩短 <code>Stop-The-World </code>停顿时间。部分其他收集器原本需要停顿 <code>Java </code>线程执行的 <code>GC</code> 动作，<code>G1</code> 收集器仍然可以通过并发的方式让 <code>java </code>程序继续执行。</p>
</li>
<li><p>分代收集：虽然 <code>G1</code> 可以不需要其他收集器配合就能独立管理整个 <code>GC</code> 堆，但是还是保留了分代的概念。在内存空间上，<code>G1</code>  将内存划分为很多小块，每一个小块可以被标记为<code>O\S\E</code>种的一个。从而使得垃圾回收变成更彻底。</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>可预测的停顿</strong>：这是 <code>G1</code> 相对于 <code>CMS</code> 的另一个大优势， <code>G1</code> 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</p>
<p>   <strong>实现原理</strong>：<code>G1</code>的一个显著特点是他能够让用户设置应用的暂停时间，<code>G1</code>收集器回收的第四步是选择一个内存来回收，而不是整代内存，这使得回收内存所需时间就取决于内存大小，以及实际垃圾的多少。所以，到底回收多少垃圾就取决于用户配置的暂停时间，时间多一点就多回收一些垃圾，实现伸缩的自如。</p>
<p> <code>G1</code> 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li><strong>初始标记</strong>：在垃圾回收的最开始有一个短暂的时间段会停止应用。</li>
<li><strong>并发标记</strong>：继续运行程序，同时<code>G1</code>开始标记。</li>
<li><strong>最终标记</strong>：再次停止应用来做最后的标记。</li>
<li><strong>筛选回收</strong>：根据<code>Garbage First</code>的原则，选择一个内存块进回收。</li>
</ul>
<p> <code>G1</code> 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 <code>Region</code>。这种使用 <code>Region</code> 划分内存空间以及有优先级的区域回收方式，保证了 <code>G1</code> 收集器在有限时间内可以尽可能高的收集效率。</p>
</li>
</ul>
<ol start="9">
<li><p>类加载过程与类加载器？</p>
<ol>
<li><p>类的生命周期：加载-&gt;连接-&gt;初始化-&gt;使用-&gt;卸载.连接过程又分为：验证-&gt;准备-&gt;解析。</p>
</li>
<li><p>类加载器：<code>JVM</code> 中内置了三个重要的 <code>ClassLoader</code>，除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p>
<ol>
<li><strong><code>BootstrapClassLoader</code>(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li>
<li><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</li>
<li><strong><code>AppClassLoader</code>(应用程序类加载器)</strong> :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li>
</ol>
</li>
<li><p><code>Thread.currentThread.getContextLoader()</code>（上下文类加载器）。</p>
<p><code>Java</code>提供了很多服务提供者接口（<code>Service Provider Interface SPI</code>）,允许第三方为这些接口提供实现，例如<code>JDBC、JNDI、JBI</code>等。</p>
<p>线程上下文类加载器，可以打破双亲委派机制，实现逆向调用类加载器来加载当前线程中类加载其加载不到的类。</p>
</li>
<li><p>双亲委派：</p>
<h3 id="双亲委派模型介绍"><a href="#双亲委派模型介绍" class="headerlink" title="双亲委派模型介绍"></a>双亲委派模型介绍</h3><p>每一个类都有一个对应它的类加载器。系统中的 <code>ClassLoder</code> 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为<code>null</code>时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p>
</li>
</ol>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-29-36.png" class="">

<ol start="5">
<li><p>打破双亲委派机制</p>
<ol>
<li><p>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 <code>loadClass()</code> 即可。</p>
</li>
<li><p><code>tomcat</code>中的打破双亲委派机制：先加载<code>JVM</code>的类-&gt;<code>tomcat</code>的类-&gt;自己定义的类-&gt;应用程序的类-&gt;公共的类。</p>
<p>顺序：1 使用<code>bootstrap</code>引导类加载器加载 （<code>JVM</code> 的东西 ）</p>
<p>​            2 使用<code>system</code>系统类加载器加载 （<code>tomcat</code>的启动类<code>Bootstrap</code>包）</p>
<p>​            3 使用<code>WebAppClassLoader</code> 加载 <code>WEB-INF/classes</code> （应用自定义的<code>class</code>）</p>
<p>​            4 使用<code>WebAppClassLoader</code> 加载在<code>WEB-INF/lib</code> （应用的依赖包）</p>
<p>​            5 使用<code>common</code>类加载器在<code>CATALINA_HOME/lib</code>中加载 （<code>tomcat</code>的依赖包，公共的，被各个应用共享的）</p>
</li>
</ol>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-29-45.png" class="">

<ol start="10">
<li><p><code>Minor GC</code>与<code>Full FC？</code></p>
<p><code>Minor GC</code>用于新生代的垃圾回收，会有短暂的暂停，每一次<code>minor GC </code>都会增加对象的生命，达到某个阈值进入老年代。而<code>Full GC</code>用于回收大对象，用于老年代的回收。</p>
</li>
<li><p><code>GC</code>调优策略？</p>
<p><strong>策略 1</strong>:将新对象预留在新生代，由于 <code>Full GC</code> 的成本远高于 <code>Minor GC</code>，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 <code>GC</code> 日志分析新生代空间大小分配是否合理，适当通过“<code>-Xmn</code>”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p>
<p>**策略 2:**大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦）。<code>-XX:PretenureSizeThreshold</code> 可以设置直接进入老年代的对象大小。</p>
<p>**策略 3:**合理设置进入老年代对象的年龄，<code>-XX:MaxTenuringThreshold</code> 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 <code>full gc </code>发生的频率。</p>
<p><strong>策略 4：</strong>设置稳定的堆大小，堆大小设置有两个参数：<code>-Xms</code> 初始化堆大小，<code>-Xmx</code> 最大堆大小。</p>
<p><strong>策略5：</strong>注意： 如果满足下面的指标，<strong>则一般不需要进行 <code>GC </code>优化：</strong></p>
<blockquote>
<p><code>MinorGC</code> 执行时间不到<code>50ms</code>； <code>Minor GC</code> 执行不频繁，约10秒一次； <code>Full GC</code> 执行时间不到<code>1s</code>； <code>Full GC</code> 执行频率不算频繁，不低于10分钟1次。</p>
</blockquote>
</li>
</ol>
<h3 id="三：集合-容器"><a href="#三：集合-容器" class="headerlink" title="三：集合\容器"></a>三：集合\容器</h3><ol>
<li><p><code>List,Set,Map</code>三者的区别?</p>
<ol>
<li><code>List</code>与<code>Set</code>继承自<code>Collection</code>,基于<code>List</code>实现的方法有<code>ArrayList</code>-<code>Vector</code>-<code>LinkedList</code>;基于<code>Set</code>实现的方法有<code>HashSet</code>-<code>LinkedHashSet</code>-<code>TreeSet</code>;基于<code>Map</code>实现的有<code>HashMap</code>-<code>LinkedHashMap</code>-<code>HahTable</code>-<code>TreeMap</code>;</li>
<li><code>LIst</code>接口存储一组不唯一,有序的对象;</li>
<li><code>Set</code>接口存储不允许重复的对象;</li>
<li><code>Map</code>使用键值对存储.</li>
</ol>
</li>
<li><p><code>ArrayList</code>与<code>LinkedList</code>区别,以及<code>ArrayLIst</code>与<code>Vector</code>的区别?</p>
<ol>
<li><code>ArrayList</code>底层使用的时数组结构,<code>LinkedList</code>底层使用的时双向链表数据结构.</li>
<li>插入元素与删除元素时间复杂度受数组和链表的影响.</li>
<li><code>ArrayList</code>与<code>LinkedList</code>是线程不安全的,而<code>Vector</code>是线程安全的.</li>
</ol>
</li>
<li><p><code>ArrayList</code>与<code>HashMap</code>的扩容机制?</p>
<p>1.<code> ArrayList</code>是使用懒加载的方式,每次扩容通过<code>Arrays.copyOf(elementData, newCapacity)</code>来实现的,即将当前数组元素拷贝到新的数组中,每次扩容后的容量为原来容量的<code>1.5</code>倍.</p>
<ol start="2">
<li><code>HashMap</code>底层采用的是<code>数组+链表+红黑树</code>的数据结构来实现.扩容扩展的是数组的长度,无参构造时默认<code>第一次扩容16单位</code>.阈值=<code>数组长度*负载因子</code>.默认的负载因子是<code>0.75</code>,例如,<code>16X0.75 = 12</code>,当元素个数超过<code>12</code>时,容量扩容为原来的<code>2</code>倍,当容量扩大至<code>Integer.MAX_VALUE</code>时,容量设置为<code>Integer.MAX_VALUE</code>,且不在增长.</li>
</ol>
</li>
<li><p><code>HashMap</code>与<code>HashTable</code>的区别,以及<code>HashMap</code>与<code>HashSet</code>的区别?</p>
<ol>
<li>线程是否安全:<code>HashMap</code>是非线程安全的,<code>HashTable</code>是线程安全的,具体实现方式是通过<code>synchronized</code>修饰.</li>
<li><code>HashMap</code>中,<code>null</code>值可以作为<code>key</code>,这压根的<code>key</code>只能有一个,而值可以有多个或一个为<code>null</code>.</li>
<li><code>HashMap</code>与<code>HashTable</code>的扩容机制不同以及初融容量不同,<code>HashMap</code>初始容量是<code>16</code>,每次扩容为想在容量的<code>两倍</code>,<code>HashTable</code>的初始容量为<code>11</code>,每次扩容是现有容量的<code>2n+1</code>.</li>
<li>底层的数组结构,<code>HashMap</code>在链表长度大于8的时候会转为红黑树,而<code>HashTable</code>没有这样的机制.</li>
<li><code> HashSet</code>基于<code>HashMap</code>实现,实现的是<code>Set</code>的接口.</li>
</ol>
</li>
<li><p><code>HashMap</code>底层实现的原理?</p>
<ol>
<li><code>HashMap</code>底层是数组+链表+红黑树实现.为了减少<code>Hash</code>碰撞,将数据尽量均匀分配,<code>HashMap</code>的容量是<code>2的幂次方</code>.<code>Hash</code>值范围前后加起来大概有<code>40亿</code>,直接使用,内存是放不下的,所以需要与数组下标&amp;运算,这也就解释了为什么长度是<code>2的幂次方</code>.</li>
</ol>
</li>
<li><p><code>ConcurrentHashMap</code>和<code>HashTable</code>的区别?</p>
<ol>
<li><p>在底层数据结构上,<code>ConcurrentHashMap</code>使用的是<code>分段数组+链表+红黑树</code>的实现,<code>HashTable</code>使用的是数组+链表.</p>
</li>
<li><p><code>ConcurrentHashMap</code>与<code>HashTable</code>的区别主要体现在实现线程安全的方式上不同.在<code>JDK1.7</code>之前,<code>ConcurrentHashMap</code>对整个数组进行了分割和分段,每一段有一把锁,在访问不同段里面的数据时就不会存在锁竞争.在<code>JDK1.8</code>之后,<code>ConcurrentHashMap</code>摒弃了数组分段的概念,直接是用<code>数组+链表+红黑树</code>的结构,并发控制使用的是<code>Synchronized</code>和<code>CAS</code>来控制,看起来是优化过且线程安全的<code>HashMap</code>.</p>
</li>
</ol>
</li>
<li><p><strong>红黑树</strong></p>
<p>红黑树是一个自平衡的二叉查找树。但其与平衡二叉树<code>（ALV）</code>的区别在于平衡二叉树是严格的平衡，适用于插入和删除操作少，查询多的情况，而红黑树是一颗弱平衡二叉树，相同情况下，树的高度会高于平衡二叉树。</p>
<ol>
<li><p>特性：</p>
<ol>
<li>每个节点或者是黑色或者是红色，且根节点是黑色，每个叶子节点（<code>NULL</code>空值节点）也是黑色。</li>
<li>如果一个节点是红色，则它的子节点必须是黑色。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑色节点。</li>
<li>红黑树最长路径的长度不超过最短路径的两倍。</li>
</ol>
</li>
<li><p>操作：</p>
<ol>
<li>左旋</li>
</ol>
</li>
</ol>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-29-56.png" class="">

<pre><code>     <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LEFT-ROTATE（T，x）</span><br><span class="line">    y &lt;- right[x] 		<span class="comment">//假设X节点的右孩子是y。</span></span><br><span class="line">    right[x] &lt;- left[y]	<span class="comment">//将y节点的左孩子设为x节点的右孩子</span></span><br><span class="line">    P[left[y]] &lt;- x		<span class="comment">//将x设置为y节点左孩子的父亲</span></span><br><span class="line">    p[y] &lt;- p[x]		<span class="comment">//将x的父亲设置为y的父亲</span></span><br><span class="line">    <span class="keyword">if</span> p[x] = nil[T]	<span class="comment">//情况1：如果x的父节点是空姐点，则将y设置为根节点</span></span><br><span class="line">        root[T] &lt;- y</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> x = left[p[x]]</span><br><span class="line">        left[p[x]] &lt;- y	<span class="comment">//情况2：如果x是其父节点的左孩子，则将y设置为其父节点的左孩子</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        right[p[x]] &lt;- y <span class="comment">//情况3：如果x是其父节点的右孩子，则将y设置为其父节点的额右孩子</span></span><br><span class="line">    left[y] &lt;- x 		<span class="comment">//将x设置为y的左孩子</span></span><br><span class="line">    p[x] &lt;- y			<span class="comment">//将x节点的父亲设置为y</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

     

  2. 右旋
</code></pre>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-30-05.png" class="">

<pre><code>     <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Right-AOTATE(T,y)</span><br><span class="line">    x &lt;- left[y]			<span class="comment">//设置x为y节点左孩子</span></span><br><span class="line">    left[y] &lt;- right[x]		<span class="comment">//将x的右孩子设置为y的左孩子</span></span><br><span class="line">    p[right[x]] &lt;- y		<span class="comment">//将y设置为x右孩子的父亲</span></span><br><span class="line">    p[x] &lt;- p[y] 			<span class="comment">//将y的父亲设为x的父亲</span></span><br><span class="line">    <span class="keyword">if</span> p[y] = nil[T]		</span><br><span class="line">        root[T] &lt;- x		<span class="comment">//情况1，如果y的父亲是空节点，则将x设为根节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> y = right[p[y]]  </span><br><span class="line">            then right[p[y]] ← x   <span class="comment">// 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”</span></span><br><span class="line">            <span class="keyword">else</span> left[p[y]] ← x    <span class="comment">// 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子”</span></span><br><span class="line">  right[x] ← y            <span class="comment">// 将 “y” 设为 “x的右孩子”</span></span><br><span class="line">  p[y] ← x                <span class="comment">// 将 “y的父节点” 设为 “x”</span></span><br></pre></td></tr></table></figure>

  3. 添加与删除节点操作

     
</code></pre>
<h3 id="四：计算机网络"><a href="#四：计算机网络" class="headerlink" title="四：计算机网络"></a>四：计算机网络</h3><ol>
<li><p><code>TCP/IP</code>各层的结构与功能,都有哪些协议?</p>
<ol>
<li>七层网络结构：物理层、数据链路层、网络层（<code>IP</code>）、传输层（<code>TCP，UDP</code>）、会话层、表示层、应用层（<code>HTTP，HTTPS，SMTP，DNS</code>）。</li>
</ol>
</li>
<li><p><strong><code>TCP</code>三次握手与四次握手</strong></p>
<ol>
<li><p>三次握手的流程：</p>
<ol>
<li><code>TCP</code>服务器进程先创建传输控制块，时刻准备着接受客户进程的连接请求，此时服务器就进入了<code>LISTEN</code>状态。</li>
<li><code>TCP</code>客户进程也是先创建传输控制块<code>TCB</code>，然后像服务器发送连接请求报文，这时报文首部中的<code>SYN=1</code>，同时产生一个初始序列号<code>seq=x</code>，此时，<code>TCP</code>客户端进程进入<code>SYN-SENT</code>状态。</li>
<li><code>TCP</code>服务器收到请求报文后，如果同意连接，则发送确认报文，这时确认报文中<code>ACK＝１，SYN＝１</code>，确认号是<code>ack=x+1</code>，同时自己也初始化一个序列号<code>seq=y</code>，此时，<code>TCP</code>服务器进程进入<code>SYN-RCVD</code>状态。</li>
<li><code>TCP</code>客户端进程收到确认后，还要向服务器给出确认，确认报文<code>ACK=1，ack=1</code>，自己的序列号<code>seq=x+1</code>，此时，<code>TCP</code>连接建立，客户端进入<code>ESTABLISHED</code>状态，</li>
<li>当服务器收到客户端的确认后也进入<code>ESTABLISHED</code>状态，此后，双方就可以开始通信了。                    </li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p><code>TCP</code>四次握手流程：</p>
<ol>
<li>客户端进程发送连接释放报文，并且停止发送数据，释放数据报文首部，此时<code>FIN=1</code>，序列号为<code>seq=u</code>，此时客户端进入<code>FIN-WAIT-1</code>状态</li>
<li>服务器收到连接释放报文，发出确认报文，此时<code>ACK=1，ack=u+</code>，并且带上自己序列号<code>seq=v</code>，此时服务器就进入<code>CLOSED-WAIT</code>状态。</li>
<li>客户端收到服务器的确认请求后，客户端就进入<code>FIN-WAIT-2</code>状态，等待服务器发送释放连接的报文。</li>
<li>服务器将最后的数据发送完毕后，就像客户端发送连接释放报文，<code>FIN=1，ack=u+1</code>，此时的序列号为服务器就进入<code>LAST-ACK</code>状态，等待客户端的确认。</li>
<li>客户端收到服务器的连接释放报文后，必须发送确认，<code>ACK=1，ack=w+1</code>，而自己的序列号是<code>seq=u+1</code>，此时，客户端就进入了<code>TIME-WAIT</code>状态。此时<code>TCP</code>连接还没有释放，必须经过<code>2*MSL（最长报文段寿命）</code>的时间后，当客户端撤销相应的<code>TCB</code>后，才进入<code>CLOSED</code>状态。</li>
<li>服务器只要收到客户端发送的确认，立即进入<code>CLOSED</code>状态，同样，撤销<code>TCB</code>后，就结束了这次的<code>TCP</code>连接。</li>
</ol>
</li>
<li><p>为什么客户端还要等待2个报文寿命时间？</p>
<ol>
<li>第一：保证客户端发送的最后一个<code>ACK</code>报文能够到达服务器，因为这个<code>ACK</code>报文可能丢失，而客户端就能在这个<code>2MSL</code>时间内收到这个重传的报文，接着给出回应报，并且重计<code>2MSL</code>时间。</li>
<li>防止类似与”三次握手“中提到的”已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个<code>2MSL</code>时间中，就可以使本链接持续的时间内所产生的所有报文段都从网络中消失。</li>
</ol>
</li>
<li><p>如果已经连接了连接，凡是客户端突然出现故障了怎么办？</p>
<ol>
<li><code>TCP</code>还有一个保活计时器，如果客户端出现故障，服务器不能一直等下去。服务器每收到一次客户端的请求后都会重新复位这个计时器。时间一般为2小时，若两个小时都还没收到客户端的任何数据，服务器就会发送一个探测报文段，以后每个75秒发送一次，若连续发送10个探测报文段都没有反应，服务器就认为客户端出现了故障，接着关闭连接。</li>
</ol>
</li>
<li><p><code>TCP</code>与<code>UDP</code>的区别，以及使用场景？</p>
<table>
<thead>
<tr>
<th>&amp;</th>
<th>​TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>可靠性</td>
<td>可靠</td>
<td>不可靠</td>
</tr>
<tr>
<td>连接性</td>
<td>面向连接</td>
<td>连接</td>
</tr>
<tr>
<td>报文</td>
<td>面向字节流</td>
<td>面向报文</td>
</tr>
<tr>
<td>效率</td>
<td>效率低</td>
<td>效率高</td>
</tr>
<tr>
<td>双工性</td>
<td>一对一</td>
<td>一对多，多对一，多对多</td>
</tr>
<tr>
<td>拥塞控制</td>
<td>慢开始、拥塞避免、快重传</td>
<td>无</td>
</tr>
<tr>
<td>应用场景</td>
<td>对效率要求低</td>
<td>对传输效率要求高</td>
</tr>
<tr>
<td>常见使用场景</td>
<td><code>SMTP、HTTP、FTP</code></td>
<td><code>DNS</code>、视频连接</td>
</tr>
</tbody></table>
</li>
<li><p>滑动窗口与流量控制、拥塞控制．</p>
<ol>
<li><p><code>TCP</code>利用滑动窗口实现流量控制，流量控制是为了控制发送方发送速率，保证接收方来得及接受，接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率，将窗口字段设置为<code>0</code>，则发送方不能发送数据。</p>
</li>
<li><p>拥塞控制：拥塞控制的四种算法：慢开始、拥塞控制、快重传、快恢复。</p>
<p>​    发送方从拥塞窗口为<code>1</code>开始发送数据，以指数的形式扩大发送的窗口值，当达到设置的阈值后，开始进入拥塞避免阶段，开始以线性增加窗口值，直到发送的收据出现丢失，出现拥塞的现象，然后从慢开始重新传递。并更新阈值。</p>
<p>快速重传：发送方丢失报文，接收方连续三次重复确认丢失报文之前的报文段，发送方立即重新传递丢失的报文，接收方确认。</p>
<p>快恢复：接收方收到三个相同的确认后，立即快重传，之后进入快恢复阶段，阈值更新为目前的1/2然后进入拥塞避免的阶段。</p>
</li>
</ol>
</li>
</ol>
<ol start="5">
<li><p>浏览器输入<code>URL</code>之后的流程</p>
<ol>
<li><code>DNS</code>解析-&gt;<code>TCP</code> 连接-&gt;发送<code>HTTP</code>请求-&gt;服务器处理请求并返回<code>HTTP</code>报文-&gt;浏览器解析渲染画面-&gt;连接结束。<ol>
<li><strong><code>DNS</code>解析过程</strong>:<ol>
<li>在浏览器中输入域名,操作系统会先检查自己本地的<code>hosts</code>文件是否含有这个网址映射关系,如果有,就先调用这个<code>IP</code>地址映射,完成域名解析.</li>
<li>如果<code>hosts</code>里灭有这个域名的映射,则查找本地<code>DNS</code>解析器缓存,是否有这个网址映射关系,如果有,直接返回,完成域名解析.</li>
<li>如果,本地<code>hosts</code>文件和本地<code>DNS</code>缓存没有对应的网址映射关系，则会查找本地<code>DNS</code>服务器，如果要查询的域名包含在本地<code>DNS</code>区域资源中，则返回解析结果给客户端，完成域名解析．</li>
<li>如果本地<code>DNS</code>服务器＼本地缓存文件＼<code>hosts</code>文件都失效了，则根据本地<code>DNS</code>服务器的设置进行查询，如果没有用转发模式，本地<code>DNS</code>服务器就把请求发送至<code>13</code>台根<code>DNS</code>服务器，根服务器会根据域名的信息来判断是谁来授权管理这个域名的服务器，将请求交给管理者<code>DNS</code>服务器，如果自己无法解析，就会找下一级的<code>DNS</code>服务器地址给本地<code>DNS</code>服务器．</li>
<li>如果用的是转发模式，本地<code>DNS</code>服务器会把请求转发至上一级<code>DNS</code>服务器，又上一级服务器进行解析，如果上一级服务器不能解析，再找上上级服务器，以此循环．</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>常见的状态码</p>
</li>
</ol>
<pre><code>&amp; | * | $ | ^
-----|---|---|---
1XX    | 信息性状态码    |        处理的请求正在处理    | 100客户端继续发送请求，部分请求服务器已经接受
2XX    | 成功状态码    |        请求正常处理完毕    |200服务器已经成功接收请求    
  202 , 204  | 202服务器已经接受请求但不知道会不会处理    |     204服务器已经处理了请求，但没有返回任何的内容。
3XX    | 重定向状态码    | 需要进行附加操作以完成请求    | 301客户端请求的网页已经永久移动到新的位置
4XX |    客户端错误状态码 |    服务器无法处理请求    | 404请求失败，客户端请求的资源没有找到或者不存在
5XX |    服务器错误状态码 |    服务器处理请求出错    | 500服务器遇到未知的错误，导致无法完成客户端的请求    
503 | 503服务器由于临时服务器过载或者是维护无法完成当前的请求    
</code></pre>
<ol start="7">
<li><p><code>Http</code>的长连接与短链接</p>
<ol>
<li><code>Http/1.0</code>默认使用的是短连接，<code>1.1</code>起默认使用长连接，用以保持连接的<code>HTTP</code>特性</li>
</ol>
</li>
</ol>
<ol start="8">
<li><p><code>Cookie</code>的作用的是什么，和<code>Session</code>的作用的区别？</p>
<ol>
<li><code>Cookie</code>和<code>Session</code>都是用来跟踪浏览器用户身份的会话方式，<code>Cookie</code>是浏览器中保留的数据，而<code>Session</code>是服务器中保留的数据。<code>Session</code>的安全性更高。</li>
</ol>
</li>
<li><p>单个<code>cookie</code>保存的数据不能超过4k，而<code>session</code>随想没有对存储数据量的限制。</p>
</li>
<li><p><code>Http</code>与<code>Https</code>的区别？</p>
</li>
<li><p>端口：<code>HTTP</code>默认使用的是80端口，而<code>HTTPS</code>默认使用的是<code>443</code>端口</p>
</li>
<li><p>安全性和资源消耗，<code>HTTP</code>运行于<code>TCP</code>之上，所传输的内容是明文；<code>HTTPS</code>运行在<code>SSL/TLS</code>之上，所传输的内容经过加密，加密的方式采用对称加密，但对称加密的密钥用服务器放的证书进行了非对称加密。</p>
<ol>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加密解密速度快，典型的算法有<code>DES</code>和<code>AES</code></li>
<li>非对称加密：密钥成对出现，加密解密使用不同的密钥，相对于对称加密读书较慢，典型的非对称加密算法有<code>RSA、DSA</code>等</li>
</ol>
</li>
</ol>
<h3 id="五：-操作系统（并发，多线程）"><a href="#五：-操作系统（并发，多线程）" class="headerlink" title="五： 操作系统（并发，多线程）"></a>五： 操作系统（并发，多线程）</h3><ol>
<li><p><strong>简述线程、进程、协程的概念，以及他们之间的关系</strong>？</p>
<ol>
<li>进程：是程序运行的基本单位，也是操作系统分配资源的基本单位。<ol>
<li>僵尸进程</li>
<li>孤儿进程</li>
</ol>
</li>
<li>线程：一个进程可以产生多个线程，是比进程更小的执行单位，是<code>CPU</code>时间分配的基本单位。</li>
<li>协程：比线程更轻量级的存在，子程序的切换不是线程的切换，因此，没有线程切换的开销。第二个优势是没有多线程的锁机制，也不存在写冲突。</li>
<li>在进程进行上下文切换的时候需要保存寄存器、用户栈等信息。如果是线程进行上下文切换，则分两种情况，第一种若是线程不属于同一进程，切换过程和进程上下文切换一样。若线程属于同一进程，则只需要切换线程私有的数据、寄存器等不共享的数据。</li>
</ol>
</li>
<li><p><strong>内核态与用户态的区别</strong>？</p>
<ol>
<li>内核态：指操作系统在系统态运行，运行操作系统本身的程序。特权指令：指的是在系统态下运行的指令。</li>
<li>用户态：指运行应用程序，而应用程序只能在用户态运行。非特权指令：指的是用户用运行下的指令。</li>
<li>状态切换：用户态切换到内核态的唯一途径只有中断、异常、陷入这三种方式。而内核态切换到用户态的途径通过设置程序。</li>
</ol>
</li>
<li><p>进程间通信的几种方式？</p>
<ol>
<li><strong>管道（<code>pipe</code>）及命名管道（<code>named pipe</code>）</strong>：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</li>
<li><strong>信号（<code>signal</code>）</strong>：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列</strong>：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</li>
<li><strong>共享内存</strong>：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；</li>
<li><strong>信号量</strong>：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</li>
<li><strong>套接字</strong>：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</li>
</ol>
</li>
<li><p>线程的运行状态？</p>
<ol>
<li><p>新建-&gt;可运行状态-&gt;运行状态-&gt;阻塞状态-&gt;死亡状态。</p>
<p>阻塞状态分为：等待阻塞（<code>wait</code>），同步阻塞（多线程锁），其他阻塞。</p>
</li>
</ol>
</li>
<li><p><code>Wait（）</code>与<code>Sleep（）</code>方法的区别？</p>
<ol>
<li>来自不同的类，一个是<code>Thread</code>，一个是<code>Object</code>。</li>
<li><code>Wait</code>方法释放了锁，<code>Sleep</code>方法没有释放锁。</li>
</ol>
</li>
<li><p>什么是死锁，如何避免死锁？</p>
<ol>
<li>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。</li>
<li>打破四个必要条件<ol>
<li>循环等待</li>
<li>不剥夺</li>
<li>互斥</li>
<li>请求与保持</li>
</ol>
</li>
</ol>
</li>
<li><p>操作系统进程调度策略？</p>
<ol>
<li>**<code>FCFS</code>(先来先服务，队列实现，非抢占的)**：先请求<code>CPU</code>的进程先分配到<code>CPU</code></li>
<li>**SJF(最短作业优先调度算法)**：平均等待时间最短，但难以知道下一个<code>CPU</code>区间长度</li>
<li>**优先级调度算法(可以是抢占的，也可以是非抢占的)**：优先级越高越先分配到<code>CPU</code>，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待<code>CPU</code>，会导致无穷阻塞或饥饿；解决方案：老化</li>
<li>**时间片轮转调度算法(可抢占的)**：队列中没有进程被分配超过一个时间片的<code>CPU</code>时间，除非它是唯一可运行的进程。如果进程的<code>CPU</code>区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。</li>
<li><strong>多级队列调度算法</strong>：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。</li>
<li><strong>多级反馈队列调度算法</strong>：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多<code>CPU</code>时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</li>
</ol>
</li>
<li><p>页面置换算法？</p>
<ol>
<li><strong><code>FIFO</code>先进先出算法</strong>：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；</li>
<li><strong><code>LRU（Least recently use）</code>最近最少使用算法</strong>：根据使用时间到现在的长短来判断；</li>
<li><strong><code>LFU（Least frequently use）</code>最少使用次数算法</strong>：根据使用次数来判断；</li>
<li><strong><code>OPT（Optimal replacement）</code>最优置换算法</strong>：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。</li>
</ol>
</li>
<li><p><strong><code>Synchronized</code>关键字原理</strong>？</p>
<p><code>synchronized</code>关键字用于解决多线程之间访问资源的同步性，可以在实例方法、静态方法、代码块使用，在<code>JDK1.6</code>之前，<code>synchronized</code>是一种重量级锁，在1.6之后，<code>Java</code>对其进行了优化，引入了如自旋锁、适应性自旋锁、锁销除、锁粗化、偏向锁、轻量级锁等技术，减少锁操作的开销。<strong>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。</strong>他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<ol>
<li><p>详细的优化？</p>
<ol>
<li><p><strong>自旋锁</strong>：就是让该线程等待一段时间，不会被立即挂起（就是不让前来获取该锁（已被占用）的线程立即阻塞），看持有锁的线程是否会很快释放锁。</p>
</li>
<li><p><strong>适应自旋锁</strong>：线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p>
</li>
<li><p><strong>锁消除</strong>：为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，<code>JVM</code>检测到不可能存在共享数据竞争，这是<code>JVM</code>会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。 </p>
</li>
<li><p><strong>锁粗化</strong>：就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</p>
</li>
<li><p><strong>轻量级锁</strong>：轻量级锁在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的指向和状态。如果没有竞争，轻量级锁使用<code>CAS</code>操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了<code>CAS</code>操作，因此<strong>在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</strong></p>
</li>
<li><p><strong>偏向锁</strong>：偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。</p>
</li>
<li><p><strong>重量级锁</strong>：　重量级锁通过对象内部的监视器（<code>monitor</code>）实现，其中<code>monitor</code>的本质是依赖于底层操作系统的<code>Mutex Lock</code>实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>
</li>
<li><p>**<code>CAS</code>**？</p>
<p><code>compare and swap</code>,<code>CAS</code>操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。有三个参数<code>V</code>，<code>except,update</code>。</p>
<p><code>ABA</code>：使用<code>CAS</code>乐观锁会造成<code>ABA</code>的问题，什么<code>ABA</code>，简单来说，就是一个线程对数据进行了修改，然后又修改回原来的数据，此时，一个正在执行的线程在修改前和修改后取到了相同的数据。</p>
<p>什么方法避免<code>ABA</code>问题：</p>
<p>​    使用<code>AtomicStampReference</code>，版本戳来解决。</p>
</li>
<li><p><code>synchronized</code>作用于代码块和方法上的区别？</p>
<ol>
<li>简单来说就是粗粒度锁和细粒度多的区别，作用于代码块，被同步的方法一次只能有一个线程进入，其他线程等待，而作用于代码块，则会更加灵活，通过锁定对象。</li>
</ol>
</li>
<li><p><strong><code>synchronized</code>与<code>reentrantLock</code>的异同</strong>？</p>
</li>
<li><p>两者都是可重入锁。自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
</li>
<li><p><code>synchronized</code> 依赖于 <code>JVM</code> 而 <code>ReentrantLock</code> 依赖于 <code>API</code></p>
<p><code>synchronized</code> 是依赖于 <code>JVM</code> 实现的，前面我们也讲到了 虚拟机团队在 <code>JDK1.6</code> 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReentrantLock</code> 是 <code>JDK</code> 层面实现的（也就是 <code>API</code> 层面，需要 <code>lock() </code>和 <code>unlock()</code> 方法配合 <code>try/finally</code> 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
</li>
<li><p><strong><code>synchronized</code>底层原理</strong>？</p>
<p>通过Javap命令查看字节码相关文件可以看到，<code>synchronied</code>同步语句块实际上是使用了<code>monitorenter</code>和<code>monitorexit</code>指令。当线程获取锁之后，锁计数器会+1，当退出锁之后，锁计数器会-1.</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p><code>ReentrantLock</code>锁详解。</p>
<p><code>ReentrantLock</code>除了实现<code>synchronized</code>的功能外，还实现了额外的功能。</p>
<ol>
<li><p>公平锁</p>
<p>公平锁是指当锁可用时，在锁上等待时间最长的线程将获得锁的使用权，而非公平锁是随机分配这种使用权，默认情况下是非公平锁，在创建<code>ReentrantLock</code>的时候通过传入参数<code>true</code>来设置公平锁。虽然非公平锁的性能会更好，但是会导致饥饿的问题。</p>
</li>
<li><p>可响应中断</p>
<p>当使用<code>synchronized</code>实现锁时，如果造成死锁，在外界不干扰的情况下，将一直等待，而<code>ReentrantLock</code>可以实现响应中断。</p>
</li>
<li><p>获取锁时限时等待</p>
<p><code>ReentrantLock</code>还给我们提供了获取锁限时等待的方法<code>tryLock()</code>,可以选择传入时间参数,表示等待指定的时间,无参则表示立即返回锁申请的结果:<code>true</code>表示获取锁成功,<code>false</code>表示获取锁失败。我们可以使用该方法配合失败重试机制来更好的解决死锁问题。</p>
</li>
</ol>
<p><strong>结合<code>Condition</code>实现等待通知机制</strong></p>
<p>​    使用<code>synchronized</code>结合<code>Object</code>上的<code>wait</code>和<code>notify</code>方法可以实现线程间的等待通知机制，<code>ReentrantLock</code>结合<code>Condition</code>接口同样可以实现这个功能。而且相比前者使用起来更加清晰。<code>Condition</code>接口在使用前必须先调用<code>ReentrantLock</code>的<code>lock()</code>方法获得锁，之后调用<code>Condition</code>接口的<code>await()</code>将释放锁，并且在该<code>Condition</code>上等待，直到有其他线程调用<code>Condition</code>的<code>signal()</code>方法唤醒线程。</p>
<p><strong>使用<code>Condition</code>实现简单的阻塞队列</strong></p>
<p>入队和出队线程安全，当队列满时，入队线程会被阻塞，当队列为空时，出队线程会被阻塞。</p>
</li>
<li><p><code>Volatile</code>关键字<code>JMM</code>内存模型？</p>
<ol start="12">
<li><p><code>JMM</code>内存模型？</p>
<p><code>Java</code>内存模式是一种虚拟机规范。<code>Java</code>虚拟机规范中定义了<code>Java</code>内存模型（<code>Java Memory Model</code>，<code>JMM</code>），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让<code>Java</code>程序在各种平台下都能达到一致的并发效果，<code>JMM</code>规范了<code>Java</code>虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>
</li>
<li><p><code>Volatile</code>（原子性（不保证），可见性，顺序性）：线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。 <strong><code>volatile</code></strong> 关键字的主要作用就是保证变量的可见性（也就是当一个线程修改了一个被<code>volatile</code>修饰共享变量的值，新值总数可以被其他线程立即得知）然后还有一个作用是防止指令重排序。</p>
<ol>
<li><p><strong>内存屏障</strong>？</p>
<p>内存屏障，又称内存栅栏，是一个<code>CPU</code>指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性（利用该特性实现<code>volatile</code>的内存可见性）。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p><code>synchronized</code>与<code>volatile</code>之间的区别？</p>
<ol>
<li><strong><code>volatile</code>关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<code>volatile</code>性能肯定比<code>synchronized</code>关键字要好。但是**<code>volatile</code>关键字只能用于变量而<code>synchronized</code>关键字可以修饰方法以及代码块**。</li>
<li><strong>多线程访问<code>volatile</code>关键字不会发生阻塞，而<code>synchronized</code>关键字可能会发生阻塞</strong></li>
<li><strong><code>volatile</code>关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code>关键字两者都能保证。</strong>（例如两个线程同时i++，自增操作是多个原子性操作，还没有完成操作就阻塞了）</li>
<li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code>关键字解决的是多个线程之间访问资源的同步性。</strong></li>
</ol>
</li>
<li><p><strong><code>ThreadLocal</code> 面试题?</strong></p>
<p><code>ThreadLocal</code>是除了加锁这种同步方式之外的一种规避多线程访问同一变量造成线程不安全的方法,当我们在创建一个变量后,如果每个线程对其进行访问的时候都是自己的变量,这样就不会存在线程不安全的问题.</p>
<ol>
<li><p><code>ThreadLocal</code>实现原理:</p>
<p>Thread类中有两个变量<code>threadLocals</code>和<code>ingeritableThreadLocals</code>,两者都是<code>ThreadLocal</code>内部类<code>ThreadLocalMap</code>类型的变量.线程的本地变量不是存放在<code>ThreadLocal</code>的实例中,而是放在调用线程的<code>ThreadLocals</code>变量里面.也就是说,使用<code>set</code>赋值,是给自己线程里面的变量赋值而不是给实例赋值.</p>
</li>
<li><p><code>ThreadLocal</code>不支持继承</p>
<p>同一个<code>ThreadLocal</code>变量在父线程中被设置值后,在子线程中是获取不到的.</p>
</li>
<li><p><code>InheritableThreadLocal</code>实现子线程访问父线程.</p>
<p><code>InheritableThreadLocal</code>类继承了<code>ThreadLocal</code>类，并重写了<code>childValue</code>、<code>getMap</code>、<code>createMap</code>三个方法。其中<code>createMap</code>方法在被调用（当前线程调用<code>set</code>方法时得到的<code>map</code>为<code>null</code>的时候需要调用该方法）的时候，创建的是<code>inheritableThreadLocal</code>而不是<code>threadLocals</code>。同理，<code>getMap</code>方法在当前调用者线程调用<code>get</code>方法的时候返回的也不是<code>threadLocals</code>而是<code>inheritableThreadLocal</code>。</p>
</li>
<li><p><code>ThreadLocal</code>使用不当造成的内存泄漏</p>
<p>从源代码中可以知道,<code>ThreadLocalMap</code>是一个类似于<code>hashmap</code>的数据结构,而且其<code>key</code>的引用是弱引用,.当线程调用<code>ThreadLocal</code>的<code>set</code>方法设置变量的时候,当前线程的<code>ThreadLocalMap</code>就会存放着一个记录,这个记录的<code>key</code>值为<code>ThreadLocal</code>的弱引用,<code>value</code>通过<code>set</code>方法设置.接下去的情况就与弱引用的<code>weakhashMap</code>一样,当<code>key</code>值被<code>GC</code>回收的时候,<code>value</code>值还存在,从而造成内存的泄漏.</p>
</li>
</ol>
</li>
<li><p>多线程启动的三种方式，以及<code>Runnable</code>接口与<code>Callable</code>接口的区别？</p>
<ol>
<li><p>继承<code>Thread</code>类，新建一个当前类对象，并且运行其<code>start（）</code>方法。</p>
</li>
<li><p>实现<code>Runnable</code>接口，然后新建当前类对象，接着新建<code>Thread</code>对象时把当前类对象传进去，最后运行<code>Thread</code>对象的<code>start()</code>方法。</p>
</li>
<li><p>实现<code>Callable</code>接口，新建当前类对象，在新建<code>FutureTask</code>类对象时传入当前类对象，接着新建<code>Thread</code>类对象时传入<code>FutureTask</code>类对象，最后运行<code>Thread</code>对象的<code>start()</code>方法。</p>
</li>
<li><p><code>callable</code>提供了比<code>Runnable</code>更强大的功能。</p>
<p><strong>1.<code>Callable</code>可以在任务结束的时候提供一个返回值，<code>Runnable</code>无法提供这个功能</strong></p>
<p><strong>2.<code>Callable</code>的<code>call</code>方法分可以抛出异常，而<code>Runnable</code>的<code>run</code>方法不能抛出异常。</strong></p>
</li>
</ol>
</li>
<li><p><code>ThreadPoolExecutor</code> 7大参数  作用 流程</p>
</li>
</ol>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">            　　　　　　　　　　　<span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">　　　　　　　　　　　　　　　　　　ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">参数含义：</span><br><span class="line">    corePoolSize:		<span class="number">1</span>					线程池核心线程数             </span><br><span class="line">	maximumPoolSize:	Integer.Max_VALUE	线程池最大数                   </span><br><span class="line">	keepAliveTime:		60s					空闲线程存活时间</span><br><span class="line">	unit:				TimeUnit.SECONDS	时间单位</span><br><span class="line">	workQueue:			Integer.MAX_VALUE	线程池所使用的缓冲队列</span><br><span class="line">	threadFactory:							线程池创建线程使用的工厂</span><br><span class="line">	handler:			AbortPolicy()		线程池对拒绝任务的处理策略</span><br></pre></td></tr></table></figure>

线程池处理流程：

​            当线程数小于核心线程数时，创建线程。

​            当线程数大于等于核心线程数时，且任务队列未满，将任务放入到任务对列中。

​            当线程数大于等于核心线程数时，且任务队列已满

​                    若线程数小于最大线程数，则创建线程。

​                    若线程数等于最大线程数，抛出异常，拒绝任务。
</code></pre>
<ol start="16">
<li><p><code>Future</code> 机制</p>
<p><code>Future</code>表示异步计算的结果，<code>Future</code>接口提供了检查计算是否完成、检查计算是否被取消、等待计算完成并获取计算结果等方法。</p>
<p><code>Future</code>是一个接口，有多种实现方式，比较常见的一种是<code>FutureTask</code>，这个类继承了<code>RunnabelFuture</code>，然后<code>RunnabelFuture</code>又实现了<code>Future</code>接口。在成功执行<code>run()</code>方法就，可以通过<code>Future</code>访问执行结果，通过<code>get()</code>方法，当未执行完时，会进行阻塞，等待执行结束。</p>
</li>
<li><p>阻塞队列 <code>Queue</code> ，7 种阻塞队列， 消费者生产者模式</p>
<p>阻塞队列是一个支持两个附加操作的队列，在队列为空时，获取元素的线程会等待会裂变为非空，当队列满时，存储元素的线程会等待队列可用。</p>
<p>七种阻塞队列：</p>
</li>
</ol>
<pre><code>- ``ArrayBlockingQueue``：是一个用数组实现的有界阻塞队列，此队列按照先进先出（``FIFO``）的原则对元素进行排序。支持公平锁和非公平锁。【注：每一个线程在获取锁的时候可能都会排队等待，如果在等待时间上，先获取锁的线程的请求一定先被满足，那么这个锁就是公平的。反之，这个锁就是不公平的。公平的获取锁，也就是当前等待时间最长的线程先获取锁】
- ``LinkedBlockingQueue``：一个由链表结构组成的有界队列，此队列的长度为``Integer.MAX_VALUE``。此队列按照先进先出的顺序进行排序。
- ``PriorityBlockingQueue``： 一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现``compareTo()``方法来指定元素排序规则，不能保证同优先级元素的顺序。
- ``DelayQueue：`` 一个实现``PriorityBlockingQueue``实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。（``DelayQueue``可以运用在以下应用场景：1.缓存系统的设计：可以用``DelayQueue``保存缓存元素的有效期，使用一个线程循环查询``DelayQueue``，一旦能从``DelayQueue``中获取元素时，表示缓存有效期到了。2.定时任务调度。使用``DelayQueue``保存当天将会执行的任务和执行时间，一旦从``DelayQueue``中获取到任务就开始执行，从比如``TimerQueue``就是使用``DelayQueue``实现的。）
- ``SynchronousQueue：`` 一个不存储元素的阻塞队列，每一个``put``操作必须等待``take``操作，否则不能添加元素。支持公平锁和非公平锁。``SynchronousQueue``的一个使用场景是在线程池里。``Executors.newCachedThreadPool()``就使用了``SynchronousQueue``，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。
- ``LinkedTransferQueue：`` 一个由链表结构组成的无界阻塞队列，相当于其它队列，``LinkedTransferQueue``队列多了``transfer``和``tryTransfer``方法。
- ``LinkedBlockingDeque：`` 一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半。
</code></pre>
<ol start="18">
<li><p><code>AQS</code> (<strong><code>AbstractQueuedSynchronizer</code></strong>) 共享锁<code>CountDownLatch</code>，排他锁<code>ReentrantLock</code>。</p>
<p><code>AQS（AbstractQueuedSynchronizer）</code>抽象队列同步器，为线程的同步和等待操作提供一个基础模板类，即该类使用的时模板模式。通过子类继承该模板实现自己的功能即可，例如<code>CountDownLatch</code>和<code>ReentrantLock</code>。<code>AQS</code>中有两个重要的概念，<code>State</code>和<code>CLH</code>队列，<code>State</code>表示锁的状态，<code>CLH</code>表示线程的阻塞队列。其中<code>state</code>被<code>volatile</code>修饰，表证了内存的可见性。<code>CLH</code>队列是一个双向链表的数据结构。根据节点类型的不同可以实现上述的不同类型的锁。</p>
<ol>
<li>独占资源</li>
</ol>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-30-29.png" class="">


<h3 id="六：数据库"><a href="#六：数据库" class="headerlink" title="六：数据库"></a>六：数据库</h3><h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a><code>Mysql</code></h4><ol>
<li><p><strong><code>MyISAM</code>和<code>InnoDB</code>引擎的区别</strong>？</p>
<ol>
<li><code>MyISAM</code>是<code>MySQL</code>的默认数据库引擎（<code>5.5版</code>之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但<code>MyISAM</code>不支持事务机制和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。<code>5.5版本</code>之后，<code>MySQL</code>引入了<code>InnoDB</code>。大多数时候我们使用的都是 <code>InnoDB</code> 存储引擎，但是在某些情况下使用 <code>MyISAM</code> 也是合适的比如读密集的情况下。</li>
</ol>
</li>
<li><p><strong>索引？（重点）</strong></p>
<ol>
<li><p>为什么要使用索引，索引的缺点？</p>
<ol>
<li>通过创建唯一性索引，保证表中每一行数据的唯一性。</li>
<li>加快数据的检索速度。</li>
<li>将随机<code>IO</code>变成顺序<code>IO</code>。</li>
<li>帮助服务器避免排序。</li>
</ol>
<p><strong>缺点</strong>：占用物理空间，对标进行改动时，维护成本高。</p>
</li>
<li><p><strong><code>Mysql</code>中使用的是<code>B+Tree</code>索引，在<code>MYSIAM</code>和<code>InnoDB</code>索引的实现方式上有些区别？</strong></p>
<ol>
<li><code>MyISAM</code> ：使用的是非聚簇索引，<code>B+Tree</code>叶节点的<code>data</code>区域存放的是数据记录的地址，然后找到对应的地址读取数据记录。</li>
<li><code>InnoDB</code> :  使用的是聚簇索引，其数据文件本身就是索引文件，叶节点<code>data</code>域保存了完整的数据记录，这个索引的<code>key</code>是数据表的主键。</li>
</ol>
</li>
<li><p><strong><code>B+树</code>比<code>B树</code>的好处</strong></p>
<ol>
<li><code>B+树</code>的数据都存储在叶子节点，而<code>B树</code>存储在各层节点中，利用上下文局部性的原理查询效率高。</li>
<li><code>B+树</code>比<code>B树</code>矮，<code>IO</code>更少。</li>
<li><code>B+树</code>的叶子节点之间有索引，有利于数据库的扫描。</li>
</ol>
</li>
<li><p>索引的类型？</p>
<ol>
<li>种类：<ol>
<li>聚簇索引：叶子节点存储的是数据行。</li>
<li>非聚簇索引：叶子节点存储的是数据行的地址。<ol>
<li>回表操作：指在非聚簇索引中找到了目标数据的地址，然后在根据地址去查询其他索引。</li>
<li>索引覆盖：将查询的字段联合索引里面去。</li>
</ol>
</li>
<li><code>UNIQUE</code>唯一性索引。</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>索引的优化</strong>？（重要）</p>
<ol>
<li>索引失效情况：<ol>
<li>范围查询的列之后还有查询条件。</li>
<li>对列进行了运算操作。</li>
<li>字符串没有加  <code>‘ ’</code> ；</li>
</ol>
</li>
<li>尽量使用覆盖索引，避免使用<code>select *</code>；需要回表查询。</li>
<li>对于<code>or</code>语句分割的条件，如果<code>or</code>前的条件中的列有索引，中间是<code>or</code>进行连接的是不走索引的。</li>
<li>模糊匹配，<code>%</code> 加在 条件之前，会造成索引失效，可以通过覆盖索引来解决。</li>
<li>尽量使用符合索引，减少使用单列索引。</li>
</ol>
</li>
</ol>
</li>
<li><p>事务？四大特性？（重点）</p>
<ol>
<li><code>原子性A</code>：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><code>一致性C</code>： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><code>隔离性I</code>： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><code>持久性D</code>：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<p><strong>原子性实现原理</strong>：<code>undo log</code></p>
<p>​        实现原子性的关键在于<code>undo log</code>日志。当事务回滚时能够撤销所有已经成功执行的<code>sql</code>语句，当事务对数据库进行修改时，<code>InnoDB</code>会生成对应的<code>undo log</code>，与操作相反的语句。<code>undo log</code>属于逻辑日志。</p>
<p><strong>持久性实现原理</strong>：<code>redo log</code></p>
<p>​        当数据修改时，除了修改<code>buffer</code>中的数据，还会生成<code>redo log</code>日志记录，当事务提交时，会调用<code>fsync</code>接口对<code>redo log</code>进型更新。当数据库宕机重启时，读取<code>redo log</code>中的数据，对数据库进行恢复操作。</p>
<p>​        除了<code>redo log</code>还有一个<code>bin log</code>，也可以用来记录操作信息，<code>bin log</code>是二进制日志，存储二进制的信息，也是用来主从复制的关键。</p>
<p><strong>隔离性实现原理</strong>：</p>
<p>​与第4点隔离机制一样。</p>
<p>​<code>MVCC</code>多版本并发控制协议实现原理：</p>
<p>​<code>MVCC</code>最大的优点是读不加锁，并发性能好，主要是通过以下技术和数据结构：</p>
<p>​    1. 隐藏列：<code>Innodb</code>中每行数据都有隐藏列，存储着本行数据的事务<code>id</code>，指向<code>undo log</code>的指针等信息。</p>
<p>​    2. 基于<code>undo log</code>的版本链：每条<code>undo log</code>也会指向更早版本的<code>undo log</code>，从而形成一条版本链。</p>
<p>​    3. <code>ReadView</code>：通过隐藏列和版本链，<code>Mysql</code>可以将数据恢复到指定的版本，具体恢复到哪个版本就是通过<code>ReadView</code>（事务系统快照）来确定。事务进行读操作的时候，会将读取到事务<code>ID</code>与快照找的信息进行比较，从而判断数据对该<code>ReadView</code>是否可见。</p>
</li>
<li><p><strong>事务隔离机制</strong>,以及脏读\不可重复读\幻读的区别？</p>
<ol>
<li><p>数据出现的错误情况:</p>
<p>​    脏读:    指一个事务修改了数据还没有提交,另一个线程来读取了修改后未提交的数据,导致数据不是真实的.</p>
<p>​    不可重复读:    指一个事务还没有结束,另一个事务读取并修改了数据,导致,当前事务的数据不一致.</p>
<p>​    幻读:    指一个事务执行操作的时候(有关全表数据的操作),另一个事务进行了操作,这种操作可能是<code>增加/删除</code>等,导致第一个事务发现数据表中出现了没有修改的数据行,就像发生了幻觉一样.</p>
</li>
<li><p><strong>隔离机制</strong></p>
<ol>
<li><strong><code>READ-UNCOMMITTED</code>(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong><code>READ-COMMITTED</code>(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong><code>REPEATABLE-READ</code>(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改,通过MVCC版本控制实现，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。(Mysql的隔离机制)</li>
<li><strong><code>SERIALIZABLE</code>(可串行化)：</strong> 最高的隔离级别，完全服从<code>ACID</code>的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ol>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td><code>READ-UNCOMMITTED</code></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td><code>READ-COMMITTED</code></td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td><code>REPEATABLE-READ</code></td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td><code>SERIALIZABLE</code></td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
</li>
<li><p><strong>如何解决幻读</strong>?</p>
<p><code>Mysql</code>在<code>RR</code>级别下确实解决了幻读,但是有两种情况.</p>
<ol>
<li>在快照读的情况下,<code>MySQL</code>通过<code>MVCC</code>来避免.</li>
<li>在当前读的情况下,<code>Mysql</code>通过间隙锁+ 行锁实现.</li>
</ol>
<p>此外,通过序列化的隔离机制也可以解决幻读.</p>
</li>
</ol>
</li>
<li><p><code>Mysql</code>中的锁机制与<code>InnoDB</code>锁算法？</p>
<p><strong><code>MyISAM</code>和<code>InnoDB</code>存储引擎使用的锁：</strong></p>
<ol>
<li><code>MyISAM</code>采用表级锁(<code>table-level locking</code>)。</li>
<li>InnoDB支持行级锁(<code>row-level locking</code>)和表级锁,默认为行级锁.</li>
</ol>
</li>
<li><p>冷热数据分离？</p>
<ol>
<li>设计分库：比如有一个订单表，日均写入几万几十万数据进去，存储数据的时候存储双份，<code>order</code>表存一份数据，<code>order_history</code>表同样也存一份数据，然后，<code>order</code>表设置一个定时任务，每天定期删除30天以上的数据，<code>order_history</code>表不做任何删除操作，只插入新的数据，保留最原始的数据。</li>
<li>优化？<ol>
<li>限定数据的范围。</li>
<li>读/写分离。</li>
</ol>
</li>
</ol>
</li>
<li><p><code>sql</code>优化</p>
<ol>
<li>对于查询的<code>sql</code>语句优化：<ol>
<li>查看<code>sql</code>语句执行频次，通过命令<code>show status like</code>；</li>
<li>定位低效率执行的<code>sql</code>，有两种方式，根据需求不同，选择不同。<ol>
<li>通过慢查询日志。</li>
<li><code>show processlist</code>；命令，查看实时执行时间。</li>
</ol>
</li>
<li>   通过<code>explain</code>命令，查看<code>Extra</code>字段，如果存在<code>Using File Sort</code>，或者<code>Using temporary</code>字段，则需要进行优化。</li>
</ol>
</li>
<li> 对于大量数据插入的<code>sql</code>语句优化<code>load</code>命令：</li>
<li>尽量使用主键顺序插入。</li>
<li>关闭唯一性校验。</li>
<li>手动提交事务。</li>
<li>对于<code>insert</code>语句的优化：<ol>
<li>将多次插入改为一条语句，或者将事务提交改为手动提交。</li>
</ol>
</li>
<li>对于<code>order by</code>语句的优化：<ol>
<li>两种排序模式，<code>Using FileSort，Using index</code>。<ol>
<li>对于<code>USing fileSort</code>排序有两种实现方式，一次扫描排序，两次扫扫描排序，对于使用哪种算法，会根据一些字段来比较。</li>
</ol>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
<li><p>解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?</p>
<p>我们常见的如<code>java</code>线程池、<code>jdbc</code>连接池、<code>redis</code>连接池等就是这类设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。就好比你去食堂打饭，打饭的大妈会先把饭盛好几份放那里，你来了就直接拿着饭盒加菜即可，不用再临时又盛饭又打菜，效率就高了。</p>
</li>
</ol>
<h4 id="Postgres"><a href="#Postgres" class="headerlink" title="Postgres"></a><code>Postgres</code></h4><ol>
<li>与<code>Mysql</code>相比，优势何在？<ol>
<li><code>Mysql</code>使用多线程，<code>Postgresql</code>使用多进程。</li>
<li><code>PG</code>的稳定新极强，在高并发读写，负载极限的情况下，<code>PG</code>还能稳定速率不下降。</li>
<li>数据同步方式不同，<code>MySQL</code>时异步同步的方式，而且是基于<code>binlog</code>的逻辑复制，<code>pg</code>可以实现同步复制、异步复制、半同步复制，而且基于<code>wal</code>复制。</li>
<li><code>PG</code>是志愿者在维护，<code>Mysql</code>是商业公司在维护。</li>
</ol>
</li>
</ol>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><code>Redis</code></h4><ol>
<li><p><strong><code>CAP？Nosql</code>中的特性</strong>。</p>
<ol>
<li>C： <code>Consistency</code> （一致性）：即访问所有的节点得到的数据应该是一样的。</li>
<li>A： <code>Availability </code>（可用性）：所有的节点都保持高可用性。</li>
<li>P： <code>Partition Tolerance</code> （分区容错性）：这里指网络意义的分区，在节点不能通信的时，要保证系统可以继续正常服务。</li>
</ol>
<p>一个分布式系统，不可能同时满足<code>C、A、P</code>这３个条件。</p>
</li>
<li><p>为什么要用<code>redis</code>做缓存？</p>
<ol>
<li>高性能：<code>redis</code>运行于内存中，相比于传统的运行于磁盘的数据库非常的高效。</li>
<li>高并发：直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</li>
</ol>
<p>优点：</p>
<ol>
<li>读写性能优异， <code>Redis</code>能读的速度是110000次/s，写的速度是81000次/s。</li>
<li>支持数据持久化，支持<code>AOF</code>和<code>RDB</code>两种持久化方式。</li>
<li>支持事务，<code>Redis</code>的所有操作都是原子性的，同时<code>Redis</code>还支持对几个操作合并后的原子性执 行。</li>
<li>数据结构丰富，除了支持<code>string</code>类型的<code>value</code>外还支持<code>hash、set、zset、list</code>等数据结构。</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ol>
<p>缺点：</p>
<ol>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此<code>Redis</code>适合的场景主 要局限在较小数据量的高性能操作和运算上。</li>
<li><code>Redis</code> 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要 等待机器重启或者手动切换前端的<code>IP</code>才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换<code>IP</code>后还会引入数据不一致的问题， 降低了系统的可用性。</li>
<li><code>Redis</code> 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问 题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ol>
</li>
<li><p><code>redis</code>应用场景</p>
<ol>
<li>计数器</li>
<li>缓存</li>
<li>会话缓存</li>
<li>全页缓存（<code>FPC</code>）</li>
<li>查找表</li>
</ol>
</li>
<li><p>为什么要用<code>redis</code>而不用<code>map/guava</code>做缓存呢？</p>
<p>缓存分为本地缓存和分布式缓存。以<code>Java</code>为例，使用自带的 <code>map</code> 或者 <code>guava</code> 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 <code>jvm</code> 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。使用 <code>redis</code> 或 <code>memcached</code> 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 <code>redis</code> 或 <code>memcached</code>服务的高可用，整个程序架构上较为复杂。</p>
</li>
<li><p><code>redis</code>常见的数据结构？</p>
<ol>
<li><p><code>String</code>：<code>String</code>数据结构是简单的<code>key-value</code>类型，<code>value</code>其实不仅可以是<code>String</code>，也可以是数字。 常规<code>key-value</code>缓存应用； 常规计数：<code>微博数，粉丝数</code>等。</p>
</li>
<li><p><code>Hash：hash</code> 是一个 <code>string</code> 类型的 <code>field</code> 和 <code>value</code> 的映射表，<code>hash</code> 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 <code>hash</code> 数据结构来存储<code>用户信息，商品信息</code>等等。</p>
</li>
<li><p><code>List</code>：<code>list</code> 就是链表，<code>Redis</code> <code>list</code> 的应用场景非常多，也是<code>Redis</code>最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用<code>Redis</code>的 <code>list</code> 结构来实现。</p>
<p><code>Redis</code> <code>list</code> 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p>另外可以通过 <code>lrange</code> 命令，就是从某个元素开始读取多少个元素，可以基于 <code>list</code> 实现分页查询，这个很棒的一个功能，基于 <code>redis</code> 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p>
</li>
<li><p><code>Set</code>：<code>set</code> 对外提供的功能与<code>list</code>类似是一个列表的功能，特殊之处在于 <code>set</code> 是可以自动排重的。</p>
<p>当你需要存储一个列表数据，又不希望出现重复数据时，<code>set</code>是一个很好的选择，并且<code>set</code>提供了判断某个成员是否在一个<code>set</code>集合内的重要接口，这个也是<code>list</code>所不能提供的。可以基于 <code>set</code> 轻易实现交集、并集、差集的操作。</p>
<p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。<code>Redis</code>可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。</p>
</li>
<li><p><code>Sort Set</code>：和<code>set</code>相比，<code>sorted set</code>增加了一个权重参数<code>score</code>，使得集合中的元素能够按<code>score</code>进行有序排列。</p>
<p>原理：使用字典（<code>dict</code>）+跳表（<code>skiplist</code>)，当数据比较少的时候用<code>ziplist</code>编码结构存储。</p>
</li>
</ol>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-31-08.png" class="">

<pre><code>  ​    ``ziplist``编码的Zset使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个节点爆粗你``score``。``ziplist``内的集合元素按``score``从小到大排序。

  跳跃表十一总有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。
</code></pre>
<ol start="6">
<li><p><code>redis</code>设置过期时间</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">redis<span class="operator">&gt;</span> <span class="keyword">SET</span> cache_page &quot;www.google.com&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis<span class="operator">&gt;</span> EXPIRE cache_page <span class="number">30</span>  # 设置过期时间为 <span class="number">30</span> 秒</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"></span><br><span class="line">redis<span class="operator">&gt;</span> TTL cache_page    # 查看剩余生存时间</span><br><span class="line">(<span class="type">integer</span>) <span class="number">23</span></span><br><span class="line"></span><br><span class="line">redis<span class="operator">&gt;</span> EXPIRE cache_page <span class="number">30000</span>   # 更新过期时间</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"></span><br><span class="line">redis<span class="operator">&gt;</span> TTL cache_page</span><br><span class="line">(<span class="type">integer</span>) <span class="number">29996</span></span><br></pre></td></tr></table></figure>

<ol>
<li>定期删除：<code>redis</code>默认是每隔 <code>100ms</code> 就<strong>随机抽取</strong>一些设置了过期时间的<code>key</code>，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 <code>redis</code> 存了几十万个 <code>key</code> ，每隔100ms就遍历所有的设置过期时间的 <code>key</code> 的话，就会给 <code>CPU</code> 带来很大的负载！</li>
<li>惰性删除：定期删除可能会导致很多过期 <code>key</code> 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 <code>key</code>，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 <code>key</code>，才会被<code>redis</code>给删除掉。这就是所谓的惰性删除！</li>
<li>定时删除：超过设置时间的数据就会立马删除，占用<code>cpu</code>资源。</li>
</ol>
</li>
<li><p><code>redis</code>内存淘汰机制，当内存不够时进行的操作。</p>
<ol>
<li>检测易失数据：<ol>
<li><code>volatile-lru</code>：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li>
<li><code>volatile-ttl</code>：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li>
<li><code>volatile-random</code>：从已设置过期时间的数据集中随机选择数据淘汰。</li>
<li><code>vlotile-lfu</code>：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。</li>
</ol>
</li>
<li>检测全库数据：<ol>
<li><code>allkeys-lru</code>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</li>
<li><code>allkeys-random</code>：从数据集中任意选择数据淘汰。</li>
<li><code>allkeys-lfu</code>：当内存不足以容纳新写入数据时，在键空间中，一处最不经常使用的key。</li>
</ol>
</li>
<li><code>n o-eviction</code>：静止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ol>
</li>
<li><p><code>redis</code>持久化机制。</p>
<ol>
<li>快照（<code>RDB</code>）：<code>Redis</code>可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。<code>Redis</code>创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（<code>Redis</code>主从结构，主要用来提高<code>Redis</code>性能），还可以将快照留在原地以便重启服务器的时候使用。<ol>
<li>通过<code>save</code>指令保存<code>rdb</code>文件，但是会占用线程，阻塞。</li>
<li>通过<code>bgsave</code>指令进行后端保存，不占用线程。<ol>
<li><code>bgsave</code>发送指令后，返回消息，然后调用fork函数生成子进程，通过子进程创建<code>rdb</code>文件。</li>
</ol>
</li>
<li>自动执行，配置文件。<ol>
<li>在<code>conf</code>文件中，命令 <code>save 60 10000</code>，在<code>60</code>秒内有<code>10000</code>个操作就进行</li>
</ol>
</li>
</ol>
</li>
<li>追加文件（<code>AOF</code>）：与快照持久化相比，<code>AOF</code>持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下<code>Redis</code>没有开启<code>AOF</code>（<code>append only file</code>）方式的持久化，可以通过<code>appendonly</code>参数开启。将指令先加到缓存中。<ol>
<li>写数据三种策略（<code>appendfsync</code>）。<ol>
<li><code>always</code>每次，不建议使用。</li>
<li><code>everysecond</code>每秒，默认配置。</li>
<li><code>no</code>系统控制，有系统控制，不可控。</li>
</ol>
</li>
<li><code>AOF</code>重写<ol>
<li>规则：对于进程内已经超时的数据不在写入文件；忽略无效指令，合并<code>set</code>指令。</li>
<li>调用<code>bgrewriteaof</code>指令。与<code>bgsave</code>指令一样时<code>fork</code>一个子进程进行重写。</li>
<li>自动调用，通过配置文件设置，参数，</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p> 数据库与缓存一致性问题。</p>
</li>
</ol>
<p>   提供了两种解决方法，结合业务和技术代价选择使用。</p>
<ol>
<li><p>采用延时双删策略</p>
<p>在写库前后都进行<code>redis.del(key)</code>操作，并且设置合理的超时时间。</p>
</li>
<li><p>异步更新缓存</p>
<p>基于订阅<code>bin log</code>日志的同步机制，增删改对<code>MySQL</code>进行操作之后，通过<code>bin log</code>分析，利用消息队列推送至各台的<code>redis</code>缓存数据。 </p>
</li>
<li><p><code>redis</code>事务？</p>
</li>
</ol>
<p>   <code>redis</code>具有原子性，一致性，隔离性，并且放<code>redis</code>运行在某种特定的持久化模式下，也就有持久性。</p>
<ol start="11">
<li><p>缓存雪崩和缓存击穿？</p>
</li>
<li><p>主从复制</p>
<ol>
<li><p>什么是主从复制？</p>
<p>主从复制是用于读写分离的一种实现，将数据操作的读写用到不同的<code>redis</code>服务器上，一般的是<code>master</code>主机用于写，<code>slave</code>从机用于读数据。有效的提高<code>redis</code>服务器的性能。</p>
</li>
<li><p>主从复制的流程：</p>
<ol>
<li>首先是<code>slave</code>服务器向<code>master</code>服务器发起连接请求，告诉<code>master</code>有一个<code>slave</code>需要连接，<code>master</code>接收到后，将<code>id</code>和指令缓冲队列的<code>offset</code>发送给<code>slave</code>。建立一个<code>socket</code>连接。</li>
<li>之后<code>slave</code>开始<code>rdb</code>数据的复制。全量复制。</li>
<li>全量复制结束之后，通过判断<code>offset</code>的值是否相等，如果相等则开始局部复制，而这个复制的是命令缓冲队列里面的命令，到<code>slave</code>上在执行命令。</li>
</ol>
</li>
<li><p>心跳机制：</p>
<ol>
<li>为了保证集群的高可用，<code>master</code>与<code>slave</code>之间通过<code>ping</code>命令来相互访问，确定<code>master</code>节点和<code>slave</code>节点还存活。</li>
</ol>
</li>
</ol>
</li>
<li><p>哨兵机制</p>
<ol>
<li>哨兵机制用于监督集群的运行状态，若<code>master</code>服务器宕机了，通过哨兵会发起一个选举机制，一般哨兵的数量是奇数个，当有<code>n/2+1</code>个哨兵检测到<code>master</code>节点宕机，则开始重新选举<code>master</code>。</li>
</ol>
</li>
<li><p> 缓存雪崩：缓存同一时间大面积的失效，请求直接落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
</li>
<li><p>缓存击穿：同一时间，大量的连接访问同一个<code>key</code>，这个<code>key</code>在<code>mysql</code>数据库上，这样就会造成缓存的击穿。</p>
<pre><code>1. 对于缓存的击穿的解决有两类方式，通过道和术。
</code></pre>
</li>
<li><p> 缓存穿透：<code>key</code>对应的数据在数据源并不存在，每次针对此<code>key</code>的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>
</li>
<li><p>布隆过滤器？</p>
<p>   布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在与海量数据中。我们需要的就是判断 <code>key</code> 是否合法，把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，我会先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>​    <strong>原理:</strong></p>
</li>
</ol>
<img data-src="/blog/posts/a5258aa2/2022-02-16-00-31-22.png" class="">

<pre><code>​    布隆过滤器的核心是实现一个超大位数组和几个哈希函数.假设为数组的长度为``m``,哈希函数的个数为``k``.具体操作流程如下:

​        &gt; 将数组进行初始化,每个位置设置为``0``.

​        &gt; 对于集合中的每一个元素,将元素依次通过``k``个哈希函数映射.每次映射都会长生一个哈希值,这个值对应位数组上面的一个点,并    将该点编注为1.

​        &gt; 查询``W``元素是否存在集合中的时候,将``W``一次通过``k``个哈希函数的计算,如果k个点有一个不为1,那么该元素一定不在集合中.

​        &gt; 存在误判率,假设``w``经过``k``个哈希函数映射出来的值并不是来自一个已存在的映射,就是误判.
</code></pre>
<ol start="15">
<li><p>如何解决<code>redis</code>的并发竞争<code>Key</code>问题？</p>
<p>同一时间，多个请求需要堆同一个<code>key</code>值处理，不同的处理顺序结果也不相同,可用的处理结果如下.</p>
<ol>
<li>可以通过分布式锁(<code>redis</code>自身的分布式锁或者<code>Zookeeper</code>)+时间戳来实现。</li>
<li>利用消息队列,将请求进行串行化.</li>
</ol>
</li>
</ol>
<h3 id="七：消息队列"><a href="#七：消息队列" class="headerlink" title="七：消息队列"></a>七：消息队列</h3><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a><code>Kafka</code></h4><p>​    <code>Kafka</code>是一个分布式的，基于发布/订阅模式的消息队列。</p>
<ol>
<li><p>应用场景：</p>
<ol>
<li>缓冲和削峰:有过多数据时,把消息暂存于<code>kafka</code>中,达到一个缓冲的作用.</li>
<li>解耦于扩展性:解耦重要的业务流程.</li>
<li>冗余:可以采用一对多的方式,一个生产者发布消息,可以被多个订阅的<code>topic</code>的服务消费到,供多个毫无关联的业务使用.</li>
<li>健壮性:即使业务端短时间挂机,消息队列中的消息不会丢失.</li>
<li>异步通信:用户不想也不需要立即处理的消息,将其放入<code>kafka</code>中,等到需要处理的时候在处理.</li>
</ol>
</li>
<li><p><code>kafka</code>消息丢失与重复消费?</p>
<ol>
<li><p>保证消息不丢失？</p>
<ol>
<li><p>生产者丢失消息的情况。</p>
<p>消息可能因为网路问题没有发送出去，所以在<code>send</code>方法之后，不能确定消息是否发送成功。可以添加回调函数的形式，如果消息发送失败，就检查失败的原因，重新发送。‘</p>
</li>
<li><p>消费者丢失的情况。</p>
<p>消息被加到<code>Partition</code>时，会分配一个偏移量，当消费者拉取到分区的消息之后，消费者会自动提交<code>offset</code>，加入此刻，突然挂机，消息还没有被消费，而<code>offset</code>已经提交，造成数据丢失的情况。若关闭自动提交，则在消费完消息后突然挂机，则会重复消费。</p>
</li>
<li><p><code>Kafka</code>丢失消息。</p>
<p>分区的副本有很多，有<code>leader</code>和<code>follower</code>，而倘若<code>leader</code>突然挂机，<code>follower</code>副本还没有完成全部消息的复制，则就会造成消息的丢失。</p>
</li>
</ol>
</li>
<li><p>调优<code>broker</code>参数防止消息丢失。</p>
</li>
</ol>
</li>
<li><p><code>lsr</code>?</p>
<blockquote>
<p><code>producer 的deliver guarantee</code> 可以通过<code>request.required.acks</code>参数的设置来进行调整：</p>
<p><code>0</code> ，相当于异步发送，消息发送完毕即<code>offset</code>增加，继续生产；相当于<code>At most once</code><br><code>1</code>，<code>leader</code>收到<code>leader replica</code> 对一个消息的接受<code>ack</code>才增加<code>offset</code>，然后继续生产；<br><code>-1</code>，<code>leader</code>收到所有<code>replica</code> 对一个消息的接受<code>ack</code>才增加<code>offset</code>，然后继续生产</p>
</blockquote>
<p><code>Kafka</code>结合同步复制和异步复制，使用<code>ISR</code>（与<code>Partition</code> <code>Leader</code>保持同步的<code>Replica</code>列表）的方式在确保数据不丢失和吞吐率之间做了平衡。<code>Producer</code>只需把消息发送到<code>Partition</code> <code>Leader</code>，<code>Leader</code>将消息写入本地<code>Log。Follower</code>则从<code>Leader pull</code>数据。<code>Follower</code>在收到该消息向<code>Leader</code>发送<code>ACK</code>。一旦<code>Leader</code>收到了<code>ISR</code>中所有<code>Replica</code>的<code>ACK</code>，该消息就被认为已经<code>commit</code>了，<code>Leader</code>将增加<code>HW（high watermark</code>，最后 <code>commit</code> 的 <code>offset</code>）并且向<code>Producer</code>发送ACK。这样如果<code>leader</code>挂了，只要<code>Isr</code>中有一个<code>replica</code>存活，就不会丢数据。</p>
</li>
<li><p>解释<code>Kafka</code>的<code>Zookeeper</code>是什么?我们可以在没有<code>Zookeeper</code>的情况下使用Kafka吗?</p>
<p><code>Zookeeper</code>是一个开放源码的、高性能的协调服务，它用于<code>Kafka</code>的分布式应用。<br>不，不可能越过<code>Zookeeper</code>，直接联系<code>Kafka broker</code>。一旦<code>Zookeeper</code>停止工作，它就不能服务客户端请求。<br><code>Zookeeper</code>主要用于在集群中不同节点之间进行通信<br>在<code>Kafka</code>中，它被用于提交偏移量，因此如果节点在任何情况下都失败了，它都可以从之前提交的偏移量中获取<br>除此之外，它还执行其他活动，如: <code>leader</code>检测、分布式同步、配置管理、识别新节点何时离开或连接、集群、节点实时状态等等</p>
</li>
</ol>
<h3 id="八：Elasticsearch-ELK"><a href="#八：Elasticsearch-ELK" class="headerlink" title="八：Elasticsearch+ELK"></a>八：<code>Elasticsearch+ELK</code></h3><ol>
<li><p><strong><code>Elasticsearch</code>是什么</strong>？</p>
<p><code>ES</code>是一个基于分布式的，近实时的，具有<code>RestFul</code>风格的企业级搜索引擎。</p>
</li>
<li><p>倒排索引？</p>
<p>倒排索引是<code>ES</code>搜索引擎的核心，也是<code>ES</code>搜索速度快的原因。倒排索引是一种像散列图的数据结构，传统的检索是通过文章逐个遍历找到对应的关键词，而倒排索引是通过分词策略，形成词与文章的映射关系表，这个词+映射表的模式就是倒排索引。我们可以通过<code>term</code>字典，找到对应的<code>docid</code>，在通过相应的得分计算，获得权重进行排序。s</p>
</li>
<li><p><code>es</code>数据写入与数据读取的过程，数据搜索的过程？</p>
<ol>
<li>数据写入：客户端将请求发送到协调节点，再由协调节点发送到对应的<code>node</code>节点，<code>node</code>节点处理请求后，将数据通过到分片，处理完后，将响应结果返回给客户端。</li>
<li>数据读取：同理，客户端发送请求到协调节点，协调节点在路由至对应的节点上，此时，数据的读取可以是分片也可以是主节点上的数据，请求负载均衡，然后将结果返回给客户端。</li>
<li>数据搜索：客户端发送请求到协调节点，协调节点将搜索请求转发到所有的<code>shard</code>对应的<code>primary shard</code>和<code>replica shard</code>。每个<code>shard</code>将自己的搜索结果返回给协调节点，再由协调节点进行数据的合并、排序、分页等操作，最后产生结果。</li>
</ol>
</li>
<li><p><code>es</code>数据删除和更新过程？</p>
<ol>
<li>磁盘上的每个段都有一个相应的<code>.del</code> 文件。当删除请求发送后，文档并没有真的被删除，而是在<code>.del</code> 文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在<code>.del</code> 文件中被标记为删除的文档将不会被写入新段。</li>
<li>在新的文档被创建时，<code>Elasticsearch</code> 会为该文档指定一个版本号，当执行更新时，旧版本的文档在<code>.del</code> 文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</li>
</ol>
</li>
<li><p><code>es</code>的<code>master</code>选举过程，如何解决脑裂问题？</p>
<ol>
<li>发起选举的时间点是集群初始化启动、<code>Master</code>节点奔溃或者是<code>Master</code>节点没有得到<code>n/2+1</code>节点的认可。</li>
<li>第一步，通过<code>ping</code>，获取存活的<code>Master</code>节点，筛选<code>activeMasters</code>，并不包括本地节点。筛选<code>masterCandidates</code>列表，是当前集群有资格成为<code>Master</code>的节点。</li>
<li>第二步，判断<code>activeMaster</code>列表是否为空，如果不为空，则从<code>active Master</code>种选举，如果为空，则从<code>MasterCandidate</code>种选举。</li>
<li>第三步：上述两种情况中的任何一种产生的<code>Master</code>，如果是本地节点，则等待集群的其他成员投票，超过<code>n/2+1</code>则称为<code>master</code>，若果不是本地节点，则向<code>Master</code>节点申请加入集群的请求。</li>
<li>避免脑裂，需要得到<code>n/2+1</code>上的票才可以成为<code>Master</code>，如果只剩两节点集群，则集群就挂了。</li>
</ol>
</li>
<li><p><code>es</code>在数据量很大的时候如何提高性能？</p>
<ol>
<li>写优化：处理大量数据写入的时候<ol>
<li>批量提交，<code>bulk API</code></li>
<li>优化存储设备</li>
<li>合理使用合并，提高段合并速度</li>
<li>减少<code>Refresh</code>使用的次数</li>
<li>减少副本的数量</li>
</ol>
</li>
<li>读优化，适用于读取大量数据的情况<ol>
<li>使用<code>Scroll</code>：将分页查询的数据一次性读取，减少查询和排序的次数。</li>
<li>选择合适的路由，避免查询所有的分片。</li>
<li>定期删除：删除<code>.del</code>文件。</li>
<li>设置堆大小，初始堆内存太小。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="九：框架"><a href="#九：框架" class="headerlink" title="九：框架"></a>九：框架</h3><h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><code>Spring</code></h4><ol>
<li><p>什么是<code>Spring</code>框架?</p>
<ol>
<li><code>Spring</code>是一种轻量级开发框架，用于提高开发人员的开发效率以及系统的可维护性。我们一般说 <code>Spring</code> 框架指的都是 <code>Spring Framework</code>，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。</li>
</ol>
</li>
<li><p><code>Spring</code>有哪些模块？</p>
<ol>
<li><strong><code>Spring Core</code>：</strong> 基础,可以说 <code>Spring</code> 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。</li>
<li><strong><code>Spring Aspects</code></strong> ： 该模块为与<code>AspectJ</code>的集成提供支持。</li>
<li><strong><code>Spring AOP</code></strong> ：提供了面向切面的编程实现。</li>
<li><strong><code>Spring JDBC</code></strong> : <code>Java</code>数据库连接。</li>
<li><strong><code>Spring JMS</code></strong> ：<code>Java</code>消息服务。</li>
<li><strong><code>Spring ORM</code></strong> : 用于支持<code>Hibernate</code>等<code>ORM</code>工具。</li>
<li><strong><code>Spring Web</code></strong> : 为创建<code>Web</code>应用程序提供支持。</li>
<li><strong><code>Spring Test</code></strong> : 提供了对 <code>JUnit</code> 和 <code>TestNG</code> 测试的支持。</li>
</ol>
</li>
<li><p>@<code>RestController</code>与@<code>Controller</code>的区别？</p>
<p>@<code>RestController=@ResponseBody+@Controller</code>。使用<code>@Controller</code>返回的是<code>jsp</code>或者<code>html</code>页面，如果在方法前加上<code>@ResponseBody</code>则返回的是<code>json</code>或者<code>xml</code>数据。</p>
</li>
<li><p><code>Spring IOC</code>与<code>AOP</code>？</p>
<ol>
<li><code>IOC：IOC</code>是一中设计思想，就是将原本在程序中需要手动创建对象的控制权，交由<code>Spring</code>框架管理，并由<code>IoC</code>容器完成对象的注入。<code>IoC</code>的实现有两种方式，一：配置<code>XML</code>文件来注入到<code>Bean</code>中，二：通过注解配置的模式完成注入。</li>
<li><code>AOP</code>：面向切面编程，将那些与业务无关的，却为业务模块所共同调用代码封装起来，例如：日志管理，权限管理等。这样有利于减少系统的重复代码，降低模块之间的耦合度。<code>AOP</code>实现的关键在于代理模式，<code>AOP</code>代理主要分为静态代理和动态代理，静态代理以<code>AspectJ</code>为例，而动态代理则以<code>Spring AOP</code>代表。<ol>
<li>静态代理：也称编译时增强，<code>AOP</code>框架会在编译阶段生成<code>AOP</code>代理类，并将<code>AspectJ</code>织入到<code>Java</code>字节码文件中，运行的时候就是增强之后的<code>AOP</code>对象。</li>
<li>动态代理：也称运行时增强，其就是不会去修改<code>AOP</code>的字节码，而是每次运行在内存中临时为方法生成一个<code>AOP</code>对象，这个AOP对象包含目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。<ol>
<li><code>JDK</code>动态代理：<code>JDK</code>代理只提供接口的代理，不提供类的代理，要求被代理的类实现接口。</li>
<li><code>CgLib</code>动态代理： 如果被代理类没有实现接口，那么<code>Spring AOP</code>会选择使用<code>CGLIB</code>来动态代理目标类。<code>CGLIB</code>（是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现<code>AOP</code>。<code>CGLIB</code>是通过继承的方式做的动态代理，因此如果某个类被标记为<code>final</code>，那么它是无法使用<code>CGLIB</code>做动态代理的。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><code>Spring AOP</code>与<code>AspectJ AOP</code>有什么区别？</p>
<p>静态代理与动态代理区别在于生成<code>AOP</code>代理对象的时机不同，相对来说<code>AspectJ</code>的静态代理方式具有更好的性能，但是<code>AspectJ</code>需要特定的编译器进行处理，而<code>Spring AOP</code>则无需特定的编译器处理。</p>
</li>
<li><p><code>Spring</code>中的<code>bean</code>作用域以及生命周期？</p>
<ol>
<li>简单来说，<code>Spring Bean</code>的生命周期只有四个阶段：<strong>实例化-&gt;属性赋值-&gt;初始化-&gt;销毁</strong>。</li>
<li><code>Spring Bean</code>的作用域。<ol>
<li><code>singleton</code>：默认作用域，单例<code>bean</code>，每个容器中只有一个<code>bean</code>的实例。</li>
<li><code>prototype</code>：为每一个<code>bean</code>请求创建一个实例。</li>
<li><code>request</code>：为每一个<code>request</code>请求创建一个实例，在请求完成以后，<code>bean</code>会失效并被垃圾回收器回收。</li>
<li><code>session</code>：与<code>request</code>范围类似，同一个<code>session</code>会话共享一个实例，不同会话使用不同的实例。</li>
<li><code>global-session</code>：全局作用域，所有会话共享一个实例。如果想要声明让所有会话共享的存储变量的话，那么这全局变量需要存储在<code>global-session</code>中。</li>
</ol>
</li>
</ol>
</li>
<li><p><code>Spring</code>如何解决循环依赖？</p>
<p>循环依赖问题在<code>Spring</code>中主要有三种情况：</p>
<p>（1）通过构造方法进行依赖注入时产生的循环依赖问题。<br>（2）通过<code>setter</code>方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。<br>（3）通过<code>setter</code>方法进行依赖注入且是在单例模式下产生的循环依赖问题。<br>在<code>Spring</code>中，只有第（3）种方式的循环依赖问题被解决了，其他两种方式在遇到循环依赖问题时都会产生异常。这是因为：</p>
<p>第一种构造方法注入的情况下，在new对象的时候就会堵塞住了，其实也就是”先有鸡还是先有蛋“的历史难题。<br>第二种<code>setter</code>方法（多例）的情况下，每一次<code>getBean</code>()时，都会产生一个新的<code>Bean</code>，如此反复下去就会有无穷无尽的<code>Bean</code>产生了，最终就会导致<code>OOM</code>问题的出现。<br><code>Spring</code>在单例模式下的<code>setter</code>方法依赖注入引起的循环依赖问题，主要是通过二级缓存和三级缓存来解决的，其中三级缓存是主要功臣。解决的核心原理就是：在对象实例化之后，依赖注入之前，<code>Spring</code>提前暴露的<code>Bean</code>实例的引用在第三级缓存中进行存储。</p>
</li>
<li><p>有哪些注解？</p>
<ol>
<li><code>spring Bean</code>相关：<ol>
<li><code>@Autowired</code></li>
<li><code>@Component</code>：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注</li>
<li><code>@Repository</code>：对应持久层即 <code>Dao</code> 层，主要用于数据库相关操作</li>
<li><code>@Service</code>：对应服务层，主要涉及一些复杂的逻辑，需要用到 <code>Dao</code>层</li>
<li><code>@Controller</code>：对应 <code>Spring MVC</code> 控制层，主要用户接受用户请求并调用 <code>Service</code> 层返回数据给前端页面</li>
</ol>
</li>
<li>常见处理HTTP请求<ol>
<li><code>@GetMapping</code> : <code>GET</code> 请求、</li>
<li><code>@PostMapping</code> : <code>POST</code> 请求。</li>
<li><code>@PutMapping</code> : <code>PUT</code> 请求。</li>
<li><code>@DeleteMapping</code> : <code>DELETE</code> 请求。</li>
</ol>
</li>
</ol>
</li>
<li><p>SpringMVC？</p>
<ol>
<li><strong><code>Model1</code> 时代</strong> : 在 <code>Model1</code> 模式下，整个 <code>Web</code> 应用几乎全部用 <code>JSP</code> 页面组成，只用少量的 <code>JavaBean</code> 来处理数据库连接、访问等操作。这个模式下 <code>JSP</code> 即是控制层又是表现层。显而易见，这种模式存在很多问题。比如①将控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；②前端和后端相互依赖，难以进行测试并且开发效率极低；</li>
<li><strong><code>Model2 </code>时代</strong> ：学过 <code>Servlet</code> 并做过相关 <code>Demo</code> 的朋友应该了解<code>“Java Bean(Model)+ JSP（View,）+Servlet（Controller） ”</code>这种开发模式,这就是早期的 <code>JavaWeb MVC</code> 开发模式。<code>Model</code>:系统涉及的数据，也就是 <code>dao</code> 和 <code>bean</code>。<code>View</code>：展示模型中的数据，只是用来展示。<code>Controller</code>：处理用户请求 ，然后返回数据给 <code>JSP</code> 并展示给用户。<code>Struts2.</code></li>
<li>**<code>SpringMVC</code>**：<code>MVC</code> 是一种设计模式,<code>Spring MVC</code> 是一款很优秀的 <code>MVC</code> 框架。<code>Spring MVC</code> 可以帮助我们进行更简洁的<code>Web</code>层的开发，并且它天生与 <code>Spring </code>框架集成。<code>Spring MVC</code> 下我们一般把后端项目分为 <code>Service</code>层（处理业务）、<code>Dao</code>层（数据库操作）<code>、Entity</code>层（实体类）、<code>Controller</code>层(控制层，返回数据给前台页面)。</li>
</ol>
</li>
<li><p><code>Spring</code>框架中的设计模式？</p>
<ol>
<li><strong>工厂设计模式</strong> ：<code>Spring</code>使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象</li>
<li><strong>代理设计模式</strong> : <code>Spring AOP</code> 功能的实现。</li>
<li><strong>单例设计模式</strong> : <code>Spring</code> 中的 <code>Bean</code> 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : <code>Spring</code> 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 <code>Template</code> 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> <code>Spring</code> 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :<code>Spring AOP</code> 的增强或通知(<code>Advice</code>)使用到了适配器模式、<code>spring MVC </code>中也是用到了适配器模式适配<code>Controller</code>。</li>
</ol>
</li>
<li><p><code>Spring</code>事务？</p>
<ol>
<li><p>编程式事务：在代码中硬编码。</p>
</li>
<li><p>声明式事务：在配置文件中配置。</p>
<ol>
<li>基于<code>XML</code>的声明式事务。</li>
<li>基于注解的声明式事务。</li>
</ol>
</li>
<li><p>Spring事务中的隔离级别有哪几种？</p>
<p><strong><code>TransactionDefinition</code> 接口中定义了五个表示隔离级别的常量：</strong></p>
<ul>
<li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code>:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>:</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>:</strong> 最高的隔离级别，完全服从<code>ACID</code>的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a><code>Spring Boot</code></h4><ol>
<li><p>优点？</p>
<ol>
<li>开发基于 <code>Spring</code> 的应用程序很容易。</li>
<li><code>Spring Boot</code> 项目所需的开发或工程时间明显减少，通常会提高整体生产力。</li>
<li><code>Spring Boot</code> 不需要编写大量样板代码、<code>XML</code> 配置和注释。</li>
<li><code>Spring</code> 引导应用程序可以很容易地与 <code>Spring</code> 生态系统集成，如 <code>Spring JDBC、Spring ORM、Spring Data、Spring Security</code> 等。</li>
<li><code>Spring Boot</code> 遵循“固执己见的默认配置”，以减少开发工作（默认配置可以修改）。</li>
<li><code>Spring Boot</code> 应用程序提供嵌入式<code> HTTP</code> 服务器，如<code> Tomcat</code> 和 <code>Jetty</code>，可以轻松地开发和测试<code>web</code>应用程序。（这点很赞！普通运行 Java 程序的方式就能运行基于 <code>Spring Boot web</code> 项目，省事很多）</li>
<li><code>Spring Boot</code> 提供命令行接口(<code>CLI</code>)工具，用于开发和测试 <code>Spring Boot</code> 应用程序，如 <code>Java</code> 或 <code>Groovy</code>。</li>
<li><code>Spring Boot</code> 提供了多种插件，可以使用内置工具(如 <code>Maven</code> 和 <code>Gradle</code>)开发和测试 <code>Spring Boot</code> 应用程序。</li>
</ol>
</li>
<li><p>介绍一下<code>@SpringBootApplication</code>注解？</p>
<p>可以看出大概可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li>
<li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描该类所在的包下所有的类。</li>
<li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类。</li>
</ul>
</li>
</ol>
<h4 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a><code>Mybatis</code></h4><ol>
<li><p><code>#&#123;&#125;</code>和<code>$&#123;&#125;</code> 的区别是什么？</p>
<ol>
<li><code>$&#123;&#125;</code>是<code>Properties</code>文件中的变量占位符，它可以用于标签属性值和<code>sql</code>内部，属于静态文本替换，比如<code>$&#123;driver&#125;</code>会被静态替换为<code>com.mysql.jdbc.Driver。</code></li>
<li><code>#&#123;&#125;</code>是sql的参数占位符，<code>Mybatis</code>会将<code>sql</code>中的<code>#&#123;&#125;</code>替换为<code>?</code>号，在<code>sql</code>执行前会使用<code>PreparedStatement</code>的参数设置方法，按序给<code>sql</code>的<code>?</code>号占位符设置参数值，比如<code>ps.setInt(0, parameterValue)，#&#123;item.name&#125;</code>的取值方式为使用反射从参数对象中获取<code>item</code>对象的<code>name</code>属性值，相当于<code>param.getItem().getName()</code>。在预编译处理，可以有效的防止<code>SQL</code>注入。</li>
</ol>
</li>
<li><p><code>XML</code>映射文件中，除了常见的<code>select|insert|update|delete</code>标签之外，还有哪些标签？</p>
<ol>
<li>还有很多其他的标签，<code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态 <code>sql</code> 的 9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>等，其中为 <code>sql </code>片段标签，通过<code>&lt;include&gt;</code>标签引入 <code>sql</code> 片段，<code>&lt;selectKey&gt;</code>为不支持自增的主键生成策略标签。</li>
</ol>
</li>
<li><p><code>Mybatis</code>是如何实现分页的？分页插件的原理是什么？</p>
<ol>
<li><code>RowBounds</code>：在<code>mapper.java</code>中传入<code>RowBounds</code>对象，它是针对 <code>ResultSet</code> 结果集执行的内存分页，而非物理分页。</li>
<li><code>PageHelper</code>插件：使用 <code>Mybatis</code> 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 <code>sql</code>，然后重写 <code>sql</code>，根据 <code>dialect</code> 方言，添加对应的物理分页语句和物理分页参数</li>
</ol>
</li>
<li><p><code>Mybatis</code>能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及他们之间的区别？</p>
<p>能，<code>Mybatis</code> 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 <code>selectOne()</code>修改为 <code>selectList()</code>即可；多对多查询，其实就是一对多查询，只需要把 <code>selectOne()</code>修改为 <code>selectList()</code>即可。</p>
<p>关联对象查询，有两种实现方式，一种是单独发送一个 <code>sql</code> 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 <code>join </code>查询，一部分列是 <code>A</code> 对象的属性值，另外一部分列是关联对象 <code>B</code> 的属性值，好处是只发一个 <code>sql</code> 查询，就可以把主对象和其关联对象查出来。</p>
<p>那么问题来了，<code>join </code>查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是<code>&lt;resultMap&gt;</code>标签内的<code>&lt;id&gt;</code>子标签，指定了唯一确定一条记录的 id 列，Mybatis 根据列值来完成 100 条记录的去重复功能，<code>&lt;id&gt;</code>可以有多个，代表了联合主键的语意。</p>
<p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p>
</li>
<li><p><code>Mybatis</code>的一级、二级缓存:</p>
<p>（1）一级缓存: 基于 <code>PerpetualCache</code> 的 <code>HashMap</code> 本地缓存，其存储作用域为 <code>Session</code>，当 <code>Session flush</code> 或 <code>close</code> 之后，该 <code>Session</code> 中的所有 <code>Cache</code> 就将清空，默认打开一级缓存。</p>
<p>（2）二级缓存与一级缓存其机制相同，默认也是采用 <code>PerpetualCache，HashMap</code> 存储，不同在于其存储作用域为 <code>Mapper(Namespace)</code>，并且可自定义存储源，如 <code>Ehcache</code>。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现<code>Serializable</code>序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；</p>
<p>（3）对于缓存数据更新机制，当某一个作用域(一级缓存 <code>Session/</code>二级缓存<code>Namespaces</code>)的进行了<code>C/U/D</code> 操作后，默认该作用域下所有 <code>select</code> 中的缓存将被 <code>clear</code> 掉并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。</p>
</li>
<li><p><code>Mybatis</code>的延迟加载？</p>
</li>
</ol>
<p>  <code> Mybatis</code> 仅支持 <code>association </code>关联对象和 <code>collection</code> 关联集合对象的延迟加载，<code>association</code> 指的就是一对一，<code>collection</code> 指的就是一对多查询。在 <code>Mybatis</code> 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false。</code></p>
<p>   它的原理是，使用<code> CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code>，拦截器 <code>invoke()</code>方法发现 <code>a.getB()</code>是 <code>null</code> 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 <code>a.setB(b)</code>，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code>方法的调用。这就是延迟加载的基本原理。</p>
<ol start="7">
<li><p><code>Mybatis</code>如何执行批处理？</p>
<p>使用 <code>BatchExecutor</code> 完成批处理。</p>
</li>
<li><p><code>Mybatis</code>为什么是半自动<code>ORM</code>映射框架，与全自动映射区别在哪？</p>
<p><code>Hibernate</code> 属于全自动 <code>ORM</code> 映射工具，使用 <code>Hibernate</code> 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 <code>Mybatis</code> 在查询关联对象或关联集合对象时，需要手动编写 <code>sql</code> 来完成，所以，称之为半自动 <code>ORM</code> 映射工具。</p>
</li>
</ol>
<h3 id="十-Linux"><a href="#十-Linux" class="headerlink" title="十:  Linux"></a>十:  Linux</h3><h3 id="十一：Go"><a href="#十一：Go" class="headerlink" title="十一：Go"></a>十一：Go</h3><h3 id="十二：算法"><a href="#十二：算法" class="headerlink" title="十二：算法"></a>十二：算法</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a><strong>链表</strong></h4><ol>
<li>空间代价为O（1）去除链表种重复的节点。</li>
<li>判断链表有无环。</li>
<li>最小连续子序列之和&gt;=target.</li>
<li>堆排序</li>
<li>桶排序</li>
<li>快速排序</li>
<li>二分查找</li>
<li>K个一组进行链表反转.</li>
<li>Z型遍历二叉树</li>
<li>跳台阶</li>
<li>最大乘积的子数组</li>
</ol>
<h3 id="十三：场景题"><a href="#十三：场景题" class="headerlink" title="十三：场景题"></a>十三：场景题</h3><blockquote>
<p>select……for update会锁表还是锁行。 select查询语句是不会加锁的，但是select for update除了有查询的作用外，还会加锁呢，而且它是悲观锁。 那么它加的是行锁还是表锁， 没用索引/主键的话就是表锁，否则就是是行锁。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java面试</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
</search>

{
    "version": "https://jsonfeed.org/version/1",
    "title": "JIN MAO 's Blog • All posts by \"归并排序\" tag",
    "description": "",
    "home_page_url": "https://smile1231.github.io",
    "items": [
        {
            "id": "https://smile1231.github.io/posts/1599bffe/",
            "url": "https://smile1231.github.io/posts/1599bffe/",
            "title": "归并排序",
            "date_published": "2022-03-12T17:09:11.000Z",
            "content_html": "<h2 id=\"归并排序（稳定）\"><a href=\"#归并排序（稳定）\" class=\"headerlink\" title=\"归并排序（稳定）\"></a>归并排序（稳定）</h2><p>归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>\n<span id=\"more\"></span>\n\n<img data-src=\"/posts/1599bffe/2022-03-13-13-44-14.png\" class=\"\">\n\n<h3 id=\"1、基本思想\"><a href=\"#1、基本思想\" class=\"headerlink\" title=\"1、基本思想\"></a>1、基本思想</h3><p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>\n<h3 id=\"2、算法描述\"><a href=\"#2、算法描述\" class=\"headerlink\" title=\"2、算法描述\"></a>2、算法描述</h3><p>归并排序可通过两种方式实现：</p>\n<ul>\n<li>自上而下的递归</li>\n<li>自下而上的迭代<br>一、递归法（假设序列共有n个元素）：</li>\n</ul>\n<p>①. 将序列每相邻两个数字进行归并操作，形成 <code>floor(n/2)</code>个序列，排序后每个序列包含两个元素；<br>②. 将上述序列再次归并，形成 <code>floor(n/4)</code>个序列，每个序列包含四个元素；<br>③. 重复步骤②，直到所有元素排序完毕。</p>\n<p>二、迭代法</p>\n<p>①. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>②. 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>③. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>④. 重复步骤③直到某一指针到达序列尾<br>⑤. 将另一序列剩下的所有元素直接复制到合并序列尾</p>\n<h3 id=\"3、代码实现\"><a href=\"#3、代码实现\" class=\"headerlink\" title=\"3、代码实现\"></a>3、代码实现</h3><p>归并排序其实要做两件事：</p>\n<ul>\n<li>分解：将序列每次折半拆分</li>\n<li>合并：将划分后的序列段两两排序合并<br>因此，归并排序实际上就是两个操作，拆分+合并</li>\n</ul>\n<p>如何合并？</p>\n<p><code>L[first…mid]</code>为第一段，<code>L[mid+1…last]</code>为第二段，并且两端已经有序，现在我们要将两端合成达到<code>L[first…last]</code>并且也有序。</p>\n<p>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给<code>temp[]</code><br>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给<code>temp[]</code><br>此时将<code>temp[]</code>中的元素复制给<code>L[]</code>，则得到的<code>L[first…last]</code>有序</p>\n<p>如何分解？</p>\n<p>在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列<br>分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p>\n<p>这里我写了递归算法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 归并排序（递归）</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</span></span><br><span class=\"line\"><span class=\"comment\"> * ②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</span></span><br><span class=\"line\"><span class=\"comment\"> * ③. 重复步骤②，直到所有元素排序完毕。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> arr\t 待排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] mergingSort(<span class=\"keyword\">int</span>[] arr)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arr.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = arr.length &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] leftArr = Arrays.copyOfRange(arr, <span class=\"number\">0</span>, num);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] rightArr = Arrays.copyOfRange(arr, num, arr.length);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;split two array: &quot;</span> + Arrays.toString(leftArr) + <span class=\"string\">&quot; And &quot;</span> + Arrays.toString(rightArr));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr));      <span class=\"comment\">//不断拆分为最小单元，再排序合并</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] mergeTwoArray(<span class=\"keyword\">int</span>[] arr1, <span class=\"keyword\">int</span>[] arr2)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>, k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[arr1.length + arr2.length];  <span class=\"comment\">//申请额外的空间存储合并之后的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123;      <span class=\"comment\">//选取两个序列中的较小值放入新数组</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr1[i] &lt;= arr2[j])&#123;</span><br><span class=\"line\">            result[k++] = arr1[i++];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            result[k++] = arr2[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; arr1.length)&#123;     <span class=\"comment\">//序列1中多余的元素移入新数组</span></span><br><span class=\"line\">        result[k++] = arr1[i++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &lt; arr2.length)&#123;     <span class=\"comment\">//序列2中多余的元素移入新数组</span></span><br><span class=\"line\">        result[k++] = arr2[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Merging: &quot;</span> + Arrays.toString(result));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由上, 长度为<code>n</code>的数组, 最终会调用<code>mergeSort</code>函数<code>2n-1</code>次。通过自上而下的递归实现的归并排序, 将存在堆栈溢出的风险。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAvIyVFNCVCOCU4MyVFMyU4MCU4MSVFNSVCRCU5MiVFNSVCOSVCNiVFNiU4RSU5MiVFNSVCQSU4RiVFRiVCQyU4OE1lcmdpbmctU29ydCVFRiVCQyU4OQ==\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "归并排序"
            ]
        }
    ]
}
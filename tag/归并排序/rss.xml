<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>JIN MAO &#39;s Blog • Posts by &#34;归并排序&#34; tag</title>
        <link>https://smile1231.github.io</link>
        <description></description>
        <language>en</language>
        <pubDate>Sun, 13 Mar 2022 01:09:11 +0800</pubDate>
        <lastBuildDate>Sun, 13 Mar 2022 01:09:11 +0800</lastBuildDate>
        <category>SAP</category>
        <category>Java</category>
        <category>Cache</category>
        <category>Cookie</category>
        <category>Session</category>
        <category>Java面试</category>
        <category>Corn</category>
        <category>前端</category>
        <category>Css</category>
        <category>DisPlay属性</category>
        <category>生物信息</category>
        <category>基因编辑</category>
        <category>DDD</category>
        <category>领域驱动设计</category>
        <category>Docker</category>
        <category>FastJson</category>
        <category>blog</category>
        <category>hexo</category>
        <category>next</category>
        <category>JavaScript</category>
        <category>Html</category>
        <category>SpringBoot</category>
        <category>IDEA</category>
        <category>Jvm</category>
        <category>Jenkins</category>
        <category>CI/CD</category>
        <category>map</category>
        <category>Stream流</category>
        <category>函数式接口</category>
        <category>Assert</category>
        <category>java</category>
        <category>calender</category>
        <category>Springboot</category>
        <category>Python</category>
        <category>Jupyter</category>
        <category>Machine Learning</category>
        <category>LeetCode</category>
        <category>算法</category>
        <category>递归</category>
        <category>numpy</category>
        <category>pandas</category>
        <category>sklearn</category>
        <category>Mybatis</category>
        <category>分页查询</category>
        <category>Linux</category>
        <category>模糊查询</category>
        <category>Nginx</category>
        <category>Spring</category>
        <category>SrpingBoot</category>
        <category>文件上传</category>
        <category>事务</category>
        <category>master</category>
        <category>Groovy</category>
        <category>TypeScript</category>
        <category>WebPack</category>
        <category>UML</category>
        <category>Ubuntu</category>
        <category>Mysql</category>
        <category>VsCode</category>
        <category>Shell</category>
        <category>VSCODE</category>
        <category>快捷键</category>
        <category>Vue</category>
        <category>git</category>
        <category>Stream</category>
        <category>日期</category>
        <category>线程池</category>
        <category>ubuntu</category>
        <category>虚拟机</category>
        <category>二分查找</category>
        <category>数据挖掘</category>
        <category>Hadoop</category>
        <category>操作系统</category>
        <category>EasyExcel</category>
        <category>node</category>
        <category>JVM</category>
        <category>Yaml</category>
        <category>Hexo</category>
        <category>junit</category>
        <category>数据库</category>
        <category>Mysql事务</category>
        <category>Git</category>
        <category>冒泡排序</category>
        <category>git,npm,node</category>
        <category>动态规划</category>
        <category>堆排序</category>
        <category>多线程</category>
        <category>Google</category>
        <category>幂等性</category>
        <category>流</category>
        <category>归并排序</category>
        <category>直接插入排序</category>
        <category>快速排序</category>
        <category>正则表达式</category>
        <category>选择排序</category>
        <category>Spring事务</category>
        <category>Java 面试</category>
        <category>数据结构</category>
        <category>阻塞队列</category>
        <category>JDK</category>
        <category>动态代理</category>
        <category>Date</category>
        <category>ArrayList</category>
        <category>接口</category>
        <category>SpringMvc</category>
        <category>排序</category>
        <category>执行计划</category>
        <category>HashMap</category>
        <category>Email</category>
        <category>设计模式</category>
        <category>cheatsheet</category>
        <item>
            <guid isPermalink="true">https://smile1231.github.io/posts/1599bffe/</guid>
            <title>归并排序</title>
            <link>https://smile1231.github.io/posts/1599bffe/</link>
            <category>Java面试</category>
            <category>算法</category>
            <category>归并排序</category>
            <pubDate>Sun, 13 Mar 2022 01:09:11 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;归并排序稳定&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#归并排序稳定&#34;&gt;#&lt;/a&gt; 归并排序（稳定）&lt;/h2&gt;
&lt;p&gt;归并排序是建立在归并操作上的一种有效的排序算法，1945 年由约翰・冯・诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;img data-src=&#34;/posts/1599bffe/2022-03-13-13-44-14.png&#34; class=&#34;&#34;&gt;
&lt;h3 id=&#34;1-基本思想&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-基本思想&#34;&gt;#&lt;/a&gt; 1、基本思想&lt;/h3&gt;
&lt;p&gt;归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。&lt;/p&gt;
&lt;h3 id=&#34;2-算法描述&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-算法描述&#34;&gt;#&lt;/a&gt; 2、算法描述&lt;/h3&gt;
&lt;p&gt;归并排序可通过两种方式实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自上而下的递归&lt;/li&gt;
&lt;li&gt;自下而上的迭代&lt;br&gt;
一、递归法（假设序列共有 n 个元素）：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;①. 将序列每相邻两个数字进行归并操作，形成  &lt;code&gt;floor(n/2)&lt;/code&gt;  个序列，排序后每个序列包含两个元素；&lt;br&gt;
②. 将上述序列再次归并，形成  &lt;code&gt;floor(n/4)&lt;/code&gt;  个序列，每个序列包含四个元素；&lt;br&gt;
③. 重复步骤②，直到所有元素排序完毕。&lt;/p&gt;
&lt;p&gt;二、迭代法&lt;/p&gt;
&lt;p&gt;①. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&lt;br&gt;
②. 设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;br&gt;
③. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;br&gt;
④. 重复步骤③直到某一指针到达序列尾&lt;br&gt;
⑤. 将另一序列剩下的所有元素直接复制到合并序列尾&lt;/p&gt;
&lt;h3 id=&#34;3-代码实现&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3-代码实现&#34;&gt;#&lt;/a&gt; 3、代码实现&lt;/h3&gt;
&lt;p&gt;归并排序其实要做两件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分解：将序列每次折半拆分&lt;/li&gt;
&lt;li&gt;合并：将划分后的序列段两两排序合并&lt;br&gt;
因此，归并排序实际上就是两个操作，拆分 + 合并&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何合并？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;L[first…mid]&lt;/code&gt;  为第一段， &lt;code&gt;L[mid+1…last]&lt;/code&gt;  为第二段，并且两端已经有序，现在我们要将两端合成达到 &lt;code&gt;L[first…last]&lt;/code&gt;  并且也有序。&lt;/p&gt;
&lt;p&gt;首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给 &lt;code&gt;temp[]&lt;/code&gt; &lt;br&gt;
 重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给 &lt;code&gt;temp[]&lt;/code&gt; &lt;br&gt;
 此时将 &lt;code&gt;temp[]&lt;/code&gt;  中的元素复制给 &lt;code&gt;L[]&lt;/code&gt; ，则得到的 &lt;code&gt;L[first…last]&lt;/code&gt;  有序&lt;/p&gt;
&lt;p&gt;如何分解？&lt;/p&gt;
&lt;p&gt;在这里，我们采用递归的方法，首先将待排序列分成 A,B 两组；然后重复对 A、B 序列&lt;br&gt;
分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。&lt;/p&gt;
&lt;p&gt;这里我写了递归算法如下：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; * 归并排序（递归）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; * ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; * ②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; * ③. 重复步骤②，直到所有元素排序完毕。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; * &lt;span class=&#34;doctag&#34;&gt;@param&lt;/span&gt; arr	 待排序数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[] mergingSort(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[] arr)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt;(arr.length &amp;lt;= &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; arr;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; num = arr.length &amp;gt;&amp;gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[] leftArr = Arrays.copyOfRange(arr, &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, num);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[] rightArr = Arrays.copyOfRange(arr, num, arr.length);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;split two array: &amp;quot;&lt;/span&gt; + Arrays.toString(leftArr) + &lt;span class=&#34;string&#34;&gt;&amp;quot; And &amp;quot;&lt;/span&gt; + Arrays.toString(rightArr));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr));      &lt;span class=&#34;comment&#34;&gt;//不断拆分为最小单元，再排序合并&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[] mergeTwoArray(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[] arr1, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[] arr2)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, j = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, k = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[] result = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[arr1.length + arr2.length];  &lt;span class=&#34;comment&#34;&gt;//申请额外的空间存储合并之后的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt;(i &amp;lt; arr1.length &amp;amp;&amp;amp; j &amp;lt; arr2.length)&amp;#123;      &lt;span class=&#34;comment&#34;&gt;//选取两个序列中的较小值放入新数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt;(arr1[i] &amp;lt;= arr2[j])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            result[k++] = arr1[i++];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            result[k++] = arr2[j++];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt;(i &amp;lt; arr1.length)&amp;#123;     &lt;span class=&#34;comment&#34;&gt;//序列1中多余的元素移入新数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        result[k++] = arr1[i++];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt;(j &amp;lt; arr2.length)&amp;#123;     &lt;span class=&#34;comment&#34;&gt;//序列2中多余的元素移入新数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        result[k++] = arr2[j++];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Merging: &amp;quot;&lt;/span&gt; + Arrays.toString(result));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由上，长度为 &lt;code&gt;n&lt;/code&gt;  的数组，最终会调用 &lt;code&gt;mergeSort&lt;/code&gt;  函数 &lt;code&gt;2n-1&lt;/code&gt;  次。通过自上而下的递归实现的归并排序，将存在堆栈溢出的风险。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAvIyVFNCVCOCU4MyVFMyU4MCU4MSVFNSVCRCU5MiVFNSVCOSVCNiVFNiU4RSU5MiVFNSVCQSU4RiVFRiVCQyU4OE1lcmdpbmctU29ydCVFRiVCQyU4OQ==&#34;&gt;链接&lt;/span&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>

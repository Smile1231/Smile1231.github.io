{
    "version": "https://jsonfeed.org/version/1",
    "title": "JIN MAO 's Blog • All posts by \"正则表达式\" tag",
    "description": "",
    "home_page_url": "https://smile1231.github.io",
    "items": [
        {
            "id": "https://smile1231.github.io/posts/2f57a694/",
            "url": "https://smile1231.github.io/posts/2f57a694/",
            "title": "正则表达式",
            "date_published": "2022-02-19T08:18:37.000Z",
            "content_html": "<h1 id=\"正则表达式中的特殊字符\"><a href=\"#正则表达式中的特殊字符\" class=\"headerlink\" title=\"正则表达式中的特殊字符\"></a>正则表达式中的特殊字符</h1><h2 id=\"正则表达式中的特殊字符（📖表示-）\"><a href=\"#正则表达式中的特殊字符（📖表示-）\" class=\"headerlink\" title=\"正则表达式中的特殊字符（📖表示 |）\"></a>正则表达式中的特殊字符（📖表示 <code>|</code>）</h2><p>正则真的太难学了: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWdleG9uZS5jb20v\">https://regexone.com/</span>   学习网站这不就来了</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGFidWxhZG9uZy9wLzEyMzIwNDEzLmh0bWw=\"> git + 正则 </span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29sLm9zY2hpbmEubmV0L3VwbG9hZHMvYXBpZG9jcy9qcXVlcnkvcmVnZXhwLmh0bWw=\"> 手册 </span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWdleDEwMS5jb20vci9jTzhscXMvOQ==\"> 好用的网站 </span></p>\n<span id=\"more\"></span>\n\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>\\</code></td>\n<td>依照下列规则匹配：在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有<code>&quot;\\&quot;</code>的 <code>&quot;b&quot;</code> 通常匹配小写字母 <code>&quot;b&quot;</code>，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 <code>&quot;\\&quot;</code>，它将不再匹配任何字符，而是表示一个字符边界。在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。详情请参阅下文中的 “转义（Escaping）” 部分。如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。<code>/[a-z]\\s/i</code> 和 <code>new RegExp(&quot;[a-z]\\\\s&quot;, &quot;i&quot;)</code> 创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（<code>\\s</code> 可看后文）并且在 <code>a-z</code> 范围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和正则表达式级别都对它进行转义。例如 <code>/[a-z]:\\\\/i </code>和 <code>new RegExp(&quot;[a-z]:\\\\\\\\&quot;,&quot;i&quot;)</code> 会创建相同的表达式，即匹配类似 <code>&quot;C:\\&quot;</code> 字符串。</td>\n</tr>\n<tr>\n<td><code>^</code></td>\n<td>匹配输入的开始。如果多行标志被设置为<code> true</code>，那么也匹配换行符后紧跟的位置。例如，<code>/^A/</code> 并不会匹配 <code>&quot;an A&quot; </code>中的 <code>&#39;A&#39;</code>，但是会匹配 <code>&quot;An E&quot; </code>中的<code> &#39;A&#39;</code>。当 <code>&#39;^&#39; </code>作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。反向字符集合 一节有详细介绍和示例。</td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>匹配输入的结束。如果多行标志被设置为<code> true</code>，那么也匹配换行符前的位置。例如，<code>/t$/</code> 并不会匹配 <code>&quot;eater&quot;</code> 中的 <code>&#39;t&#39;</code>，但是会匹配 <code>&quot;eat&quot; </code>中的<code>&#39;t&#39;</code>。</td>\n</tr>\n<tr>\n<td><code>*</code></td>\n<td>匹配前一个表达式<code> 0 次</code>或<code>多次</code>。等价于 <code>&#123;0,&#125;</code>。例如，<code>/bo*/</code> 会匹配 <code>&quot;A ghost boooooed&quot;</code> 中的 <code>&#39;booooo&#39; </code>和 <code>&quot;A bird warbled&quot;</code> 中的 <code>&#39;b&#39;</code>，但是在 <code>&quot;A goat grunted&quot;</code> 中不会匹配任何内容。</td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td>匹配前面一个表达式 <code>1 次</code>或者<code>多次</code>。等价于<code> &#123;1,&#125;</code>。例如，<code>/a+/</code> 会匹配 <code>&quot;candy&quot;</code> 中的 <code>&#39;a&#39;</code> 和<code>&quot;caaaaaaandy&quot;</code>中所有的 <code>&#39;a&#39;</code>，但是在<code>&quot;cndy&quot;</code>中不会匹配任何内容。</td>\n</tr>\n<tr>\n<td><code>?</code></td>\n<td>匹配前面一个表达式 <code>0 次</code>或者<code> 1 次</code>。等价于<code> &#123;0,1&#125;</code>。例如，<code>/e?le?/</code> 匹配 <code>&quot;angel&quot;</code> 中的 <code>&#39;el&#39;、&quot;angle&quot;</code> 中的 <code>&#39;le&#39;</code> 以及 <code>&quot;oslo&#39;</code> 中的 <code>&#39;l&#39;</code>。如果紧跟在任何量词 <code>*、 +、?</code> 或 <code>&#123;&#125;</code> 的后面，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 <code>&quot;123abc&quot;</code> 使用 <code>/\\d+/</code> 将会匹配 <code>&quot;123&quot;</code>，而使用 <code>/\\d+?/</code> 则只会匹配到 <code>&quot;1&quot;</code>。还用于先行断言中，如本表的 <code>x(?=y)</code> 和 <code>x(?!y)</code> 条目所述。</td>\n</tr>\n<tr>\n<td><code>.    </code></td>\n<td>小数点）默认匹配除换行符之外的任何单个字符。例如，<code>/.n/</code> 将会匹配 <code>&quot;nay, an apple is on the tree&quot;</code> 中的 <code>&#39;an&#39;</code> 和 <code>&#39;on&#39;</code>，但是不会匹配 <code>&#39;nay&#39;</code>。如果 <code>s (&quot;dotAll&quot;) </code>标志位被设为 <code>true</code>，它也会匹配换行符。</td>\n</tr>\n<tr>\n<td><code>(x)</code></td>\n<td>像下面的例子展示的那样，它会匹配 <code>&#39;x&#39;</code> 并且记住匹配项。其中括号被称为捕获括号。模式 <code>/(foo) (bar) \\1 \\2/ </code>中的 <code>&#39;(foo)&#39;</code> 和 <code>&#39;(bar)&#39;</code> 匹配并记住字符串 <code>&quot;foo bar foo bar&quot;</code> 中前两个单词。模式中的 <code>\\1</code> 和 <code>\\2</code> 表示第一个和第二个被捕获括号匹配的子字符串，即 <code>foo</code> 和 <code>bar</code>，匹配了原字符串中的后两个单词。注意 <code>\\1、\\2、...、\\n</code> 是用在正则表达式的匹配环节，详情可以参阅后文的 <code>\\n</code> 条目。而在正则表达式的替换环节，则要使用像 <code>$1、$2、...、$n</code> 这样的语法，例如，<code>&#39;bar foo&#39;.replace(/(...) (...)/, &#39;$2 $1&#39;)</code>。<code>$&amp;</code> 表示整个用于匹配的原字符串。</td>\n</tr>\n<tr>\n<td><code>(?:x)    </code></td>\n<td>匹配 <code>&#39;x&#39;</code> 但是不记住匹配项。这种括号叫作非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。看看这个例子 <code>/(?:foo)&#123;1,2&#125;/</code>。如果表达式是 <code>/foo&#123;1,2&#125;/，&#123;1,2&#125;</code> 将只应用于 <code>&#39;foo&#39;</code> 的最后一个字符 <code>&#39;o&#39;</code>。如果使用非捕获括号，则 <code>&#123;1,2&#125;</code> 会应用于整个 <code>&#39;foo&#39;</code> 单词。更多信息，可以参阅下文的 <code>Using parentheses</code> 条目.</td>\n</tr>\n<tr>\n<td><code>x(?=y)</code></td>\n<td>匹配<code>&#39;x&#39;</code>仅仅当<code>&#39;x&#39;</code>后面跟着<code>&#39;y&#39;</code>.这种叫做先行断言。例如，<code>/Jack(?=Sprat)/</code>会匹配到<code>&#39;Jack&#39;</code>仅当它后面跟着``’Sprat’。/Jack(?=Sprat</td>\n</tr>\n<tr>\n<td><code>(?&lt;=y)x</code></td>\n<td>匹配<code>&#39;x&#39;</code>仅当<code>&#39;x&#39;</code>前面是<code>&#39;y&#39;</code>.这种叫做后行断言。例如，<code>/(?&lt;=Jack)Sprat/</code>会匹配到<code>&#39; Sprat &#39;</code>仅仅当它前面是<code>&#39;Jack&#39;。/(?&lt;=Jack📖Tom)Sprat/</code>匹配<code>‘ Sprat ’</code>仅仅当它前面是<code>Jack</code>或者是<code>‘Tom’</code>。但是<code>‘Jack’</code>和<code>‘Tom’</code>都不是匹配结果的一部分。</td>\n</tr>\n<tr>\n<td><code>x(?!y)</code></td>\n<td>仅仅当<code>&#39;x&#39;</code>后面不跟着<code>&#39;y&#39;</code>时匹配<code>&#39;x&#39;</code>，这被称为正向否定查找。例如，仅仅当这个数字后面没有跟小数点的时候，<code>/\\d+(?!\\.)/ </code>匹配一个数字。正则表达式<code>/\\d+(?!\\.)/.exec(&quot;3.141&quot;)</code>匹配<code>‘141’</code>而不是<code>‘3.141’</code></td>\n</tr>\n<tr>\n<td><code>(?&lt;!y)x</code></td>\n<td>仅仅当<code>&#39;x&#39;</code>前面不是<code>&#39;y&#39;</code>时匹配<code>&#39;x&#39;</code>，这被称为反向否定查找。例如, 仅仅当这个数字前面没有负号的时候，<code>/(?&lt;!-)\\d+/</code> 匹配一个数字。<code>/(?&lt;!-)\\d+/.exec(&#39;3&#39;)</code> 匹配到 <code>&quot;3&quot;./(?&lt;!-)\\d+/.exec(&#39;-3&#39;) </code>因为这个数字前有负号，所以没有匹配到。</td>\n</tr>\n<tr>\n<td><code>x📖y</code></td>\n<td>匹配<code>‘x’</code>或者<code>‘y’</code>。例如，``/green</td>\n</tr>\n<tr>\n<td><code>&#123;n&#125;</code></td>\n<td><code>n</code> 是一个正整数，匹配了前面一个字符刚好出现了 <code>n</code> 次。比如，<code> /a&#123;2&#125;/</code> 不会匹配<code>“candy”</code>中的<code>&#39;a&#39;</code>,但是会匹配<code>“caandy”</code>中所有的 <code>a</code>，以及<code>“caaandy”</code>中的前两个<code>&#39;a&#39;</code>。</td>\n</tr>\n<tr>\n<td><code>&#123;n,&#125;</code></td>\n<td><code>n</code>是一个正整数，匹配前一个字符至少出现了<code>n</code>次。例如, <code>/a&#123;2,&#125;/ </code>匹配 <code>&quot;aa&quot;</code>, <code>&quot;aaaa&quot;</code> 和 <code>&quot;aaaaa&quot;</code> 但是不匹配 <code>&quot;a&quot;</code>。</td>\n</tr>\n<tr>\n<td><code>&#123;n,m&#125;    </code></td>\n<td><code>n</code> 和 <code>m</code> 都是整数。匹配前面的字符至少<code>n</code>次，最多<code>m</code>次。如果 <code>n</code> 或者 <code>m</code> 的值是<code>0</code>， 这个值被忽略。例如，<code>/a&#123;1, 3&#125;/</code> 并不匹配<code>“cndy”</code>中的任意字符，匹配<code>“candy”</code>中的<code>a</code>，匹配<code>“caandy”</code>中的前两个<code>a</code>，也匹配<code>“caaaaaaandy”</code>中的前三个<code>a</code>。注意，当匹配<code>”caaaaaaandy“</code>时，匹配的值是<code>“aaa”</code>，即使原始的字符串中有更多的<code>a</code>。</td>\n</tr>\n<tr>\n<td><code>[xyz]</code></td>\n<td>一个字符集合。匹配方括号中的任意字符，包括转义序列。你可以使用破折号（<code>-</code>）来指定一个字符范围。对于点<code>（.）</code>和星号<code>（*）</code>这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。例如，<code>[abcd]</code> 和<code>[a-d]</code>是一样的。他们都匹配<code>&quot;brisket&quot;</code>中的<code>‘b’</code>,也都匹配<code>“city”</code>中的<code>‘c’</code>。<code>/[a-z.]+/</code> 和<code>/[\\w.]+/</code>与字符串<code>“test.i.ng”</code>匹配。</td>\n</tr>\n<tr>\n<td><code>[^xyz]</code></td>\n<td>一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。例如，<code>[^abc]</code> 和 <code>[^a-c]</code> 是一样的。他们匹配<code>&quot;brisket&quot;</code>中的<code>‘r’</code>，也匹配<code>“chop”</code>中的<code>‘h’</code>。</td>\n</tr>\n<tr>\n<td><code>[\\b]</code></td>\n<td>匹配一个退格(<code>U+0008</code>)。（不要和<code>\\b</code>混淆了。）</td>\n</tr>\n<tr>\n<td><code>\\b</code></td>\n<td><strong>匹配一个词的边界</strong>。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是<code>0</code>。（不要和<code>[\\b]</code>混淆了）使用<code>&quot;moon&quot;</code>举例：<code>/\\bm/</code>匹配<code>“moon”</code>中的<code>‘m’</code>；<code>/oo\\b/</code>并不匹配<code>&quot;moon&quot;</code>中的<code>&#39;oo&#39;</code>，因为<code>&#39;oo&#39;</code>被一个“字”字符<code>&#39;n&#39;</code>紧跟着。<code>/oon\\b/</code>匹配<code>&quot;moon&quot;</code>中的<code>&#39;oon&#39;</code>，因为<code>&#39;oon&#39;</code>是这个字符串的结束部分。这样他没有被一个“字”字符紧着。<code>/\\w\\b\\w/</code>将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。注意: <code>JavaScript</code>的正则表达式引擎将特定的字符集定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，十进制数字和下划线字符。不幸的是，重要的字符，例如<code>“é”</code>或<code>“ü”</code>，被视为断词。</td>\n</tr>\n<tr>\n<td><code>\\B</code></td>\n<td>匹配一个非单词边界。匹配如下几种情况：字符串第一个字符为非“字”字符字符串最后一个字符为非“字”字符两个单词字符之间两个非单词字符之间空字符串例如，<code>/\\B../</code>匹配<code>&quot;noonday&quot;</code>中的<code>&#39;oo&#39;</code>, 而<code>/y\\B../</code>匹配<code>&quot;possibly yesterday&quot;</code>中的<code>’yes‘</code></td>\n</tr>\n<tr>\n<td><code>\\cX</code></td>\n<td>当<code>X</code>是处于<code>A</code>到<code>Z</code>之间的字符的时候，匹配字符串中的一个控制符。例如，<code>/\\cM/</code> 匹配字符串中的 <code>control-M (U+000D)</code>。</td>\n</tr>\n<tr>\n<td><code>\\d</code></td>\n<td>匹配一个数字。等价于[0-9]。例如， <code>/\\d/</code> 或者 <code>/[0-9]/</code> 匹配”<code>B2 is the suite number.</code>“中的<code>&#39;2&#39;</code>。</td>\n</tr>\n<tr>\n<td><code>\\D</code></td>\n<td>匹配一个非数字字符。等价于<code>[^0-9]</code>。例如， <code>/\\D/</code> 或者 <code>/[^0-9]/</code> 匹配”<code>B2 is the suite number.</code>“中的’<code>B</code>‘ 。</td>\n</tr>\n<tr>\n<td><code>\\f</code></td>\n<td>匹配一个换页符 <code>(U+000C)</code>。</td>\n</tr>\n<tr>\n<td><code>\\n</code></td>\n<td>匹配一个换行符 <code>(U+000A)</code>。</td>\n</tr>\n<tr>\n<td><code>\\r</code></td>\n<td>匹配一个回车符 <code>(U+000D)</code>。</td>\n</tr>\n<tr>\n<td><code>\\s</code></td>\n<td>匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于<code>[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]</code>。例如, <code>/\\s\\w*/</code> 匹配”foo bar.”中的’ bar’。经测试，\\s不匹配”\\u180e”，在当前版本Chrome(v80.0.3987.122)和Firefox(76.0.1)控制台输入/\\s/.test(“\\u180e”)均返回false。</td>\n</tr>\n<tr>\n<td><code>\\S</code></td>\n<td>匹配一个非空白字符。等价于 <code>[^\\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]</code>。例如，<code>/\\S\\w*/</code> 匹配<code>&quot;foo bar.&quot;</code>中的’foo’。</td>\n</tr>\n<tr>\n<td><code>\\t</code></td>\n<td>匹配一个水平制表符 <code>(U+0009</code>)。</td>\n</tr>\n<tr>\n<td><code>\\v</code></td>\n<td>匹配一个垂直制表符 (U+000B)。</td>\n</tr>\n<tr>\n<td><code>\\w</code></td>\n<td>匹配一个单字字符（字母、数字或者下划线）。等价于 <code>[A-Za-z0-9_]</code>。例如, <code>/\\w/</code> 匹配 <code>&quot;apple,&quot;</code> 中的 <code>&#39;a&#39;，&quot;$5.28,&quot;</code>中的 <code>&#39;5&#39;</code> 和 <code>&quot;3D.&quot;</code> 中的 <code>&#39;3&#39;</code>。</td>\n</tr>\n<tr>\n<td><code>\\W</code></td>\n<td>匹配一个非单字字符。等价于 <code>[^A-Za-z0-9_]</code>。例如,<code> /\\W/</code> 或者 <code>/[^A-Za-z0-9_]/</code> 匹配 <code>&quot;50%.&quot;</code> 中的 <code>&#39;%&#39;</code>。</td>\n</tr>\n<tr>\n<td><code>\\n</code></td>\n<td>在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。比如 <code>/apple(,)\\sorange\\1/</code> 匹配<code>&quot;apple, orange, cherry, peach.&quot;</code>中的<code>&#39;apple, orange,&#39;</code> 。</td>\n</tr>\n<tr>\n<td><code>\\0</code></td>\n<td>匹配<code> NULL（U+0000）</code>字符， 不要在这后面跟其它小数，因为 <code>\\0&lt;digits&gt;</code> 是一个八进制转义序列。</td>\n</tr>\n<tr>\n<td><code>\\xhh</code></td>\n<td>匹配一个两位十六进制数<code>（\\x00-\\xFF）</code>表示的字符。</td>\n</tr>\n<tr>\n<td><code>\\uhhhh</code></td>\n<td>匹配一个四位十六进制数表示的 <code>UTF-16</code> 代码单元。</td>\n</tr>\n<tr>\n<td><code>\\u&#123;hhhh&#125;或\\u&#123;hhhhh&#125;</code></td>\n<td>（仅当设置了u标志时）匹配一个十六进制数表示的 <code>Unicode</code> 字符。</td>\n</tr>\n</tbody></table>\n<hr/>\n\n\n\n\n<table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>可匹配</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>\\r, \\n</code></td>\n<td>代表回车和换行符</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>制表符</td>\n</tr>\n<tr>\n<td><code>\\\\</code></td>\n<td>代表 <code>&quot;\\&quot;</code> 本身</td>\n</tr>\n</tbody></table>\n",
            "tags": [
                "正则表达式"
            ]
        }
    ]
}
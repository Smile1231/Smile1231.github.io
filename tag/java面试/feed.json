{
    "version": "https://jsonfeed.org/version/1",
    "title": "JIN MAO 's Blog • All posts by \"java面试\" tag",
    "description": "",
    "home_page_url": "https://smile1231.github.io",
    "items": [
        {
            "id": "https://smile1231.github.io/posts/dfdc2005/",
            "url": "https://smile1231.github.io/posts/dfdc2005/",
            "title": "JDK动态代理原理剖析(简洁版)",
            "date_published": "2022-03-14T09:40:52.000Z",
            "content_html": "<h2 id=\"动态代理两个实例-视频中学的\"><a href=\"#动态代理两个实例-视频中学的\" class=\"headerlink\" title=\"动态代理两个实例(视频中学的)\"></a>动态代理两个实例(视频中学的)</h2><p>动态代理在<code>Java</code>中有着广泛的应用，比如<code>Spring AOP、Hibernate</code>数据查询、测试框架的后端<code>mock、RPC</code>远程调用、<code>Java</code>注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。<br>本文主要介绍<code>Java</code>中两种常见的动态代理方式：<code>JDK</code>原生动态代理和<code>CGLIB</code>动态代理。</p>\n<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p>本文将介绍的<code>Java</code>动态代理与设计模式中的代理模式有关，什么是代理模式呢？</p>\n<span id=\"more\"></span>\n\n<p><strong>代理模式：</strong>给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。</p>\n<p>代理模式角色分为 <code>3</code> 种：</p>\n<ul>\n<li><p><code>Subject（抽象主题角色）</code>：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</p>\n</li>\n<li><p><code>RealSubject（真实主题角色）</code>：真正实现业务逻辑的类；</p>\n</li>\n<li><p><code>Proxy（代理主题角色）</code>：用来代理和封装真实主题；</p>\n</li>\n</ul>\n<p>代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层</p>\n<img data-src=\"/blog/posts/dfdc2005/2022-03-14-17-42-04.png\" class=\"\">\n\n<blockquote>\n<p>代理模式按照职责（使用场景）来分类，至少可以分为以下几类：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、远程代理。 </span><br><span class=\"line\"><span class=\"number\">2</span>、虚拟代理。 </span><br><span class=\"line\"><span class=\"number\">3</span>、Copy-on-Write 代理。 </span><br><span class=\"line\"><span class=\"number\">4</span>、保护（Protect or Access）代理。 </span><br><span class=\"line\"><span class=\"number\">5</span>、Cache代理。 </span><br><span class=\"line\"><span class=\"number\">6</span>、防火墙（Firewall）代理。 </span><br><span class=\"line\"><span class=\"number\">7</span>、同步化（Synchronization）代理。 </span><br><span class=\"line\"><span class=\"number\">8</span>、智能引用（Smart Reference）代理等等。</span><br></pre></td></tr></table></figure>\n\n<p>如果根据字节码的创建时机来分类，可以分为静态代理和动态代理：</p>\n<ul>\n<li>所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了。</li>\n<li>而动态代理的源码是在程序运行期间由<code>JVM</code>根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件</li>\n</ul>\n<h3 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h3><p>我们先通过实例来学习静态代理，然后理解静态代理的缺点，再来学习本文的主角：动态代理</p>\n<p>编写一个接口 <code>UserService</code> ，以及该接口的一个实现类 <code>UserServiceImpl</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">select</span><span class=\"params\">()</span></span>;   </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">select</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;查询 selectById&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;更新 update&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将通过静态代理对 <code>UserServiceImpl</code> 进行功能增强，在调用 <code>select</code> 和 <code>update</code> 之前记录一些日志。写一个代理类 <code>UserServiceProxy</code>，代理类需要实现 <code>UserService</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService target; <span class=\"comment\">// 被代理的对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserServiceProxy</span><span class=\"params\">(UserService target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">select</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        before();</span><br><span class=\"line\">        target.select();    <span class=\"comment\">// 这里才实际调用真实主题角色的方法</span></span><br><span class=\"line\">        after();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        before();</span><br><span class=\"line\">        target.update();    <span class=\"comment\">// 这里才实际调用真实主题角色的方法</span></span><br><span class=\"line\">        after();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">()</span> </span>&#123;     <span class=\"comment\">// 在执行方法之前执行</span></span><br><span class=\"line\">        System.out.println(String.format(<span class=\"string\">&quot;log start time [%s] &quot;</span>, <span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">after</span><span class=\"params\">()</span> </span>&#123;      <span class=\"comment\">// 在执行方法之后执行</span></span><br><span class=\"line\">        System.out.println(String.format(<span class=\"string\">&quot;log end time [%s] &quot;</span>, <span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        UserService userServiceImpl = <span class=\"keyword\">new</span> UserServiceImpl();</span><br><span class=\"line\">        UserService proxy = <span class=\"keyword\">new</span> UserServiceProxy(userServiceImpl);</span><br><span class=\"line\"></span><br><span class=\"line\">        proxy.select();</span><br><span class=\"line\">        proxy.update();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p>\n<h4 id=\"静态代理的缺点\"><a href=\"#静态代理的缺点\" class=\"headerlink\" title=\"静态代理的缺点\"></a>静态代理的缺点</h4><p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。<br>1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p>\n<pre><code>- 只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大\n- 新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类\n</code></pre>\n<p>2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护</p>\n<h3 id=\"如何改进？\"><a href=\"#如何改进？\" class=\"headerlink\" title=\"如何改进？\"></a>如何改进？</h3><p>当然是让代理类<strong>动态的生成</strong>啦，也就是动态代理。</p>\n<p><strong>为什么类可以动态的生成？</strong></p>\n<p>这就涉及到<code>Java</code>虚拟机的<strong>类加载机制</strong>了，推荐翻看《深入理解Java虚拟机》7.3节 类加载的过程。</p>\n<p>Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下3件事情：</p>\n<p>通过一个类的全限定名来获取定义此类的二进制字节流<br>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口</p>\n<p>由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，获取类的二进制字节流（class字节码）就有很多途径：</p>\n<p>从ZIP包获取，这是JAR、EAR、WAR等格式的基础<br>从网络中获取，典型的应用是 Applet<br>运行时计算生成，这种场景使用最多的是动态代理技术，在 java.lang.reflect.Proxy 类中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 *$Proxy 的代理类的二进制字节流<br>由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类<br>从数据库中获取等等</p>\n<p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。</p>\n<h3 id=\"常见的字节码操作类库\"><a href=\"#常见的字节码操作类库\" class=\"headerlink\" title=\"常见的字节码操作类库\"></a>常见的字节码操作类库</h3><p>这里有一些介绍：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vamF2YS1zb3VyY2UubmV0L29wZW4tc291cmNlL2J5dGVjb2RlLWxpYnJhcmllcw==\">java-source.net/open-source…</span></p>\n<h3 id=\"实现动态代理的思考方向\"><a href=\"#实现动态代理的思考方向\" class=\"headerlink\" title=\"实现动态代理的思考方向\"></a>实现动态代理的思考方向</h3><p>为了让生成的代理类与目标对象（真实主题角色）保持一致性，从现在开始将介绍以下两种最常见的方式：</p>\n<ul>\n<li>通过实现接口的方式 -&gt; <code>JDK</code>动态代理</li>\n<li>通过继承类的方式 -&gt; <code>CGLIB</code>动态代理</li>\n</ul>\n<p>注：使用<code>ASM</code>对使用者要求比较高，使用<code>Javassist</code>会比较麻烦</p>\n<h3 id=\"JDk动态代理\"><a href=\"#JDk动态代理\" class=\"headerlink\" title=\"JDk动态代理\"></a><code>JDk</code>动态代理</h3><p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code>，我们仍然通过案例来学习</p>\n<p>编写一个调用逻辑处理器 <code>LogHandler</code> 类，提供日志增强功能，并实现 <code>InvocationHandler</code> 接口；在 <code>LogHandler</code> 中维护一个目标对象，这个对象是被代理的对象（真实主题角色）；在 <code>invoke</code> 方法中编写方法调用的逻辑处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> jinmao</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span> 2022-03-14-10:52</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span> LogHandler</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 代理的对象，实际的方法执行者</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造方法注入</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> target</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LogHandler</span><span class=\"params\">(Object target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> proxy:代理类代理的真实代理对象com.sun.proxy.$Proxy0</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method:我们所要调用某个对象真实的方法的Method对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args:指代代理对象方法传递的参数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        before();</span><br><span class=\"line\">        <span class=\"comment\">//调用target的method方法</span></span><br><span class=\"line\">        Object result = method.invoke(target, args);</span><br><span class=\"line\">        after();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用invoke方法之前执行</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;log start time [%s] %n&quot;</span>, <span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 调用invoke方法之后执行</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">after</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;log end time [%s] %n&quot;</span>, <span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编写客户端，获取动态生成的代理类的对象须借助 <code>Proxy</code> 类的 <code>newProxyInstance</code> 方法，具体步骤可见代码和注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.cy.learn.dynamic.proxy.utils.ProxyUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@creator</span> jinmao</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span> 2022-03-14-13:14</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span> Client</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span></span><br><span class=\"line\">        <span class=\"comment\">// System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class=\"line\">        UserServiceImpl userServiceImpl = <span class=\"keyword\">new</span> UserServiceImpl();</span><br><span class=\"line\">        <span class=\"comment\">// 2. 获取对应的 ClassLoader</span></span><br><span class=\"line\">        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();</span><br><span class=\"line\">        <span class=\"comment\">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class=\"line\">        Class&lt;?&gt;[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class=\"line\">        <span class=\"comment\">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class=\"line\">        LogHandler logHandler = <span class=\"keyword\">new</span> LogHandler(userServiceImpl);</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class=\"line\"><span class=\"comment\">           a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class=\"line\"><span class=\"comment\">           b.然后根据相应的字节码转换成对应的class，</span></span><br><span class=\"line\"><span class=\"comment\">           c.然后调用newInstance()创建代理实例</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class=\"line\">        <span class=\"comment\">// 调用代理的方法</span></span><br><span class=\"line\">        proxy.select();</span><br><span class=\"line\">        proxy.update();</span><br><span class=\"line\">        <span class=\"comment\">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class=\"line\">        <span class=\"comment\">//ProxyUtils.generateClassFile(userServiceImpl.getClass(), &quot;UserServiceProxy&quot;);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log start time [Mon Mar <span class=\"number\">14</span> <span class=\"number\">18</span>:<span class=\"number\">02</span>:<span class=\"number\">11</span> CST <span class=\"number\">2022</span>] </span><br><span class=\"line\">查询 selectById</span><br><span class=\"line\">log end time [Mon Mar <span class=\"number\">14</span> <span class=\"number\">18</span>:<span class=\"number\">02</span>:<span class=\"number\">11</span> CST <span class=\"number\">2022</span>] </span><br><span class=\"line\">log start time [Mon Mar <span class=\"number\">14</span> <span class=\"number\">18</span>:<span class=\"number\">02</span>:<span class=\"number\">11</span> CST <span class=\"number\">2022</span>] </span><br><span class=\"line\">更新 update</span><br><span class=\"line\">log end time [Mon Mar <span class=\"number\">14</span> <span class=\"number\">18</span>:<span class=\"number\">02</span>:<span class=\"number\">11</span> CST <span class=\"number\">2022</span>] </span><br></pre></td></tr></table></figure>\n<p><code>InvocationHandler</code> 和 <code>Proxy</code> 的主要方法介绍如下：</p>\n<p><strong><code>java.lang.reflect.InvocationHandler</code></strong></p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object invoke(Object proxy, <span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">method</span>, <span class=\"title\">Object</span>[] <span class=\"title\">args</span>) 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</span></span><br></pre></td></tr></table></figure>\n\n<p><strong><code>java.lang.reflect.Proxy</code></strong></p>\n<figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static InvocationHandler getInvocationHandler(Object proxy)  用于获取指定代理对象所关联的调用处理器<span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) 返回指定接口的代理类<span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">static</span> Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的<span class=\"built_in\"> invoke </span>方法<span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">static</span> boolean isProxyClass(Class&lt;?&gt; cl) 返回 cl 是否为一个代理类</span><br></pre></td></tr></table></figure>\n<h3 id=\"代理类的调用过程\"><a href=\"#代理类的调用过程\" class=\"headerlink\" title=\"代理类的调用过程\"></a>代理类的调用过程</h3><p>生成的代理类到底长什么样子呢？借助下面的工具类，把代理类保存下来再探个究竟</p>\n<p>（通过设置环境变量<code>sun.misc.ProxyGenerator.saveGeneratedFiles=true</code>也可以保存代理类）</p>\n<p>手写一个工具类:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sun.misc.ProxyGenerator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileOutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@creator</span> jinmao</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span> 2022-03-14-13:24</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span> ProxyUtils</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyUtils</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将根据类信息动态生成的二进制字节码保存到硬盘中，默认的是clazz目录下</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> clazz: 需要生成动态代理类的类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> proxyName: 为动态生成的代理类的名称</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">generateClassFile</span><span class=\"params\">(Class clazz, String proxyName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据类信息和提供的代理类名称，生成字节码</span></span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces());</span><br><span class=\"line\">        String paths = clazz.getResource(<span class=\"string\">&quot;.&quot;</span>).getPath();</span><br><span class=\"line\">        System.out.println(paths);</span><br><span class=\"line\">        FileOutputStream out = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//保留到硬盘中</span></span><br><span class=\"line\">            out = <span class=\"keyword\">new</span> FileOutputStream(paths + proxyName + <span class=\"string\">&quot;.class&quot;</span>);</span><br><span class=\"line\">            out.write(classFile);</span><br><span class=\"line\">            out.flush();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                out.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将这两行注释放开即可:</p>\n<img data-src=\"/blog/posts/dfdc2005/2022-03-14-18-10-35.png\" class=\"\">\n\n<p>运行结果:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log start time [Mon Mar <span class=\"number\">14</span> <span class=\"number\">18</span>:<span class=\"number\">25</span>:<span class=\"number\">57</span> CST <span class=\"number\">2022</span>] </span><br><span class=\"line\">查询 selectById</span><br><span class=\"line\">log end time [Mon Mar <span class=\"number\">14</span> <span class=\"number\">18</span>:<span class=\"number\">25</span>:<span class=\"number\">57</span> CST <span class=\"number\">2022</span>] </span><br><span class=\"line\">log start time [Mon Mar <span class=\"number\">14</span> <span class=\"number\">18</span>:<span class=\"number\">25</span>:<span class=\"number\">57</span> CST <span class=\"number\">2022</span>] </span><br><span class=\"line\">更新 update</span><br><span class=\"line\">log end time [Mon Mar <span class=\"number\">14</span> <span class=\"number\">18</span>:<span class=\"number\">25</span>:<span class=\"number\">57</span> CST <span class=\"number\">2022</span>] </span><br></pre></td></tr></table></figure>\n\n\n<p><code>IDEA</code> 再次运行之后就可以在 <code>out</code> 的类路径下找到 <code>UserServiceProxy.class</code>，双击后<code>IDEA</code>的反编译插件会将该二进制<code>class</code>文件</p>\n<img data-src=\"/blog/posts/dfdc2005/2022-03-14-18-12-41.png\" class=\"\">\n\n<p><code>UserServiceProxy</code>的反编译代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class=\"line\"><span class=\"comment\">// (powered by FernFlower decompiler)</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.cy.learn.dynamic.proxy.UserService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceProxy</span> <span class=\"keyword\">extends</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m1;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m2;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m4;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m0;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m3;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserServiceProxy</span><span class=\"params\">(InvocationHandler var1)</span> <span class=\"keyword\">throws</span>  </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object var1)</span> <span class=\"keyword\">throws</span>  </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">select</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m4, (Object[])<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> var2;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m3, (Object[])<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> var2;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            m1 = Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>).getMethod(<span class=\"string\">&quot;equals&quot;</span>, Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>));</span><br><span class=\"line\">            m2 = Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>).getMethod(<span class=\"string\">&quot;toString&quot;</span>);</span><br><span class=\"line\">            m4 = Class.forName(<span class=\"string\">&quot;com.cy.learn.dynamic.proxy.UserService&quot;</span>).getMethod(<span class=\"string\">&quot;select&quot;</span>);</span><br><span class=\"line\">            m0 = Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>).getMethod(<span class=\"string\">&quot;hashCode&quot;</span>);</span><br><span class=\"line\">            m3 = Class.forName(<span class=\"string\">&quot;com.cy.learn.dynamic.proxy.UserService&quot;</span>).getMethod(<span class=\"string\">&quot;update&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中看一段我们自己的和新方法<code>select()</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">select</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m4, (Object[])<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> var2;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var3);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此处的<code>super</code>就是<code>extends</code>的<code>Proxy</code>类,我们来看<code>super</code>中的<code>h</code>到底是什么?</p>\n<img data-src=\"/blog/posts/dfdc2005/2022-03-14-18-24-12.png\" class=\"\">\n\n<p>而<code>super.h.invoke</code>方法即为我们手写的<code>LogHandler</code>中的<code>invoke</code>方法,所以日志才会打印</p>\n<img data-src=\"/blog/posts/dfdc2005/2022-03-14-18-25-17.png\" class=\"\">\n\n<blockquote>\n<p>小总结</p>\n</blockquote>\n<p>从 <code>UserServiceProxy</code> 的代码中我们可以发现：</p>\n<ul>\n<li><code>UserServiceProxy</code> 继承了 <code>Proxy</code> 类，并且实现了被代理的所有接口，以及<code>equals、hashCode、toString</code>等方法</li>\n<li>由于 <code>UserServiceProxy</code> 继承了 <code>Proxy</code> 类，所以每个代理类都会关联一个 <code>InvocationHandler</code> 方法调用处理器</li>\n<li>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</li>\n<li>每个方法都有一个 <code>Method</code> <code>对象来描述，Method</code> 对象在<code>static</code>静态代码块中创建，以<code> m + 数字</code> 的格式命名</li>\n<li>调用方法的时候通过 <code>super.h.invoke(this, m1, (Object[])null)</code>; 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 <code>LogHandler</code> 对象，它继承 <code>InvocationHandler</code> 类，负责实际的调用处理逻辑</li>\n</ul>\n<p>而 <code>LogHandler</code> 的 <code>invoke</code> 方法接收到 <code>method、args</code> 等参数后，进行一些处理，然后通过反射让被代理的对象 <code>target</code> 执行方法</p>\n<p>JDK动态代理执行方法调用的过程简图如下：</p>\n<img data-src=\"/blog/posts/dfdc2005/2022-03-14-18-28-41.png\" class=\"\">\n\n\n<h2 id=\"Proxy-newProxyInstance源码debug\"><a href=\"#Proxy-newProxyInstance源码debug\" class=\"headerlink\" title=\"Proxy.newProxyInstance源码debug\"></a><code>Proxy.newProxyInstance</code>源码<code>debug</code></h2><p>代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回将方法调用分派到指定调用处理程序的指定接口的代理类的实例。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@CallerSensitive</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                        Class&lt;?&gt;[] interfaces,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                        InvocationHandler h)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> IllegalArgumentException</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(h);</span><br><span class=\"line\">    <span class=\"comment\">//复制一份传入的接口字节码对象数组</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sm != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//查找或生成指定的代理类</span></span><br><span class=\"line\">    <span class=\"comment\">//此处使用类加载器和接口生成一个Proxy子类字节码对象</span></span><br><span class=\"line\">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs); ------------------------------------&gt;  进入该核心方法</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用指定的调用处理程序调用其构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sm != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//获取构造器对象和调用处理器</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> InvocationHandler ih = h;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class=\"line\">            AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    cons.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//用构造器和调用处理器创建proxy代理对象并返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cons.newInstance(<span class=\"keyword\">new</span> Object[]&#123;h&#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>进入<code>getProxyClass0</code>方法：</p>\n<img data-src=\"/blog/posts/dfdc2005/2022-03-14-22-06-24.png\" class=\"\">\n\n\n<p>进入到<code>get</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过缓存查找值。如果给定的 (key, subKey) 对的缓存中没有条目或条目已被清除</span></span><br><span class=\"line\"><span class=\"comment\">// 则这始终评估subKeyFactory函数并可选地评估valueFactory函数。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(K key, P parameter)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(parameter);</span><br><span class=\"line\"></span><br><span class=\"line\">    expungeStaleEntries();</span><br><span class=\"line\"></span><br><span class=\"line\">    Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 惰性地为特定的cacheKey安装第二级值map</span></span><br><span class=\"line\">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (valuesMap == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class=\"line\">            = map.putIfAbsent(cacheKey,</span><br><span class=\"line\">                                valuesMap = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldValuesMap != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            valuesMap = oldValuesMap;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建subKey并从valuesMap中检索由该subKey存储的可能的Supplier&lt;V&gt;</span></span><br><span class=\"line\">    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class=\"line\">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class=\"line\">    Factory factory = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (supplier != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// supplier可以是一个Factory或者CacheValue&lt;V&gt;实例</span></span><br><span class=\"line\">            V value = supplier.get(); -----------------------------------&gt;  进入该和新方法</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//否则缓存中没有供应商 </span></span><br><span class=\"line\">        <span class=\"comment\">//或返回null的供应商(可以是一个清除的CacheValue)</span></span><br><span class=\"line\">        <span class=\"comment\">//或一个工厂，没有成功安装CacheValue)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 懒惰地建造工厂</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (factory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            factory = <span class=\"keyword\">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (supplier == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (supplier == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// successfully installed Factory</span></span><br><span class=\"line\">                supplier = factory;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// else retry with winning supplier</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// successfully replaced</span></span><br><span class=\"line\">                <span class=\"comment\">// cleared CacheEntry / unsuccessful Factory</span></span><br><span class=\"line\">                <span class=\"comment\">// with our Factory</span></span><br><span class=\"line\">                supplier = factory;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// retry with current supplier</span></span><br><span class=\"line\">                supplier = valuesMap.get(subKey);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Supplier.get</code>方法,此处是<code>Factory</code>实现类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// serialize access</span></span><br><span class=\"line\">    <span class=\"comment\">// re-check</span></span><br><span class=\"line\">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (supplier != <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//在我们等待的时候发生了一些变化: </span></span><br><span class=\"line\">        <span class=\"comment\">//可能是我们被CacheValue替换了 </span></span><br><span class=\"line\">        <span class=\"comment\">//或因为失败而被删除-&gt; </span></span><br><span class=\"line\">        <span class=\"comment\">//返回null信号WeakCache.get()重试 </span></span><br><span class=\"line\">        <span class=\"comment\">//循环</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// else still us (supplier == this)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// create new value</span></span><br><span class=\"line\">    V value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        value = Objects.requireNonNull(valueFactory.apply(key, parameter)); ---------&gt; 进入该apply核心方法</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// remove us on failure</span></span><br><span class=\"line\">            valuesMap.remove(subKey, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 断言非空值</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> value != <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用CacheValue (WeakReference)包装值</span></span><br><span class=\"line\">    CacheValue&lt;V&gt; cacheValue = <span class=\"keyword\">new</span> CacheValue&lt;&gt;(value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// put into reverseMap</span></span><br><span class=\"line\">    reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// try replacing us with CacheValue (this should always succeed)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!valuesMap.replace(subKey, <span class=\"keyword\">this</span>, cacheValue)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">&quot;Should not reach here&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// successfully replaced us with new CacheValue -&gt; return the value</span></span><br><span class=\"line\">    <span class=\"comment\">// wrapped by it</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>apply</code>源码,此处为<code>Proxy</code>实现类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class=\"keyword\">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//验证类装入器解析此名称 指向同一个Class对象的接口</span></span><br><span class=\"line\">        Class&lt;?&gt; interfaceClass = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            interfaceClass = Class.forName(intf.getName(), <span class=\"keyword\">false</span>, loader);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (interfaceClass != intf) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(</span><br><span class=\"line\">                intf + <span class=\"string\">&quot; is not visible from class loader&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//验证Class对象实际表示接口。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(</span><br><span class=\"line\">                interfaceClass.getName() + <span class=\"string\">&quot; is not an interface&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 确认该接口不是重复的接口。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(</span><br><span class=\"line\">                <span class=\"string\">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    String proxyPkg = <span class=\"keyword\">null</span>;     <span class=\"comment\">// package to define proxy class in</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 记录非公共代理接口的包，</span></span><br><span class=\"line\">    <span class=\"comment\">// 使代理类将在同一个包中定义。</span></span><br><span class=\"line\">    <span class=\"comment\">// 验证所有的非公共代理接口都在同一个包中。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> flags = intf.getModifiers();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class=\"line\">            accessFlags = Modifier.FINAL;</span><br><span class=\"line\">            String name = intf.getName();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = name.lastIndexOf(<span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">            String pkg = ((n == -<span class=\"number\">1</span>) ? <span class=\"string\">&quot;&quot;</span> : name.substring(<span class=\"number\">0</span>, n + <span class=\"number\">1</span>));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (proxyPkg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                proxyPkg = pkg;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(</span><br><span class=\"line\">                    <span class=\"string\">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (proxyPkg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有非公共代理接口，使用  com.sun.proxy 包</span></span><br><span class=\"line\">        proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class=\"string\">&quot;.&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 为要生成的代理类选择一个名称</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class=\"line\">    <span class=\"comment\">// 这理解解释了为什么我们每次debug的时候都会有一个 com.sun.proxy.$Proxy0  这种类名</span></span><br><span class=\"line\">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//生成特定的代理类</span></span><br><span class=\"line\">    <span class=\"comment\">//在上面中我讲生成的class文件输出在了out中，就是调用了这个方法，地方使用了AccessController.doPrivileged，为native方法，由C++编写</span></span><br><span class=\"line\">    <span class=\"keyword\">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class=\"line\">        proxyName, interfaces, accessFlags);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用native方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> defineClass0(loader, proxyName,</span><br><span class=\"line\">                            proxyClassFile, <span class=\"number\">0</span>, proxyClassFile.length);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassFormatError e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//类formaterror表示(禁止代理类生成代码)还有一些其他的 提供给代理的参数的无效方面 类创建(如虚拟机限制超过)</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(e.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>小总结</p>\n</blockquote>\n<p><code>newProxyInstance</code> -&gt; <code>getProxyClass0</code> -&gt; <code>supplier.get()</code> -&gt; <code>valueFactory.apply</code> 就是生成代理类的大概原理啦，只要有兴趣，<code>debug</code>一下就可以了。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNzQ0OTU0NDMzNTQ0\">参考文章</span> </p>\n",
            "tags": [
                "Java面试",
                "JDK",
                "动态代理"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/56be7cc9/",
            "url": "https://smile1231.github.io/posts/56be7cc9/",
            "title": "关于Linux排查问题命令",
            "date_published": "2022-03-13T07:13:24.000Z",
            "content_html": "<h2 id=\"Linux命令之top\"><a href=\"#Linux命令之top\" class=\"headerlink\" title=\"Linux命令之top\"></a><code>Linux</code>命令之<code>top</code></h2><blockquote>\n<p>top - 整机性能查看</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<img data-src=\"/blog/posts/56be7cc9/2022-03-13-22-54-06.png\" class=\"\">\n\n<img data-src=\"/blog/posts/56be7cc9/2022-03-13-22-58-37.png\" class=\"\">\n\n<p>主要看<code>load average, CPU, MEN</code>三部分</p>\n<ul>\n<li><code>load average</code>表示系统负载，即任务队列的平均长度。 三个数值分别为 <code>1</code>分钟、<code>5</code>分钟、<code>15</code>分钟前到现在的平均值。</li>\n<li><code>load average</code>: 如果这个数除以逻辑<code>CPU</code>的数量，结果高于<code>5</code>的时候就表明系统在超负荷运转了。</li>\n</ul>\n<p><a href=\"https://yjclsx.blog.csdn.net/article/details/81508455\"><code>Linux</code>中<code>top</code>命令参数详解</a></p>\n<blockquote>\n<p>uptime - 系统性能命令的精简版</p>\n</blockquote>\n<img data-src=\"/blog/posts/56be7cc9/2022-03-13-23-00-56.png\" class=\"\">\n\n<h2 id=\"Linux之cpu查看vmstat-mac中为vm-stat\"><a href=\"#Linux之cpu查看vmstat-mac中为vm-stat\" class=\"headerlink\" title=\"Linux之cpu查看vmstat (mac中为vm_stat)\"></a><code>Linux</code>之<code>cpu</code>查看<code>vmstat</code> (<code>mac</code>中为<code>vm_stat</code>)</h2><img data-src=\"/blog/posts/56be7cc9/2022-03-13-23-05-38.png\" class=\"\">\n\n<ul>\n<li><code>procs</code><ul>\n<li><code>r</code>：运行和等待的<code>CPU</code>时间片的进程数，原则上<code>1</code>核的<code>CPU</code>的运行队列不要超过<code>2</code>，整个系统的运行队列不超过总核数的2倍，否则代表系统压力过大，我们看蘑菇博客测试服务器，能发现都超过了<code>2</code>，说明现在压力过大</li>\n<li><code>b</code>：等待资源的进程数，比如正在等待磁盘<code>I/O</code>、网络<code>I/O</code>等</li>\n</ul>\n</li>\n<li><code>cpu</code><br>  <code>us</code>：用户进程消耗<code>CPU</code>时间百分比，<code>us</code>值高，用户进程消耗<code>CPU</code>时间多，如果长期大于<code>50%</code>，优化程序<br>  <code>sy</code>：内核进程消耗的CPU时间百分比<br>  <code>us + sy </code>参考值为<code>80%</code>，如果<code>us + sy</code> 大于<code>80%</code>，说明可能存在<code>CPU</code>不足，从上面的图片可以看出，<code>us + sy</code>还没有超过百分80，因此说明蘑菇博客的<code>CPU</code>消耗不是很高<br>  <code>id</code>：处于空闲的<code>CPU</code>百分比<br>  <code>wa</code>：系统等待<code>IO</code>的<code>CPU</code>时间百分比<br>  <code>st</code>：来自于一个虚拟机偷取的<code>CPU</code>时间比</li>\n</ul>\n<h2 id=\"Linux之cpu查看pidstat（Mac中没有）\"><a href=\"#Linux之cpu查看pidstat（Mac中没有）\" class=\"headerlink\" title=\"Linux之cpu查看pidstat（Mac中没有）\"></a><code>Linux</code>之<code>cpu</code>查看<code>pidstat</code>（<code>Mac</code>中没有）</h2><p>查看看所有<code>cpu</code>核信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mpstat -P ALL 2</span><br></pre></td></tr></table></figure>\n\n<img data-src=\"/blog/posts/56be7cc9/2022-03-13-23-10-51.png\" class=\"\">\n\n\n<p>每个进程使用<code>cpu</code>的用量分解信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pidstat -u 1 -p 进程编号</span><br></pre></td></tr></table></figure>\n<img data-src=\"/blog/posts/56be7cc9/2022-03-13-23-11-14.png\" class=\"\">\n\n\n\n<h2 id=\"Linux之内存查看free和pidstat（Mac中没有）\"><a href=\"#Linux之内存查看free和pidstat（Mac中没有）\" class=\"headerlink\" title=\"Linux之内存查看free和pidstat（Mac中没有）\"></a><code>Linux</code>之内存查看<code>free</code>和<code>pidstat</code>（<code>Mac</code>中没有）</h2><p>应用程序可用内存数</p>\n<p>经验值</p>\n<p>应用程序可用内存l系统物理内存&gt;<code>70%</code>内存充足</p>\n<p>应用程序可用内存/系统物理内存&lt;<code>20%</code>内存不足，需要增加内存</p>\n<p><code>20%</code>&lt;应用程序可用内存/系统物理内存&lt;<code>70%</code>内存基本够用</p>\n<p><code>m/g</code>：兆/吉</p>\n<img data-src=\"/blog/posts/56be7cc9/2022-03-13-23-12-13.png\" class=\"\">\n\n<p>查看额外</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pidstat -p 进程号 -r 采样间隔秒数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Linux之硬盘查看df\"><a href=\"#Linux之硬盘查看df\" class=\"headerlink\" title=\"Linux之硬盘查看df\"></a><code>Linux</code>之硬盘查看<code>df</code></h2><p>查看磁盘剩余空间数</p>\n<img data-src=\"/blog/posts/56be7cc9/2022-03-13-23-13-22.png\" class=\"\">\n\n<h2 id=\"Linux之磁盘IO查看iostat和pidstat\"><a href=\"#Linux之磁盘IO查看iostat和pidstat\" class=\"headerlink\" title=\"Linux之磁盘IO查看iostat和pidstat\"></a><code>Linux</code>之磁盘<code>IO</code>查看<code>iostat</code>和<code>pidstat</code></h2><p>磁盘<code>I/O</code>性能评估<br><code>mac</code>:</p>\n<img data-src=\"/blog/posts/56be7cc9/2022-03-13-23-16-06.png\" class=\"\">\n\n<p><code>linux</code>:</p>\n<img data-src=\"/blog/posts/56be7cc9/2022-03-13-23-16-54.png\" class=\"\">\n\n<p>磁盘块设备分布</p>\n<ul>\n<li><code>rkB/s</code>每秒读取数据量<code>kB;wkB/s</code>每秒写入数据量<code>kB</code>;</li>\n<li><code>svctm lO</code>请求的平均服务时间，单位毫秒;</li>\n<li><code>await l/O</code>请求的平均等待时间，单位毫秒;值越小，性能越好;</li>\n<li><code>util</code>一秒中有百分几的时间用于<code>I/O</code>操作。接近<code>100%</code>时，表示磁盘带宽跑满，需要优化程序或者增加磁盘;</li>\n<li><code>rkB/s、wkB/s</code>根据系统应用不同会有不同的值，但有规律遵循:长期、超大数据读写，肯定不正常，需要优化程序读取。</li>\n<li><code>svctm</code>的值与<code>await</code>的值很接近，表示几乎没有IO等待，磁盘性能好。</li>\n<li>如果<code>await</code>的值远高于<code>svctm</code>的值，则表示<code>IO</code>队列等待太长，需要优化程序或更换更快磁盘。</li>\n</ul>\n<h2 id=\"Linux之网络IO查看ifstat\"><a href=\"#Linux之网络IO查看ifstat\" class=\"headerlink\" title=\"Linux之网络IO查看ifstat\"></a><code>Linux</code>之网络<code>IO</code>查看<code>ifstat</code></h2><p>默认本地没有，下载<code>ifstat</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://gael.roualland.free.fr/lifstat/ifstat-1.1.tar.gz</span><br><span class=\"line\">tar -xzvf ifstat-1.1.tar.gz</span><br><span class=\"line\">cd ifstat-1.1</span><br><span class=\"line\">./configure</span><br><span class=\"line\">make</span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n<p>查看网络<code>IO</code></p>\n<p>各个网卡的<code>in、out</code></p>\n<p>观察网络负载情况程序</p>\n<p>网络读写是否正常</p>\n<ul>\n<li>程序网络<code>I/O</code>优化</li>\n<li>增加网络<code>I/O</code>带宽</li>\n</ul>\n<img data-src=\"/blog/posts/56be7cc9/2022-03-13-23-19-52.png\" class=\"\">\n\n<h2 id=\"Linux查看物理CPU个数、核数、逻辑CPU个数\"><a href=\"#Linux查看物理CPU个数、核数、逻辑CPU个数\" class=\"headerlink\" title=\"Linux查看物理CPU个数、核数、逻辑CPU个数\"></a><code>Linux</code>查看物理<code>CPU</code>个数、核数、逻辑<code>CPU</code>个数</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 总核数 = 物理CPU个数 X 每颗物理CPU的核数 </span></span><br><span class=\"line\"><span class=\"comment\"># 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看物理CPU个数</span></span><br><span class=\"line\">cat /proc/cpuinfo| grep <span class=\"string\">&quot;physical id&quot;</span>| sort| uniq| wc -l</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看每个物理CPU中core的个数(即核数)</span></span><br><span class=\"line\">cat /proc/cpuinfo| grep <span class=\"string\">&quot;cpu cores&quot;</span>| uniq</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看逻辑CPU的个数 , 这是我们关心的,涉及到线程池大小</span></span><br><span class=\"line\">cat /proc/cpuinfo| grep <span class=\"string\">&quot;processor&quot;</span>| wc -l</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>查看服务器信息指令</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#查看CPU信息（型号）</span></span><br><span class=\"line\">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#查看内存信息</span></span><br><span class=\"line\">cat /proc/meminfo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#如何查看Linux 内核</span></span><br><span class=\"line\">uname -a</span><br><span class=\"line\">cat /proc/version</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#查看机器型号（机器硬件型号）</span></span><br><span class=\"line\">dmidecode | grep <span class=\"string\">&quot;Product Name&quot;</span></span><br><span class=\"line\">dmidecode</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#如何查看linux 系统版本</span></span><br><span class=\"line\">cat /etc/redhat-release</span><br><span class=\"line\">lsb_release -a</span><br><span class=\"line\">cat  /etc/issue</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#如何查看linux系统和CPU型号，类型和大小</span></span><br><span class=\"line\">cat /proc/cpuinfo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#如何查看linux 系统内存大小的信息，可以查看总内存，剩余内存，可使用内存等信息  </span></span><br><span class=\"line\">cat /proc/meminfo</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"CPU占用过高的定位分析思路\"><a href=\"#CPU占用过高的定位分析思路\" class=\"headerlink\" title=\"CPU占用过高的定位分析思路\"></a><code>CPU</code>占用过高的定位分析思路</h2><p>结合<code>Linux</code>和<code>JDK</code>命令一块分析</p>\n<p>案例步骤</p>\n<ul>\n<li>先用<code>top</code>命令找出<code>CPU</code>占比最高的</li>\n</ul>\n<img data-src=\"/blog/posts/56be7cc9/2022-03-13-23-20-27.png\" class=\"\">\n\n<ul>\n<li><p><code>ps -ef</code>或者<code>jps</code>进一步定位，得知是一个怎么样的一个后台程序作搞屎棍</p>\n<img data-src=\"/blog/posts/56be7cc9/2022-03-13-23-24-51.png\" class=\"\"></li>\n<li><p>定位到具体线程或者代码</p>\n<ul>\n<li><code>ps -mp</code> 进程 <code>-o THREAD,tid,time</code></li>\n<li><code>-m</code> 显示所有的线程</li>\n<li><code>-p pid</code>进程使用<code>cpu</code>的时间</li>\n<li><code>-o</code> 该参数后是用户自定义格式</li>\n</ul>\n</li>\n</ul>\n<img data-src=\"/blog/posts/56be7cc9/2022-03-13-23-25-31.png\" class=\"\">\n\n<ul>\n<li>将需要的线程<code>ID</code>转换为<code>16</code>进制格式（英文小写格式），命令<code>printf %x 172 </code>将<code>172</code>转换为十六进制</li>\n<li><code>jstack 进程ID | grep tid</code>（<code>16</code>进制线程<code>ID</code>小写英文）<code>-A60</code></li>\n</ul>\n<blockquote>\n<p>ps - process status<br>-A Display information about other users’ processes, including those without controlling terminals.<br>-e Identical to -A.<br>-f Display the uid, pid, parent pid, recent CPU usage, process start time, controlling tty, elapsed CPU usage, and the associated command. If the -u option is also used, display the user name rather then the numeric uid. When -o or -O is used to add to the display following -f, the command field is not truncated as severely as it is in other formats.<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6dWZlbmcvYXJ0aWNsZS9kZXRhaWxzLzgzNTM3Mjc1\">ps -ef中的e、f是什么含义</span></p>\n</blockquote>\n<p>对于<code>JDK</code>自带的<code>JVM</code>监控和性能分析工具用过哪些?一般你是怎么用的?<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4NjMwMjQvYXJ0aWNsZS9kZXRhaWxzLzEwNjY1MTA2OA==\">link</span></p>\n<h2 id=\"GitHub骚操作之awesome搜索\"><a href=\"#GitHub骚操作之awesome搜索\" class=\"headerlink\" title=\"GitHub骚操作之awesome搜索\"></a><code>GitHub</code>骚操作之<code>awesome</code>搜索</h2><ul>\n<li>公式：<code>awesome</code> 关键字：<code>awesome</code>系列，一般用来收集学习、工具、书籍类相关的项目</li>\n<li>搜索优秀的<code>redis</code>相关的项目，包括框架，教程等 <code>awesome redis</code><h2 id=\"GitHub骚操作之-L数字\"><a href=\"#GitHub骚操作之-L数字\" class=\"headerlink\" title=\"GitHub骚操作之#L数字\"></a><code>GitHub</code>骚操作之<code>#L</code>数字</h2>一行：地址后面紧跟 <code>#L10</code><br><code>https://github.com/abc/abc/pom.xml#L13</code><br>多行：地址后面紧跟 <code>#Lx - #Ln</code><br><code>https://github.com/moxi624/abc/abc/pom.xml#L13-L30</code><h2 id=\"GitHub骚操作之T搜索\"><a href=\"#GitHub骚操作之T搜索\" class=\"headerlink\" title=\"GitHub骚操作之T搜索\"></a><code>GitHub</code>骚操作之<code>T</code>搜索</h2></li>\n</ul>\n<img data-src=\"/blog/posts/56be7cc9/2022-03-13-23-31-47.png\" class=\"\">",
            "tags": [
                "Java面试",
                "Linux"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/a72f470b/",
            "url": "https://smile1231.github.io/posts/a72f470b/",
            "title": "关于JVM常用参数",
            "date_published": "2022-03-13T07:12:45.000Z",
            "content_html": "<p>笔记链接： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4NjMwMjQvYXJ0aWNsZS9kZXRhaWxzLzExNDY4NDQyOA==\">大厂面试视频</span></p>\n<h2 id=\"JVM的标配参数和X参数\"><a href=\"#JVM的标配参数和X参数\" class=\"headerlink\" title=\"JVM的标配参数和X参数\"></a><code>JVM</code>的标配参数和<code>X</code>参数</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvdG9vbHMvd2luZG93cy9qYXZhLmh0bWw=\">官方文档</span></p>\n<p><code>JVM</code>的参数类型：</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>标配参数</p>\n</blockquote>\n<ul>\n<li><code>-version java -version</code></li>\n<li><code>-help</code></li>\n</ul>\n<blockquote>\n<p><code>X</code>参数（了解）</p>\n</blockquote>\n<ul>\n<li><code>-Xint</code>：解释执行</li>\n<li><code>-Xcomp</code>：第一次使用就编译成本地代码</li>\n<li><code>-Xmixed</code>：混合模式</li>\n</ul>\n<h2 id=\"VM的XX参数之布尔类型\"><a href=\"#VM的XX参数之布尔类型\" class=\"headerlink\" title=\"VM的XX参数之布尔类型\"></a><code>VM</code>的<code>XX</code>参数之布尔类型</h2><p>公式：<code>-XX:+</code> 或者 <code>-</code> 某个属性值（<code>+</code>表示开启，<code>-</code>表示关闭）</p>\n<p>如何查看一个正在运行中的<code>java</code>程序，它的某个<code>jvm</code>参数是否开启？具体值是多少？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jps -l 查看一个正在运行中的java程序，得到Java程序号。</span><br><span class=\"line\">jinfo -<span class=\"function\">flag <span class=\"title\">PrintGCDetails</span> <span class=\"params\">(Java程序号 )</span>查看它的某个jvm参数（如PrintGCDetails ）是否开启。</span></span><br><span class=\"line\"><span class=\"function\">jinfo -<span class=\"title\">flags</span> <span class=\"params\">(Java程序号 )</span>查看它的所有jvm参数</span></span><br></pre></td></tr></table></figure>\n<p>Case</p>\n<blockquote>\n<p>是否打印<code>GC</code>收集细节</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:-PrintGCDetails</span><br><span class=\"line\">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>是否使用串行垃圾回收器</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:-UseSerialGC</span><br><span class=\"line\">-XX:+UserSerialGC</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JVM的XX参数之设值类型\"><a href=\"#JVM的XX参数之设值类型\" class=\"headerlink\" title=\"JVM的XX参数之设值类型\"></a><code>JVM</code>的<code>XX</code>参数之设值类型</h2><p>公式：<code>-XX</code>:属性<code>key=</code>属性值<code>value</code></p>\n<p>Case</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:MetaspaceSize=128m</span><br><span class=\"line\">-XX:MaxTenuringThreshold=<span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"VM的XX参数之XmsXmx坑题\"><a href=\"#VM的XX参数之XmsXmx坑题\" class=\"headerlink\" title=\"VM的XX参数之XmsXmx坑题\"></a><code>VM</code>的<code>XX</code>参数之<code>XmsXmx</code>坑题</h2><p>两个经典参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms等价于-XX:InitialHeapSize，初始大小内存，默认物理内存<span class=\"number\">1</span>/<span class=\"number\">64</span></span><br><span class=\"line\">-Xmx等价于-XX:MaxHeapSize，最大分配内存，默认为物理内存<span class=\"number\">1</span>/<span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JVM盘点家底查看初始默认\"><a href=\"#JVM盘点家底查看初始默认\" class=\"headerlink\" title=\"JVM盘点家底查看初始默认\"></a><code>JVM</code>盘点家底查看初始默认</h2><blockquote>\n<p>查看初始默认参数值</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:+PrintFlagsInitial</span><br></pre></td></tr></table></figure>\n\n<p>公式：<code>java -XX:+PrintFlagsInitial</code></p>\n<img data-src=\"/blog/posts/a72f470b/2022-03-13-15-29-37.png\" class=\"\">\n\n<blockquote>\n<p>查看修改更新参数值</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:+PrintFlagsFinal</span><br></pre></td></tr></table></figure>\n\n<p>公式：<code>java -XX:+PrintFlagsFinal</code></p>\n<img data-src=\"/blog/posts/a72f470b/2022-03-13-15-32-07.png\" class=\"\">\n\n<p><strong><code>=</code>表示默认，<code>:=</code>表示修改过的。</strong></p>\n<h2 id=\"JVM盘点家底查看修改变更值\"><a href=\"#JVM盘点家底查看修改变更值\" class=\"headerlink\" title=\"JVM盘点家底查看修改变更值\"></a><code>JVM</code>盘点家底查看修改变更值</h2><p><code>PrintFlagsFinal</code>举例，运行<code>java</code>命令的同时打印出参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -XX:+PrintFlagsFinal -XX:MetaspaceSize=512m HelloWorld</span><br><span class=\"line\"></span><br><span class=\"line\">--------------</span><br><span class=\"line\">...</span><br><span class=\"line\">   size_t MetaspaceSize                            := <span class=\"number\">536870912</span>                               &#123;pd product&#125; &#123;<span class=\"keyword\">default</span>&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>打印命令行参数</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:+PrintCommandLineFlags</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) ➜  ~ java -XX:+PrintCommandLineFlags -version</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:G1ConcRefinementThreads=<span class=\"number\">8</span> -XX:GCDrainStackTargetSize=<span class=\"number\">64</span> -XX:InitialHeapSize=<span class=\"number\">268435456</span> -XX:MaxHeapSize=<span class=\"number\">4294967296</span> -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=<span class=\"number\">251658240</span> -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br><span class=\"line\">java version <span class=\"string\">&quot;11.0.10&quot;</span> <span class=\"number\">2021</span>-<span class=\"number\">01</span>-<span class=\"number\">19</span> <span class=\"function\">LTS</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Java</span><span class=\"params\">(TM)</span> SE Runtime Environment 18.9 <span class=\"params\">(build <span class=\"number\">11.0</span><span class=\"number\">.10</span>+<span class=\"number\">8</span>-LTS-<span class=\"number\">162</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">Java <span class=\"title\">HotSpot</span><span class=\"params\">(TM)</span> 64-Bit Server VM 18.9 <span class=\"params\">(build <span class=\"number\">11.0</span><span class=\"number\">.10</span>+<span class=\"number\">8</span>-LTS-<span class=\"number\">162</span>, mixed mode)</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"堆内存初始大小快速复习\"><a href=\"#堆内存初始大小快速复习\" class=\"headerlink\" title=\"堆内存初始大小快速复习\"></a>堆内存初始大小快速复习</h2><p><code>JDK 1.8</code>之后将最初的永久代取消了，由元空间取代。</p>\n<img data-src=\"/blog/posts/a72f470b/2022-03-13-15-48-45.png\" class=\"\">\n\n<p>在<code>Java8</code>中，永久代已经被移除，被一个称为元空间的区域所取代。元空间的本质和永久代类似。</p>\n<p>元空间(<code>Java8</code>)与永久代(<code>Java7</code>)之间最大的区别在于：永久带使用的<code>JVM</code>的堆内存，但是<code>Java8</code>以后的元空间<strong>并不在虚拟机中而是使用本机物理内存</strong>。</p>\n<p>因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入<code>native memory</code>，字符串池和类的静态变量放入<code>java</code>堆中，这样可以加载多少类的元数据就不再由<code>MaxPermSize</code>控制，而由系统的实际可用空间来控制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JVMMemorySizeDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回Java虚拟机中内存的总量</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 返回Java虚拟机中试图使用的最大内存量</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(String.format(<span class=\"string\">&quot;TOTAL_MEMORY(-Xms): %d B, %.2f MB.&quot;</span>, totalMemory, totalMemory / <span class=\"number\">1024.0</span> / <span class=\"number\">1024</span>));</span><br><span class=\"line\">        System.out.println(String.format(<span class=\"string\">&quot;MAX_MEMORY(-Xmx): %d B, %.2f MB.&quot;</span>, maxMemory, maxMemory / <span class=\"number\">1024.0</span> / <span class=\"number\">1024</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<img data-src=\"/blog/posts/a72f470b/2022-03-13-15-51-39.png\" class=\"\">\n\n<h2 id=\"常用基础参数栈内存Xss讲解\"><a href=\"#常用基础参数栈内存Xss讲解\" class=\"headerlink\" title=\"常用基础参数栈内存Xss讲解\"></a>常用基础参数栈内存<code>Xss</code>讲解</h2><p>设置单个线程栈的大小，一般默认为<code>512k~1024K</code></p>\n<p>等价于<code>-XX:ThreadStackSize</code></p>\n<blockquote>\n<p>-XX:ThreadStackSize=size<br>Sets the thread stack size (in bytes). Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, g or G to indicate gigabytes. The default value depends on virtual memory.<br>The following examples show how to set the thread stack size to 1024 KB in different units:<br>-XX:ThreadStackSize=1m<br>-XX:ThreadStackSize=1024k<br>-XX:ThreadStackSize=1048576<br>This option is equivalent to <code>-Xss</code>. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvdG9vbHMvd2luZG93cy9qYXZhLmh0bWwjQkdCQ0lFRkM=\">文档</span></p>\n</blockquote>\n<h2 id=\"常用基础参数元空间MetaspaceSize讲解\"><a href=\"#常用基础参数元空间MetaspaceSize讲解\" class=\"headerlink\" title=\"常用基础参数元空间MetaspaceSize讲解\"></a>常用基础参数元空间<code>MetaspaceSize</code>讲解</h2><ul>\n<li><code>-Xmn</code>：设置年轻代大小</li>\n<li><code>-XX:MetaspaceSize</code> 设置元空间大小</li>\n</ul>\n<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制</p>\n<p>典型设置案例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms128m -Xmx4096m -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails-XX:+UseSerialGC</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用基础参数PrintGCDetails回收前后对比讲解\"><a href=\"#常用基础参数PrintGCDetails回收前后对比讲解\" class=\"headerlink\" title=\"常用基础参数PrintGCDetails回收前后对比讲解\"></a>常用基础参数<code>PrintGCDetails</code>回收前后对比讲解</h2><p><code>-XX:+PrintGCDetails</code> 输出详细<code>GC</code>收集日志信息</p>\n<p>设置参数 <code>-Xms10m -Xmx10m -XX:+PrintGCDetails</code> 运行以下程序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrintGCDetailsDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">byte</span>[] byteArray = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tTimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 778K-&gt;480K(2560K)] 778K-&gt;608K(9728K), <span class=\"number\">0.0029909</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 480K-&gt;480K(2560K)] 608K-&gt;616K(9728K), <span class=\"number\">0.0007890</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span> [PSYoungGen: 480K-&gt;0<span class=\"title\">K</span><span class=\"params\">(2560K)</span>] [ParOldGen: 136K-&gt;518<span class=\"title\">K</span><span class=\"params\">(7168K)</span>] 616K-&gt;518<span class=\"title\">K</span><span class=\"params\">(9728K)</span>, [Metaspace: 2644K-&gt;2644<span class=\"title\">K</span><span class=\"params\">(1056768K)</span>], 0.0058272 secs] [Times: user</span>=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 518K-&gt;518K(9728K), <span class=\"number\">0.0002924</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0<span class=\"title\">K</span><span class=\"params\">(2560K)</span>] [ParOldGen: 518K-&gt;506<span class=\"title\">K</span><span class=\"params\">(7168K)</span>] 518K-&gt;506<span class=\"title\">K</span><span class=\"params\">(9728K)</span>, [Metaspace: 2644K-&gt;2644<span class=\"title\">K</span><span class=\"params\">(1056768K)</span>], 0.0056906 secs] [Times: user</span>=<span class=\"number\">0.01</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat com.lun.jvm.PrintGCDetailsDemo.main(PrintGCDetailsDemo.java:<span class=\"number\">9</span>)</span><br><span class=\"line\">Heap</span><br><span class=\"line\"> PSYoungGen      total 2560K, used 61K [<span class=\"number\">0x00000000ffd00000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">  eden space 2048K, <span class=\"number\">3</span>% used [<span class=\"number\">0x00000000ffd00000</span>,<span class=\"number\">0x00000000ffd0f748</span>,<span class=\"number\">0x00000000fff00000</span>)</span><br><span class=\"line\">  from space 512K, <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000fff00000</span>,<span class=\"number\">0x00000000fff00000</span>,<span class=\"number\">0x00000000fff80000</span>)</span><br><span class=\"line\">  to   space 512K, <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000fff80000</span>,<span class=\"number\">0x00000000fff80000</span>,<span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> ParOldGen       total 7168K, used 506K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ffd00000</span>, <span class=\"number\">0x00000000ffd00000</span>)</span><br><span class=\"line\">  object space 7168K, <span class=\"number\">7</span>% used [<span class=\"number\">0x00000000ff600000</span>,<span class=\"number\">0x00000000ff67ea58</span>,<span class=\"number\">0x00000000ffd00000</span>)</span><br><span class=\"line\"> Metaspace       used 2676K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 285<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 386<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n<img data-src=\"/blog/posts/a72f470b/2022-03-13-16-04-30.png\" class=\"\">\n\n<img data-src=\"/blog/posts/a72f470b/2022-03-13-16-04-40.png\" class=\"\">\n\n<h2 id=\"常用基础参数SurvivorRatio讲解\"><a href=\"#常用基础参数SurvivorRatio讲解\" class=\"headerlink\" title=\"常用基础参数SurvivorRatio讲解\"></a>常用基础参数<code>SurvivorRatio</code>讲解</h2><img data-src=\"/blog/posts/a72f470b/2022-03-13-16-05-01.png\" class=\"\">\n\n<p>调节新生代中 <code>eden</code> 和 <code>S0、S1</code>的空间比例，默认为 <code>-XX:SuriviorRatio=8，Eden:S0:S1 = 8:1:1</code></p>\n<p>假如设置成 <code>-XX:SurvivorRatio=4</code>，则为 <code>Eden:S0:S1 = 4:1:1</code></p>\n<p><code>SurvivorRatio</code>值就是设置<code>eden</code>区的比例占多少，<code>S0</code>和<code>S1</code>相同。</p>\n<h2 id=\"常用基础参数NewRatio讲解\"><a href=\"#常用基础参数NewRatio讲解\" class=\"headerlink\" title=\"常用基础参数NewRatio讲解\"></a>常用基础参数<code>NewRatio</code>讲解</h2><p>配置年轻代<code>new</code>和老年代<code>old</code> 在堆结构的占比</p>\n<p>默认：<code>-XX:NewRatio=2</code> 新生代占<code>1</code>，老年代<code>2</code>，年轻代占整个堆的<code>1/3</code></p>\n<p><code>-XX:NewRatio=4：</code>新生代占<code>1</code>，老年代占<code>4</code>，年轻代占整个堆的<code>1/5</code>，</p>\n<p><code>NewRadio</code>值就是设置老年代的占比，剩下的<code>1</code>个新生代。</p>\n<p>新生代特别小，会造成频繁的进行<code>GC</code>收集。</p>\n<h2 id=\"常用基础参数MaxTenuringThreshold讲解\"><a href=\"#常用基础参数MaxTenuringThreshold讲解\" class=\"headerlink\" title=\"常用基础参数MaxTenuringThreshold讲解\"></a>常用基础参数<code>MaxTenuringThreshold</code>讲解</h2><p>晋升到老年代的对象年龄。</p>\n<p><code>SurvivorTo和SurvivorFrom</code>互换，原<code>SurvivorTo</code>成为下一次<code>GC</code>时的<code>SurvivorFrom</code>区，部分对象会在<code>From</code>和<code>To</code>区域中复制来复制去，如此交换<code>15</code>次（由<code>JVM</code>参数<code>MaxTenuringThreshold</code>决定，这个参数默认为<code>15</code>），最终如果还是存活，就存入老年代。</p>\n<p>这里就是调整这个次数的，默认是15，并且设置的值 在 <code>0~15</code>之间。</p>\n<p><code>-XX:MaxTenuringThreshold=0</code>：设置垃圾最大年龄。如果设置为0的话，则年轻对象不经过<code>Survivor</code>区，直接进入老年代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大的值，则年轻代对象会在<code>Survivor</code>区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概念。</p>\n",
            "tags": [
                "Java面试",
                "JVM"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/de5e33d7/",
            "url": "https://smile1231.github.io/posts/de5e33d7/",
            "title": "关于JDK中的Arrays.sort排序方法",
            "date_published": "2022-03-13T05:11:15.000Z",
            "content_html": "<p>是这样的，我们在刚学数据结构时候，都会学什么八大排序算法乱七八糟的，但是真正在写<code>Java</code>项目时，都是直接化身<code>API</code>调用工程师，<code>Arrays.sort()</code>完事，无意间点开，其实里面的玄机另有洞天。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Debug源码\"><a href=\"#Debug源码\" class=\"headerlink\" title=\"Debug源码\"></a><code>Debug</code>源码</h2><p>我们以最基础的方法<code>public static void sort(int[] a)</code>为例；</p>\n<p>点开<code>Arrays.sort()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    DualPivotQuicksort.sort(a, <span class=\"number\">0</span>, a.length - <span class=\"number\">1</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接进去，此处<code>Sort</code>有很多的重载，需要仔细注意</p>\n<p><code>Arrays.sort()</code>重载了四类方法</p>\n<ol>\n<li><code>sort(T[] a)</code>：对指定T型数组按数字升序排序。</li>\n<li><code>sort(T[] a,int formIndex, int toIndex)</code>：对指定<code>T</code>型数组的指定范围按数字升序排序。</li>\n<li><code>sort(T[] a, Comparator&lt;? supre T&gt; c)</code>: 根据指定比较器产生的顺序对指定对象数组进行排序。</li>\n<li><code>sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c)</code>: 根据指定比较器产生的顺序对指定对象数组的指定对象数组进行排序。</li>\n</ol>\n<img data-src=\"/blog/posts/de5e33d7/2022-03-13-14-55-38.png\" class=\"\">\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    如果可能合并，使用给定的工作空间数组片对数组的指定范围进行排序</span></span><br><span class=\"line\"><span class=\"comment\">    参数:</span></span><br><span class=\"line\"><span class=\"comment\">    a -要排序的数组</span></span><br><span class=\"line\"><span class=\"comment\">    left - 要排序的第一个元素的索引(包括第一个元素)</span></span><br><span class=\"line\"><span class=\"comment\">    right - 最后一个要排序的元素的下标</span></span><br><span class=\"line\"><span class=\"comment\">    Work -工作空间数组(片)</span></span><br><span class=\"line\"><span class=\"comment\">    workBase -工作数组中可用空间的来源</span></span><br><span class=\"line\"><span class=\"comment\">    workLen -工作数组的可用大小</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果要排序的数组长度小于这个常量，则优先使用快速排序，而不是归并排序。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> QUICKSORT_THRESHOLD = <span class=\"number\">286</span>;</span><br><span class=\"line\"><span class=\"comment\">//归并排序的最大运行次数。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_RUN_COUNT = <span class=\"number\">67</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right,<span class=\"keyword\">int</span>[] work, <span class=\"keyword\">int</span> workBase, <span class=\"keyword\">int</span> workLen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 小数组使用快排，阈值为286</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//快排</span></span><br><span class=\"line\">        sort(a, left, right, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//索引运行[i]是第i次运行的开始(升序或降序)。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] run = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[MAX_RUN_COUNT + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; run[<span class=\"number\">0</span>] = left;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 检查数组是否接近排序 见解释 1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = left; k &lt; right; run[count] = k) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 序列开头相等的项</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &lt; right &amp;&amp; a[k] == a[k + <span class=\"number\">1</span>])</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == right) <span class=\"keyword\">break</span>;  <span class=\"comment\">// 序列以相等的项结束</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[k] &lt; a[k + <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 升序</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (++k &lt;= right &amp;&amp; a[k - <span class=\"number\">1</span>] &lt;= a[k]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[k] &gt; a[k + <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 降序</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (++k &lt;= right &amp;&amp; a[k - <span class=\"number\">1</span>] &gt;= a[k]);</span><br><span class=\"line\">            <span class=\"comment\">//转换成一个升序序列</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> lo = run[count] - <span class=\"number\">1</span>, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> t = a[lo]; </span><br><span class=\"line\">                a[lo] = a[hi]; </span><br><span class=\"line\">                a[hi] = t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 合并一个转换后的降序序列，后面跟着升序序列</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            count--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 如果count == 归并排序的最大次数说明数组不是高度结构化的，使用快速排序代替归并排序。</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++count == MAX_RUN_COUNT) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//进入到快排</span></span><br><span class=\"line\">            sort(a, left, right, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这些不变量应该是正确的:</span></span><br><span class=\"line\">    <span class=\"comment\">//    run[0] = 0</span></span><br><span class=\"line\">    <span class=\"comment\">//    run[&lt;last&gt;] = right + 1; (terminator)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 单次相等跑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count == <span class=\"number\">1</span> &amp;&amp; run[count] &gt; right) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//单个升序或转换后的降序运行。总是检查一个最终运行是一个适当的结束符，否则我们有一个未终止的尾随运行，以处理下游。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    right++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (run[count] &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 极端情况:最后的运行不是终结者。</span></span><br><span class=\"line\">        <span class=\"comment\">//这可能发生：如果最后一次运行是一个等于运行，或有一个单元素运行在结尾。通过在末尾添加适当的终止符来解决这个问题。</span></span><br><span class=\"line\">        <span class=\"comment\">//注意，我们以(right + 1)结束，在前面加1。</span></span><br><span class=\"line\">        run[++count] = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 确定合并的交替基</span></span><br><span class=\"line\">    <span class=\"keyword\">byte</span> odd = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n = <span class=\"number\">1</span>; (n &lt;&lt;= <span class=\"number\">1</span>) &lt; count; odd ^= <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用或创建临时数组b进行合并</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] b;                 <span class=\"comment\">// temp array; alternates with a</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ao, bo;              <span class=\"comment\">// array offsets from &#x27;left&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> blen = right - left; <span class=\"comment\">// space needed for b</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (work == <span class=\"keyword\">null</span> || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class=\"line\">        work = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[blen];</span><br><span class=\"line\">        workBase = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (odd == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        System.arraycopy(a, left, work, workBase, blen);</span><br><span class=\"line\">        b = a;</span><br><span class=\"line\">        bo = <span class=\"number\">0</span>;</span><br><span class=\"line\">        a = work;</span><br><span class=\"line\">        ao = workBase - left;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        b = work;</span><br><span class=\"line\">        ao = <span class=\"number\">0</span>;</span><br><span class=\"line\">        bo = workBase - left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 归并</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> last; count &gt; <span class=\"number\">1</span>; count = last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = (last = <span class=\"number\">0</span>) + <span class=\"number\">2</span>; k &lt;= count; k += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> hi = run[k], mi = run[k - <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = run[k - <span class=\"number\">2</span>], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class=\"line\">                    b[i + bo] = a[p++ + ao];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    b[i + bo] = a[q++ + ao];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            run[++last] = hi;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((count &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = right, lo = run[count - <span class=\"number\">1</span>]; --i &gt;= lo;</span><br><span class=\"line\">                b[i + bo] = a[i + ao]</span><br><span class=\"line\">            );</span><br><span class=\"line\">            run[++last] = right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] t = a; a = b; b = t;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> o = ao; ao = bo; bo = o;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//上文快速排序入口</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果要排序的数组长度小于这个值常量，插入排序优先于快速排序。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INSERTION_SORT_THRESHOLD = <span class=\"number\">47</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 按双重Povit快速排序 对数组的指定范围进行排序</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> a 待排序数组</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> left 待排数组左索引</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> right 待排数组右索引</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> leftmost 指示这部分是否为范围的最左边</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right, <span class=\"keyword\">boolean</span> leftmost)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = right - left + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 小于47，使用插入排序</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leftmost) &#123;</span><br><span class=\"line\">           <span class=\"comment\">//传统的(没有哨兵的)插入排序，为服务器虚拟机优化，用于最左边的部分。</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> ai = a[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (ai &lt; a[j]) &#123;</span><br><span class=\"line\">                    a[j + <span class=\"number\">1</span>] = a[j];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (j-- == left) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                a[j + <span class=\"number\">1</span>] = ai;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//跳过最长升序序列。</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (left &gt;= right) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (a[++left] &gt;= a[left - <span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//来自相邻部分的每一个元素都起着作用，因此这允许我们避免每次迭代的左范围检查。</span></span><br><span class=\"line\">            <span class=\"comment\">//此外,我们使用更优化的算法，所谓的对插入排序，它更快(在快速排序的上下文中)比传统的插入排序实现。</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> a1 = a[k], a2 = a[left];</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a1 &lt; a2) &#123;</span><br><span class=\"line\">                    a2 = a1; a1 = a[left];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (a1 &lt; a[--k]) &#123;</span><br><span class=\"line\">                    a[k + <span class=\"number\">2</span>] = a[k];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                a[++k + <span class=\"number\">1</span>] = a1;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (a2 &lt; a[--k]) &#123;</span><br><span class=\"line\">                    a[k + <span class=\"number\">1</span>] = a[k];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                a[k + <span class=\"number\">1</span>] = a2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> last = a[right];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (last &lt; a[--right]) &#123;</span><br><span class=\"line\">                a[right + <span class=\"number\">1</span>] = a[right];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            a[right + <span class=\"number\">1</span>] = last;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//////////////以下为双轴快排</span></span><br><span class=\"line\">    <span class=\"comment\">// 长度/7的近似</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> seventh = (length &gt;&gt; <span class=\"number\">3</span>) + (length &gt;&gt; <span class=\"number\">6</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对五个均匀间隔的元素进行排序 ，在范围的中心元素。这些元素将被用于枢轴选择如下所述。</span></span><br><span class=\"line\">    <span class=\"comment\">//间隔的选择 根据经验，这些因素决定很好地发挥作用 各种各样的输入。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> e3 = (left + right) &gt;&gt;&gt; <span class=\"number\">1</span>; <span class=\"comment\">// The midpoint</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> e2 = e3 - seventh;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> e1 = e2 - seventh;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> e4 = e3 + seventh;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> e5 = e4 + seventh;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用插入排序对这些元素进行排序</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a[e2] &lt; a[e1]) &#123; <span class=\"keyword\">int</span> t = a[e2]; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a[e3] &lt; a[e2]) &#123; <span class=\"keyword\">int</span> t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a[e4] &lt; a[e3]) &#123; <span class=\"keyword\">int</span> t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a[e5] &lt; a[e4]) &#123; <span class=\"keyword\">int</span> t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t &lt; a[e3]) &#123; a[e4] = a[e3]; a[e3] = t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pointers</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> less  = left;  <span class=\"comment\">// The index of the first element of center part</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> great = right; <span class=\"comment\">// The index before the first element of right part</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//使用五个排序元素中的第二个和第四个作为枢轴。 </span></span><br><span class=\"line\">        <span class=\"comment\">//这些值是第一个和的廉价近似值. Note that pivot1 &lt;= pivot2.</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> pivot1 = a[e2];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pivot2 = a[e4];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * The first and the last elements to be sorted are moved to the</span></span><br><span class=\"line\"><span class=\"comment\">            * locations formerly occupied by the pivots. When partitioning</span></span><br><span class=\"line\"><span class=\"comment\">            * is complete, the pivots are swapped back into their final</span></span><br><span class=\"line\"><span class=\"comment\">            * positions, and excluded from subsequent sorting.</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">        a[e2] = a[left];</span><br><span class=\"line\">        a[e4] = a[right];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * Skip elements, which are less or greater than pivot values.</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[++less] &lt; pivot1);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[--great] &gt; pivot2);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * Partitioning:</span></span><br><span class=\"line\"><span class=\"comment\">            *</span></span><br><span class=\"line\"><span class=\"comment\">            *   left part           center part                   right part</span></span><br><span class=\"line\"><span class=\"comment\">            * +--------------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"comment\">            * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span></span><br><span class=\"line\"><span class=\"comment\">            * +--------------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"comment\">            *               ^                          ^       ^</span></span><br><span class=\"line\"><span class=\"comment\">            *               |                          |       |</span></span><br><span class=\"line\"><span class=\"comment\">            *              less                        k     great</span></span><br><span class=\"line\"><span class=\"comment\">            *</span></span><br><span class=\"line\"><span class=\"comment\">            * Invariants:</span></span><br><span class=\"line\"><span class=\"comment\">            *</span></span><br><span class=\"line\"><span class=\"comment\">            *              all in (left, less)   &lt; pivot1</span></span><br><span class=\"line\"><span class=\"comment\">            *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span></span><br><span class=\"line\"><span class=\"comment\">            *              all in (great, right) &gt; pivot2</span></span><br><span class=\"line\"><span class=\"comment\">            *</span></span><br><span class=\"line\"><span class=\"comment\">            * Pointer k is the first index of ?-part.</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">        outer:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = less - <span class=\"number\">1</span>; ++k &lt;= great; ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ak = a[k];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ak &lt; pivot1) &#123; <span class=\"comment\">// Move a[k] to left part</span></span><br><span class=\"line\">                a[k] = a[less];</span><br><span class=\"line\">                <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                    * Here and below we use &quot;a[i] = b; i++;&quot; instead</span></span><br><span class=\"line\"><span class=\"comment\">                    * of &quot;a[i++] = b;&quot; due to performance issue.</span></span><br><span class=\"line\"><span class=\"comment\">                    */</span></span><br><span class=\"line\">                a[less] = ak;</span><br><span class=\"line\">                ++less;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ak &gt; pivot2) &#123; <span class=\"comment\">// Move a[k] to right part</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (a[great] &gt; pivot2) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (great-- == k) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span> outer;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a[great] &lt; pivot1) &#123; <span class=\"comment\">// a[great] &lt;= pivot2</span></span><br><span class=\"line\">                    a[k] = a[less];</span><br><span class=\"line\">                    a[less] = a[great];</span><br><span class=\"line\">                    ++less;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// pivot1 &lt;= a[great] &lt;= pivot2</span></span><br><span class=\"line\">                    a[k] = a[great];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                    * Here and below we use &quot;a[i] = b; i--;&quot; instead</span></span><br><span class=\"line\"><span class=\"comment\">                    * of &quot;a[i--] = b;&quot; due to performance issue.</span></span><br><span class=\"line\"><span class=\"comment\">                    */</span></span><br><span class=\"line\">                a[great] = ak;</span><br><span class=\"line\">                --great;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Swap pivots into their final positions</span></span><br><span class=\"line\">        a[left]  = a[less  - <span class=\"number\">1</span>]; a[less  - <span class=\"number\">1</span>] = pivot1;</span><br><span class=\"line\">        a[right] = a[great + <span class=\"number\">1</span>]; a[great + <span class=\"number\">1</span>] = pivot2;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Sort left and right parts recursively, excluding known pivots</span></span><br><span class=\"line\">        sort(a, left, less - <span class=\"number\">2</span>, leftmost);</span><br><span class=\"line\">        sort(a, great + <span class=\"number\">2</span>, right, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * If center part is too large (comprises &gt; 4/7 of the array),</span></span><br><span class=\"line\"><span class=\"comment\">            * swap internal pivot values to ends.</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                * Skip elements, which are equal to pivot values.</span></span><br><span class=\"line\"><span class=\"comment\">                */</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (a[less] == pivot1) &#123;</span><br><span class=\"line\">                ++less;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (a[great] == pivot2) &#123;</span><br><span class=\"line\">                --great;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                * Partitioning:</span></span><br><span class=\"line\"><span class=\"comment\">                *</span></span><br><span class=\"line\"><span class=\"comment\">                *   left part         center part                  right part</span></span><br><span class=\"line\"><span class=\"comment\">                * +----------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"comment\">                * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span></span><br><span class=\"line\"><span class=\"comment\">                * +----------------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"comment\">                *              ^                        ^       ^</span></span><br><span class=\"line\"><span class=\"comment\">                *              |                        |       |</span></span><br><span class=\"line\"><span class=\"comment\">                *             less                      k     great</span></span><br><span class=\"line\"><span class=\"comment\">                *</span></span><br><span class=\"line\"><span class=\"comment\">                * Invariants:</span></span><br><span class=\"line\"><span class=\"comment\">                *</span></span><br><span class=\"line\"><span class=\"comment\">                *              all in (*,  less) == pivot1</span></span><br><span class=\"line\"><span class=\"comment\">                *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span></span><br><span class=\"line\"><span class=\"comment\">                *              all in (great, *) == pivot2</span></span><br><span class=\"line\"><span class=\"comment\">                *</span></span><br><span class=\"line\"><span class=\"comment\">                * Pointer k is the first index of ?-part.</span></span><br><span class=\"line\"><span class=\"comment\">                */</span></span><br><span class=\"line\">            outer:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = less - <span class=\"number\">1</span>; ++k &lt;= great; ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> ak = a[k];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ak == pivot1) &#123; <span class=\"comment\">// Move a[k] to left part</span></span><br><span class=\"line\">                    a[k] = a[less];</span><br><span class=\"line\">                    a[less] = ak;</span><br><span class=\"line\">                    ++less;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ak == pivot2) &#123; <span class=\"comment\">// Move a[k] to right part</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (a[great] == pivot2) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (great-- == k) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span> outer;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (a[great] == pivot1) &#123; <span class=\"comment\">// a[great] &lt; pivot2</span></span><br><span class=\"line\">                        a[k] = a[less];</span><br><span class=\"line\">                        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                            * Even though a[great] equals to pivot1, the</span></span><br><span class=\"line\"><span class=\"comment\">                            * assignment a[less] = pivot1 may be incorrect,</span></span><br><span class=\"line\"><span class=\"comment\">                            * if a[great] and pivot1 are floating-point zeros</span></span><br><span class=\"line\"><span class=\"comment\">                            * of different signs. Therefore in float and</span></span><br><span class=\"line\"><span class=\"comment\">                            * double sorting methods we have to use more</span></span><br><span class=\"line\"><span class=\"comment\">                            * accurate assignment a[less] = a[great].</span></span><br><span class=\"line\"><span class=\"comment\">                            */</span></span><br><span class=\"line\">                        a[less] = pivot1;</span><br><span class=\"line\">                        ++less;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// pivot1 &lt; a[great] &lt; pivot2</span></span><br><span class=\"line\">                        a[k] = a[great];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    a[great] = ak;</span><br><span class=\"line\">                    --great;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 对中心部分进行递归排序</span></span><br><span class=\"line\">        sort(a, less, great, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// Partitioning with one pivot</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * Use the third of the five sorted elements as pivot.</span></span><br><span class=\"line\"><span class=\"comment\">            * This value is inexpensive approximation of the median.</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> pivot = a[e3];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            * Partitioning degenerates to the traditional 3-way</span></span><br><span class=\"line\"><span class=\"comment\">            * (or &quot;Dutch National Flag&quot;) schema:</span></span><br><span class=\"line\"><span class=\"comment\">            *</span></span><br><span class=\"line\"><span class=\"comment\">            *   left part    center part              right part</span></span><br><span class=\"line\"><span class=\"comment\">            * +-------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"comment\">            * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span></span><br><span class=\"line\"><span class=\"comment\">            * +-------------------------------------------------+</span></span><br><span class=\"line\"><span class=\"comment\">            *              ^              ^        ^</span></span><br><span class=\"line\"><span class=\"comment\">            *              |              |        |</span></span><br><span class=\"line\"><span class=\"comment\">            *             less            k      great</span></span><br><span class=\"line\"><span class=\"comment\">            *</span></span><br><span class=\"line\"><span class=\"comment\">            * Invariants:</span></span><br><span class=\"line\"><span class=\"comment\">            *</span></span><br><span class=\"line\"><span class=\"comment\">            *   all in (left, less)   &lt; pivot</span></span><br><span class=\"line\"><span class=\"comment\">            *   all in [less, k)     == pivot</span></span><br><span class=\"line\"><span class=\"comment\">            *   all in (great, right) &gt; pivot</span></span><br><span class=\"line\"><span class=\"comment\">            *</span></span><br><span class=\"line\"><span class=\"comment\">            * Pointer k is the first index of ?-part.</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = less; k &lt;= great; ++k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[k] == pivot) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ak = a[k];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ak &lt; pivot) &#123; <span class=\"comment\">// Move a[k] to left part</span></span><br><span class=\"line\">                a[k] = a[less];</span><br><span class=\"line\">                a[less] = ak;</span><br><span class=\"line\">                ++less;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// a[k] &gt; pivot - Move a[k] to right part</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (a[great] &gt; pivot) &#123;</span><br><span class=\"line\">                    --great;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a[great] &lt; pivot) &#123; <span class=\"comment\">// a[great] &lt;= pivot</span></span><br><span class=\"line\">                    a[k] = a[less];</span><br><span class=\"line\">                    a[less] = a[great];</span><br><span class=\"line\">                    ++less;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// a[great] == pivot</span></span><br><span class=\"line\">                    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                        * Even though a[great] equals to pivot, the</span></span><br><span class=\"line\"><span class=\"comment\">                        * assignment a[k] = pivot may be incorrect,</span></span><br><span class=\"line\"><span class=\"comment\">                        * if a[great] and pivot are floating-point</span></span><br><span class=\"line\"><span class=\"comment\">                        * zeros of different signs. Therefore in float</span></span><br><span class=\"line\"><span class=\"comment\">                        * and double sorting methods we have to use</span></span><br><span class=\"line\"><span class=\"comment\">                        * more accurate assignment a[k] = a[great].</span></span><br><span class=\"line\"><span class=\"comment\">                        */</span></span><br><span class=\"line\">                    a[k] = pivot;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                a[great] = ak;</span><br><span class=\"line\">                --great;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//对左右部分递归排序。所有元素从中心部分是相等的，因此，已经排序。</span></span><br><span class=\"line\">        sort(a, left, less - <span class=\"number\">1</span>, leftmost);</span><br><span class=\"line\">        sort(a, great + <span class=\"number\">1</span>, right, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Tips： </p>\n<ul>\n<li>如果<code>length&lt;47</code>，那么采用插入排序算法。</li>\n<li>如果<code>47&lt;=length&lt;286</code>，或者<code>286&lt;=length</code>，但数组不具备特定结构，那么使用快速排序的一种优化形式：双轴快排算法。</li>\n<li>如果<code>286&lt;=length</code>，并且数组具备特定结构，那么使用归并排序算法。</li>\n</ul>\n<h3 id=\"解释1\"><a href=\"#解释1\" class=\"headerlink\" title=\"解释1:\"></a>解释1:</h3><p>这里主要作用是看他数组具不具备结构：实际逻辑是分组排序，每个降序序列为一个组，像<code>1,9,8,7,6,8。9</code>到<code>6</code>是降序，为一个组，然后把降序的一组排成升序：<code>1,6,7,8,9,8。</code>然后再从最后的8开始继续往后面找。</p>\n<p>每遇到这样一个降序组，<code>++count</code>，当<code>count</code>大于<code>MAX_RUN_COUNT（67）</code>，被判断为这个数组不具备结构，也就是说这数据时而升时而降，波峰波谷太多，排列太过陡峭，说明不适合采用归并排序，还是使用快速排序为宜。</p>\n<p>如果<code>count</code>少于<code>MAX_RUN_COUNT（67）</code>的，说明这个数组还有点结构，就继续往下走下面的归并排序。</p>\n<p>参考链接 :</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaGVyaXNoLWxzLmdpdGh1Yi5pby8yMDIwLzEwLzE0L0pBVkElRTUlODYlODUlRTclQkQlQUUlRTYlOEUlOTIlRTUlQkElOEZBcnJheXMtc29ydCVFNSVBRSU5RSVFNyU4RSVCMCVFNyVBRSU4MCVFOCVCRiVCMC8=\">源码讲解</span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hvbG1vZnkvYXJ0aWNsZS9kZXRhaWxzLzcxMTY4NTMw\">单轴与双轴快排</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/1599bffe/",
            "url": "https://smile1231.github.io/posts/1599bffe/",
            "title": "归并排序",
            "date_published": "2022-03-12T17:09:11.000Z",
            "content_html": "<h2 id=\"归并排序（稳定）\"><a href=\"#归并排序（稳定）\" class=\"headerlink\" title=\"归并排序（稳定）\"></a>归并排序（稳定）</h2><p>归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>\n<span id=\"more\"></span>\n\n<img data-src=\"/blog/posts/1599bffe/2022-03-13-13-44-14.png\" class=\"\">\n\n<h3 id=\"1、基本思想\"><a href=\"#1、基本思想\" class=\"headerlink\" title=\"1、基本思想\"></a>1、基本思想</h3><p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>\n<h3 id=\"2、算法描述\"><a href=\"#2、算法描述\" class=\"headerlink\" title=\"2、算法描述\"></a>2、算法描述</h3><p>归并排序可通过两种方式实现：</p>\n<ul>\n<li>自上而下的递归</li>\n<li>自下而上的迭代<br>一、递归法（假设序列共有n个元素）：</li>\n</ul>\n<p>①. 将序列每相邻两个数字进行归并操作，形成 <code>floor(n/2)</code>个序列，排序后每个序列包含两个元素；<br>②. 将上述序列再次归并，形成 <code>floor(n/4)</code>个序列，每个序列包含四个元素；<br>③. 重复步骤②，直到所有元素排序完毕。</p>\n<p>二、迭代法</p>\n<p>①. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>②. 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>③. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>④. 重复步骤③直到某一指针到达序列尾<br>⑤. 将另一序列剩下的所有元素直接复制到合并序列尾</p>\n<h3 id=\"3、代码实现\"><a href=\"#3、代码实现\" class=\"headerlink\" title=\"3、代码实现\"></a>3、代码实现</h3><p>归并排序其实要做两件事：</p>\n<ul>\n<li>分解：将序列每次折半拆分</li>\n<li>合并：将划分后的序列段两两排序合并<br>因此，归并排序实际上就是两个操作，拆分+合并</li>\n</ul>\n<p>如何合并？</p>\n<p><code>L[first…mid]</code>为第一段，<code>L[mid+1…last]</code>为第二段，并且两端已经有序，现在我们要将两端合成达到<code>L[first…last]</code>并且也有序。</p>\n<p>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给<code>temp[]</code><br>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给<code>temp[]</code><br>此时将<code>temp[]</code>中的元素复制给<code>L[]</code>，则得到的<code>L[first…last]</code>有序</p>\n<p>如何分解？</p>\n<p>在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列<br>分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p>\n<p>这里我写了递归算法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 归并排序（递归）</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</span></span><br><span class=\"line\"><span class=\"comment\"> * ②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</span></span><br><span class=\"line\"><span class=\"comment\"> * ③. 重复步骤②，直到所有元素排序完毕。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> arr\t 待排序数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] mergingSort(<span class=\"keyword\">int</span>[] arr)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arr.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = arr.length &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] leftArr = Arrays.copyOfRange(arr, <span class=\"number\">0</span>, num);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] rightArr = Arrays.copyOfRange(arr, num, arr.length);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;split two array: &quot;</span> + Arrays.toString(leftArr) + <span class=\"string\">&quot; And &quot;</span> + Arrays.toString(rightArr));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr));      <span class=\"comment\">//不断拆分为最小单元，再排序合并</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] mergeTwoArray(<span class=\"keyword\">int</span>[] arr1, <span class=\"keyword\">int</span>[] arr2)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>, k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[arr1.length + arr2.length];  <span class=\"comment\">//申请额外的空间存储合并之后的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123;      <span class=\"comment\">//选取两个序列中的较小值放入新数组</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr1[i] &lt;= arr2[j])&#123;</span><br><span class=\"line\">            result[k++] = arr1[i++];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            result[k++] = arr2[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; arr1.length)&#123;     <span class=\"comment\">//序列1中多余的元素移入新数组</span></span><br><span class=\"line\">        result[k++] = arr1[i++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &lt; arr2.length)&#123;     <span class=\"comment\">//序列2中多余的元素移入新数组</span></span><br><span class=\"line\">        result[k++] = arr2[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Merging: &quot;</span> + Arrays.toString(result));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由上, 长度为<code>n</code>的数组, 最终会调用<code>mergeSort</code>函数<code>2n-1</code>次。通过自上而下的递归实现的归并排序, 将存在堆栈溢出的风险。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAvIyVFNCVCOCU4MyVFMyU4MCU4MSVFNSVCRCU5MiVFNSVCOSVCNiVFNiU4RSU5MiVFNSVCQSU4RiVFRiVCQyU4OE1lcmdpbmctU29ydCVFRiVCQyU4OQ==\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "归并排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/14e6f1eb/",
            "url": "https://smile1231.github.io/posts/14e6f1eb/",
            "title": "冒泡排序",
            "date_published": "2022-03-12T13:58:14.000Z",
            "content_html": "<h2 id=\"冒泡排序（稳定）\"><a href=\"#冒泡排序（稳定）\" class=\"headerlink\" title=\"冒泡排序（稳定）\"></a>冒泡排序（稳定）</h2><h3 id=\"1、基本思想\"><a href=\"#1、基本思想\" class=\"headerlink\" title=\"1、基本思想\"></a>1、基本思想</h3><p>冒泡排序（<code>Bubble Sort</code>）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n<span id=\"more\"></span>\n<h3 id=\"2、算法描述\"><a href=\"#2、算法描述\" class=\"headerlink\" title=\"2、算法描述\"></a>2、算法描述</h3><p>冒泡排序算法的运作如下：</p>\n<p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>③. 针对所有的元素重复以上的步骤，除了最后一个。<br>④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</p>\n<h3 id=\"3、代码实现\"><a href=\"#3、代码实现\" class=\"headerlink\" title=\"3、代码实现\"></a>3、代码实现</h3><p>冒泡排序需要两个嵌套的循环. 其中, 外层循环移动游标; 内层循环遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = arr.length; i &gt; <span class=\"number\">0</span>; i--) &#123;      <span class=\"comment\">//外层循环移动游标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i &amp;&amp; (j+<span class=\"number\">1</span>) &lt; i; j++)&#123;    <span class=\"comment\">//内层循环遍历游标及之后(或之前)的元素</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &gt; arr[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = arr[j];</span><br><span class=\"line\">                arr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                arr[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Sorting: &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "冒泡排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/c2a5fdc5/",
            "url": "https://smile1231.github.io/posts/c2a5fdc5/",
            "title": "堆排序",
            "date_published": "2022-03-12T13:58:00.000Z",
            "content_html": "<h2 id=\"堆排序（不稳定）\"><a href=\"#堆排序（不稳定）\" class=\"headerlink\" title=\"堆排序（不稳定）\"></a>堆排序（不稳定）</h2><p>个人感觉堆排序还是挺难的，虽然会有演示动画<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAvIyVFNSU5QiU5QiVFMyU4MCU4MSVFNSVBMCU4NiVFNiU4RSU5MiVFNSVCQSU4RiVFRiVCQyU4OEhlYXAtU29ydCVFRiVCQyU4OQ==\">链接</span></p>\n<p>但是从代码层面就没有那么好的通俗</p>\n<span id=\"more\"></span>\n\n<p>堆的含义就是：完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。</p>\n<h3 id=\"1、基本思想\"><a href=\"#1、基本思想\" class=\"headerlink\" title=\"1、基本思想\"></a>1、基本思想</h3><p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p>\n<h3 id=\"2、算法描述\"><a href=\"#2、算法描述\" class=\"headerlink\" title=\"2、算法描述\"></a>2、算法描述</h3><p>①. 先将初始序列<code>K[1..n]</code>建成一个大顶堆, 那么此时第一个元素<code>K1</code>最大, 此堆为初始的无序区.<br>②. 再将关键字最大的记录<code>K1</code> (即堆顶, 第一个元素)和无序区的最后一个记录 <code>Kn</code> 交换, 由此得到新的无序区<code>K[1..n−1]</code>和有序区<code>K[n]</code>, 且满足<code>K[1..n−1].keys⩽K[n].key</code><br>③. 交换<code>K1</code> 和 <code>Kn</code> 后, 堆顶可能违反堆性质, 因此需将<code>K[1..n−1]</code>调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</p>\n<h3 id=\"3、代码实现\"><a href=\"#3、代码实现\" class=\"headerlink\" title=\"3、代码实现\"></a>3、代码实现</h3><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p>\n<p>总结起来就是定义了以下几种操作：</p>\n<ul>\n<li>最大堆调整（<code>Max_Heapify</code>）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>\n<li>创建最大堆（<code>Build_Max_Heap</code>）：将堆所有数据重新排序</li>\n<li>堆排序（<code>HeapSort</code>）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>\n</ul>\n<p>对于堆节点的访问：</p>\n<ul>\n<li>父节点i的左子节点在位置：<code>(2*i+1);</code></li>\n<li>父节点i的右子节点在位置：<code>(2*i+2);</code></li>\n<li>子节点i的父节点在位置：<code>floor((i-1)/2);</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = arr.length; i &gt; <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        max_heapify(arr, i);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[<span class=\"number\">0</span>];      <span class=\"comment\">//堆顶元素(第一个元素)与Kn交换</span></span><br><span class=\"line\">        arr[<span class=\"number\">0</span>] = arr[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        arr[i-<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">max_heapify</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> limit)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arr.length &lt;= <span class=\"number\">0</span> || arr.length &lt; limit) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> parentIdx = limit / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; parentIdx &gt;= <span class=\"number\">0</span>; parentIdx--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(parentIdx * <span class=\"number\">2</span> &gt;= limit)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = parentIdx * <span class=\"number\">2</span>;       <span class=\"comment\">//左子节点位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = (left + <span class=\"number\">1</span>) &gt;= limit ? left : (left + <span class=\"number\">1</span>);    <span class=\"comment\">//右子节点位置，如果没有右节点，默认为左节点位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxChildId = arr[left] &gt;= arr[right] ? left : right;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[maxChildId] &gt; arr[parentIdx])&#123;   <span class=\"comment\">//交换父节点与左右子节点中的最大值</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = arr[parentIdx];</span><br><span class=\"line\">            arr[parentIdx] = arr[maxChildId];</span><br><span class=\"line\">            arr[maxChildId] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Max_Heapify: &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Tips: 由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列. 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "堆排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/43d00a99/",
            "url": "https://smile1231.github.io/posts/43d00a99/",
            "title": "选择排序",
            "date_published": "2022-03-12T13:45:07.000Z",
            "content_html": "<h2 id=\"选择排序（不稳定）ON2\"><a href=\"#选择排序（不稳定）ON2\" class=\"headerlink\" title=\"选择排序（不稳定）ON2\"></a>选择排序（不稳定）ON2</h2><p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p>\n<h3 id=\"1、基本思想\"><a href=\"#1、基本思想\" class=\"headerlink\" title=\"1、基本思想\"></a>1、基本思想</h3><p>选择排序的基本思想：比较 + 交换。</p>\n<p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>\n<h3 id=\"2、算法描述\"><a href=\"#2、算法描述\" class=\"headerlink\" title=\"2、算法描述\"></a>2、算法描述</h3><p>①. 从待排序序列中，找到关键字最小的元素；<br>②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br>③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</p>\n<h3 id=\"3、代码实现\"><a href=\"#3、代码实现\" class=\"headerlink\" title=\"3、代码实现\"></a>3、代码实现</h3><p>选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">selectionSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arr.length-<span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; arr.length; j++)&#123;    <span class=\"comment\">//选出之后待排序中值最小的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class=\"line\">                min = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(min != i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = arr[min];      <span class=\"comment\">//交换操作</span></span><br><span class=\"line\">            arr[min] = arr[i];</span><br><span class=\"line\">            arr[i] = temp;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Sorting:  &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "选择排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/2b06d603/",
            "url": "https://smile1231.github.io/posts/2b06d603/",
            "title": "直接插入排序",
            "date_published": "2022-03-12T09:57:45.000Z",
            "content_html": "<h2 id=\"插入排序（稳定）\"><a href=\"#插入排序（稳定）\" class=\"headerlink\" title=\"插入排序（稳定）\"></a>插入排序（稳定）</h2><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>\n<p>①. 从第一个元素开始，该元素可以认为已经被排序<br>②. 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>③. 如果该元素（已排序）大于新元素，将该元素移到下一位置<br>④. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>⑤. 将新元素插入到该位置后<br>⑥. 重复步骤②~⑤</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertionSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; arr.length; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[i];    <span class=\"comment\">// 取出下一个元素，在已经排序的元素序列中从后向前扫描</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> j = i; j &gt;= <span class=\"number\">0</span>; j-- ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>( j &gt; <span class=\"number\">0</span> &amp;&amp; arr[j-<span class=\"number\">1</span>] &gt; temp ) &#123;</span><br><span class=\"line\">                arr[j] = arr[j-<span class=\"number\">1</span>];    <span class=\"comment\">// 如果该元素（已排序）大于取出的元素temp，将该元素移到下一位置</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Temping:  &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将新元素插入到该位置后</span></span><br><span class=\"line\">                arr[j] = temp;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Sorting:  &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交换次数较多的实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertionSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;arr.length-<span class=\"number\">1</span>; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>; j&gt;<span class=\"number\">0</span>; j-- ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>( arr[j-<span class=\"number\">1</span>] &lt;= arr[j] )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = arr[j];      <span class=\"comment\">//交换操作</span></span><br><span class=\"line\">            arr[j] = arr[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">            arr[j-<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Sorting:  &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//JDK直接插入排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a,<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ai = a[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ai &lt; a[j]) &#123;</span><br><span class=\"line\">            a[j + <span class=\"number\">1</span>] = a[j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j-- == left) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a[j + <span class=\"number\">1</span>] = ai;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGltZXRyYXZlbGVyLmdpdGh1Yi5pby8yMDE3LzA3LzE4LyVFNSU4NSVBQiVFNSVBNCVBNyVFNiU4RSU5MiVFNSVCQSU4RiVFNyVBRSU5NyVFNiVCMyU5NSVFNiU4MCVCQiVFNyVCQiU5MyVFNCVCOCU4RWphdmElRTUlQUUlOUUlRTclOEUlQjAv\">链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "直接插入排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/ff8068c0/",
            "url": "https://smile1231.github.io/posts/ff8068c0/",
            "title": "快速排序",
            "date_published": "2022-03-12T05:24:41.000Z",
            "content_html": "<h2 id=\"快排-不稳定\"><a href=\"#快排-不稳定\" class=\"headerlink\" title=\"快排 (不稳定)\"></a>快排 (不稳定)</h2><p>快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。</p>\n<h3 id=\"快速排序的原理\"><a href=\"#快速排序的原理\" class=\"headerlink\" title=\"快速排序的原理\"></a>快速排序的原理</h3><span id=\"more\"></span>\n\n<p>排序算法的思想非常简单，在待排序的数列中，我们首先要找一个数字作为基准数（这只是个专用名词）。为了方便，我们一般选择第 <code>1</code> 个数字作为基准数（其实选择第几个并没有关系）。接下来我们需要把这个待排序的数列中小于基准数的元素移动到待排序的数列的左边，把大于基准数的元素移动到待排序的数列的右边。这时，左右两个分区的元素就相对有序了；接着把两个分区的元素分别按照上面两种方法继续对每个分区找出基准数，然后移动，直到各个分区只有一个数时为止。</p>\n<p>这是典型的分治思想，即分治法。下面我们对一个实际例子进行算法描述，讲解快速排序的排序步骤。</p>\n<p><code>以 47、29、71、99、78、19、24、47</code> 的待排序的数列为例进行排序，为了方便区分两个 <code>47</code>，我们对后面的 <code>47</code> 增加一个下画线，即待排序的数列为 <code>47、29、71、99、78、19、24、47</code>。</p>\n<p>首先我们需要在数列中选择一个基准数，我们一般会选择中间的一个数或者头尾的数，这里直接选择第 <code>1</code> 个数 <code>47</code> 作为基准数，接着把比 <code>47</code> 小的数字移动到左边，把比 <code>47</code> 大的数字移动到右边，对于相等的数字不做移动。所以实际上我们需要找到中间的某个位置 <code>k</code>，这样 <code>k</code> 左边的值全部比 <code>k</code> 上的值小，<code>k</code> 右边的值全部比 <code>k</code> 上的值大。</p>\n<p>接下来开始移动元素。怎么移动呢？其实冒泡排序也涉及对元素的移动，但是那样移动起来很累，比如把最后一个元素移动到第 <code>1</code> 个，就需要比较 <code>n-1</code> 次，同时交换 <code>n-1</code> 次，效率很低。其实，只需把第 <code>1</code> 个元素和最后一个元素交换就好了，这种思想是不是在排序时可以借鉴呢？之前说快速排序就是对冒泡排序的一个改进，就是这个原因。</p>\n<p>快速排序的操作是这样的：首先从数列的右边开始往左边找，我们设这个下标为 <code>i</code>，也就是进行减减操作（<code>i--</code>），找到第 <code>1</code> 个比基准数小的值，让它与基准值交换；接着从左边开始往右边找，设这个下标为 <code>j</code>，然后执行加加操作<code>（j++）</code>，找到第 <code>1</code> 个比基准数大的值，让它与基准值交换；然后继续寻找，直到 <code>i </code>与 <code>j</code> 相遇时结束，最后基准值所在的位置即 <code>k</code> 的位置，也就是说 <code>k</code> 左边的值均比 <code>k</code> 上的值小，而 <code>k</code> 右边的值都比 <code>k </code>上的值大。</p>\n<p>所以对于上面的数列 47、29、71、99、78、19、24、 <u>47</u>，进行第 <code>1</code> 趟第 <code>1</code> 个交换的排序情况如下，第 <code>1</code> 次的操作情况如图 1 所示。</p>\n<img data-src=\"/blog/posts/ff8068c0/2022-03-12-16-52-14.png\" class=\"\">\n\n<p>交换之后，<code>j</code> 移动到了下标为 <code>6</code> 的位置，对 <code>i</code> 继续扫描，如图 <code>2</code> 所示。</p>\n<img data-src=\"/blog/posts/ff8068c0/2022-03-12-16-55-14.png\" class=\"\">\n\n<p>此时交换后的数列变为 24、29、47、99、78、19、71、<u>47</u>。接下来我们继续对 i、j 进行操作，如图 3 所示，继续进行 i– 及 j++ 的比较操作。</p>\n<img data-src=\"/blog/posts/ff8068c0/2022-03-12-16-58-42.png\" class=\"\">\n\n<p>进行了这两次 i、j 的移动、比较、交换之后，我们最终得到的数列是 24、29、19、47、78、99、71、<u>47</u>。接下来我们继续进行 i– 的操作，发现在 i 为 4 时比 47 大不用交换，在 i 为 3 时与 j 相遇，这时就不需要继续移动、比较了，已经找到 k 了，并且 k 的值为 3。我们可以确认一下当前的数列是不是 k 左边的值都比 47 小，而 k 右边的值都比 47 大（由于要保持相对位置不变，所以 47 同样在基准值 47 的右边）。</p>\n<p>47 这个值已经落到了它该在的位置，第 1 趟排序完成了。接下来就是以 k 为基准，分为两部分，然后在左右两部分分别执行上述排序操作，最后数据会分为 4 部分；接着对每部分进行操作，直到每部分都只有一个值为止。</p>\n<p>接下来进行第 2 趟排序，现在左边部分为 24、29、19，我们选择第 1 个数 24 作为基准数，接着进行 i–、j++ 的操作，我们发现 i 最初的值为 19，比 24 这个基准值小，所以与基准值进行交换，得到的数列为 19、29、24；当 j 为 1 时，我们发现 29 比 24 大，所以与基准值进行交换，得到的数列 19、24、29，此时 i 为 2，j 为 1；继续 i– 时发现 i 为 1，与 j 相遇，左边部分的数列的 k 为 1，并且左右两部分分别只有一个元素，此时第 2 轮排序的左边部分的排序结束，同时左边部分的所有数据都排序完成。</p>\n<p>我们接着看右边部分的排序，待排序的数列为 78、99、71、<u>47</u>，我们同样选择第 1 个值 78 为基准值，接下来进行 i 与 j 的移动与比较，发现 47 比 78 小，进行交换，得到的数列 47、99、71、78；从左往右发现 99 比基准值 78 大，进行交换，得到的数列为 47、78、71、99；继续从右向左看，发现 71 比基准值 78 小，进行交换，得到的数列为 <u>47</u>、71、78、99。此时 i 在整体数组中的下标为 6，j 为 5，若继续 j++ 则与 i 相遇，所以完成此轮排序。</p>\n<p>此时右边数列的 k 为 6，一般会是相遇的位置，也就是基准值所在的位置，这时数列又被分为两部分，左边是 47、71，右边是 99，需要继续对左边部分的数据进行排序，虽然只有两个数据，但我们还是继续按照快速排序的思想操作一下，选择 <u>47</u> 作为基准数，将i进行从右向左的移动、比较，发现 i 与 j 相等时没有产生移动，完成第 2 轮排序。</p>\n<p>至此，所有排序都已经完成，最终数列的结果是 19、24、29、47、47、71、78、99，怎么样，快速排序是不是非常简单地完成了所有的排序呢？虽然本次快速排序没有改变相同值的元素的顺序，但是由于快速排序需要对数列中的元素来回移动，有时还是会改变相对顺序的（比如 47 在第 1 轮的移动过程中就被移动到 47 的右边了），所以快速排序并不是一个稳定的算法。</p>\n<h2 id=\"快速排序的实现\"><a href=\"#快速排序的实现\" class=\"headerlink\" title=\"快速排序的实现\"></a>快速排序的实现</h2><p>通过以上的学习，你是否可以自己写出快速排序的实现代码呢？在接着学习之前，最好自己能对代码的实现进行一些思考，然后和下面的内容进行比对，看看自己有哪些疏忽之处。</p>\n<p>其实快速排序有一个比较简单的思想，就是递归。对于每一趟排序都是一样的思想，只不过需要进行排序的数组的范围越来越小了，使用递归实现这种排序最适合不过了。</p>\n<h3 id=\"实现一\"><a href=\"#实现一\" class=\"headerlink\" title=\"实现一\"></a>实现一</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuickSort</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] array;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">QuickSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.array = array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        quickSort(array, <span class=\"number\">0</span>, array.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            System.out.println(array[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 递归排序</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> src</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> begin</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> end</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] src, <span class=\"keyword\">int</span> begin, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (begin &lt; end) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> key = src[begin];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = begin;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = end;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (i &lt; j &amp;&amp; src[j] &gt; key) &#123;</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; j) &#123;</span><br><span class=\"line\">                    src[i] = src[j];</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (i &lt; j &amp;&amp; src[i] &lt; key) &#123;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; j) &#123;</span><br><span class=\"line\">                    src[j] = src[i];</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            src[i] = key;</span><br><span class=\"line\">            quickSort(src, begin, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">            quickSort(src, i + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现二\"><a href=\"#实现二\" class=\"headerlink\" title=\"实现二\"></a>实现二</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arr.length &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(low &gt;= high) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = high;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = arr[left];   <span class=\"comment\">//挖坑1：保存基准的值</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= temp)&#123;  <span class=\"comment\">//坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span></span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[left] = arr[right];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= temp)&#123;   <span class=\"comment\">//坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span></span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[right] = arr[left];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[left] = temp;   <span class=\"comment\">//基准值填补到坑3中，准备分治递归快排</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Sorting: &quot;</span> + Arrays.toString(arr));</span><br><span class=\"line\">    quickSort(arr, low, left-<span class=\"number\">1</span>);</span><br><span class=\"line\">    quickSort(arr, left+<span class=\"number\">1</span>, high);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"快速排序的特点及性能\"><a href=\"#快速排序的特点及性能\" class=\"headerlink\" title=\"快速排序的特点及性能\"></a>快速排序的特点及性能</h2><p>快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。</p>\n<p>但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 <code>O(n2)</code>，实际上每次比较都需要交换，但是这种情况并不常见。我们可以思考一下如果每次比较都需要交换，那么数列的平均时间复杂度是 <code>O(nlogn)</code>，事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。</p>\n<p>快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的空间复杂度为 <code>O(logn)</code>，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为<code> O(n)</code>。所以我们一般认为快速排序的空间复杂度为 <code>O(logn)</code>。</p>\n<p>快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。</p>\n<p>快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2RhdGEuYmlhbmNoZW5nLm5ldC92aWV3LzExNy5odG1s\">本文链接</span></p>\n",
            "tags": [
                "Java面试",
                "算法",
                "快速排序"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/a80d0031/",
            "url": "https://smile1231.github.io/posts/a80d0031/",
            "title": "动态规划",
            "date_published": "2022-02-17T14:58:10.000Z",
            "content_html": "<h1 id=\"动态规划算法\"><a href=\"#动态规划算法\" class=\"headerlink\" title=\"动态规划算法\"></a>动态规划算法</h1><h2 id=\"什么是动态规划\"><a href=\"#什么是动态规划\" class=\"headerlink\" title=\"什么是动态规划\"></a>什么是动态规划</h2><p>动态规划的大致思路是把一个复杂的问题转化成一个分阶段逐步递推的过程，从简单的初始状态一步一步递推，最终得到复杂问题的最优解。</p>\n<blockquote>\n<p>基本思想与策略编辑:</p>\n</blockquote>\n<p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中</p>\n<span id=\"more\"></span>\n\n<ol>\n<li><p><font color=\"red\"><strong>拆分问题</strong></font>:根据问题的可能性把问题划分成通过递推或者递归一步一步实现。关键就是这个步骤,动态规划有一类问题就是从后往前推到,有时候我们很容易知道 : 如果只有一种情况时,最佳的选择应该怎么做.然后根据这个最佳选择往前一步推导,得到前一步的最佳选择</p>\n</li>\n<li><p><font color=\"blue\">定义问题状态和状态之间的关系：</font>用一种量化的形式表现出来,类似于高中学的推导公式,因为这种式子很容易用程序写出来,也可以说对程序比较亲和(也就是最后所说的状态转移方程式)</p>\n</li>\n<li><p>动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，<font color=\"white\">前一子问题的解，为后一子问题的求解提供了有用的信息。</font>在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>\n</li>\n</ol>\n<p><strong>我的理解是</strong>：比如我们找到最优解,我们应该讲最优解保存下来,为了往前推导时能够使用前一步的最优解,在这个过程中难免有一些相比于最优解差的解,此时我们应该放弃,只保存最优解,</p>\n<p>这样我们每一次都把最优解保存了下来,大大降低了时间复杂度。</p>\n<hr/>\n\n<p>动态规划解决问题的过程分为两步：</p>\n<ol>\n<li><p>寻找状态转移方程式</p>\n</li>\n<li><p>利用状态转移方程式自底向上求解问题</p>\n</li>\n</ol>\n<h2 id=\"动态规划原理\"><a href=\"#动态规划原理\" class=\"headerlink\" title=\"动态规划原理\"></a>动态规划原理</h2><ul>\n<li>使用条件：可分为多个相关子问题，子问题的解被重复使用</li>\n<li><code>Optimal substructure（优化子结构）</code>：<ul>\n<li> 一个问题的优化解包含了子问题的优化解</li>\n<li> 缩小子问题集合，只需那些优化问题中包含的子问题，降低实现复杂性</li>\n<li> 我们可以自下而上的</li>\n</ul>\n</li>\n<li><code>Subteties（重叠子问题）</code>：在问题的求解过程中，很多子问题的解将被多次使用。</li>\n<li><strong>动态规划算法的设计步骤：</strong><ul>\n<li>分析优化解的结构</li>\n<li>递归地定义最优解的代价</li>\n<li>自底向上地计算优化解的代价保存之，并获取构造最优解的信息</li>\n<li>根据构造最优解的信息构造优化解</li>\n</ul>\n</li>\n<li>动态规划特点：<ul>\n<li>把原始问题划分成一系列子问题；</li>\n<li>求解每个子问题仅一次，并将其结果保存在一个表中，以后用到时直接存取，不重复计算，节省计算时间</li>\n<li>自底向上地计算。</li>\n<li>整体问题最优解取决于子问题的最优解（状态转移方程）（将子问题称为状态，最终状态的求解归结为其他状态的求解</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"经典例题\"><a href=\"#经典例题\" class=\"headerlink\" title=\"经典例题\"></a>经典例题</h2><h3 id=\"最长公共子序列（longest-common-subsequence-LCS）\"><a href=\"#最长公共子序列（longest-common-subsequence-LCS）\" class=\"headerlink\" title=\"最长公共子序列（longest-common-subsequence, LCS）\"></a>最长公共子序列（<code>longest-common-subsequence, LCS</code>）</h3><p><a href=\"https://leetcode-cn.com/problems/longest-common-subsequence/\"><code>LeetCode</code></a></p>\n<img data-src=\"/blog/posts/a80d0031/2022-02-17-23-18-58.png\" class=\"\">\n\n<p>(1) 子序列：一个序列<code>X ＝ x1x2...xn</code>,中任意删除若干项，剩余的序列叫做<code>A</code>的一个子序列。也可以认为是从序列<code>A</code>按原顺序保留任意若干项得到的序列。<br>      例如：对序列 <code>1,3,5,4,2,6,8,7</code>来说，序列<code>3,4,8,7</code> 是它的一个子序列。对于一个长度为<code>n</code>的序列，它一共有<code>2^n</code> 个子序列，有<code>(2^n – 1)</code>个非空子序列。在这里需要提醒大家，子序列不是子集，它和原始序列的元素顺序是相关的。</p>\n<p>(2) 公共子序列：如果序列<code>Z</code>既是序列<code>X</code>的子序列，同时也是序列Y的子序列，则称它为序列<code>X</code>和序列<code>Y</code>的公共子序列。空序列是任何两个序列的公共子序列。</p>\n<p>(3) 最长公共子序列：<code>X</code>和<code>Y</code>的公共子序列中长度最长的（包含元素最多的）叫做<code>X</code>和<code>Y</code>的最长公共子序列。</p>\n<p>这个问题如果用穷举法时间，最终求出最长公共子序列时，时间复杂度是<code>Ο（2mn）</code>，是指数级别的复杂度，对于长序列是不适用的。因此我们使用动态规划法来求解。</p>\n<h3 id=\"刻画最长公共子序列问题的最优子结构\"><a href=\"#刻画最长公共子序列问题的最优子结构\" class=\"headerlink\" title=\"刻画最长公共子序列问题的最优子结构\"></a>刻画最长公共子序列问题的最优子结构</h3><p>设<code>X=x1x2…xm</code>和<code>Y=y1y2…yn</code>是两个序列，<code>Z=z1z2…zk</code>是这两个序列的一个最长公共子序列。</p>\n<ol>\n<li><p>如果<code>xm=yn</code>，那么<code>zk=xm=yn</code>，且<code>Zk-1</code>是<code>Xm-1</code>，<code>Yn-1</code>的一个最长公共子序列；</p>\n</li>\n<li><p>如果<code>xm≠yn</code>，那么<code>zk≠xm</code>，意味着<code>Z</code>是<code>Xm-1</code>，<code>Y</code>的一个最长公共子序列；</p>\n</li>\n<li><p>如果<code>xm≠yn</code>，那么<code>zk≠yn</code>，意味着<code>Z</code>是<code>X</code>，<code>Yn-1</code>的一个最长公共子序列。</p>\n</li>\n</ol>\n<p>从上面三种情况可以看出，两个序列的<code>LCS</code>包含两个序列的前缀的<code>LCS</code>。因此，<code>LCS</code>问题具有最优子结构特征。</p>\n<h3 id=\"递归的定义最优质\"><a href=\"#递归的定义最优质\" class=\"headerlink\" title=\"递归的定义最优质\"></a>递归的定义最优质</h3><p>从最优子结构可以看出，如果<code>xm=yn</code>，那么我们应该求解<code>Xm-1</code>，<code>Yn-1</code>的一个<code>LCS</code>，并且将<code>xm=yn</code>加入到这个<code>LCS</code>的末尾，这样得到的一个新的<code>LCS</code>就是所求。</p>\n<p>如果<code>xm≠yn</code>，我们需要求解两个子问题，分别求<code>Xm-1</code>，<code>Y</code>的一个<code>LCS</code>和<code>X</code>，<code>Yn-1</code>的一个<code>LCS</code>。两个<code>LCS</code>中较长者就是<code>X</code>和<code>Y</code>的一个<code>LCS</code>。</p>\n<p>可以看出<code>LCS</code>问题具有重叠子问题性质。为了求<code>X</code>和<code>Y</code>的一个<code>LCS</code>，我们需要分别求出<code>Xm-1</code>，<code>Y</code>的一个<code>LCS</code>和<code>X</code>，<code>Yn-1</code>的一个<code>LCS</code>，这几个字问题又包含了求出<code>Xm-1</code>，<code>Yn-1</code>的一个<code>LCS</code>的子子问题。（有点绕了。。。晕没晕。。。。）</p>\n<p>根据上面的分析，我们可以得出下面的公式；</p>\n<img data-src=\"/blog/posts/a80d0031/2022-02-17-23-19-37.png\" class=\"\">\n\n<h3 id=\"计算最优的解\"><a href=\"#计算最优的解\" class=\"headerlink\" title=\"计算最优的解\"></a>计算最优的解</h3><p> 根据上面的，我们很容易就可以写出递归计算<code>LCS</code>问题的程序，通过这个程序我们可以求出各个子问题的<code>LCS</code>的值，此外，为了求解最优解本身，我们好需要一个表<code>dp，dp[i，j]</code>记录使<code>C[i，j]</code>取值的最优子结构。</p>\n<h3 id=\"数组的填表过程\"><a href=\"#数组的填表过程\" class=\"headerlink\" title=\"数组的填表过程\"></a>数组的填表过程</h3><img data-src=\"/blog/posts/a80d0031/2022-02-17-23-19-46.png\" class=\"\">\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LCS</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findLCS</span><span class=\"params\">(String A, String B)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = A.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = B.length();</span><br><span class=\"line\">        <span class=\"comment\">//返回一个字符数组，该字符数组中存放了当前字符串中的所有字符</span></span><br><span class=\"line\">        <span class=\"comment\">//返回的是字符数组char[]a</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] a = A.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] b = B.toCharArray();</span><br><span class=\"line\">        <span class=\"comment\">//创建一个二维矩阵，用来推到公共子序列</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n][m];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果找到第一列其中一个字符等于第一行第一个字符</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[i] == b[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//找到第一列与第一行b[0]的相等的值，把其变成1</span></span><br><span class=\"line\">                dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">//并将其后面的字符都变成1</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                    dp[j][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果找到第一列其中一个字符等于第一行第一个字符</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b[i] == a[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//则把第一列后面的字符都变成1</span></span><br><span class=\"line\">                dp[<span class=\"number\">0</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                    dp[<span class=\"number\">0</span>][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//从1开始是因为横向和纵向下标为0的都遍历过了</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//横向和纵向有相等的值</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a[i] == b[j]) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//当前位置左边的值+1</span></span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//取当前位置（左边的值，上边的值）的最大值</span></span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i][j - <span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                System.out.print(dp[i][j] + <span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n - <span class=\"number\">1</span>][m - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LCS lcs = <span class=\"keyword\">new</span> LCS();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> findLCS = lcs.findLCS(<span class=\"string\">&quot;android&quot;</span>, <span class=\"string\">&quot;random&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;最长子序列长度：&quot;</span> + findLCS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n",
            "tags": [
                "Java面试",
                "动态规划"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/a4ce31d2/",
            "url": "https://smile1231.github.io/posts/a4ce31d2/",
            "title": "贪心算法",
            "date_published": "2022-02-17T14:58:04.000Z",
            "content_html": "<h1 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>所谓贪心算法是指，在对问题求解时，总是做出<strong>在当前看来是最好的选择</strong>。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p>\n<p>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p>\n<span id=\"more\"></span>\n\n<p><strong>所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</strong></p>\n<h2 id=\"贪心算法的基本思路\"><a href=\"#贪心算法的基本思路\" class=\"headerlink\" title=\"贪心算法的基本思路\"></a>贪心算法的基本思路</h2><ol>\n<li><p>建立数学模型来描述问题。</p>\n</li>\n<li><p>把求解的问题分成若干个子问题。</p>\n</li>\n<li><p>对每一子问题求解，得到子问题的局部最优解。</p>\n</li>\n<li><p>把子问题的解局部最优解合成原来解问题的一个解。</p>\n</li>\n</ol>\n<h2 id=\"贪心算法的实现框架\"><a href=\"#贪心算法的实现框架\" class=\"headerlink\" title=\"贪心算法的实现框架\"></a>贪心算法的实现框架</h2><p>贪心算法适用的前提是：局部最优策略能导致产生全局最优解</p>\n<p>实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从问题的某一初始解出发；</span><br><span class=\"line\"><span class=\"keyword\">while</span> （能朝给定总目标前进一步）</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">        利用可行的决策，求出可行解的一个解元素;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">由所有解元素组合成问题的一个可行解;</span><br></pre></td></tr></table></figure>\n<h2 id=\"贪心策略的选择\"><a href=\"#贪心策略的选择\" class=\"headerlink\" title=\"贪心策略的选择\"></a>贪心策略的选择</h2><p>因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p>\n<h2 id=\"经典例题\"><a href=\"#经典例题\" class=\"headerlink\" title=\"经典例题\"></a>经典例题</h2><p>下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。</p>\n<blockquote>\n<p> [背包问题]有一个背包，背包容量是<code>M=150</code>。有<code>7</code>个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。<br>  <figure class=\"highlight plaintext\"><figcaption><span>A     B    C    D     E     F    G</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">重量 35   30   60   50   40   10   25</span><br><span class=\"line\">价值 10   40   30   50   35   40   30</span><br></pre></td></tr></table></figure><br><strong>分析：</strong></p>\n</blockquote>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">目标函数： `∑pi`最大（价值总和最大）</span><br><span class=\"line\">约束条件是装入的物品总重量不超过背包容量：`∑wi&lt;=M( M=<span class=\"number\">150</span>)`</span><br><span class=\"line\">    （<span class=\"number\">1</span>）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？</span><br><span class=\"line\">    （<span class=\"number\">2</span>）每次挑选所占重量最小的物品装入是否能得到最优解？</span><br><span class=\"line\">    （<span class=\"number\">3</span>）每次选取单位重量价值最大的物品，成为解本题的策略。</span><br></pre></td></tr></table></figure>\n<p>值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。</p>\n<p>比如，求最小生成树的<code>Prim</code>算法和<code>Kruskal</code>算法都是漂亮的贪心算法。</p>\n<p>贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。</p>\n<p>可惜的是，它需要证明后才能真正运用到题目的算法中。</p>\n<p>一般来说，<strong>贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于例题中的<span class=\"number\">3</span>种贪心策略，都是无法成立（无法被证明）的，解释如下：</span><br><span class=\"line\">   （<span class=\"number\">1</span>）贪心策略：选取价值最大者。反例：</span><br><span class=\"line\">   W=<span class=\"number\">30</span></span><br><span class=\"line\">   物品：<span class=\"keyword\">A</span>     B   C</span><br><span class=\"line\">   重量：<span class=\"number\">28</span>  <span class=\"number\">12</span>  <span class=\"number\">12</span></span><br><span class=\"line\">   价值：<span class=\"number\">30</span>  <span class=\"number\">20</span>  <span class=\"number\">20</span></span><br><span class=\"line\">   根据策略，首先选取物品<span class=\"keyword\">A</span>，接下来就无法再选取了，可是，选取B、C则更好。</span><br><span class=\"line\"></span><br><span class=\"line\">   （<span class=\"number\">2</span>）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。</span><br><span class=\"line\"></span><br><span class=\"line\">   （<span class=\"number\">3</span>）贪心策略：选取单位重量价值最大的物品。反例：</span><br><span class=\"line\">   W=<span class=\"number\">30</span></span><br><span class=\"line\">   物品： <span class=\"keyword\">A</span>   B    C</span><br><span class=\"line\">   重量：<span class=\"number\">28</span>  <span class=\"number\">20</span>  <span class=\"number\">10</span></span><br><span class=\"line\">   价值：<span class=\"number\">28</span>  <span class=\"number\">20</span>  <span class=\"number\">10</span></span><br><span class=\"line\">   根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择<span class=\"keyword\">A</span>，则答案错误。</span><br></pre></td></tr></table></figure>\n<p><strong>其实该情况是符合贪心策略的</strong>，因为该总情况不管先选哪两个都会把背包塞满，因为该题物品可以分割成任意大小，所以，就算空下一下，也可以将最后一个物品分割，放进去，它们的单位重量的价值是一样的，所以，最后背包最后重量相同，重量相同那么价值也相同。</p>\n<p><strong><font color='yellow'>所以采用第三种策略，代码如下：(不是最优解)</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreedyPackage</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> MAX_WEIGHT = <span class=\"number\">150</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] weights = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">35</span>, <span class=\"number\">30</span>, <span class=\"number\">60</span>, <span class=\"number\">50</span>, <span class=\"number\">40</span>, <span class=\"number\">10</span>, <span class=\"number\">25</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] values = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">50</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">packageGreedy</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity, <span class=\"keyword\">int</span> weights[], <span class=\"keyword\">int</span>[] values)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = weights.length;<span class=\"comment\">//物品的数量</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span>[] r = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>[n];<span class=\"comment\">//性价比数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] index = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];<span class=\"comment\">//性价比排序物品的下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            r[i] = (<span class=\"keyword\">double</span>) values[i] / weights[i];</span><br><span class=\"line\">            index[i] = i;<span class=\"comment\">//默认排序</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> temp = <span class=\"number\">0</span>;<span class=\"comment\">//对性价比进行排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//降序，对性价比和对应下标进行排序</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r[i] &lt; r[j]) &#123;</span><br><span class=\"line\">                    temp = r[i];</span><br><span class=\"line\">                    r[i] = r[j];</span><br><span class=\"line\">                    r[j] = temp;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> x = index[i];</span><br><span class=\"line\">                    index[i] = index[j];</span><br><span class=\"line\">                    index[j] = x;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//排序好的重量和价值分别存到数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] w1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] v1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"comment\">//排序好的重量和价值分别存到数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            w1[i] = weights[index[i]];</span><br><span class=\"line\">            v1[i] = values[index[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//用来装物品的数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] x = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"comment\">//放入物品的最大价值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//放入物品的总重量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalweights = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//物品重量比包的总容量小，表示还可以装得下</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (w1[i] &lt; capacity) &#123;</span><br><span class=\"line\">                x[i] = <span class=\"number\">1</span>;<span class=\"comment\">//表示该物品被装了</span></span><br><span class=\"line\">                maxValue += v1[i];</span><br><span class=\"line\">                System.out.println(w1[i] + <span class=\"string\">&quot;kg的物品被放进包包,价值：&quot;</span> + v1[i]);</span><br><span class=\"line\">                totalweights += w1[i];</span><br><span class=\"line\">                capacity = capacity - w1[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;总共放入的物品数量：&quot;</span> + Arrays.toString(x));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;总共放入的物品总重量&quot;</span> + totalweights);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;放入物品的最大价值：&quot;</span> + maxValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        GreedyPackage greedyPackage = <span class=\"keyword\">new</span> GreedyPackage();</span><br><span class=\"line\">        greedyPackage.packageGreedy(greedyPackage.MAX_WEIGHT, greedyPackage.weights, greedyPackage.values);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n",
            "tags": [
                "Java面试",
                "算法"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/7474c898/",
            "url": "https://smile1231.github.io/posts/7474c898/",
            "title": "分治算法",
            "date_published": "2022-02-17T14:57:48.000Z",
            "content_html": "<h1 id=\"分治算法\"><a href=\"#分治算法\" class=\"headerlink\" title=\"分治算法\"></a>分治算法</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>将原问题划分成<code>n</code>个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解</p>\n<h2 id=\"分治策略\"><a href=\"#分治策略\" class=\"headerlink\" title=\"分治策略\"></a>分治策略</h2><p>“分而治之”，大问题能够拆成相似的小问题，记住这些小问题需要具有相似性。而后将小问题的每个解合成为大问题的解。所以说大问题如何拆，小问题如何合并才是这个算法最主要的一个思想。实际上很多算法如贪心算法，动态规划等等都是要求把大问题拆成小问题。而分治算法的重要一点就是要适用于能够重新把小问题的解合并为大问题的解。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"使用分治算法的前提条件\"><a href=\"#使用分治算法的前提条件\" class=\"headerlink\" title=\"使用分治算法的前提条件\"></a>使用分治算法的前提条件</h2><ul>\n<li>原问题与分解成的小问题具有相同的模式；</li>\n<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，<strong>这一点是分治算法跟动态规划的明显区别；</strong></li>\n<li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li>\n<li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了</li>\n</ul>\n<h2 id=\"每一次递归都会涉及三个操作\"><a href=\"#每一次递归都会涉及三个操作\" class=\"headerlink\" title=\"每一次递归都会涉及三个操作\"></a>每一次递归都会涉及三个操作</h2><ul>\n<li><strong>分解</strong>：将原问题分解成一系列子问题；</li>\n<li><strong>解决</strong>：递归地求解各个子问题，若子问题足够小，则直接求解；</li>\n<li><strong>合并</strong>：将子问题的结果合并成原问题</li>\n</ul>\n<h2 id=\"分治法适用条件\"><a href=\"#分治法适用条件\" class=\"headerlink\" title=\"分治法适用条件\"></a>分治法适用条件</h2><ol>\n<li><p>该问题的规模缩小到一定程度就可以很容易解决；</p>\n</li>\n<li><p>该问题可以分解为若干个规模较小的相同问题，这里注意是最优子结构性质；</p>\n</li>\n<li><p>利用该问题分解出的子问题的解可以合并为该问题的解；</p>\n</li>\n<li><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共子问题；</p>\n</li>\n</ol>\n<p>　　<strong>对于很多算法而言，第一条往往是必要的，因为数据量一旦大起来，问题往往复杂度上升的特别快。这里就需要将这个大问题分解为小问题。小问题处理起来更加方便。第二、三条的才是分治思想的核心，因为很多时候我们会采用递归的方式进行解决，所以在大问题分解为小问题的时候需要保证小问题之间的相同性。单单分解为小问题之后还不能算完成，必须要能够将小问题的解合并为这个问题的最终解才能算真正用到了分治的思想。最后一条也是最关键的，各个子问题之间必须要保证独立性，即不互相影响。如果相互之间有影响，这时候我们采用的是动态规划就更加好一点。</strong></p>\n<h2 id=\"经典例题\"><a href=\"#经典例题\" class=\"headerlink\" title=\"经典例题\"></a>经典例题</h2><p>其实算法的思想不用讲太多，能够化为几句话是最好的，下面就举几个例子来看看分治算法：</p>\n<blockquote>\n<p>例题一：二分查找，给定一个按照升序排好的数组<code>array</code>，要在这个数组中找出一个特定的元素<code>x</code>；<br>当我们遇到一个问题，完全可以在心里问自己下面四个问题：</p>\n</blockquote>\n<p>　　1、当前问题能不能切分？</p>\n<p>　　答：能切分，因为数组按照升序来排列。所以当x大于某个元素array[mid]时，x一定在array[mid]的右边。以此再来切分。每次切一半</p>\n<p>　　2、分解出来的子问题相同吗？</p>\n<p>　　答：相同，每个子问题的数据集都是父问题的1/2倍。并且每次只比较子问题的中间的数据</p>\n<p>　　3、子问题的解能合并为父问题的解吗？</p>\n<p>　　答：不需要合并，子问题的解即为父问题的解。</p>\n<p>　　4、子问题之间相互独立吗？</p>\n<p>　　答：独立，子问题只是判断，不需要和父问题有很强的关联性（这里可以参考一下动态规划算法，就能理解子问题之间怎么判断是独立的）</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>分治算法只是一种思想，不是一个具体的套路，只能说在碰见具体问题时我们能够从这个思路去思考，切分问题？合并问题？子问题之间影响关联大不大？这些都是具体问题具体考虑。还有很多很多题目是用了分治算法。也可以多刷刷题</p>\n<h2 id=\"循环赛日常表\"><a href=\"#循环赛日常表\" class=\"headerlink\" title=\"循环赛日常表\"></a>循环赛日常表</h2><p>设有<code>n=2^k</code>个运动员，要进行网球循环赛。现在要设计一个满足以下要求的比赛日程表</p>\n<p>（1）每个选手必须与其他<code>n-1</code>个选手各赛一场</p>\n<p>（2）每个选手一天只能赛一次</p>\n<p>（3）循环赛一共进行<code>n-1</code>天</p>\n<p>将比赛日程表设计成<code>n</code>行<code>n</code>列，表中除了第一列，其他<code>n-1</code>列才是我们要的，数组下标行列都从<code>0</code>开始，第i行j列代表第<code>（i+1）</code>位选手在第j天的对手：</p>\n<img data-src=\"/blog/posts/7474c898/2022-02-17-23-08-53.png\" class=\"\">\n\n<p>以8个选手为例子</p>\n<img data-src=\"/blog/posts/7474c898/2022-02-17-23-09-01.png\" class=\"\">\n\n<p>①我们先初始化第一行各个数为<code>1~8</code>（<code>2~8</code>为：第<code>1</code>天 — 第<code>7</code>天）；</p>\n<p>②因为是递归，那么要填8x8的左下角和右下角，分别需要知道它的右上角和左上角</p>\n<p>③而<code>8x8</code>的盒子它的左上角是一个<code>4x4</code>的盒子，要填<code>4x4</code>的左下角和右下角，也分别需要知道它的右上角和左上角</p>\n<p>④现在递归到<code>4x4</code>的盒子的左上角，是一个<code>2x2</code>的盒子，它不需要递归了，直接沿对角线填左下角和右下角的数字，也就是上面的图②</p>\n<p>⑤可以看到，经过上面的②③步，我们左上角4x4的盒子，它的·右上角和左上角已经知道了，那就可以沿对角线填它的左下角和右下角了，所以出现了图④</p>\n<p>⑥其他的依次类推</p>\n<p>通俗易懂地讲，就是<strong>如果你想填一个大的，你得先得出它左上角和右上角两个盒子 ， 再沿对角线分别抄到右下角和左下角。 而为了得出它左上角和右上角，就需要递归了</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SportsSchedule</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleTable</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] table, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            table[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 填充左上区域矩阵</span></span><br><span class=\"line\"><span class=\"comment\">            n值的变化：8  4  2  1</span></span><br><span class=\"line\"><span class=\"comment\">            m值的变化：4  2  1  1  */</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = n / <span class=\"number\">2</span>;</span><br><span class=\"line\">            scheduleTable(table, m);</span><br><span class=\"line\">            <span class=\"comment\">//填充右上区域矩阵</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = m; j &lt; n; j++) &#123;</span><br><span class=\"line\">                    table[i][j] = table[i][j - m] + m;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//填充左下区域矩阵</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                    table[i][j] = table[i - m][j] + m;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//填充右下区域矩阵</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = m; j &lt; n; j++) &#123;</span><br><span class=\"line\">                    table[i][j] = table[i - m][j - m];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] table = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">8</span>][<span class=\"number\">8</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">8</span>;</span><br><span class=\"line\">        SportsSchedule schedule = <span class=\"keyword\">new</span> SportsSchedule();</span><br><span class=\"line\">        schedule.scheduleTable(table, n);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//打印二维数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                System.out.print(table[i][j] + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">                c++;<span class=\"comment\">//每打印一个数，c++</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c % n == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//说明打印一行了</span></span><br><span class=\"line\">                    System.out.println();<span class=\"comment\">//换行</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"L型骨牌棋盘覆盖\"><a href=\"#L型骨牌棋盘覆盖\" class=\"headerlink\" title=\"L型骨牌棋盘覆盖\"></a><code>L</code>型骨牌棋盘覆盖</h2><h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>在一个<code>2^k×2^k </code>个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格（特殊点），且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何<code>2</code>个<code>L</code>型骨牌不得重叠覆盖。</p>\n<img data-src=\"/blog/posts/7474c898/2022-02-17-23-09-17.png\" class=\"\">\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><blockquote>\n<p>分析 </p>\n</blockquote>\n<p>当<code>k&gt;0</code>时，将<code>2^k×2^k</code> 棋盘分割为<code>4</code>个<code>2^k-1×2^k-1</code> 子棋盘<code>(a)</code>所示。特殊方格必位于<code>4</code>个较小子棋盘之一中，其余<code>3</code>个子棋盘中无特殊方格。为了将这<code>3</code>个无特殊方格的子棋盘转化为特殊棋盘，可以用一个<code>L</code>型骨牌覆盖这<code>3</code>个较小棋盘的会合处，如 <code>(b)</code>所示，从而将原问题转化为<code>4</code>个较小规模的棋盘覆盖问题。递归地使用这种分割，直至棋盘简化为棋盘<code>1×1</code>。</p>\n<img data-src=\"/blog/posts/7474c898/2022-02-17-23-09-30.png\" class=\"\">\n\n<blockquote>\n<p>实现：</p>\n</blockquote>\n<p>每次都对分割后的四个小方块进行判断，判断特殊方格是否在里面。这里的判断的方法是每次先记录下整个大方块的左上角方格的行列坐标，然后再与特殊方格坐标进行比较，就可以知道特殊方格是否在该块中。如果特殊方块在里面，这直接递归下去求即可，如果不在，这根据分割的四个方块的不同位置，把右下角、左下角、右上角或者左上角的方格标记为特殊方块，然后继续递归。在递归函数里，还要有一个变量subSize来记录边的方格数，每次对方块进行划分时，边的方格数都会减半，这个变量是为了方便判断特殊方格的位置。</p>\n<blockquote>\n<p> 覆盖步骤如图：</p>\n</blockquote>\n<img data-src=\"/blog/posts/7474c898/2022-02-17-23-09-51.png\" class=\"\">\n\n<blockquote>\n<p> 代码实现:</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cn.itcast.recursion;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessBoradProblem</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[][] board;<span class=\"comment\">//棋盘</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> specialRow;<span class=\"comment\">//特殊点行下标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> specialCol;<span class=\"comment\">//特殊点列下标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;<span class=\"comment\">//矩阵大小</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> type = <span class=\"number\">0</span>;<span class=\"comment\">//骨牌类型，1,2,3,4  因为是用数字表示的，所以用int</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChessBoradProblem</span><span class=\"params\">(<span class=\"keyword\">int</span> specialRow, <span class=\"keyword\">int</span> specialCol, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.specialRow = specialRow;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.specialCol = specialCol;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">        board = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[size][size];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> specialRow 特殊点的行下标</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> specialCol 特殊点的列下标</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leftRow    分割成4个后每个矩阵的左边的起点行下标</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leftCol    分割成4个后每个矩阵的左边起点列下标</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> size       矩阵的宽或者高</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//相对于四个方格中右上的方格，左边起点的leftRow不一定是0了</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ChessBoard</span><span class=\"params\">(<span class=\"keyword\">int</span> specialRow, <span class=\"keyword\">int</span> specialCol, <span class=\"keyword\">int</span> leftRow, <span class=\"keyword\">int</span> leftCol, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> subSize = size / <span class=\"number\">2</span>;</span><br><span class=\"line\">        type = type % <span class=\"number\">4</span> + <span class=\"number\">1</span>;<span class=\"comment\">//不断+1，超过4就取模</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = type;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//假设特殊点在左上角，然后行和列都小于一半</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specialRow &lt; leftRow + subSize &amp;&amp; specialCol &lt; leftCol + subSize) &#123;</span><br><span class=\"line\">            ChessBoard(specialRow, specialCol, leftRow, leftCol, subSize);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//不在左上角，左上角矩阵的右下角就是特殊点</span></span><br><span class=\"line\">            board[leftRow + subSize - <span class=\"number\">1</span>][leftCol + subSize - <span class=\"number\">1</span>] = n;</span><br><span class=\"line\">            ChessBoard(leftRow + subSize - <span class=\"number\">1</span>, leftRow + subSize - <span class=\"number\">1</span>, leftRow, leftCol, subSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//特殊点在右上方，行小于一半，列大于一半</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specialRow &lt; leftRow + subSize &amp;&amp; specialCol &gt;= leftCol + subSize) &#123;</span><br><span class=\"line\">            ChessBoard(specialRow, specialCol, leftRow, leftCol + subSize, subSize);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            board[leftRow + subSize - <span class=\"number\">1</span>][leftCol + subSize] = n;</span><br><span class=\"line\">            ChessBoard(leftRow + subSize - <span class=\"number\">1</span>, leftCol + subSize, leftRow, leftCol + subSize, subSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//特殊点在左下方</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specialRow &gt;= leftRow + subSize &amp;&amp; specialCol &lt; leftCol + subSize) &#123;</span><br><span class=\"line\">            ChessBoard(specialRow, specialCol, leftRow + subSize, leftCol, subSize);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            board[leftRow + subSize][leftCol + subSize - <span class=\"number\">1</span>] = n;</span><br><span class=\"line\">            ChessBoard(leftRow + subSize, leftCol + subSize - <span class=\"number\">1</span>, leftRow + subSize, leftCol, subSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//特殊点在右下方</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specialRow &gt;= leftRow + subSize &amp;&amp; specialCol &gt;= leftCol + subSize) &#123;</span><br><span class=\"line\">            ChessBoard(specialRow, specialCol, leftRow + subSize, leftCol + subSize, subSize);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            board[leftRow + subSize][leftCol + subSize] = n;</span><br><span class=\"line\">            ChessBoard(leftRow + subSize, leftCol + subSize, leftRow + subSize, leftCol + subSize, subSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printBoard</span><span class=\"params\">(<span class=\"keyword\">int</span> specialRow, <span class=\"keyword\">int</span> specialCol, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        ChessBoard(specialRow, specialCol, <span class=\"number\">0</span>, <span class=\"number\">0</span>, size);</span><br><span class=\"line\">        printResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">printResult</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; size; j++) &#123;</span><br><span class=\"line\">                System.out.print(board[i][j] + <span class=\"string\">&quot; &quot;</span>);<span class=\"comment\">//注意：print</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = <span class=\"number\">4</span>;<span class=\"comment\">//矩阵大小</span></span><br><span class=\"line\">        <span class=\"comment\">//选取特殊点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> specialRow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specialCol = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ChessBoradProblem boradProblem = <span class=\"keyword\">new</span> ChessBoradProblem(specialRow, specialCol, N);</span><br><span class=\"line\">        boradProblem.printBoard(specialRow, specialCol, N);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n",
            "tags": [
                "Java面试",
                "算法"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/b9b9f7e7/",
            "url": "https://smile1231.github.io/posts/b9b9f7e7/",
            "title": "二叉树遍历",
            "date_published": "2022-02-17T14:52:52.000Z",
            "content_html": "<h1 id=\"二叉树遍历（前序、中序、后序、层次遍历）\"><a href=\"#二叉树遍历（前序、中序、后序、层次遍历）\" class=\"headerlink\" title=\"二叉树遍历（前序、中序、后序、层次遍历）\"></a>二叉树遍历（前序、中序、后序、层次遍历）</h1><p>二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆了。所以，对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。</p>\n<p>四种主要的遍历思想为：</p>\n<span id=\"more\"></span>\n\n<p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p>\n<p>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</p>\n<p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p>\n<p>层次遍历：只需按层次遍历即可</p>\n<p>例如，求下面二叉树的各种遍历</p>\n<img data-src=\"/blog/posts/b9b9f7e7/2022-02-17-22-57-21.png\" class=\"\">\n\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">前序遍历：1 <span class=\"number\"> 2 </span><span class=\"number\"> 4 </span><span class=\"number\"> 5 </span><span class=\"number\"> 7 </span><span class=\"number\"> 8 </span><span class=\"number\"> 3 </span><span class=\"number\"> 6 </span></span><br><span class=\"line\"></span><br><span class=\"line\">中序遍历：4 <span class=\"number\"> 2 </span><span class=\"number\"> 7 </span><span class=\"number\"> 5 </span><span class=\"number\"> 8 </span><span class=\"number\"> 1 </span><span class=\"number\"> 3 </span> 6</span><br><span class=\"line\"></span><br><span class=\"line\">后序遍历：4 <span class=\"number\"> 7 </span><span class=\"number\"> 8 </span><span class=\"number\"> 5 </span><span class=\"number\"> 2 </span><span class=\"number\"> 6 </span><span class=\"number\"> 3 </span> 1</span><br><span class=\"line\"></span><br><span class=\"line\">层次遍历：1 <span class=\"number\"> 2 </span><span class=\"number\"> 3 </span><span class=\"number\"> 4 </span><span class=\"number\"> 5 </span><span class=\"number\"> 6 </span><span class=\"number\"> 7 </span> 8</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-前序遍历\"><a href=\"#1-前序遍历\" class=\"headerlink\" title=\"1. 前序遍历\"></a>1. 前序遍历</h2><ol>\n<li><p>根据上文提到的遍历思路, <code>根结点 ---&gt; 左子树 ---&gt; 右子树</code>，很容易写出递归版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrderTraverse1</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tSystem.out.print(root.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t\tpreOrderTraverse1(root.left);</span><br><span class=\"line\">\t\tpreOrderTraverse1(root.right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>现在讨论非递归的版本：</p>\n<p> 根据前序遍历的顺序，优先访问根结点，然后在访问左子树和右子树。所以，对于任意结点<code>node</code>，第一部分即直接访问之，之后在判断左子树是否为空，不为空时即重复上面的步骤，直到其为空。若为空，则需要访问右子树。注意，在访问过左孩子之后，需要反过来访问其右孩子，所以，需要<strong>栈</strong>这种数据结构的支持。对于任意一个结点<code>node</code>，具体步骤如下：</p>\n<p> a) 访问之，并把结点<code>node</code>入栈，当前结点置为左孩子；</p>\n<p> b) 判断结点<code>node</code>是否为空，若为空，则取出栈顶结点并出栈，将右孩子置为当前结点；否则重复<code>a)</code> 步直到当前结点为空或者栈为空（可以发现栈中的结点就是为了访问右孩子才存储的）</p>\n<p> 代码如下:</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrderTraverse2</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\tLinkedList&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">\tTreeNode pNode = root;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pNode != <span class=\"keyword\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.print(pNode.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t\t\tstack.push(pNode);</span><br><span class=\"line\">\t\t\tpNode = pNode.left;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class=\"line\">\t\t\tTreeNode node = stack.pop();</span><br><span class=\"line\">\t\t\tpNode = node.right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2-中序遍历\"><a href=\"#2-中序遍历\" class=\"headerlink\" title=\"2. 中序遍历\"></a>2. 中序遍历</h2><ol>\n<li><p>根据上文提到的遍历思路：<code>左子树 ---&gt; 根结点 ---&gt; 右子树</code>，很容易写出递归版本：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrderTraverse1</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tinOrderTraverse1(root.left);</span><br><span class=\"line\">\t\tSystem.out.print(root.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t\tinOrderTraverse1(root.right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>非递归实现，有了上面前序的解释，中序也就比较简单了，相同的道理。只不过访问的顺序移到出栈时。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrderTraverse2</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\tLinkedList&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">\tTreeNode pNode = root;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pNode != <span class=\"keyword\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tstack.push(pNode);</span><br><span class=\"line\">\t\t\tpNode = pNode.left;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class=\"line\">\t\t\tTreeNode node = stack.pop();</span><br><span class=\"line\">\t\t\tSystem.out.print(node.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t\t\tpNode = node.right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-后续遍历\"><a href=\"#3-后续遍历\" class=\"headerlink\" title=\"3. 后续遍历\"></a>3. 后续遍历</h2></li>\n<li><p>根据上文提到的遍历思路：<code>左子树 ---&gt; 右子树 ---&gt; 根结点</code>，很容易写出递归版本：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postOrderTraverse1</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tpostOrderTraverse1(root.left);</span><br><span class=\"line\">\t\tpostOrderTraverse1(root.right);</span><br><span class=\"line\">\t\tSystem.out.print(root.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"4-层次遍历\"><a href=\"#4-层次遍历\" class=\"headerlink\" title=\"4. 层次遍历\"></a>4. 层次遍历</h2><p>层次遍历的代码比较简单，只需要一个队列即可，先在队列中加入根结点。之后对于任意一个结点来说，在其出队列的时候，访问之。同时如果左孩子和右孩子有不为空的，入队列。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">levelTraverse</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LinkedList&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    queue.offer(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode node = queue.poll();</span><br><span class=\"line\">        System.out.print(node.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            queue.offer(node.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            queue.offer(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二叉树的深度优先遍历（DFS）与广度优先遍历（BFS）\"><a href=\"#二叉树的深度优先遍历（DFS）与广度优先遍历（BFS）\" class=\"headerlink\" title=\"二叉树的深度优先遍历（DFS）与广度优先遍历（BFS）\"></a>二叉树的深度优先遍历（<code>DFS</code>）与广度优先遍历（<code>BFS</code>）</h1><p>二叉树的深度优先遍历（<code>DFS</code>）与广度优先遍历（<code>BFS</code>）</p>\n<ul>\n<li><p><strong>深度优先遍历</strong>：从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点为止。</p>\n</li>\n<li><p><strong>广度优先遍历</strong>：从根节点出发，在横向遍历二叉树层段节点的基础上纵向遍历二叉树的层次。</p>\n</li>\n</ul>\n<img data-src=\"/blog/posts/b9b9f7e7/2022-02-17-23-00-13.png\" class=\"\">\n\n\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">DFS:</span>ABDECFG</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">BFS:</span>ABCDEFG</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>DFS</code>实现：</p>\n<p>  数据结构：栈</p>\n<p>  父节点入栈，父节点出栈，先右子节点入栈，后左子节点入栈。递归遍历全部节点即可</p>\n</li>\n<li><p><code>BFS</code>实现：</p>\n<p>  数据结构：队列</p>\n<p>  父节点入队，父节点出队列，先左子节点入队，后右子节点入队。递归遍历全部节点即可</p>\n</li>\n</ul>\n<img data-src=\"/blog/posts/b9b9f7e7/2022-02-17-23-00-38.png\" class=\"\">\n\n<p>深度优先搜索的步骤为：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）、首先节点<span class=\"number\"> 1 </span>进栈，节点1在栈顶；</span><br><span class=\"line\"></span><br><span class=\"line\">（2）、然后节点1出栈，访问节点1，节点1的孩子节点3进栈，节点2进栈；</span><br><span class=\"line\"></span><br><span class=\"line\">（3）、节点2在栈顶，然后节点2出栈，访问节点2</span><br><span class=\"line\"></span><br><span class=\"line\">（4）、节点2的孩子节点5进栈，节点4进栈</span><br><span class=\"line\"></span><br><span class=\"line\">（5）、节点4在栈顶，节点4出栈，访问节点4，</span><br><span class=\"line\"></span><br><span class=\"line\">（6）、节点4左右孩子为空，然后节点5在栈顶，节点5出栈，访问节点5；</span><br><span class=\"line\"></span><br><span class=\"line\">（7）、节点5左右孩子为空，然后节点3在站顶，节点3出栈，访问节点3；</span><br><span class=\"line\"></span><br><span class=\"line\">（8）、节点3的孩子节点7进栈，节点6进栈</span><br><span class=\"line\"></span><br><span class=\"line\">（9）、节点6在栈顶，节点6出栈，访问节点6；</span><br><span class=\"line\"></span><br><span class=\"line\">（10）、节点6的孩子为空，这个时候节点7在栈顶，节点7出栈，访问节点7</span><br><span class=\"line\"></span><br><span class=\"line\">（11）、节点7的左右孩子为空，此时栈为空，遍历结束。</span><br></pre></td></tr></table></figure>\n<p>广度优先遍历：广度优先遍历是连通图的一种遍历策略，因为它的思想是从一个顶点V0开始，辐射状地优先遍历其周围较广的区域故得名。</p>\n<p>根据广度优先遍历的特点我们利用Java数据结构队列Queue来实现。</p>\n<p>广度优先搜索的步骤为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）、节点1进队，节点1出队，访问节点1</span><br><span class=\"line\"></span><br><span class=\"line\">（2）、节点1的孩子节点2进队，节点3进队。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）、节点2出队，访问节点2，节点2的孩子节点4进队，节点5进队；</span><br><span class=\"line\"></span><br><span class=\"line\">（4）、节点3出队，访问节点3，节点3的孩子节点6进队，节点7进队；</span><br><span class=\"line\"></span><br><span class=\"line\">（5）、节点4出队，访问节点4，节点4没有孩子节点。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）、节点5出队，访问节点5，节点5没有孩子节点。</span><br><span class=\"line\"></span><br><span class=\"line\">（7）、节点6出队，访问节点6，节点6没有孩子节点。</span><br><span class=\"line\"></span><br><span class=\"line\">（8）、节点7出队，访问节点7，节点7没有孩子节点，结束。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-深度优先遍历\"><a href=\"#5-深度优先遍历\" class=\"headerlink\" title=\"5. 深度优先遍历\"></a>5. 深度优先遍历</h2><p>其实深度遍历就是上面的前序、中序和后序。但是为了保证与广度优先遍历相照应，也写在这。代码也比较好理解，其实就是前序遍历，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">depthOrderTraverse</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LinkedList&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode node = stack.pop();</span><br><span class=\"line\">        System.out.print(node.val+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            stack.push(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            stack.push(node.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-广度优先遍历\"><a href=\"#6-广度优先遍历\" class=\"headerlink\" title=\"6. 广度优先遍历\"></a>6. 广度优先遍历</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">depthFirstSearch</span><span class=\"params\">(TreeNode nodeHead)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nodeHead==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; myStack=<span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    myStack.add(nodeHead);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!myStack.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode node=myStack.pop();    <span class=\"comment\">//弹出栈顶元素</span></span><br><span class=\"line\">        System.out.print(node.data+<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node.rightNode!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            myStack.push(node.rightNode);    <span class=\"comment\">//深度优先遍历，先遍历左边，后遍历右边,栈先进后出</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node.leftNode!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            myStack.push(node.leftNode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n",
            "tags": [
                "Java面试",
                "算法"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/7e4601e3/",
            "url": "https://smile1231.github.io/posts/7e4601e3/",
            "title": "面试之旅之关于Spring事务处理",
            "date_published": "2022-02-16T13:14:23.000Z",
            "content_html": "<h1 id=\"Spring事务处理\"><a href=\"#Spring事务处理\" class=\"headerlink\" title=\"Spring事务处理\"></a><code>Spring</code>事务处理</h1><h2 id=\"Spring和事务的关系\"><a href=\"#Spring和事务的关系\" class=\"headerlink\" title=\"Spring和事务的关系\"></a><code>Spring</code>和事务的关系</h2><p>关系型数据库、某些消息队列等产品或中间件称为事务性资源，因为它们本身支持事务，也能够处理事务。</p>\n<p><code>Spring</code>很显然不是事务性资源，但是它可以管理事务性资源，所以<code>Spring</code>和事务之间是管理关系。</p>\n<p>就像<code>Jack Ma</code>虽然不会写代码，但是他却管理者一大批会写代码的码农。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Spring事务三要素\"><a href=\"#Spring事务三要素\" class=\"headerlink\" title=\"Spring事务三要素\"></a><code>Spring</code>事务三要素</h2><ul>\n<li><p>数据源：表示具体的事务性资源，是事务的真正处理者，如<code>MySQL</code>等。</p>\n</li>\n<li><p>事务管理器：像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。</p>\n</li>\n<li><p>事务应用和属性配置：像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属性如隔离级别、超时时间等。</p>\n</li>\n</ul>\n<h2 id=\"Spring事务的注解配置\"><a href=\"#Spring事务的注解配置\" class=\"headerlink\" title=\"Spring事务的注解配置\"></a><code>Spring</code>事务的注解配置</h2><ul>\n<li><p>把一个<code>DataSource（如DruidDataSource）</code>作为一个<code>@Bean</code>注册到<code>Spring</code>容器中，配置好事务性资源。</p>\n</li>\n<li><p>把一个<code>@EnableTransactionManagement</code>注解放到一个<code>@Configuration</code>类上，配置好事务管理器，并启用事务管理。</p>\n</li>\n<li><p>把一个<code>@Transactional</code>注解放到类上或方法上，可以设置注解的属性，表明该方法按配置好的属性参与到事务中。</p>\n</li>\n</ul>\n<h2 id=\"事务注解的本质\"><a href=\"#事务注解的本质\" class=\"headerlink\" title=\"事务注解的本质\"></a>事务注解的本质</h2><ul>\n<li><p><code>@Transactional</code>这个注解仅仅是一些（和事务相关的）元数据，在运行时被事务基础设施读取消费，并使用这些元数据来配置<code>bean</code>的事务行为。</p>\n</li>\n<li><p>大致来说具有两方面功能，一是表明该方法要参与事务，二是配置相关属性来定制事务的参与方式和运行行为。</p>\n</li>\n</ul>\n<h2 id=\"Spring声明式事务实现原理\"><a href=\"#Spring声明式事务实现原理\" class=\"headerlink\" title=\"Spring声明式事务实现原理\"></a><code>Spring</code>声明式事务实现原理</h2><p>声明式事务成为可能，主要得益于<code>Spring AOP</code>。使用一个事务拦截器，在方法调用的前后/周围进行事务性增强（<code>advice</code>），来驱动事务完成。</p>\n<h2 id=\"如何回滚一个事务\"><a href=\"#如何回滚一个事务\" class=\"headerlink\" title=\"如何回滚一个事务\"></a>如何回滚一个事务</h2><p>就是在一个事务上下文中当前正在执行的代码里抛出一个异常，事务基础设施代码会捕获任何未处理的异常，并且做出决定是否标记这个事务为回滚。</p>\n<h2 id=\"默认回滚规则\"><a href=\"#默认回滚规则\" class=\"headerlink\" title=\"默认回滚规则\"></a>默认回滚规则</h2><p>默认只把<code>runtime</code>, <code>unchecked exceptions</code>标记为回滚，即<code>RuntimeException</code>及其子类，<code>Error</code>默认也导致回滚。<code>Checked exceptions</code>默认不导致回滚。这些规则和<code>EJB</code>是一样的。</p>\n<h2 id=\"如何配置回滚异常\"><a href=\"#如何配置回滚异常\" class=\"headerlink\" title=\"如何配置回滚异常\"></a>如何配置回滚异常</h2><p>使用<code>@Transactional</code>注解的<code>rollbackFor/rollbackForClassName</code>属性，可以精确配置导致回滚的异常类型，包括<code>checked exceptions</code>。</p>\n<p><code>noRollbackFor/noRollbackForClassName</code>属性，可以配置不导致回滚的异常类型，当遇到这样的未处理异常时，照样提交相关事务。</p>\n<h2 id=\"事务注解在类-方法上\"><a href=\"#事务注解在类-方法上\" class=\"headerlink\" title=\"事务注解在类/方法上\"></a>事务注解在类/方法上</h2><p><code>@Transactional</code>注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的所有方法。如果此时方法上也标注了，则方法上的优先级高。</p>\n<h2 id=\"事务注解在类上的继承性\"><a href=\"#事务注解在类上的继承性\" class=\"headerlink\" title=\"事务注解在类上的继承性\"></a>事务注解在类上的继承性</h2><p><code>@Transactional</code>注解的作用可以传播到子类，即如果父类标了子类就不用标了。但倒过来就不行了。</p>\n<p>子类标了，并不会传到父类，所以父类方法不会有事务。父类方法需要在子类中重新声明而参与到子类上的注解，这样才会有事务。</p>\n<h2 id=\"事务注解在接口-类上\"><a href=\"#事务注解在接口-类上\" class=\"headerlink\" title=\"事务注解在接口/类上\"></a>事务注解在接口/类上</h2><p><code>@Transactional</code>注解可以用在接口上，也可以在类上。在接口上时，必须使用基于接口的代理才行，即<code>JDK</code>动态代理。</p>\n<p>事实是<code>Java</code>的注解不能从接口继承，如果你使用基于类的代理，即<code>CGLIB</code>，或基于织入方面，即<code>AspectJ</code>，事务设置不会被代理和织入基础设施认出来，目标对象不会被包装到一个事务代理中。</p>\n<p><code>Spring</code>团队建议注解标注在类上而非接口上。</p>\n<h2 id=\"只在public方法上生效？\"><a href=\"#只在public方法上生效？\" class=\"headerlink\" title=\"只在public方法上生效？\"></a>只在<code>public</code>方法上生效？</h2><p>当采用代理来实现事务时，（注意是代理），<code>@Transactional</code>注解只能应用在<code>public</code>方法上。当标记在<code>protected、private、package-visible</code>方法上时，不会产生错误，但也不会表现出为它指定的事务配置。可以认为它作为一个普通的方法参与到一个<code>public</code>方法的事务中。</p>\n<p>如果想在非<code>public</code>方法上生效，考虑使用<code>AspectJ（织入方式）</code>。</p>\n<h2 id=\"目标类里的自我调用没有事务？\"><a href=\"#目标类里的自我调用没有事务？\" class=\"headerlink\" title=\"目标类里的自我调用没有事务？\"></a>目标类里的自我调用没有事务？</h2><p>在代理模式中（这是默认的），只有从外部的方法调用进入通过代理会被拦截，这意味着自我调用（实际就是，目标对象中的一个方法调用目标对象的另一个方法）在运行时不会导致一个实际的事务，即使被调用的方法标有注解。</p>\n<p>如果你希望自我调用也使用事务来包装，考虑使用<code>AspectJ</code>的方式。在这种情况下，首先是没有代理。相反，目标类被织入（即它的字节码被修改）来把<code>@Transactional</code>加入到运行时行为，在任何种类的方法上都可以。</p>\n<h2 id=\"事务与线程\"><a href=\"#事务与线程\" class=\"headerlink\" title=\"事务与线程\"></a>事务与线程</h2><p>和<code>JavaEE</code>事务上下文一样，<code>Spring</code>事务和一个线程的执行相关联，底层是一个<code>ThreadLocal&lt;Map&lt;Object, Object&gt;&gt;</code>，就是每个线程一个<code>map</code>，<code>key</code>是<code>DataSource</code>，<code>value</code>是<code>Connection</code>。</p>\n<h2 id=\"逻辑事务与物理事务\"><a href=\"#逻辑事务与物理事务\" class=\"headerlink\" title=\"逻辑事务与物理事务\"></a>逻辑事务与物理事务</h2><p>事务性资源实际打开的事务就是物理事务，如数据库的<code>Connection</code>打开的事务。<code>Spring</code>会为每个<code>@Transactional</code>方法创建一个事务范围，可以理解为是逻辑事务。</p>\n<p>在逻辑事务中，大范围的事务称为外围事务，小范围的事务称为内部事务，外围事务可以包含内部事务，但在逻辑上是互相独立的。每一个这样的逻辑事务范围，都能够单独地决定<code>rollback-only</code>状态。</p>\n<p>那么如何处理逻辑事务和物理事务之间的关联关系呢，这就是传播特性解决的问题。</p>\n<h2 id=\"事务传播行为\"><a href=\"#事务传播行为\" class=\"headerlink\" title=\"事务传播行为\"></a>事务传播行为</h2><p>事务传播行为(为了解决业务层方法之间互相调用的事务问题): 当事务方法被另一个事务方法调用时,必须指定事务应该如何传播。</p>\n<p>例如:方法可能继续在现有事务中运行,也可能开启一个新事务,并在自己的事务中运行。在<code>TransactionDefinition</code>定义中包括了如下几个表示传播行为的常量:</p>\n<p><code>REQUIRED，SUPPORTS，MANDATORY，REQUIRES_NEW，NOT_SUPPORTED，NEVER，NESTED</code></p>\n<blockquote>\n<p>支持当前事务的情况:</p>\n</blockquote>\n<ul>\n<li><code>TransactionDefinition.PROPAGATION_REQUIRED:</code> 如果当前存在事务,则加入该事务;如果当前没有事务,则创建一个新的事务。</li>\n<li><code>TransactionDefinition.PROPAGATION_SUPPORTS:</code> 如果当前存在事务,则加入该事务;如果当前没有事务,则以非事务的方式继续运行。</li>\n<li><code>TransactionDefinition.PROPAGATION_MANDATORY:</code> 如果当前存在事务,则加入该事务;如果当前没有事务,则抛出异常。(<code>mandatory:强制性</code>)</li>\n</ul>\n<blockquote>\n<p>不支持当前事务的情况:</p>\n</blockquote>\n<ul>\n<li><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW:</code> 创建一个新的事务,如果当前存在事务,则把当前事务挂起。</li>\n<li><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED:</code> 以非事务方式运行,如果当前存在事务,则把当前事务挂起。</li>\n<li><code>TransactionDefinition.PROPAGATION_NEVER:</code> 以非事务方式运行,如果当前存在事务,则抛出异常。</li>\n</ul>\n<blockquote>\n<p>其他情况:</p>\n</blockquote>\n<ul>\n<li><code>TransactionDefinition.PROPAGATION_NESTED: </code>如果当前存在事务,则创建一个事务作为当前事务的嵌套事务来运行;如果当前没有事务,则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED。</code></li>\n</ul>\n<h2 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h2><p><code>TransactionDefinition</code> 接口中定义了<code>五个</code>表示隔离级别的常量:</p>\n<p><code>DEFAULT，READ_UNCOMMITTED，READ_COMMITTED，REPEATABLE_READ，SERIALIZABLE</code></p>\n<ul>\n<li><code>TransactionDefinition.ISOLATION_DEFAULT:</code> 使用后端数据库默认的隔离级别,<code>Mysql</code> 默认采用的<code>REPEATABLE_READ</code>隔离级别 <code>Oracle</code> 默认采用的 <code>READ_COMMITTED</code>隔离级别。</li>\n<li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED: </code>最低的隔离级别,允许读取尚未提交的数据变更,可能会导致脏读、幻读或不可重复读。</li>\n<li><code>TransactionDefinition.ISOLATION_READ_COMMITTED:</code> 允许读取并发事务已经提交的数据,可以阻止脏读,但是幻读或不可重复读仍有可能发生。</li>\n<li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ:</code> 对同一字段的多次读取结果都是一致的,除非数据是被本身事务自己所修改,可以阻止脏读和不可重复读,但幻读仍有可能发生。</li>\n<li><code>TransactionDefinition.ISOLATION_SERIALIZABLE:</code> 最高的隔离级别,完全服从<code>ACID</code>的隔离级别。所有的事务依次逐个执行,这样事务之间就完全不可能产生干扰,也就是说,该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>\n</ul>\n<blockquote>\n<p>脏读</p>\n</blockquote>\n<p>一个事务修改了一行数据但没有提交，第二个事务可以读取到这行被修改的数据，如果第一个事务回滚，第二个事务获取到的数据将是无效的。</p>\n<blockquote>\n<p>不可重复读</p>\n</blockquote>\n<p>一个事务读取了一行数据，第二个事务修改了这行数据，第一个事务重新读取这行数据，将获得到不同的值。</p>\n<blockquote>\n<p>幻读</p>\n</blockquote>\n<p>一个事务按照一个<code>where</code>条件读取所有符合的数据行，第二个事务插入了一行数据且恰好也满足这个<code>where</code>条件，第一个事务再以这个<code>where</code>条件重新读取，将会获取额外多出来的这一行。</p>\n<p><strong>帮助记忆：</strong><br>写读是脏读，读写读是不可重复读，<code>where insert where</code>是幻读。</p>\n<img data-src=\"/blog/posts/7e4601e3/2022-02-16-21-43-16.png\" class=\"\">\n\n\n\n",
            "tags": [
                "Java面试",
                "Spring事务"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/6b5f7afc/",
            "url": "https://smile1231.github.io/posts/6b5f7afc/",
            "title": "面试之旅关于Java知识点",
            "date_published": "2022-02-16T13:14:07.000Z",
            "content_html": "<h1 id=\"Java知识点\"><a href=\"#Java知识点\" class=\"headerlink\" title=\"Java知识点\"></a><code>Java</code>知识点</h1><h2 id=\"Collection类\"><a href=\"#Collection类\" class=\"headerlink\" title=\"Collection类\"></a><code>Collection</code>类</h2><img data-src=\"/blog/posts/6b5f7afc/2022-02-16-21-41-42.png\" class=\"\">\n\n<span id=\"more\"></span>\n\n<blockquote>\n<p><code>Collection</code></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">子接口</span><br><span class=\"line\"></span><br><span class=\"line\">\tSet,List</span><br><span class=\"line\">集合中只能放置对象的引用,不能放置原生数据类型,</span><br><span class=\"line\"></span><br><span class=\"line\">我们需要使用原生数据类型的封装类才能加入到集合中</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>Ordered</code>与<code>Sorted</code>接口</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ordered排序,按照某种由具体情况决定的顺序排序,是后天指定的</span><br><span class=\"line\"></span><br><span class=\"line\">Sorted排序,按照天然顺序进行排序,是先天指定的</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>List</code></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">实现类包括</span><br><span class=\"line\">\tLinkedList,Vector,ArrayList</span><br><span class=\"line\">列表接口,继承与Collection,可以按索引的顺序访问,有索引的Collection</span><br><span class=\"line\">\t具有列表的功能,元素顺序均是按添加的先后进行排列的,</span><br><span class=\"line\">\t允许重复的元素,允许多个<span class=\"keyword\">null</span>元素</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n",
            "tags": [
                "Java面试"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/666b2933/",
            "url": "https://smile1231.github.io/posts/666b2933/",
            "title": "面试之旅关于数据库",
            "date_published": "2022-02-16T13:13:54.000Z",
            "content_html": "<h1 id=\"常见面试题整理–数据库篇（每位开发者必备）\"><a href=\"#常见面试题整理–数据库篇（每位开发者必备）\" class=\"headerlink\" title=\"常见面试题整理–数据库篇（每位开发者必备）\"></a>常见面试题整理–数据库篇（每位开发者必备）</h1><img data-src=\"/blog/posts/666b2933/2022-02-16-21-40-29.png\" class=\"\">\n\n<h2 id=\"1-什么是存储过程？有哪些优缺点？\"><a href=\"#1-什么是存储过程？有哪些优缺点？\" class=\"headerlink\" title=\"1. 什么是存储过程？有哪些优缺点？\"></a>1. 什么是存储过程？有哪些优缺点？</h2><span id=\"more\"></span>\n\n<p>存储过程是一些预编译的<code>SQL</code>语句。</p>\n<p>更加直白的理解：存储过程可以说是一个记录集，它是由一些<code>T-SQL</code>语句组成的代码块，这些<code>T-SQL</code>语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。</p>\n<p>存储过程是一个预编译的代码块，执行效率比较高<br>一个存储过程替代大量<code>T_SQL</code>语句 ，可以降低网络通信量，提高通信速率<br>可以一定程度上确保数据安全</p>\n<h2 id=\"2-索引是什么？有什么作用以及优缺点\"><a href=\"#2-索引是什么？有什么作用以及优缺点\" class=\"headerlink\" title=\"2. 索引是什么？有什么作用以及优缺点\"></a>2. 索引是什么？有什么作用以及优缺点</h2><p>索引是对数据库表中一或多个列的值进行排序的结构，是帮助<code>MySQL</code>高效获取数据的数据结构</p>\n<p>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</p>\n<p><code>MySQL</code>数据库几个基本的索引类型：*<code>普通索引</code>、<code>唯一索引</code>、<code>主键索引</code>、<code>全文索引</code>*</p>\n<ul>\n<li>索引加快数据库的检索速度</li>\n<li>索引降低了插入、删除、修改等维护任务的速度</li>\n<li>唯一索引可以确保每一行数据的唯一性</li>\n<li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li>\n<li>索引需要占物理和数据空间</li>\n</ul>\n<h2 id=\"3-什么是事务？\"><a href=\"#3-什么是事务？\" class=\"headerlink\" title=\"3. 什么是事务？\"></a>3. 什么是事务？</h2><p>事务（<code>Transaction</code>）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</p>\n<h2 id=\"4-数据库的乐观锁和悲观锁是什么？\"><a href=\"#4-数据库的乐观锁和悲观锁是什么？\" class=\"headerlink\" title=\"4. 数据库的乐观锁和悲观锁是什么？\"></a>4. 数据库的乐观锁和悲观锁是什么？</h2><p>数据库管理系统（<code>DBMS</code>）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p>\n<p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>\n<ul>\n<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</li>\n<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li>\n</ul>\n<h2 id=\"5-使用索引查询一定能提高查询的性能吗？为什么\"><a href=\"#5-使用索引查询一定能提高查询的性能吗？为什么\" class=\"headerlink\" title=\"5. 使用索引查询一定能提高查询的性能吗？为什么\"></a>5. 使用索引查询一定能提高查询的性能吗？为什么</h2><p>通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.</p>\n<p>索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的<code>INSERT,DELETE,UPDATE</code>将为此多付出<code>4,5次</code>的磁盘<code>I/O</code>. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(<code>INDEX RANGE SCAN</code>)适用于两种情况:</p>\n<p>基于一个范围的检索,一般查询返回结果集小于表中记录数的<code>30%</code>基于非唯一性索引的检索</p>\n<h2 id=\"6-简单说一说drop、delete与truncate的区别\"><a href=\"#6-简单说一说drop、delete与truncate的区别\" class=\"headerlink\" title=\"6. 简单说一说drop、delete与truncate的区别\"></a>6. 简单说一说<code>drop</code>、<code>delete</code>与<code>truncate</code>的区别</h2><p><code>SQL</code>中的<code>drop</code>、<code>delete</code>、<code>truncate</code>都表示删除，但是三者有一些差别</p>\n<ul>\n<li><code>delete</code>和<code>truncate</code>只删除表的数据不删除表的结构</li>\n<li>速度,一般来说: <code>drop &gt; truncate &gt;delete</code></li>\n<li><code>delete</code>语句是<code>dml</code>,这个操作会放到<code>rollback segement</code>中,事务提交之后才生效;</li>\n<li>如果有相应的<code>trigger</code>,执行的时候将被触发. <code>truncate,drop</code>是<code>ddl</code>, 操作立即生效,原数据不放到<code>rollback segment</code>中,不能回滚. 操作不触发<code>trigger</code>.</li>\n</ul>\n<h2 id=\"7-drop、delete与truncate分别在什么场景之下使用？\"><a href=\"#7-drop、delete与truncate分别在什么场景之下使用？\" class=\"headerlink\" title=\"7. drop、delete与truncate分别在什么场景之下使用？\"></a>7. <code>drop</code>、<code>delete</code>与<code>truncate</code>分别在什么场景之下使用？</h2><ul>\n<li>不再需要一张表的时候，用<code>drop</code></li>\n<li>想删除部分数据行时候，用<code>delete</code>，并且带上<code>where</code>子句</li>\n<li>保留表而删除所有数据的时候用<code>truncate</code></li>\n</ul>\n<h2 id=\"8-超键、候选键、主键、外键分别是什么？\"><a href=\"#8-超键、候选键、主键、外键分别是什么？\" class=\"headerlink\" title=\"8. 超键、候选键、主键、外键分别是什么？\"></a>8. 超键、候选键、主键、外键分别是什么？</h2><ul>\n<li><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>\n</li>\n<li><p>候选键：是最小超键，即没有冗余元素的超键。</p>\n</li>\n<li><p>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（<code>Null</code>）。</p>\n</li>\n<li><p>外键：在一个表中存在的另一个表的主键称此表的外键。</p>\n</li>\n</ul>\n<h2 id=\"9-什么是视图？以及视图的使用场景有哪些？\"><a href=\"#9-什么是视图？以及视图的使用场景有哪些？\" class=\"headerlink\" title=\"9. 什么是视图？以及视图的使用场景有哪些？\"></a>9. 什么是视图？以及视图的使用场景有哪些？</h2><blockquote>\n<p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p>\n</blockquote>\n<blockquote>\n<p>只暴露部分字段给访问者，所以就建一个虚表，就是视图。<br>查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</p>\n</blockquote>\n<h2 id=\"10-说一说三个范式。\"><a href=\"#10-说一说三个范式。\" class=\"headerlink\" title=\"10. 说一说三个范式。\"></a>10. 说一说三个范式。</h2><p><strong>第一范式（<code>1NF</code>）</strong>：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</p>\n<p><strong>第二范式（<code>2NF</code>）</strong>：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</p>\n<p><strong>第三范式（<code>3NF</code>）</strong>：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在<code>&quot;A → B → C&quot;</code>的决定关系，则<code>C</code>传递函数依赖于<code>A</code>。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 <code>x </code>→ 非关键字段<code>y</code></p>\n",
            "tags": [
                "Java面试",
                "数据库"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/9f9a6182/",
            "url": "https://smile1231.github.io/posts/9f9a6182/",
            "title": "面试之旅关于数据结构",
            "date_published": "2022-02-16T13:13:39.000Z",
            "content_html": "<h1 id=\"面试之旅关于数据结构\"><a href=\"#面试之旅关于数据结构\" class=\"headerlink\" title=\"面试之旅关于数据结构\"></a>面试之旅关于数据结构</h1><p><strong><span class=\"exturl\" data-url=\"aHR0cDovL2RhdGEuYmlhbmNoZW5nLm5ldC9pbnRyby8=\">数据结构详细讲解</span></strong></p>\n<p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p>\n<h2 id=\"数据结构中的逻辑结构\"><a href=\"#数据结构中的逻辑结构\" class=\"headerlink\" title=\"数据结构中的逻辑结构\"></a>数据结构中的逻辑结构</h2><blockquote>\n<p>集合结构</p>\n</blockquote>\n<p>集合结构的里面的元素关系是孤立的</p>\n<img data-src=\"/blog/posts/9f9a6182/2022-02-16-21-37-01.png\" class=\"\">\n\n<blockquote>\n<p>线性结构</p>\n</blockquote>\n<p>线性结构里面的元素关系：一对一</p>\n<img data-src=\"/blog/posts/9f9a6182/2022-02-16-21-37-13.png\" class=\"\">\n\n\n<blockquote>\n<p>树形结构</p>\n</blockquote>\n<p>树形结构里面的元素关系：一对多</p>\n<img data-src=\"/blog/posts/9f9a6182/2022-02-16-21-37-28.png\" class=\"\">\n\n\n<blockquote>\n<p>图结构</p>\n</blockquote>\n<p>图结构里面的元素关系：多对多</p>\n<img data-src=\"/blog/posts/9f9a6182/2022-02-16-21-37-47.png\" class=\"\">\n\n<h2 id=\"数据结构的物理结构\"><a href=\"#数据结构的物理结构\" class=\"headerlink\" title=\"数据结构的物理结构\"></a>数据结构的物理结构</h2><p>物理结构:是指数据的逻辑结构在计算机中的存储形式。存储结构有两种：</p>\n<blockquote>\n<p>顺序存储结构：</p>\n</blockquote>\n<p>顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</p>\n<img data-src=\"/blog/posts/9f9a6182/2022-02-16-21-37-57.png\" class=\"\">\n\n<blockquote>\n<p>链式存储结构</p>\n</blockquote>\n<p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</p>\n<img data-src=\"/blog/posts/9f9a6182/2022-02-16-21-38-04.png\" class=\"\">\n\n\n<h2 id=\"常见的数据结构\"><a href=\"#常见的数据结构\" class=\"headerlink\" title=\"常见的数据结构\"></a>常见的数据结构</h2><ul>\n<li><p>数组（<code>Array</code>）</p>\n</li>\n<li><p>堆栈（<code>Stack</code>）</p>\n</li>\n<li><p>队列（<code>Queue</code>）</p>\n</li>\n<li><p>链表（<code>Linked List</code>）</p>\n</li>\n<li><p>树（<code>Tree</code>）</p>\n</li>\n<li><p>图（<code>Graph</code>）</p>\n</li>\n<li><p>堆（<code>Heap</code>）</p>\n</li>\n<li><p>散列表（<code>Hash</code>）</p>\n</li>\n</ul>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>链表是一种数据结构，和数组同级。比如，<code>Java</code>中我们使用的<code>ArrayList</code>，其实现原理是数组。而<code>LinkedList</code>的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。下面对单向链表做一个介绍。</p>\n<p>单向链表是一种线性表，实际上是由节点（<code>Node</code>）组成的，一个链表拥有不定数量的节点。其数据在内存中存储是不连续的，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由N各节点（<code>Node</code>）组成单向链表，每一个<code>Node</code>记录本<code>Node</code>的数据及下一个<code>Node</code>。向外暴露的只有一个头节点（<code>Head</code>），我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。</p>\n<img data-src=\"/blog/posts/9f9a6182/2022-02-16-21-38-15.png\" class=\"\">\n\n<p>上图中最左边的节点即为头结点（<code>Head</code>），但是添加节点的顺序是从右向左的，添加的新节点会被作为新节点。最先添加的节点对下一节点的引用可以为空。引用是引用下一个节点而非下一个节点的对象。因为有着不断的引用，所以头节点就可以操作所有节点了。</p>\n<p>下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成了一个单向链表。</p>\n<img data-src=\"/blog/posts/9f9a6182/2022-02-16-21-38-25.png\" class=\"\">\n\n<p>节点（<code>Node</code>）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。下面图是具体的说明：</p>\n<img data-src=\"/blog/posts/9f9a6182/2022-02-16-21-38-31.png\" class=\"\">\n\n<blockquote>\n<p>单链表实现</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.zjn.LinkAndQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 自定义链表设计</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zjn</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyLink</span> </span>&#123;</span><br><span class=\"line\">    Node head = <span class=\"keyword\">null</span>; <span class=\"comment\">// 头节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 链表中的节点，data代表节点的值，next是指向下一个节点的引用</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@author</span> zjn</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        Node next = <span class=\"keyword\">null</span>;<span class=\"comment\">// 节点的引用，指向下一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> data;<span class=\"comment\">// 节点的对象，即内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 向链表中插入数据</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> d</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addNode</span><span class=\"params\">(<span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">        Node newNode = <span class=\"keyword\">new</span> Node(d);<span class=\"comment\">// 实例化一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            head = newNode;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node tmp = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tmp.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            tmp = tmp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tmp.next = newNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index:删除第index个节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">deleteNode</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">1</span> || index &gt; length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">        Node preNode = head;</span><br><span class=\"line\">        Node curNode = preNode.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (curNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == index) &#123;</span><br><span class=\"line\">                preNode.next = curNode.next;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            preNode = curNode;</span><br><span class=\"line\">            curNode = curNode.next;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回节点长度</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">length</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Node tmp = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tmp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            length++;</span><br><span class=\"line\">            tmp = tmp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在不知道头指针的情况下删除指定节点</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> n</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">deleteNode11</span><span class=\"params\">(Node n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"keyword\">null</span> || n.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = n.data;</span><br><span class=\"line\">        n.data = n.next.data;</span><br><span class=\"line\">        n.next.data = tmp;</span><br><span class=\"line\">        n.next = n.next.next;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;删除成功！&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Node tmp = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tmp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.println(tmp.data);</span><br><span class=\"line\">            tmp = tmp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyLink list = <span class=\"keyword\">new</span> MyLink();</span><br><span class=\"line\">        list.addNode(<span class=\"number\">5</span>);</span><br><span class=\"line\">        list.addNode(<span class=\"number\">3</span>);</span><br><span class=\"line\">        list.addNode(<span class=\"number\">1</span>);</span><br><span class=\"line\">        list.addNode(<span class=\"number\">2</span>);</span><br><span class=\"line\">        list.addNode(<span class=\"number\">55</span>);</span><br><span class=\"line\">        list.addNode(<span class=\"number\">36</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;linkLength:&quot;</span> + list.length());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;head.data:&quot;</span> + list.head.data);</span><br><span class=\"line\">        list.printList();</span><br><span class=\"line\">        list.deleteNode(<span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After deleteNode(4):&quot;</span>);</span><br><span class=\"line\">        list.printList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><p>非线性存储结构</p>\n<img data-src=\"/blog/posts/9f9a6182/2022-02-16-21-38-44.png\" class=\"\">\n\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2RhdGEuYmlhbmNoZW5nLm5ldC92aWV3LzIzLmh0bWw=\">树的详细讲解</span></p>\n",
            "tags": [
                "Java面试",
                "数据结构"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/c7cf6e41/",
            "url": "https://smile1231.github.io/posts/c7cf6e41/",
            "title": "面试之旅关于计算机网络",
            "date_published": "2022-02-16T13:13:16.000Z",
            "content_html": "<h1 id=\"常见面试题整理–计算机网络篇（每位开发者必备）\"><a href=\"#常见面试题整理–计算机网络篇（每位开发者必备）\" class=\"headerlink\" title=\"常见面试题整理–计算机网络篇（每位开发者必备）\"></a>常见面试题整理–计算机网络篇（每位开发者必备）</h1><img data-src=\"/blog/posts/c7cf6e41/2022-02-16-21-31-41.png\" class=\"\">\n\n<h2 id=\"1-请简述TCP-UDP的区别\"><a href=\"#1-请简述TCP-UDP的区别\" class=\"headerlink\" title=\"1. 请简述TCP\\UDP的区别\"></a>1. 请简述<code>TCP\\UDP</code>的区别</h2><p><code>TCP</code>和<code>UDP</code>是<code>OSI</code>模型中的运输层中的协议。<code>TCP</code>提供可靠的通信传输，而<code>UDP</code>则常被用于让广播和细节控制交给应用的通信传输。</p>\n<p>两者的区别大致如下：</p>\n<ul>\n<li><code>TCP</code>面向连接，<code>UDP</code>面向非连接即发送数据前不需要建立链接</li>\n<li><code>TCP</code>提供可靠的服务（数据传输），<code>UDP</code>无法保证</li>\n<li><code>TCP</code>面向字节流，<code>UDP</code>面向报文</li>\n<li><code>TCP</code>数据传输慢，<code>UDP</code>数据传输快</li>\n</ul>\n<h2 id=\"2-请简单说一下你了解的端口及对应的服务？\"><a href=\"#2-请简单说一下你了解的端口及对应的服务？\" class=\"headerlink\" title=\"2. 请简单说一下你了解的端口及对应的服务？\"></a>2. 请简单说一下你了解的端口及对应的服务？</h2><span id=\"more\"></span>\n\n<img data-src=\"/blog/posts/c7cf6e41/2022-02-16-21-31-53.png\" class=\"\">\n\n<p><strong>端口简介：本文介绍端口的概念，分类，以及如何关闭/开启一个端口</strong></p>\n<ul>\n<li><p><code>21端口</code>：21端口主要用于<code>FTP（File Transfer Protocol，文件传输协议）</code>服务。</p>\n</li>\n<li><p><code>23</code>端口：23端口主要用于<code>Telnet（远程登录）</code>服务，是<code>Internet</code>上普遍采用的登录和仿真程序。</p>\n</li>\n<li><p><code>25端口</code>：25端口为<code>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</code>服务器所开放，主要用于发送邮件，如今绝大多数邮件服务器都使用该协议。</p>\n</li>\n<li><p><code>53端口</code>：53端口为<code>DNS（Domain Name Server，域名服务器）</code>服务器所开放，主要用于域名解析，<code>DNS</code>服务在<code>NT</code>系统中使用的最为广泛。</p>\n</li>\n<li><p><code>67、68端口</code>：67、68端口分别是为<code>Bootstrap</code>服务的<code>Bootstrap Protocol Server（引导程序协议服务端）</code>和<code>Bootstrap Protocol Client（引导程序协议客户端）</code>开放的端口。</p>\n</li>\n<li><p><code>69端口</code>：<code>TFTP</code>是Cisco公司开发的一个<code>简单文件传输协议</code>，类似于<code>FTP</code>。</p>\n</li>\n<li><p><code>79端口</code>：79端口是为<code>Finger</code>服务开放的，主要用于查询远程主机在线用户、操作系统类型以及是否缓冲区溢出等用户的详细信息。</p>\n</li>\n<li><p><code>80端口</code>：80端口是为<code>HTTP（HyperText Transport Protocol，超文本传输协议）</code>开放的，这是上网冲浪使用最多的协议，主要用于在<code>WWW（World Wide Web，万维网）</code>服务上传输信息的协议。</p>\n</li>\n<li><p><code>99端口</code>：99端口是用于一个名为<code>“Metagram Relay”（亚对策延时）</code>的服务，该服务比较少见，一般是用不到的。</p>\n</li>\n<li><p><code>109、110端口</code>：109端口是为<code>POP2（Post Office Protocol Version 2，邮局协议2）</code>服务开放的，<code>110端口是为POP3（邮件协议3）</code>服务开放的，<code>POP2、POP3</code>都是主要用于接收邮件的。</p>\n</li>\n<li><p><code>111端口</code>：111端口是<code>SUN</code>公司的<code>RPC（Remote Procedure Call，远程过程调用）</code>服务所开放的端口，主要用于分布式系统中不同计算机的内部进程通信，RPC在多种网络服务中都是很重要的组件。</p>\n</li>\n<li><p><code>113端口</code>：113端口主要用于<code>Windows</code>的<code>“Authentication Service”（验证服务）</code>。</p>\n</li>\n<li><p><code>119端口</code>：119端口是为<code>“Network News Transfer Protocol”（网络新闻组传输协议，简称NNTP）</code>开放的。</p>\n</li>\n<li><p><code>135端口</code>：135端口主要用于使用<code>RPC（Remote Procedure Call，远程过程调用）</code>协议并提供<code>DCOM（分布式组件对象模型）</code>服务。</p>\n</li>\n<li><p><code>137端口</code>：137端口主要用于<code>“NetBIOS Name Service”（NetBIOS名称服务）</code>。</p>\n</li>\n<li><p><code>139端口</code>：139端口是为<code>“NetBIOS Session Service”</code>提供的，主要用于提供<code>Windows</code>文件和打印机共享以及<code>Unix</code>中的<code>Samba</code>服务。</p>\n</li>\n<li><p><code>143端口</code>：143端口主要是用于<code>“Internet Message Access Protocol”v2（Internet消息访问协议，简称IMAP）</code>。</p>\n</li>\n<li><p><code>161端口</code>：161端口是用于<code>“Simple Network Management Protocol”（简单网络管理协议，简称SNMP）</code>。</p>\n</li>\n<li><p><code>443端口</code>：43端口即网页浏览端口，主要是用于<code>HTTPS</code>服务，是提供加密和通过安全端口传输的另一种<code>HTTP</code>。</p>\n</li>\n<li><p><code>554端口</code>：554端口默认情况下用于<code>“Real Time Streaming Protocol”（实时流协议，简称RTSP）</code>。</p>\n</li>\n<li><p><code>1024端口</code>：1024端口一般不固定分配给某个服务，在英文中的解释是<code>“Reserved”（保留）</code>。</p>\n</li>\n<li><p><code>1080端口</code>：1080端口是Socks代理服务使用的端口，大家平时上网使用的WWW服务使用的是HTTP协议的代理服务。</p>\n</li>\n<li><p><code>1755端口</code>：1755端口默认情况下用于<code>“Microsoft Media Server”（微软媒体服务器，简称MMS）</code>。</p>\n</li>\n<li><p><code>4000端口</code>：4000端口是用于大家经常使用的<code>QQ</code>聊天工具的，再细说就是为<code>QQ</code>客户端开放的端口，<code>QQ</code>服务端使用的端口是<code>8000</code>。</p>\n</li>\n<li><p><code>5554端口</code>：在今年4月30日就报道出现了一种针对微软<code>lsass服务</code>的新蠕虫病毒——震荡波（Worm.Sasser），该病毒可以利用<code>TCP 5554端口</code>开启一个<code>FTP</code>服务，主要被用于病毒的传播。</p>\n</li>\n<li><p><code>5632端口</code>：5632端口是被大家所熟悉的远程控制软件<code>pcAnywhere</code>所开启的端口。</p>\n</li>\n<li><p><code>8080端口</code>：8080端口同80端口，是被用于<code>WWW</code>代理服务的，可以实现网页</p>\n</li>\n</ul>\n<h2 id=\"3-说一说TCP的三次握手\"><a href=\"#3-说一说TCP的三次握手\" class=\"headerlink\" title=\"3. 说一说TCP的三次握手\"></a>3. 说一说<code>TCP</code>的三次握手</h2><p>在<code>TCP/IP</code>协议中，<code>TCP协议</code>提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换<code>TCP</code>窗口大小信息。</p>\n<p>下面详细说一下三次握手（来自简析<code>TCP</code>的三次握手与四次分手）</p>\n<img data-src=\"/blog/posts/c7cf6e41/2022-02-16-21-32-08.png\" class=\"\">\n\n<img data-src=\"/blog/posts/c7cf6e41/2022-02-16-21-32-16.png\" class=\"\">\n\n<h2 id=\"4-有哪些私有（保留）地址？\"><a href=\"#4-有哪些私有（保留）地址？\" class=\"headerlink\" title=\"4. 有哪些私有（保留）地址？\"></a>4. 有哪些私有（保留）地址？</h2><ul>\n<li><code>A</code>类：<code>10.0.0.0 - 10.255.255.255</code></li>\n<li><code>B</code>类：<code>172.16.0.0 - 172.31.255.255</code></li>\n<li><code>C</code>类：<code>192.168.0.0 - 192.168.255.255</code></li>\n</ul>\n<h2 id=\"5-IP地址分为哪几类？简单说一下各个分类\"><a href=\"#5-IP地址分为哪几类？简单说一下各个分类\" class=\"headerlink\" title=\"5. IP地址分为哪几类？简单说一下各个分类\"></a>5. <code>IP</code>地址分为哪几类？简单说一下各个分类</h2><img data-src=\"/blog/posts/c7cf6e41/2022-02-16-21-32-36.png\" class=\"\">\n\n<p><code>IPv6 </code>– 采用<code>128bit</code>，首部固定部分为<code>40</code>字节。</p>\n<h2 id=\"6-在浏览器中输入网址之后执行会发生什么？\"><a href=\"#6-在浏览器中输入网址之后执行会发生什么？\" class=\"headerlink\" title=\"6. 在浏览器中输入网址之后执行会发生什么？\"></a>6. 在浏览器中输入网址之后执行会发生什么？</h2><ul>\n<li>查找域名对应的<code>IP</code>地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，<code>ISPNDS</code>缓存，根域名服务器</li>\n<li>浏览器向<code>IP</code>对应的<code>web</code>服务器发送一个<code>HTTP</code>请求</li>\n<li>服务器响应请求，发回网页内容</li>\n<li>浏览器解析网页内容</li>\n</ul>\n<p>更加详细的一种说法（以百度为例）（来自计算机网络之面试常考 - 牛客网）</p>\n<img data-src=\"/blog/posts/c7cf6e41/2022-02-16-21-32-47.png\" class=\"\">\n\n<h2 id=\"7-简单解释一些ARP协议的工作过程\"><a href=\"#7-简单解释一些ARP协议的工作过程\" class=\"headerlink\" title=\"7. 简单解释一些ARP协议的工作过程\"></a>7. 简单解释一些<code>ARP</code>协议的工作过程</h2><img data-src=\"/blog/posts/c7cf6e41/2022-02-16-21-33-01.png\" class=\"\">\n\n<h2 id=\"8-说一说OSI七层模型\"><a href=\"#8-说一说OSI七层模型\" class=\"headerlink\" title=\"8. 说一说OSI七层模型\"></a>8. 说一说<code>OSI</code>七层模型</h2><img data-src=\"/blog/posts/c7cf6e41/2022-02-16-21-33-15.png\" class=\"\">\n\n<h2 id=\"9-说一说TCP-IP四层模型\"><a href=\"#9-说一说TCP-IP四层模型\" class=\"headerlink\" title=\"9. 说一说TCP/IP四层模型\"></a>9. 说一说<code>TCP/IP</code>四层模型</h2><p><code>ISO</code>制定的<code>OSI</code>参考模型的过于庞大、复杂招致了许多批评。与此对照，由技术人员自己开发的<code>TCP/IP</code>协议栈获得了更为广泛的应用。如图所示，是<code>TCP/IP</code>参考模型和<code>OSI</code>参考模型的对比示意图。</p>\n<img data-src=\"/blog/posts/c7cf6e41/2022-02-16-21-33-24.png\" class=\"\">\n\n<img data-src=\"/blog/posts/c7cf6e41/2022-02-16-21-33-31.png\" class=\"\">\n\n<p>具体讲解：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vQmx1ZVR6YXIvYXJ0aWNsZXMvODExMTYwLmh0bWw=\">链接</span></p>\n<h2 id=\"10-HTTP-协议包括哪些请求？\"><a href=\"#10-HTTP-协议包括哪些请求？\" class=\"headerlink\" title=\"10. HTTP 协议包括哪些请求？\"></a>10. <code>HTTP</code> 协议包括哪些请求？</h2><ul>\n<li><p><code>GET</code>：对服务器资源的简单请求</p>\n</li>\n<li><p><code>POST</code>：用于发送包含用户提交数据的请求</p>\n</li>\n<li><p>———–以及————</p>\n</li>\n<li><p><code>HEAD</code>：类似于GET请求，不过返回的响应中没有具体内容，用于获取报头</p>\n</li>\n<li><p><code>PUT</code>：传说中请求文档的一个版本</p>\n</li>\n<li><p><code>DELETE</code>：发出一个删除指定文档的请求</p>\n</li>\n<li><p><code>TRACE</code>：发送一个请求副本，以跟踪其处理进程</p>\n</li>\n<li><p><code>OPTIONS</code>：返回所有可用的方法，检查服务器支持哪些方法</p>\n</li>\n<li><p><code>CONNECT</code>：用于<code>ssl</code>隧道的基于代理的请求</p>\n</li>\n</ul>\n<h2 id=\"11-简述HTTP中GET和POST的区别\"><a href=\"#11-简述HTTP中GET和POST的区别\" class=\"headerlink\" title=\"11. 简述HTTP中GET和POST的区别\"></a>11. 简述<code>HTTP</code>中<code>GET</code>和<code>POST</code>的区别</h2><p>从原理性看：</p>\n<ul>\n<li>根据<code>HTTP</code>规范，<code>GET</code>用于信息获取，而且应该是安全和幂等的</li>\n<li>根据<code>HTTP</code>规范，<code>POST</code>请求表示可能修改服务器上资源的请求</li>\n</ul>\n<p>从表面上看：</p>\n<ul>\n<li><code>GET</code>请求的数据会附在<code>URL</code>后面，<code>POST</code>的数据放在<code>HTTP</code>包体</li>\n<li><code>POST</code>安全性比<code>GET</code>安全性高</li>\n</ul>\n",
            "tags": [
                "Java面试",
                "操作系统"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/4847d2e5/",
            "url": "https://smile1231.github.io/posts/4847d2e5/",
            "title": "面试之旅关于操作系统",
            "date_published": "2022-02-16T13:10:40.000Z",
            "content_html": "<h1 id=\"常见面试题整理–操作系统篇（每位开发者必备）\"><a href=\"#常见面试题整理–操作系统篇（每位开发者必备）\" class=\"headerlink\" title=\"常见面试题整理–操作系统篇（每位开发者必备）\"></a>常见面试题整理–操作系统篇（每位开发者必备）</h1><img data-src=\"/blog/posts/4847d2e5/2022-02-16-21-18-10.png\" class=\"\">\n\n<h2 id=\"1-请分别简单说一说进程和线程以及它们的区别。\"><a href=\"#1-请分别简单说一说进程和线程以及它们的区别。\" class=\"headerlink\" title=\"1. 请分别简单说一说进程和线程以及它们的区别。\"></a>1. 请分别简单说一说进程和线程以及它们的区别。</h2><blockquote>\n<p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。线程是进程的实体，是<code>CPU</code>调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。一个进程可以有多个线程，多个线程也可以并发执行</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"2-线程同步的方式有哪些？\"><a href=\"#2-线程同步的方式有哪些？\" class=\"headerlink\" title=\"2. 线程同步的方式有哪些？\"></a>2. 线程同步的方式有哪些？</h2><ul>\n<li>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li>\n<li>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>\n<li>事件（信号): 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>\n</ul>\n<h2 id=\"3-进程的通信方式有哪些？\"><a href=\"#3-进程的通信方式有哪些？\" class=\"headerlink\" title=\"3. 进程的通信方式有哪些？\"></a>3. 进程的通信方式有哪些？</h2><p>主要分为：管道、系统<code>IPC</code>（包括消息队列、信号量、共享存储）、<code>SOCKET</code></p>\n<p>管道主要分为：普通管道<code>PIPE</code> 、流管道（<code>s_pipe</code>）、命名管道（<code>name_pipe</code>）</p>\n<ul>\n<li>管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程</li>\n<li>命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信</li>\n<li>信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。</li>\n<li>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</li>\n<li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>\n<li>共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。</li>\n</ul>\n<h2 id=\"4-什么是缓冲区溢出？有什么危害？其原因是什么？\"><a href=\"#4-什么是缓冲区溢出？有什么危害？其原因是什么？\" class=\"headerlink\" title=\"4. 什么是缓冲区溢出？有什么危害？其原因是什么？\"></a>4. 什么是缓冲区溢出？有什么危害？其原因是什么？</h2><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p>\n<p>危害有以下两点：</p>\n<ul>\n<li>程序崩溃，导致拒绝额服务</li>\n<li>跳转并且执行一段恶意代码</li>\n</ul>\n<p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p>\n<h2 id=\"5-什么是死锁？死锁产生的条件\"><a href=\"#5-什么是死锁？死锁产生的条件\" class=\"headerlink\" title=\"5. 什么是死锁？死锁产生的条件\"></a>5. 什么是死锁？死锁产生的条件</h2><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p>\n<p>死锁产生的四个条件（有一个条件不成立，则不会产生死锁）</p>\n<ol>\n<li>互斥条件：一个资源一次只能被一个进程使用</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>\n<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>\n<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>\n</ol>\n<h2 id=\"6-进程有哪几种状态？\"><a href=\"#6-进程有哪几种状态？\" class=\"headerlink\" title=\"6. 进程有哪几种状态？\"></a>6. 进程有哪几种状态？</h2><ul>\n<li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源</li>\n<li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于<code>CPU</code>数</li>\n<li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行</li>\n</ul>\n<h2 id=\"7-分页和分段有什么区别？\"><a href=\"#7-分页和分段有什么区别？\" class=\"headerlink\" title=\"7. 分页和分段有什么区别？\"></a>7. 分页和分段有什么区别？</h2><ul>\n<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</li>\n<li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定</li>\n<li>段向用户提供二维地址空间；页向用户提供的是一维地址空间</li>\n<li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li>\n</ul>\n<h2 id=\"8-操作系统中进程调度策略有哪几种？\"><a href=\"#8-操作系统中进程调度策略有哪几种？\" class=\"headerlink\" title=\"8. 操作系统中进程调度策略有哪几种？\"></a>8. 操作系统中进程调度策略有哪几种？</h2><p><code>FCFS</code>(先来先服务)，优先级，时间片轮转，多级反馈</p>\n<h2 id=\"9-说一说进程同步有哪几种机制\"><a href=\"#9-说一说进程同步有哪几种机制\" class=\"headerlink\" title=\"9. 说一说进程同步有哪几种机制?\"></a>9. 说一说进程同步有哪几种机制?</h2><p>原子操作、信号量机制、自旋锁管程、会合、分布式系统</p>\n<h2 id=\"10-说一说死锁的处理基本策略和常用方法\"><a href=\"#10-说一说死锁的处理基本策略和常用方法\" class=\"headerlink\" title=\"10. 说一说死锁的处理基本策略和常用方法\"></a>10. 说一说死锁的处理基本策略和常用方法</h2><ul>\n<li><p>解决死锁的基本方法如下：<br>预防死锁、避免死锁、检测死锁、解除死锁</p>\n</li>\n<li><p>解决四多的常用策略如下：<br>鸵鸟策略、预防策略、避免策略、检测与解除死锁</p>\n</li>\n</ul>\n",
            "tags": [
                "Java面试",
                "操作系统"
            ]
        }
    ]
}
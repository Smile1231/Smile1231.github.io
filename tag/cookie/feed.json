{
    "version": "https://jsonfeed.org/version/1",
    "title": "JIN MAO 's Blog • All posts by \"cookie\" tag",
    "description": "",
    "home_page_url": "https://smile1231.github.io",
    "items": [
        {
            "id": "https://smile1231.github.io/posts/b42f0c87/",
            "url": "https://smile1231.github.io/posts/b42f0c87/",
            "title": "Cache、Cookie、Session、Token",
            "date_published": "2022-02-15T13:37:52.000Z",
            "content_html": "<h1 id=\"Cache、Cookie、Session、Token\"><a href=\"#Cache、Cookie、Session、Token\" class=\"headerlink\" title=\"Cache、Cookie、Session、Token\"></a><code>Cache、Cookie、Session、Token</code></h1><h2 id=\"协议是什么\"><a href=\"#协议是什么\" class=\"headerlink\" title=\"协议是什么\"></a>协议是什么</h2><p>在接口测试中，客户端发送的<code>request</code>至服务端反馈的<code>response</code>中传输的数据就是接口测试最重要的部分</p>\n<h2 id=\"Cache是什么\"><a href=\"#Cache是什么\" class=\"headerlink\" title=\"Cache是什么\"></a><code>Cache</code>是什么</h2><span id=\"more\"></span>\n\n<p>打开浏览器或者应用的时候，用户的等待时间叫做响应时间，打开速度影响到用户体验，提高反应速度的一个方法就是使用缓存策略，缓存策略能带来什么好处呢？</p>\n<ol>\n<li><p>减少延迟：因为网页请求指向的是更接近的客户端缓存，而不是资源服务器，所以花费的时间更短，提高用户体验</p>\n</li>\n<li><p>降低网络负荷：因为缓存可以重复使用，节省带宽，降低网络负荷，也就可以更加节省用户的流量</p>\n</li>\n</ol>\n<blockquote>\n<p>缓存一般分为以下几种：</p>\n</blockquote>\n<ol>\n<li><p>浏览器缓存　　　　<br>（缓存在本地）</p>\n</li>\n<li><p>代理缓存　　　　　<br>（缓存在网络路由，也就是共享缓存）</p>\n</li>\n<li><p>网关缓存　　　　　<br>(缓存在CDN)</p>\n</li>\n</ol>\n<h2 id=\"缓存策略一般分两种情况：\"><a href=\"#缓存策略一般分两种情况：\" class=\"headerlink\" title=\"缓存策略一般分两种情况：\"></a>缓存策略一般分两种情况：</h2><ol>\n<li><p>强缓存　　　　(直接在本地缓存中读取资源)</p>\n</li>\n<li><p>协商缓存　　  (通过服务器告知是否能用本地缓存，先和服务器协商，如果可以，就从本地缓存中读取。如果不可以，就返回最新的资源)</p>\n</li>\n</ol>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a><code>Cookie</code></h2><p><code>Cookie</code>的内容是保存一小段文本信息。组成一个通行证，用来处理客户端无状态协议的一种解决方案</p>\n<p><code>Cookie</code>使用原理如下：</p>\n<ol>\n<li><p>用户会提供信息提交给服务器</p>\n</li>\n<li><p>服务端向客户端回传相应数据的同时，也会发回<code>Cookie</code></p>\n</li>\n<li><p>客户端接收到服务器相应后，浏览器将<code>Cookie</code>保存在同一个位置</p>\n</li>\n<li><p>客户端向服务端发送请求的实话，会把<code>Cookie</code>再次发回服务端</p>\n</li>\n</ol>\n<h2 id=\"获取Cookie的途径\"><a href=\"#获取Cookie的途径\" class=\"headerlink\" title=\"获取Cookie的途径\"></a>获取<code>Cookie</code>的途径</h2><ol>\n<li><p>浏览器自带的开发工具或者抓包工具<code>（Fiddler,Charles）</code></p>\n</li>\n<li><p>本地获取（<code>ie</code>的路径为<code>C</code>盘<code>appdata/Microsoft/Windows/Cookies，Firefox位于C盘appdata/Mozilla/Firefox/Profiles，Charome位于C盘appdata/Goole/Chrome/User Date /Default）</code></p>\n</li>\n<li><p><code>js</code>代码查看(浏览器地址栏输入<code>Javascript:alert(document.cookie)</code>)</p>\n</li>\n</ol>\n<h2 id=\"Session是什么\"><a href=\"#Session是什么\" class=\"headerlink\" title=\"Session是什么\"></a><code>Session</code>是什么</h2><p><code>Session</code>是另外一种记录用户状态的机制，不同于<code>Cookie</code>的是<code>Session</code>是保存在服务器上，用来解决服务端对无状态协议</p>\n<p><code>Session</code>的传输步骤</p>\n<ol>\n<li><p>服务端创建<code>Session</code>，并创建唯一的<code>id</code></p>\n</li>\n<li><p>服务器将<code>id</code>发给客户端</p>\n</li>\n<li><p>客户端再次发送请求的实话带上<code>Session</code>的<code>id</code></p>\n</li>\n<li><p>服务器接收到请求后根据<code>Seesion</code>的<code>id</code>找到相应的<code>Session</code>，完成相应</p>\n</li>\n</ol>\n<h2 id=\"Session的传输媒介\"><a href=\"#Session的传输媒介\" class=\"headerlink\" title=\"Session的传输媒介\"></a><code>Session</code>的传输媒介</h2><ol>\n<li><p>通过<code>Cookie</code>传输</p>\n</li>\n<li><p>通过<code>URL</code>地址重写</p>\n</li>\n</ol>\n<blockquote>\n<p>很多同学不知道<code>Session</code>和<code>Cookie</code>的区别，那么我来大概讲解一下我理解的</p>\n</blockquote>\n<ol>\n<li><p>存储位置不同：大多数情况<code>Cookie</code>存储在浏览器，<code>Session</code>存储在服务器</p>\n</li>\n<li><p>存储容量不同：单个<code>Cookie</code>保存的数据不得超过<code>4kb</code>，一个站点最多<code>20</code>个<code>Cookie</code>，<code>Session</code>一般情况下没有上限，不过建议不要存放太多东西影响性能</p>\n</li>\n<li><p>存取方式不同：<code>Cookie</code>只能用<code>ASCII</code>字符串。通过编码方式获取<code>Unicode</code>字符或者<code>二进制</code>数据。不好存储复杂的信息，<code>Session</code>能存储任何类型的数据</p>\n</li>\n<li><p>隐私策略不同：<code>Cookie</code>放在客户端，可以进行<code>Cookie</code>欺骗，所以不安全。<code>Session</code>放在服务端，更加安全</p>\n</li>\n<li><p>有效期不同：<code>Cookie</code>可以设置属性达到长期有效，<code>Session</code>依赖于<code>JSESSIONID</code>的<code>Cookie</code>，<code>Cookie JSESSIONID</code>的过期时间默认为<code>-1</code>，只需要关闭窗口<code>Session</code>就会失效，，就算不依赖<code>Cookie</code>，</p>\n</li>\n</ol>\n<blockquote>\n<p>用<code>UrL</code>重写也不能完成，如果<code>Session</code>超时时间过长，容易导致内存溢出</p>\n</blockquote>\n<ol start=\"6\">\n<li>服务器压力不同：<code>Cookie</code>保存子本地。不存在服务端压力。<code>Session</code>保存在服务端，每个用户产生一个<code>Session</code>，并发过多非常占用内存</li>\n</ol>\n<p>7.浏览器支持不同：如果浏览器禁用<code>Cookie</code>，那么<code>Cookie</code>直接失效。<code>Session</code>比较好点。可以用<code>URL</code>重写</p>\n<p>8.跨域不同：<code>Cookie</code>支持跨域访问，<code>Session</code>不支持跨域</p>\n<h2 id=\"Token是什么：\"><a href=\"#Token是什么：\" class=\"headerlink\" title=\"Token是什么：\"></a><code>Token</code>是什么：</h2><ol>\n<li><p>当客户端第一次请求的实话，发送用户信息到服务端，服务器对用户信息使用<code>HSA256</code>算法以及密钥进行签名，再将这个签名和数据一次作为<code>Token</code>返回给客户端</p>\n</li>\n<li><p>服务端不保存<code>Token</code>，客户端保存<code>Token</code></p>\n</li>\n<li><p>客户端再次请求的实话，将<code>Token</code>发送给服务端</p>\n</li>\n<li><p>服务端同样用<code>HSA256</code>算法和同样的密钥对数据再一次计算签名，和<code>Token</code>中的签名做比较（如果相同，直接登录，不相同，登录失败）</p>\n</li>\n</ol>\n",
            "tags": [
                "Java",
                "Cache",
                "Cookie",
                "Session",
                "Java面试"
            ]
        }
    ]
}
{
    "version": "https://jsonfeed.org/version/1",
    "title": "JIN MAO 's Blog • All posts by \"stream流\" tag",
    "description": "",
    "home_page_url": "https://smile1231.github.io",
    "items": [
        {
            "id": "https://smile1231.github.io/posts/fc16798c/",
            "url": "https://smile1231.github.io/posts/fc16798c/",
            "title": "Java8遍历Map的三种方式",
            "date_published": "2021-12-16T08:47:03.000Z",
            "content_html": "<p>常见的 <code>Java8</code>  遍历 <code>Map</code>  的三种方式</p>\n<ul>\n<li><code>for</code>  循环</li>\n<li><code>stream</code>  流的方式处理</li>\n<li><code>forEach</code>  方法遍历</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzOTI3MDk2Mjk1NDMy\">转载</span></p>\n<p><code>Show me the code first!</code>  以下是代码，解释一下逻辑，原来的 <code>cookies</code>  数据结构为 <code>Map&lt;String, List&lt;HttpCookie&gt;&gt;</code> , 其中 <code>HttpCookie</code>  为 <code>cookie</code>  键值对，由于业务需要，我们需要将其转换成 <code>Map&lt;String, String&gt;</code>  才更方便处理，于是乎就有了以下代码。（我这里直接用了 <code>foreach</code>  循环，也可以用 <code>fori</code>  循环，例如 <code>for(int i = 0; i&lt; xx; i++)</code> ）</p>\n<span id=\"more\"></span>\n<h2 id=\"for循环遍历\"><a class=\"markdownIt-Anchor\" href=\"#for循环遍历\">#</a>  <code>for</code>  循环遍历</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从request中获取原始的cookie</span></span><br><span class=\"line\">MultiValueMap&lt;String, HttpCookie&gt; cookies = request.getCookies(); </span><br><span class=\"line\">Map&lt;String, String&gt; cookieMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;(); <span class=\"comment\">// 新建一个map，将cookie转入该map中</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;String, List&lt;HttpCookie&gt;&gt; itemList : cookies.entrySet()) &#123; <span class=\"comment\">// 遍历原始的MultiValueMap</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (HttpCookie item :itemList.getValue()) &#123; <span class=\"comment\">// 遍历每个item中的List&lt;HttpCookie&gt;，其中的HttpCookie是我们需要的内容</span></span><br><span class=\"line\">\t\tcookieMap.put(item.getName(), item.getValue()); <span class=\"comment\">// 存入内容</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"stream流的方式处理\"><a class=\"markdownIt-Anchor\" href=\"#stream流的方式处理\">#</a>  <code>stream</code>  流的方式处理</h2>\n<p>在 <code>Java8</code>  中，我们可以使用流，将 <code>Collections</code>  或者数组转化成 <code>Stream</code> ，并用链式的调用更加逻辑更加清晰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MultiValueMap&lt;String, HttpCookie&gt; cookies = request.getCookies();</span><br><span class=\"line\">Map&lt;String, String&gt; cookieMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">cookies.entrySet() <span class=\"comment\">// 获取entrySet</span></span><br><span class=\"line\">\t.stream() <span class=\"comment\">// 将其转化成流</span></span><br><span class=\"line\">\t.map(Map.Entry&lt;String, List&lt;HttpCookie&gt;&gt;::getValue) <span class=\"comment\">// MultiValueMap&lt;String, HttpCookie&gt; -&gt; List&lt;HttpCookie&gt;</span></span><br><span class=\"line\">\t.flatMap(List&lt;HttpCookie&gt;::stream) <span class=\"comment\">// List&lt;HttpCookie&gt; -&gt; HttpCookie</span></span><br><span class=\"line\">\t.forEach(cookie -&gt; cookieMap.put(cookie.getName(), cookie.getValue())); <span class=\"comment\">// 遍历，存入内容</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"collection具有的foreach方法遍历\"><a class=\"markdownIt-Anchor\" href=\"#collection具有的foreach方法遍历\">#</a>  <code>Collection</code>  具有的 <code>forEach</code>  方法遍历</h2>\n<h3 id=\"继续用stream处理\"><a class=\"markdownIt-Anchor\" href=\"#继续用stream处理\">#</a> 继续用 <code>Stream</code>  处理</h3>\n<p>我们可以看到通过流的方法处理 <code>cookie</code>  的方法，接下来，我们接着用相同的方法来处理请求参数，请求参数原本的数据格式依然为 <code>MultiValueMap&lt;String, String&gt;</code> ，可以看做是 <code>Map&lt;String, List&lt;String&gt;&gt;</code> ，其中请求参数名（ <code>key</code> ）对应的值（ <code>value</code> ）可能为多行，我们需要将其处理成一行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MultiValueMap&lt;String, String&gt; params = request.getQueryParams();</span><br><span class=\"line\">Map&lt;String, String&gt; paramMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">params.entrySet()</span><br><span class=\"line\">\t.forEach(entry -&gt;</span><br><span class=\"line\">\t\tparamMap.put(</span><br><span class=\"line\">\t\t\tentry.getKey(), <span class=\"comment\">// 将参数名写入Key</span></span><br><span class=\"line\">\t\t\tentry.getValue().stream().collect(Collectors.joining())) <span class=\"comment\">// 参数值多行合并成一行写入value</span></span><br><span class=\"line\">\t);</span><br></pre></td></tr></table></figure>\n<p>大家可以看到，在处理参数值（ <code>value</code> ）的时候，值为 <code>List&lt;String&gt;</code>  数据结构，以上代码通过 <code>entry.getValue().stream().collect(Collectors.joining()))</code>  将其 <code>List</code>  先转化为 <code>Stream</code> ，再用流的 <code>collection</code>  方法，将其合并。这个 <code>Collectors</code>  还具有将 <code>toSet/toList/groupingBy</code>  等功能，大家可以自行研究，这里就是使用的是 <code>joining</code>  合并方法。</p>\n<h3 id=\"使用collection的foreach方法遍历map\"><a class=\"markdownIt-Anchor\" href=\"#使用collection的foreach方法遍历map\">#</a> 使用 <code>Collection</code>  的 <code>forEach</code>  方法遍历 <code>Map</code></h3>\n<p>修改后的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">params.forEach((key, value) -&gt; paramMap.put(key, String.join(<span class=\"string\">&quot; &quot;</span>, value)));</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "map",
                "Stream流"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/97604c34/",
            "url": "https://smile1231.github.io/posts/97604c34/",
            "title": "获取指定集合要求中的mapkey值并重新返回map",
            "date_published": "2021-12-16T08:21:02.000Z",
            "content_html": "<p>最近遇到一个很奇怪的诉求，进行分批处理时，所得到的是一个 <code>List&lt;List&lt;String&gt;&gt; partition = Lists.partition(list, 1000)</code>  的分批 <code>List</code> , 由于只是一个类似于 <code>Map&lt;string,Object&gt;</code>  的 <code>key</code>  值进行了分组，但是业务方法使用了后面的实体类，所以想将 <code>value</code>  值保持和前面分组一致，同时 <code>map</code>  的 <code>key</code>  值变成 <code>Object</code>  实体类的其他属性.</p>\n<span id=\"more\"></span>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//先根据某个值进行分类</span></span><br><span class=\"line\">List&lt;List&lt;String&gt;&gt; partition = Lists.partition(list, <span class=\"number\">1000</span>);</span><br><span class=\"line\">partition.forEach(m -&gt;  &#123;</span><br><span class=\"line\">                    Map&lt;String, DriverSettlement&gt; driverSettlementMap = m.stream()</span><br><span class=\"line\">                            .map(driversMap::get).collect(Collectors.toMap(Student::getId, t -&gt; t));</span><br><span class=\"line\">                    method(driverSettlementMap);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"><span class=\"comment\">//这边的t-&gt;t 表示本身</span></span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "map",
                "Stream流"
            ]
        }
    ]
}
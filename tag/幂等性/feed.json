{
    "version": "https://jsonfeed.org/version/1",
    "title": "JIN MAO 's Blog • All posts by \"幂等性\" tag",
    "description": "",
    "home_page_url": "https://smile1231.github.io",
    "items": [
        {
            "id": "https://smile1231.github.io/posts/3b6bfba3/",
            "url": "https://smile1231.github.io/posts/3b6bfba3/",
            "title": "如何保证接口的幂等性",
            "date_published": "2022-02-15T13:36:39.000Z",
            "content_html": "<h1 id=\"如何保证接口的幂等性\"><a href=\"#如何保证接口的幂等性\" class=\"headerlink\" title=\"如何保证接口的幂等性\"></a><strong>如何保证接口的幂等性</strong></h1><h2 id=\"什么是幂等性\"><a href=\"#什么是幂等性\" class=\"headerlink\" title=\"什么是幂等性\"></a>什么是幂等性</h2><p>幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"什么情况下需要幂等\"><a href=\"#什么情况下需要幂等\" class=\"headerlink\" title=\"什么情况下需要幂等\"></a>什么情况下需要幂等</h2><p>以<code>SQL</code>为例：</p>\n<ul>\n<li><p><code>SELECT col1 FROM tab1 WHER col2=2，</code>无论执行多少次都不会改变状态，是天然的幂等。</p>\n</li>\n<li><p><code>UPDATE tab1 SET col1=1 WHERE col2=2</code>，无论执行成功多少次状态都是一致的，因此也是幂等操作。</p>\n</li>\n<li><p><code>UPDATE tab1 SET col1=col1+1 WHERE col2=2</code>，每次执行的结果都会发生变化，这种不是幂等的。</p>\n</li>\n<li><p><code>insert into user(userid,name) values(1,&#39;a&#39;)</code> 如<code>userid</code>为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。<br>如<code>userid</code>不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。</p>\n</li>\n<li><p><code>delete from user where userid=1</code>，多次操作，结果一样，具备幂等性</p>\n</li>\n</ul>\n<h2 id=\"如何保证幂等\"><a href=\"#如何保证幂等\" class=\"headerlink\" title=\"如何保证幂等\"></a>如何保证幂等</h2><ul>\n<li><h3 id=\"token机制\"><a href=\"#token机制\" class=\"headerlink\" title=\"token机制\"></a><code>token</code>机制</h3><ol>\n<li><p>服务端提供了发送<code>token</code>的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取<code>token</code>，服务器会把<code>token</code>保存到<code>redis</code>中。</p>\n</li>\n<li><p>然后调用业务接口请求时，把<code>token</code>携带过去，一般放在请求头部。</p>\n</li>\n<li><p>服务器判断<code>token</code>是否存在<code>redis</code>中，存在表示第一次请求，然后删除<code>token</code>,继续执行业务。</p>\n</li>\n<li><p>如果判断<code>token</code>不存在<code>redis</code>中，就表示是重复操作，直接返回重复标记给<code>client</code>，这样就保证了业务代码，不被重复执行。</p>\n<h4 id=\"关键点-先删除token，还是后删除token。\"><a href=\"#关键点-先删除token，还是后删除token。\" class=\"headerlink\" title=\"关键点 先删除token，还是后删除token。\"></a><strong>关键点 先删除<code>token</code>，还是后删除<code>token</code>。</strong></h4><p>   后删除<code>token</code>：如果进行业务处理成功后，删除<code>redis</code>中的<code>token</code>失败了，这样就导致了有可能会发生重复请求，因为<code>token</code>没有被删除。这个问题其实是数据库和缓存<code>redis</code>数据不一致问题，后续会写文章进行讲解。</p>\n<p>   先删除<code>token</code>：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但<code>token</code>已经删除掉了，服务端判断<code>token</code>不存在，认为是重复请求，就直接返回了，无法进行业务处理了。</p>\n<p>   先删除<code>token</code>可以保证不会因为重复请求，业务数据出现问题。出现业务异常，可以让调用方配合处理一下，重新获取新的<code>token</code>，再次由业务调用方发起重试请求就<code>ok</code>了。</p>\n<h4 id=\"token机制缺点\"><a href=\"#token机制缺点\" class=\"headerlink\" title=\"token机制缺点\"></a><code>token</code>机制缺点</h4><p>   业务请求每次请求，都会有额外的请求（一次获取<code>token</code>请求、判断<code>token</code>是否存在的业务）。其实真实的生产环境中，1万请求也许只会存在<code>10</code>个左右的请求会发生重试，为了这<code>10</code>个请求，我们让<code>9990</code>个请求都发生了额外的请求。</p>\n</li>\n</ol>\n</li>\n<li><h3 id=\"乐观锁机制\"><a href=\"#乐观锁机制\" class=\"headerlink\" title=\"乐观锁机制\"></a>乐观锁机制</h3><p>  这种方法适合在更新的场景中<code>update t_goods set count = count -1 , version = version + 1 where good_id=2 and version = 1</code><br>  根据<code>version</code>版本，也就是在操作库存前先获取当前商品的<code>version</code>版本号，然后操作的时候带上此<code>version</code>号。我们梳理下，我们第一次操作库存时，得到<code>version</code>为<code>1</code>，调用库存服务<code>version</code>变成了<code>2</code>；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的<code>version</code>还是<code>1</code>，再执行上面的<code>sql</code>语句时，就不会执行；因为<code>version</code>已经变为<code>2</code>了，<code>where</code>条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。<br>  乐观锁主要使用于处理读多写少的问题</p>\n</li>\n<li><h3 id=\"唯一主键\"><a href=\"#唯一主键\" class=\"headerlink\" title=\"唯一主键\"></a>唯一主键</h3><p>  这个机制是利用了数据库的主键唯一约束的特性，解决了在<code>insert</code>场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。</p>\n<p>  如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</p>\n</li>\n<li><h3 id=\"防重表\"><a href=\"#防重表\" class=\"headerlink\" title=\"防重表\"></a>防重表</h3><p>  使用订单号<code>orderNo</code>做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</p>\n</li>\n<li><h3 id=\"唯一ID\"><a href=\"#唯一ID\" class=\"headerlink\" title=\"唯一ID\"></a>唯一<code>ID</code></h3><p>  调用接口时，生成一个唯一<code>id</code>，<code>redis</code>将数据保存到集合中（去重），存在即处理过。</p>\n</li>\n</ul>\n",
            "tags": [
                "Java面试",
                "幂等性"
            ]
        }
    ]
}
{
    "version": "https://jsonfeed.org/version/1",
    "title": "JIN MAO 's Blog • All posts by \"jvm\" tag",
    "description": "",
    "home_page_url": "https://smile1231.github.io",
    "items": [
        {
            "id": "https://smile1231.github.io/posts/a72f470b/",
            "url": "https://smile1231.github.io/posts/a72f470b/",
            "title": "关于JVM常用参数",
            "date_published": "2022-03-13T07:12:45.000Z",
            "content_html": "<p>笔记链接： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4NjMwMjQvYXJ0aWNsZS9kZXRhaWxzLzExNDY4NDQyOA==\">大厂面试视频</span></p>\n<h2 id=\"JVM的标配参数和X参数\"><a href=\"#JVM的标配参数和X参数\" class=\"headerlink\" title=\"JVM的标配参数和X参数\"></a><code>JVM</code>的标配参数和<code>X</code>参数</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvdG9vbHMvd2luZG93cy9qYXZhLmh0bWw=\">官方文档</span></p>\n<p><code>JVM</code>的参数类型：</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>标配参数</p>\n</blockquote>\n<ul>\n<li><code>-version java -version</code></li>\n<li><code>-help</code></li>\n</ul>\n<blockquote>\n<p><code>X</code>参数（了解）</p>\n</blockquote>\n<ul>\n<li><code>-Xint</code>：解释执行</li>\n<li><code>-Xcomp</code>：第一次使用就编译成本地代码</li>\n<li><code>-Xmixed</code>：混合模式</li>\n</ul>\n<h2 id=\"VM的XX参数之布尔类型\"><a href=\"#VM的XX参数之布尔类型\" class=\"headerlink\" title=\"VM的XX参数之布尔类型\"></a><code>VM</code>的<code>XX</code>参数之布尔类型</h2><p>公式：<code>-XX:+</code> 或者 <code>-</code> 某个属性值（<code>+</code>表示开启，<code>-</code>表示关闭）</p>\n<p>如何查看一个正在运行中的<code>java</code>程序，它的某个<code>jvm</code>参数是否开启？具体值是多少？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jps -l 查看一个正在运行中的java程序，得到Java程序号。</span><br><span class=\"line\">jinfo -<span class=\"function\">flag <span class=\"title\">PrintGCDetails</span> <span class=\"params\">(Java程序号 )</span>查看它的某个jvm参数（如PrintGCDetails ）是否开启。</span></span><br><span class=\"line\"><span class=\"function\">jinfo -<span class=\"title\">flags</span> <span class=\"params\">(Java程序号 )</span>查看它的所有jvm参数</span></span><br></pre></td></tr></table></figure>\n<p>Case</p>\n<blockquote>\n<p>是否打印<code>GC</code>收集细节</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:-PrintGCDetails</span><br><span class=\"line\">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>是否使用串行垃圾回收器</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:-UseSerialGC</span><br><span class=\"line\">-XX:+UserSerialGC</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JVM的XX参数之设值类型\"><a href=\"#JVM的XX参数之设值类型\" class=\"headerlink\" title=\"JVM的XX参数之设值类型\"></a><code>JVM</code>的<code>XX</code>参数之设值类型</h2><p>公式：<code>-XX</code>:属性<code>key=</code>属性值<code>value</code></p>\n<p>Case</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:MetaspaceSize=128m</span><br><span class=\"line\">-XX:MaxTenuringThreshold=<span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"VM的XX参数之XmsXmx坑题\"><a href=\"#VM的XX参数之XmsXmx坑题\" class=\"headerlink\" title=\"VM的XX参数之XmsXmx坑题\"></a><code>VM</code>的<code>XX</code>参数之<code>XmsXmx</code>坑题</h2><p>两个经典参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms等价于-XX:InitialHeapSize，初始大小内存，默认物理内存<span class=\"number\">1</span>/<span class=\"number\">64</span></span><br><span class=\"line\">-Xmx等价于-XX:MaxHeapSize，最大分配内存，默认为物理内存<span class=\"number\">1</span>/<span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JVM盘点家底查看初始默认\"><a href=\"#JVM盘点家底查看初始默认\" class=\"headerlink\" title=\"JVM盘点家底查看初始默认\"></a><code>JVM</code>盘点家底查看初始默认</h2><blockquote>\n<p>查看初始默认参数值</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:+PrintFlagsInitial</span><br></pre></td></tr></table></figure>\n\n<p>公式：<code>java -XX:+PrintFlagsInitial</code></p>\n<img data-src=\"/posts/a72f470b/2022-03-13-15-29-37.png\" class=\"\">\n\n<blockquote>\n<p>查看修改更新参数值</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:+PrintFlagsFinal</span><br></pre></td></tr></table></figure>\n\n<p>公式：<code>java -XX:+PrintFlagsFinal</code></p>\n<img data-src=\"/posts/a72f470b/2022-03-13-15-32-07.png\" class=\"\">\n\n<p><strong><code>=</code>表示默认，<code>:=</code>表示修改过的。</strong></p>\n<h2 id=\"JVM盘点家底查看修改变更值\"><a href=\"#JVM盘点家底查看修改变更值\" class=\"headerlink\" title=\"JVM盘点家底查看修改变更值\"></a><code>JVM</code>盘点家底查看修改变更值</h2><p><code>PrintFlagsFinal</code>举例，运行<code>java</code>命令的同时打印出参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -XX:+PrintFlagsFinal -XX:MetaspaceSize=512m HelloWorld</span><br><span class=\"line\"></span><br><span class=\"line\">--------------</span><br><span class=\"line\">...</span><br><span class=\"line\">   size_t MetaspaceSize                            := <span class=\"number\">536870912</span>                               &#123;pd product&#125; &#123;<span class=\"keyword\">default</span>&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>打印命令行参数</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:+PrintCommandLineFlags</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) ➜  ~ java -XX:+PrintCommandLineFlags -version</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:G1ConcRefinementThreads=<span class=\"number\">8</span> -XX:GCDrainStackTargetSize=<span class=\"number\">64</span> -XX:InitialHeapSize=<span class=\"number\">268435456</span> -XX:MaxHeapSize=<span class=\"number\">4294967296</span> -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=<span class=\"number\">251658240</span> -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br><span class=\"line\">java version <span class=\"string\">&quot;11.0.10&quot;</span> <span class=\"number\">2021</span>-<span class=\"number\">01</span>-<span class=\"number\">19</span> <span class=\"function\">LTS</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Java</span><span class=\"params\">(TM)</span> SE Runtime Environment 18.9 <span class=\"params\">(build <span class=\"number\">11.0</span><span class=\"number\">.10</span>+<span class=\"number\">8</span>-LTS-<span class=\"number\">162</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">Java <span class=\"title\">HotSpot</span><span class=\"params\">(TM)</span> 64-Bit Server VM 18.9 <span class=\"params\">(build <span class=\"number\">11.0</span><span class=\"number\">.10</span>+<span class=\"number\">8</span>-LTS-<span class=\"number\">162</span>, mixed mode)</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"堆内存初始大小快速复习\"><a href=\"#堆内存初始大小快速复习\" class=\"headerlink\" title=\"堆内存初始大小快速复习\"></a>堆内存初始大小快速复习</h2><p><code>JDK 1.8</code>之后将最初的永久代取消了，由元空间取代。</p>\n<img data-src=\"/posts/a72f470b/2022-03-13-15-48-45.png\" class=\"\">\n\n<p>在<code>Java8</code>中，永久代已经被移除，被一个称为元空间的区域所取代。元空间的本质和永久代类似。</p>\n<p>元空间(<code>Java8</code>)与永久代(<code>Java7</code>)之间最大的区别在于：永久带使用的<code>JVM</code>的堆内存，但是<code>Java8</code>以后的元空间<strong>并不在虚拟机中而是使用本机物理内存</strong>。</p>\n<p>因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入<code>native memory</code>，字符串池和类的静态变量放入<code>java</code>堆中，这样可以加载多少类的元数据就不再由<code>MaxPermSize</code>控制，而由系统的实际可用空间来控制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JVMMemorySizeDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回Java虚拟机中内存的总量</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 返回Java虚拟机中试图使用的最大内存量</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(String.format(<span class=\"string\">&quot;TOTAL_MEMORY(-Xms): %d B, %.2f MB.&quot;</span>, totalMemory, totalMemory / <span class=\"number\">1024.0</span> / <span class=\"number\">1024</span>));</span><br><span class=\"line\">        System.out.println(String.format(<span class=\"string\">&quot;MAX_MEMORY(-Xmx): %d B, %.2f MB.&quot;</span>, maxMemory, maxMemory / <span class=\"number\">1024.0</span> / <span class=\"number\">1024</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<img data-src=\"/posts/a72f470b/2022-03-13-15-51-39.png\" class=\"\">\n\n<h2 id=\"常用基础参数栈内存Xss讲解\"><a href=\"#常用基础参数栈内存Xss讲解\" class=\"headerlink\" title=\"常用基础参数栈内存Xss讲解\"></a>常用基础参数栈内存<code>Xss</code>讲解</h2><p>设置单个线程栈的大小，一般默认为<code>512k~1024K</code></p>\n<p>等价于<code>-XX:ThreadStackSize</code></p>\n<blockquote>\n<p>-XX:ThreadStackSize=size<br>Sets the thread stack size (in bytes). Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, g or G to indicate gigabytes. The default value depends on virtual memory.<br>The following examples show how to set the thread stack size to 1024 KB in different units:<br>-XX:ThreadStackSize=1m<br>-XX:ThreadStackSize=1024k<br>-XX:ThreadStackSize=1048576<br>This option is equivalent to <code>-Xss</code>. <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvdG9vbHMvd2luZG93cy9qYXZhLmh0bWwjQkdCQ0lFRkM=\">文档</span></p>\n</blockquote>\n<h2 id=\"常用基础参数元空间MetaspaceSize讲解\"><a href=\"#常用基础参数元空间MetaspaceSize讲解\" class=\"headerlink\" title=\"常用基础参数元空间MetaspaceSize讲解\"></a>常用基础参数元空间<code>MetaspaceSize</code>讲解</h2><ul>\n<li><code>-Xmn</code>：设置年轻代大小</li>\n<li><code>-XX:MetaspaceSize</code> 设置元空间大小</li>\n</ul>\n<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制</p>\n<p>典型设置案例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms128m -Xmx4096m -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails-XX:+UseSerialGC</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用基础参数PrintGCDetails回收前后对比讲解\"><a href=\"#常用基础参数PrintGCDetails回收前后对比讲解\" class=\"headerlink\" title=\"常用基础参数PrintGCDetails回收前后对比讲解\"></a>常用基础参数<code>PrintGCDetails</code>回收前后对比讲解</h2><p><code>-XX:+PrintGCDetails</code> 输出详细<code>GC</code>收集日志信息</p>\n<p>设置参数 <code>-Xms10m -Xmx10m -XX:+PrintGCDetails</code> 运行以下程序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrintGCDetailsDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">byte</span>[] byteArray = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tTimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 778K-&gt;480K(2560K)] 778K-&gt;608K(9728K), <span class=\"number\">0.0029909</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 480K-&gt;480K(2560K)] 608K-&gt;616K(9728K), <span class=\"number\">0.0007890</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span> [PSYoungGen: 480K-&gt;0<span class=\"title\">K</span><span class=\"params\">(2560K)</span>] [ParOldGen: 136K-&gt;518<span class=\"title\">K</span><span class=\"params\">(7168K)</span>] 616K-&gt;518<span class=\"title\">K</span><span class=\"params\">(9728K)</span>, [Metaspace: 2644K-&gt;2644<span class=\"title\">K</span><span class=\"params\">(1056768K)</span>], 0.0058272 secs] [Times: user</span>=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 518K-&gt;518K(9728K), <span class=\"number\">0.0002924</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0<span class=\"title\">K</span><span class=\"params\">(2560K)</span>] [ParOldGen: 518K-&gt;506<span class=\"title\">K</span><span class=\"params\">(7168K)</span>] 518K-&gt;506<span class=\"title\">K</span><span class=\"params\">(9728K)</span>, [Metaspace: 2644K-&gt;2644<span class=\"title\">K</span><span class=\"params\">(1056768K)</span>], 0.0056906 secs] [Times: user</span>=<span class=\"number\">0.01</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat com.lun.jvm.PrintGCDetailsDemo.main(PrintGCDetailsDemo.java:<span class=\"number\">9</span>)</span><br><span class=\"line\">Heap</span><br><span class=\"line\"> PSYoungGen      total 2560K, used 61K [<span class=\"number\">0x00000000ffd00000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">  eden space 2048K, <span class=\"number\">3</span>% used [<span class=\"number\">0x00000000ffd00000</span>,<span class=\"number\">0x00000000ffd0f748</span>,<span class=\"number\">0x00000000fff00000</span>)</span><br><span class=\"line\">  from space 512K, <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000fff00000</span>,<span class=\"number\">0x00000000fff00000</span>,<span class=\"number\">0x00000000fff80000</span>)</span><br><span class=\"line\">  to   space 512K, <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000fff80000</span>,<span class=\"number\">0x00000000fff80000</span>,<span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> ParOldGen       total 7168K, used 506K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ffd00000</span>, <span class=\"number\">0x00000000ffd00000</span>)</span><br><span class=\"line\">  object space 7168K, <span class=\"number\">7</span>% used [<span class=\"number\">0x00000000ff600000</span>,<span class=\"number\">0x00000000ff67ea58</span>,<span class=\"number\">0x00000000ffd00000</span>)</span><br><span class=\"line\"> Metaspace       used 2676K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">space</span>    <span class=\"title\">used</span> 285<span class=\"title\">K</span>, <span class=\"title\">capacity</span> 386<span class=\"title\">K</span>, <span class=\"title\">committed</span> 512<span class=\"title\">K</span>, <span class=\"title\">reserved</span> 1048576<span class=\"title\">K</span></span></span><br></pre></td></tr></table></figure>\n\n<img data-src=\"/posts/a72f470b/2022-03-13-16-04-30.png\" class=\"\">\n\n<img data-src=\"/posts/a72f470b/2022-03-13-16-04-40.png\" class=\"\">\n\n<h2 id=\"常用基础参数SurvivorRatio讲解\"><a href=\"#常用基础参数SurvivorRatio讲解\" class=\"headerlink\" title=\"常用基础参数SurvivorRatio讲解\"></a>常用基础参数<code>SurvivorRatio</code>讲解</h2><img data-src=\"/posts/a72f470b/2022-03-13-16-05-01.png\" class=\"\">\n\n<p>调节新生代中 <code>eden</code> 和 <code>S0、S1</code>的空间比例，默认为 <code>-XX:SuriviorRatio=8，Eden:S0:S1 = 8:1:1</code></p>\n<p>假如设置成 <code>-XX:SurvivorRatio=4</code>，则为 <code>Eden:S0:S1 = 4:1:1</code></p>\n<p><code>SurvivorRatio</code>值就是设置<code>eden</code>区的比例占多少，<code>S0</code>和<code>S1</code>相同。</p>\n<h2 id=\"常用基础参数NewRatio讲解\"><a href=\"#常用基础参数NewRatio讲解\" class=\"headerlink\" title=\"常用基础参数NewRatio讲解\"></a>常用基础参数<code>NewRatio</code>讲解</h2><p>配置年轻代<code>new</code>和老年代<code>old</code> 在堆结构的占比</p>\n<p>默认：<code>-XX:NewRatio=2</code> 新生代占<code>1</code>，老年代<code>2</code>，年轻代占整个堆的<code>1/3</code></p>\n<p><code>-XX:NewRatio=4：</code>新生代占<code>1</code>，老年代占<code>4</code>，年轻代占整个堆的<code>1/5</code>，</p>\n<p><code>NewRadio</code>值就是设置老年代的占比，剩下的<code>1</code>个新生代。</p>\n<p>新生代特别小，会造成频繁的进行<code>GC</code>收集。</p>\n<h2 id=\"常用基础参数MaxTenuringThreshold讲解\"><a href=\"#常用基础参数MaxTenuringThreshold讲解\" class=\"headerlink\" title=\"常用基础参数MaxTenuringThreshold讲解\"></a>常用基础参数<code>MaxTenuringThreshold</code>讲解</h2><p>晋升到老年代的对象年龄。</p>\n<p><code>SurvivorTo和SurvivorFrom</code>互换，原<code>SurvivorTo</code>成为下一次<code>GC</code>时的<code>SurvivorFrom</code>区，部分对象会在<code>From</code>和<code>To</code>区域中复制来复制去，如此交换<code>15</code>次（由<code>JVM</code>参数<code>MaxTenuringThreshold</code>决定，这个参数默认为<code>15</code>），最终如果还是存活，就存入老年代。</p>\n<p>这里就是调整这个次数的，默认是15，并且设置的值 在 <code>0~15</code>之间。</p>\n<p><code>-XX:MaxTenuringThreshold=0</code>：设置垃圾最大年龄。如果设置为0的话，则年轻对象不经过<code>Survivor</code>区，直接进入老年代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大的值，则年轻代对象会在<code>Survivor</code>区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概念。</p>\n",
            "tags": [
                "Java面试",
                "JVM"
            ]
        },
        {
            "id": "https://smile1231.github.io/posts/57681474/",
            "url": "https://smile1231.github.io/posts/57681474/",
            "title": "JVM简单原理",
            "date_published": "2022-02-15T14:33:11.000Z",
            "content_html": "<h1 id=\"Jvm原理的第一次接触\"><a href=\"#Jvm原理的第一次接触\" class=\"headerlink\" title=\"Jvm原理的第一次接触\"></a><code>Jvm</code>原理的第一次接触</h1><h2 id=\"JVM内存结构\"><a href=\"#JVM内存结构\" class=\"headerlink\" title=\"JVM内存结构\"></a><code>JVM</code>内存结构</h2><span id=\"more\"></span>\n\n<img data-src=\"/posts/57681474/2022-02-16-20-49-46.png\" class=\"\">\n\n<ul>\n<li>第一，<code>JVM</code>分为五个区域：虚拟机栈(<code>VM Stack</code>)、本地方法栈(<code>Native Method Stack</code>)、方法区(<code>Method Area</code>)、堆(<code>Heap</code>)、程序计数器(<code>Program Counter Register</code>)。<code>PS</code>：大家不要排斥英语，此处用英文记忆反而更容易理解。</li>\n<li>第二，<code>JVM</code>五个区中虚拟机栈、本地方法栈、程序计数器为线程私有，方法区和堆为线程共享区。图中已经用颜色区分，绿色表示“通行”，橘黄色表示停一停（需等待）。</li>\n<li>第三，<code>JVM</code>不同区域的占用内存大小不同，一般情况下堆最大，程序计数器较小。那么最大的区域会放什么？当然就是<code>Java中最多的“对象”</code>了。<br>学习延伸：如果你记住了这张图，是不是就可以说出关于<code>JVM</code>的内存结构了呢？可以尝试一下，切记不用死记硬背，发挥你的想象。</li>\n</ul>\n<h2 id=\"堆-Heap\"><a href=\"#堆-Heap\" class=\"headerlink\" title=\"堆(Heap)\"></a>堆(<code>Heap</code>)</h2><p>上面已经得出结论，堆内存最大，堆是被线程共享，堆的目的就是存放对象。几乎所有的对象实例都在此分配。当然，随着优化技术的更新，某些数据也会被放在栈上等。</p>\n<p>枪打出头鸟，树大招风。因为堆占用内存空间最大，堆也是<code>Java</code>垃圾回收的主要区域（重点对象），因此也称作<code>“GC堆”</code>（<code>Garbage Collected Heap</code>）。</p>\n<p>关于<code>GC</code>的操作，我们后面章节会详细讲，但正因为<code>GC</code>的存在，而现代收集器基本都采用分代收集算法，堆又被细化了。</p>\n<img data-src=\"/posts/57681474/2022-02-16-20-49-59.png\" class=\"\">\n\n<p>同样，对上图呈现内容汇总分析。</p>\n<ul>\n<li>第一，堆的<code>GC</code>操作采用分代收集算法。</li>\n<li>第二，堆区分了新生代和老年代；</li>\n<li>第三，新生代又分为：<code>Eden</code>空间、<code>From Survivor（S0）</code>空间、<code>To Survivor（S1）</code>空间。</li>\n</ul>\n<p><code>Java</code>虚拟机规范规定，<code>Java</code>堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。也就是说堆的内存是一块块拼凑起来的。要增加堆空间时，往上“拼凑”（可扩展性）即可，但当堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p>\n<h2 id=\"方法区（Method-Area）\"><a href=\"#方法区（Method-Area）\" class=\"headerlink\" title=\"方法区（Method Area）\"></a>方法区<code>（Method Area）</code></h2><p>方法区与堆有很多共性：线程共享、内存不连续、可扩展、可垃圾回收，同样当无法再扩展时会抛出<code>OutOfMemoryError</code>异常。</p>\n<p>正因为如此相像，<code>Java</code>虚拟机规范把<em><strong>方法区描述为堆</strong></em>的一个逻辑部分，但目前实际上是与<code>Java</code>堆分开的（<code>Non-Heap</code>）。</p>\n<p>方法区个性化的是，它存储的是<em><strong>已被虚拟机加载的类信息、常量、静态变量</strong></em>即时编译器编译后的代码等数据。</p>\n<p>方法区的内存回收目标主要是针对<em><strong>常量池的回收和对类型的卸载</strong></em>，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是回收确实是有必要的。</p>\n<img data-src=\"/posts/57681474/2022-02-16-20-50-12.png\" class=\"\">\n\n\n<h2 id=\"程序计数器（Program-Counter-Register）\"><a href=\"#程序计数器（Program-Counter-Register）\" class=\"headerlink\" title=\"程序计数器（Program Counter Register）\"></a>程序计数器（<code>Program Counter Register</code>）</h2><p>关于程序计数器我们已经得知：占用内存较小，现成私有。它是唯一没有<code>OutOfMemoryError</code>异常的区域。</p>\n<p>程序计数器的作用可以看做是当前线程所执行的<strong>字节码的行号指示器</strong>，字节码解释器工作时就是通过改变计数器的值来选取下一条字节码指令。其中，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器来完成。</p>\n<p><code>Java</code>虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。</p>\n<img data-src=\"/posts/57681474/2022-02-16-20-50-23.png\" class=\"\">\n\n\n\n<p>因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>\n<p>如果线程正在执行的是一个<code>Java</code>方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<code>Natvie</code>方法，这个计数器值则为空（<code>Undefined</code>）。</p>\n<h2 id=\"虚拟机栈（JVM-Stacks）\"><a href=\"#虚拟机栈（JVM-Stacks）\" class=\"headerlink\" title=\"虚拟机栈（JVM Stacks）\"></a>虚拟机栈（<code>JVM Stacks</code>）</h2><p>虚拟机栈线程私有，生命周期与线程相同。</p>\n<p>栈帧(<code>Stack Frame</code>)是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。</p>\n<img data-src=\"/posts/57681474/2022-02-16-20-50-34.png\" class=\"\">\n\n\n<p>局部变量表(<code>Local Variable Table</code>)是一组变量值存储空间，用于<code>存放方法参数</code>和<code>方法内定义</code>的局部变量。包括8种基本数据类型、对象引用（<code>reference</code>类型）和<code>returnAddress</code>类型（指向一条字节码指令的地址）。</p>\n<p>其中<code>64位</code>长度的<code>long</code>和<code>double</code>类型的数据会占用2个局部变量空间（<code>Slot</code>），其余的数据类型只占用<code>1</code>个。</p>\n<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常；如果虚拟机栈动态扩展时无法申请到足够的内存时会抛出<code>OutOfMemoryError</code>异常。</p>\n<p>操作数栈(<code>Operand Stack</code>)也称作操作栈，是一个<code>后入先出栈(LIFO)</code>。随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。</p>\n<p>动态链接：<code>Java</code>虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接(<code>Dynamic Linking</code>)。</p>\n<p>方法返回：无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行。</p>\n<h2 id=\"本地方法栈（Native-Method-Stacks）\"><a href=\"#本地方法栈（Native-Method-Stacks）\" class=\"headerlink\" title=\"本地方法栈（Native Method Stacks）\"></a>本地方法栈（<code>Native Method Stacks</code>）</h2><p>本地方法栈（<code>Native Method Stacks</code>）与虚拟机栈作用相似，也会抛出<code>StackOverflowError和OutOfMemoryError</code>异常。</p>\n<p>区别在于虚拟机栈为虚拟机执行<code>Java</code>方法（<code>字节码</code>）服务，而本地方法栈是为虚拟机使用到的<code>Native</code>方法服务。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><img data-src=\"/posts/57681474/2022-02-16-20-50-46.png\" class=\"\">\n\n\n\n\n\n\n\n\n",
            "tags": [
                "Java面试",
                "Jvm"
            ]
        }
    ]
}
{
    "version": "https://jsonfeed.org/version/1",
    "title": "JIN MAO 's Blog • All posts by \"线程池\" tag",
    "description": "",
    "home_page_url": "https://smile1231.github.io",
    "items": [
        {
            "id": "https://smile1231.github.io/posts/1748805d/",
            "url": "https://smile1231.github.io/posts/1748805d/",
            "title": "java线程池与五种常用线程池策略使用与解析",
            "date_published": "2021-12-28T08:53:41.000Z",
            "content_html": "<h1 id=\"一线程池\"><a class=\"markdownIt-Anchor\" href=\"#一线程池\">#</a> 一。线程池</h1>\n<p>关于为什么要使用线程池久不赘述了，首先看一下 <code>java</code>  中作为线程池 <code>Executor</code>  底层实现类的 <code>ThredPoolExecutor</code>  的构造函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                              <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                              <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                              TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                              ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>其中各个参数含义如下：</p>\n<ul>\n<li><code>corePoolSize</code> - 池中所保存的线程数，包括空闲线程。需要注意的是在初创建线程池时线程不会立即启动，直到有任务提交才开始启动线程并逐渐时线程数目达到 <code>corePoolSize</code> 。若想一开始就创建所有核心线程需调用 <code>prestartAllCoreThreads</code>  方法。</li>\n<li><code>maximumPoolSize</code> - 池中允许的最大线程数。需要注意的是当核心线程满且阻塞队列也满时才会判断当前线程数是否小于最大线程数，并决定是否创建新线程。</li>\n<li><code>keepAliveTime</code>  - 当线程数大于核心时，多于的空闲线程最多存活时间</li>\n<li><code>unit</code>  -  <code>keepAliveTime</code>  参数的时间单位。</li>\n<li><code>workQueue</code>  - 当线程数目超过核心线程数时用于保存任务的队列。主要有 3 种类型的 <code>BlockingQueue</code>  可供选择：无界队列，有界队列和同步移交。将在下文中详细阐述。从参数中可以看到，此队列仅保存实现 <code>Runnable</code>  接口的任务。</li>\n<li><code>threadFactory</code>  - 执行程序创建新线程时使用的工厂。</li>\n<li><code>handler</code>  - 阻塞队列已满且线程数达到最大值时所采取的饱和策略。 <code>java</code>  默认提供了 4 种饱和策略的实现方式：中止、抛弃、抛弃最旧的、调用者运行。将在下文中详细阐述:</li>\n</ul>\n<h2 id=\"二可选择的阻塞队列blockingqueue详解\"><a class=\"markdownIt-Anchor\" href=\"#二可选择的阻塞队列blockingqueue详解\">#</a> 二。可选择的阻塞队列 <code>BlockingQueue</code>  详解</h2>\n<p>首先看一下新任务进入时线程池的执行策略：<br>\n如果运行的线程少于 <code>corePoolSize</code> ，则  <code>Executor</code>  始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于 <code>corePoolSize</code> ，则任务根本不会存入 <code>queue</code>  中，而是直接运行）<br>\n如果运行的线程大于等于  <code>corePoolSize</code> ，则  <code>Executor</code>  始终首选将请求加入队列，而不添加新的线程。<br>\n如果无法将请求加入队列，则创建新的线程，除非创建此线程超出  <code>maximumPoolSize</code> ，在这种情况下，任务将被拒绝。<br>\n主要有 3 种类型的 <code>BlockingQueue</code> :</p>\n<h2 id=\"21-无界队列\"><a class=\"markdownIt-Anchor\" href=\"#21-无界队列\">#</a> 2.1 无界队列</h2>\n<p>队列大小无限制，常用的为无界的 <code>LinkedBlockingQueue</code> ，使用该队列做为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致 <code>OOM</code> 。最近工作中就遇到因为采用 <code>LinkedBlockingQueue</code>  作为阻塞队列，部分任务耗时 <code>80s</code> ＋且不停有新任务进来，导致 <code>cpu</code>  和内存飙升服务器挂掉。</p>\n<h2 id=\"22-有界队列\"><a class=\"markdownIt-Anchor\" href=\"#22-有界队列\">#</a> 2.2 有界队列</h2>\n<p>常用的有两类，一类是遵循 <code>FIFO</code>  原则的队列如 <code>ArrayBlockingQueue</code>  与有界的 <code>LinkedBlockingQueue</code> ，另一类是优先级队列如 <code>PriorityBlockingQueue</code> 。 <code>PriorityBlockingQueue</code>  中的优先级由任务的 <code>Comparator</code>  决定。<br>\n使用有界队列时队列大小需和线程池大小互相配合，线程池较小有界队列较大时可减少内存消耗，降低 <code>cpu</code>  使用率和上下文切换，但是可能会限制系统吞吐量。</p>\n<h2 id=\"23-同步移交\"><a class=\"markdownIt-Anchor\" href=\"#23-同步移交\">#</a> 2.3 同步移交</h2>\n<p>如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用 <code>SynchronousQueue</code>  作为等待队列。 <code>SynchronousQueue</code>  不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入 <code>SynchronousQueue</code>  中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。</p>\n<h2 id=\"24-几种blockingqueue的具体实现原理\"><a class=\"markdownIt-Anchor\" href=\"#24-几种blockingqueue的具体实现原理\">#</a> 2.4 几种 <code>BlockingQueue</code>  的具体实现原理</h2>\n<p>关于上述几种 <code>BlockingQueue</code>  的具体实现原理与分析将在下篇博文中详细阐述。</p>\n<h1 id=\"三可选择的饱和策略rejectedexecutionhandler详解\"><a class=\"markdownIt-Anchor\" href=\"#三可选择的饱和策略rejectedexecutionhandler详解\">#</a> 三。可选择的饱和策略 <code>RejectedExecutionHandler</code>  详解</h1>\n<p><code>JDK</code>  主要提供了 <code>4</code>  种饱和策略供选择。 <code>4</code>  种策略都做为静态内部类在 <code>ThreadPoolExcutor</code>  中进行实现。</p>\n<h2 id=\"31-abortpolicy中止策略\"><a class=\"markdownIt-Anchor\" href=\"#31-abortpolicy中止策略\">#</a> 3.1  <code>AbortPolicy</code>  中止策略</h2>\n<p>该策略是默认饱和策略。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RejectedExecutionException(<span class=\"string\">&quot;Task &quot;</span> + r.toString() +</span><br><span class=\"line\">                                                <span class=\"string\">&quot; rejected from &quot;</span> +</span><br><span class=\"line\">                                                e.toString());</span><br><span class=\"line\">          &#125;</span><br></pre></td></tr></table></figure>\n<p>使用该策略时在饱和时会抛出 <code>RejectedExecutionException（继承自RuntimeException）</code> ，调用者可捕获该异常自行处理。</p>\n<h2 id=\"32-discardpolicy抛弃策略\"><a class=\"markdownIt-Anchor\" href=\"#32-discardpolicy抛弃策略\">#</a> 3.2  <code>DiscardPolicy</code>  抛弃策略</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>如代码所示，不做任何处理直接抛弃任务</p>\n<h2 id=\"33-discardoldestpolicy抛弃旧任务策略\"><a class=\"markdownIt-Anchor\" href=\"#33-discardoldestpolicy抛弃旧任务策略\">#</a> 3.3 DiscardOldestPolicy 抛弃旧任务策略</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!e.isShutdown()) &#123;</span><br><span class=\"line\">            e.getQueue().poll();</span><br><span class=\"line\">            e.execute(r);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如代码，先将阻塞队列中的头元素出队抛弃，再尝试提交任务。如果此时阻塞队列使用 <code>PriorityBlockingQueue</code>  优先级队列，将会导致优先级最高的任务被抛弃，因此不建议将该种策略配合优先级队列使用。</p>\n<h2 id=\"34-callerrunspolicy调用者运行\"><a class=\"markdownIt-Anchor\" href=\"#34-callerrunspolicy调用者运行\">#</a> 3.4  <code>CallerRunsPolicy</code>  调用者运行</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!e.isShutdown()) &#123;</span><br><span class=\"line\">            r.run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>既不抛弃任务也不抛出异常，直接运行任务的 <code>run</code>  方法，换言之将任务回退给调用者来直接运行。使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成。</p>\n<h1 id=\"四java提供的四种常用线程池解析\"><a class=\"markdownIt-Anchor\" href=\"#四java提供的四种常用线程池解析\">#</a> 四. <code>java</code>  提供的四种常用线程池解析</h1>\n<p>在 <code>JDK</code>  帮助文档中，有如此一段话：</p>\n<p>强烈建议程序员使用较为方便的 <code>Executors</code>  工厂方法 <code>Executors.newCachedThreadPool()</code> （无界线程池，可以进行自动线程回收）、 <code>Executors.newFixedThreadPool(int)</code> （固定大小线程池） <code>Executors.newSingleThreadExecutor()</code> （单个后台线程）它们均为大多数使用场景预定义了设置。</p>\n<p>详细介绍一下上述四种线程池。</p>\n<h2 id=\"41-newcachedthreadpool\"><a class=\"markdownIt-Anchor\" href=\"#41-newcachedthreadpool\">#</a> 4.1  <code>newCachedThreadPool</code></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>newCachedThreadPool</code>  中如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>\n初看该构造函数时我有这样的疑惑：核心线程池为 <code>0</code> ，那按照前面所讲的线程池策略新任务来临时无法进入核心线程池，只能进入  <code>SynchronousQueue</code>  中进行等待，而 <code>SynchronousQueue</code>  的大小为 1，那岂不是第一个任务到达时只能等待在队列中，直到第二个任务到达发现无法进入队列才能创建第一个线程？<br>\n这个问题的答案在上面讲 <code>SynchronousQueue</code>  时其实已经给出了，要将一个元素放入 <code>SynchronousQueue</code>  中，必须有另一个线程正在等待接收这个元素。因此即便 <code>SynchronousQueue</code>  一开始为空且大小为 <code>1</code> ，第一个任务也无法放入其中，因为没有线程在等待从 <code>SynchronousQueue</code>  中取走元素。因此第一个任务到达时便会创建一个新线程执行该任务。<br>\n这里引申出一个小技巧：有时我们可能希望线程池在没有任务的情况下销毁所有的线程，既设置线程池核心大小为 <code>0</code> ，但又不想使用 <code>SynchronousQueue</code>  而是想使用有界的等待队列。显然，不进行任何特殊设置的话这样的用法会发生奇怪的行为：直到等待队列被填满才会有新线程被创建，任务才开始执行。这并不是我们希望看到的，此时可通过 <code>allowCoreThreadTimeOut</code>  使等待队列中的元素出队被调用执行</p>\n<h2 id=\"42-newfixedthreadpool-创建一个定长线程池可控制线程最大并发数超出的线程会在队列中等待\"><a class=\"markdownIt-Anchor\" href=\"#42-newfixedthreadpool-创建一个定长线程池可控制线程最大并发数超出的线程会在队列中等待\">#</a> 4.2  <code>newFixedThreadPool</code>  创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                    <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                    <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>看代码一目了然了，使用固定大小的线程池并使用无限大的队列</p>\n<h2 id=\"43-newscheduledthreadpool-创建一个定长线程池支持定时及周期性任务执行\"><a class=\"markdownIt-Anchor\" href=\"#43-newscheduledthreadpool-创建一个定长线程池支持定时及周期性任务执行\">#</a> 4.3  <code>newScheduledThreadPool</code>  创建一个定长线程池，支持定时及周期性任务执行。</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在来看看 <code>ScheduledThreadPoolExecutor（）</code> 的构造函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScheduledThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(corePoolSize, Integer.MAX_VALUE, <span class=\"number\">0</span>, NANOSECONDS,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> DelayedWorkQueue());</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><code>ScheduledThreadPoolExecutor</code>  的父类即 <code>ThreadPoolExecutor</code> ，因此这里各参数含义和上面一样。值得关心的是 <code>DelayedWorkQueue</code>  这个阻塞对列，在上面没有介绍，它作为静态内部类就在 <code>ScheduledThreadPoolExecutor</code>  中进行了实现。具体分析讲会在后续博客中给出，在这里只进行简单说明： <code>DelayedWorkQueue</code>  是一个无界队列，它能按一定的顺序对工作队列中的元素进行排列。因此这里设置的最大线程数  <code>Integer.MAX_VALUE</code>  没有任何意义。</p>\n<h2 id=\"44-newsinglethreadexecutor-创建一个单线程化的线程池它只会用唯一的工作线程来执行任务保证所有任务按照指定顺序fifo-lifo-优先级执行\"><a class=\"markdownIt-Anchor\" href=\"#44-newsinglethreadexecutor-创建一个单线程化的线程池它只会用唯一的工作线程来执行任务保证所有任务按照指定顺序fifo-lifo-优先级执行\">#</a> 4.4  <code>newSingleThreadExecutor</code>  创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序 ( <code>FIFO, LIFO,</code>  优先级) 执行。</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newSingleThreadScheduledExecutor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DelegatedScheduledExecutorService</span><br><span class=\"line\">        (<span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先 <code>new</code>  了一个线程数目为 <code>1</code>  的 <code>ScheduledThreadPoolExecutor</code> ，再把该对象传入 <code>DelegatedScheduledExecutorService</code>  中，看看 <code>DelegatedScheduledExecutorService</code>  的实现代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DelegatedScheduledExecutorService(ScheduledExecutorService executor) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">super</span>(executor);</span><br><span class=\"line\">           e = executor;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>在看看它的父类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;</span><br></pre></td></tr></table></figure>\n<p>其实就是使用装饰模式增强了 <code>ScheduledExecutorService（1）</code> 的功能，不仅确保只有一个线程顺序执行任务，也保证线程意外终止后会重新创建一个线程继续执行任务。具体实现原理会在后续博客中讲解。</p>\n<h2 id=\"45-newworkstealingpool创建一个拥有多个任务队列以便减少连接数的线程池\"><a class=\"markdownIt-Anchor\" href=\"#45-newworkstealingpool创建一个拥有多个任务队列以便减少连接数的线程池\">#</a> 4.5  <code>newWorkStealingPool</code>  创建一个拥有多个任务队列（以便减少连接数）的线程池。</h2>\n<p>这是 <code>jdk1.8</code>  中新增加的一种线程池实现，先看一下它的无参实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newWorkStealingPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ForkJoinPool</span><br><span class=\"line\">        (Runtime.getRuntime().availableProcessors(),</span><br><span class=\"line\">          ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class=\"line\">          <span class=\"keyword\">null</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回的 <code>ForkJoinPool</code>  从 <code>jdk1.7</code>  开始引进，个人感觉类似于 <code>mapreduce</code>  的思想。这个线程池较为特殊</p>\n",
            "tags": [
                "Java",
                "线程池"
            ]
        }
    ]
}
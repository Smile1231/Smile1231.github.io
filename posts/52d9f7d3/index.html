



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="JIN MAO 's Blog" href="https://smile1231.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="JIN MAO 's Blog" href="https://smile1231.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="JIN MAO 's Blog" href="https://smile1231.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="HashMap" />


<link rel="canonical" href="https://smile1231.github.io/posts/52d9f7d3/">



  <title>
Java面试必问--HashMap的底层 - HashMap - Java面试 |
Jin Mao when to get rich ? = JIN MAO 's Blog = got windy(起风了)</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">Java面试必问--HashMap的底层
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2022-02-09 17:00:15">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2022-02-09T17:00:15+08:00">2022-02-09</time>
  </span>
  <span class="item" title="Symbols count in article">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">Symbols count in article</span>
    <span>22k</span>
    <span class="text">words</span>
  </span>
  <span class="item" title="Reading time">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">Reading time</span>
    <span>20 mins.</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Jin Mao when to get rich ?</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclize41wj20zk0m87gk.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicljitigmj20zk0m87fp.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclx29mstj20zk0m8hdt.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipexj2jgzj20zk0m8b09.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipevuctzzj20zk0m84qp.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclh0m9pdj20zk0m8hdt.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Java%E9%9D%A2%E8%AF%95/" itemprop="item" rel="index" title="In Java面试"><span itemprop="name">Java面试</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Java%E9%9D%A2%E8%AF%95/HashMap/" itemprop="item" rel="index" title="In HashMap"><span itemprop="name">HashMap</span></a>
<meta itemprop="position" content="2" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://smile1231.github.io/posts/52d9f7d3/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.png">
    <meta itemprop="name" content="JIN Mao">
    <meta itemprop="description" content="got windy(起风了), ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="JIN MAO 's Blog">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h2 id="jdk7-HashMap"><a href="#jdk7-HashMap" class="headerlink" title="jdk7 HashMap"></a><code>jdk7 HashMap</code></h2><blockquote>
<p>数组</p>
</blockquote>
<p>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为<code>O(1)</code>；<br>数组的特点是：寻址容易，插入和删除困难；</p>
<ul>
<li><code>HashMap</code> 里面实现一个静态内部类 <code>Entry，Entry</code> 包含四个属性：<code>key，value，hash</code>值和用于单向链表的 <code>next</code>。<code>Entry</code> 就是 <code>HashMap</code> 键值对实现的一个基础 <code>bean</code>，我们上面说到 <code>HashMap</code> 的基础就是一个线性数组，这个数组就是 <code>Entry[]，Map</code> 里面的内容都保存在 <code>Entry[]</code> 里面</li>
</ul>
<span id="more"></span>

<blockquote>
<p>链表</p>
</blockquote>
<p>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，为<code>O(N)</code>。<br>链表的特点是：寻址困难，插入和删除容易。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);   <span class="comment">// 比 hash(key)%(length -1) 更高效的方法</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>1.8</code>之前是这样的头插法: 当<code>put</code>时要插入的元素的索引有重复时，会发生<code>hash</code>冲突碰撞，此时链表发挥作用：新插入的<code>Entry</code>的<code>next</code>指针指向旧的<code>Entry</code>，并通过修改当前索引位置的引用地址指向新的<code>Entry</code>，链表向下移动从而取代旧<code>Entry</code>的位置，放在数组相应索引位置，</li>
</ul>
<p><strong>哈希表</strong> 那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表<code>（(Hash table）</code>既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。</p>
<ul>
<li>每个数据对象的<code>hash</code>对应唯一一个值，但是一个<code>hash</code>值不一定对应唯一的数据对象。如果两个不同对象的 <code>hash</code> 哈希冲突。</li>
</ul>
<p>哈希表是由数组+链表组成的，一个长度为<code>16</code>的数组中，每个数组中元素存储的是一个链表的头结点。</p>
<img data-src="/posts/52d9f7d3/2022-02-21-12-14-24.png" class="">

<ul>
<li>源码解析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="comment">// 另外3个构造方法都会调用带有2个参数的构造方法：HashMap(int initialCapacity, float loadFactor)</span></span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另外3个构造方法都会调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>put</code>源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果put的key在map中已经存在则旧value会被覆盖，然后返回被覆盖的value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="comment">// 使用头插法的原因是：插入结点的速度比尾插法更快</span></span><br><span class="line">        <span class="comment">// 遍历当前数组索引 i 上的链表从而寻找到该链表的尾结点</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">// 如果插入当前链表的结点它的hashCode和key都相等</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;  <span class="comment">// 先取出oldValue，最后要返回该值</span></span><br><span class="line">                e.value = value;		<span class="comment">// 覆盖oldValue</span></span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);  <span class="comment">// hashMap用不到，LinkedList采用得到该方法</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;  <span class="comment">// 返回被覆盖的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++; <span class="comment">// 表示修改次数</span></span><br><span class="line">        addEntry(hash, key, value, i); <span class="comment">// 数组扩容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="put头插法的问题"><a href="#put头插法的问题" class="headerlink" title="put头插法的问题"></a><code>put</code>头插法的问题</h3><p>数据插入使用头插法，会造成一个问题：<br>在<code>resize</code>扩容时，里面有一个<code>resize</code>方法又调用了<code>transfer</code>方法，把里面一些<code>Entry</code>进行了<code>rehash</code>，在这个过程中可能造成一个链表的循环，可能导致在下一次<code>Get</code>时候出现要给死循环； 也有可能因为没有加锁，在多个线程并发情况下，不能保证数据安全，可能<code>put</code>一个值<code>get</code>出来还是那个值</p>
<ul>
<li>数组<code>table</code>容量初始化（<code>inflateTable</code>）<br>在第一个元素插入 <code>HashMap</code> 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证数组大小一定是 2 的 n 次方。</span></span><br><span class="line">    <span class="comment">// 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">// 计算扩容阈值：capacity * loadFactor</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 算是初始化数组吧</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); <span class="comment">//ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算具体数组位置（indexFor）"><a href="#计算具体数组位置（indexFor）" class="headerlink" title="计算具体数组位置（indexFor）"></a>计算具体数组位置（<code>indexFor</code>）</h3><p>取<code>hash</code> 值的低 <code>n</code> 位。如在数组长度为 <code>32</code> 的时候，其实取的就是 <code>key</code> 的 <code>hash</code> 值的低 <code>5</code> 位，作为它在数组中的下标位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> hash, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> hash &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加节点到链表中（addEntry）"><a href="#添加节点到链表中（addEntry）" class="headerlink" title="添加节点到链表中（addEntry）"></a>添加节点到链表中（<code>addEntry</code>）</h3><ul>
<li>找到数组下标后，会先进行 <code>key</code> 判重，如果没有重复，就准备将新值放入到链表的表头。</li>
<li>主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 扩容，后面会介绍一下</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">// 扩容以后，重新计算 hash 值</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 重新计算扩容后的新的下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往下看</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个很简单，其实就是将新值放到链表的表头，然后 size++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组扩容（resize）"><a href="#数组扩容（resize）" class="headerlink" title="数组扩容（resize）"></a>数组扩容（<code>resize</code>）</h3><ul>
<li>插入新值的时候，如果当前的 <code>size</code> 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 <code>2</code> 倍。</li>
<li>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</li>
<li>数组扩容是为了分散链表，让链表变短而使得<code>get</code>效率提高，加快查询效率</li>
<li>由于是双倍扩容，迁移过程中，会将原来 <code>table[i]</code> 中的链表的所有节点，分拆到新的数组的 <code>newTable[i]</code>和 <code>newTable[i + oldLength]</code> 位置上。如原来数组长度是 <code>16</code>，那么扩容后，原来 <code>table[0]</code> 处的链表中的所有元素会被分配到新数组中 <code>newTable[0]</code> 和 <code>newTable[16]</code> 这两个位置。代码比较简单，这里就不展开了。</li>
<li>毛病：在多线程扩容时有可能会出现循环链表的情况，导致在get时会循环遍历。起因是扩容时使用头插法，导致<code>next</code>在结点<code>e</code> 之前，使得数据顺序发生变化</li>
</ul>
<p>解决方法：防止<code>hash</code>扩容，具体可以控制阈值<code>threshold</code>大于所需要的数组。还可以加锁、并发安全控制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将原来数组中的值迁移到新的更大的数组中  transfer()底层是通过双重循环数组直到非空元素，然后转移到新的数组相对应的索引位置</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity)); <span class="comment">// 元素转移</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a><code>get</code> 过程分析</h3><ul>
<li>根据 <code>key</code> 计算 <code>hash</code> 值。</li>
<li>找到相应的数组下标：<code>hash &amp; (length - 1)</code>。</li>
<li>遍历该数组位置处的链表，直到找到相等<code>(==或equals)</code>的 <code>key</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="comment">// 确定数组下标，然后从头开始遍历链表，直到找到为止</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];   <span class="comment">// 定位数组下标，遍历链表</span></span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;  <span class="comment">// 通过比较key和hash是否相等，相等则表示找到，返回entry</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a><strong><code>remove</code></strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;  </span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>1.7的插入存储底层实现：</p>
<ul>
<li>数组(默认长度为<code>16bit</code>，源码默认容量 <code>= 1 &lt;&lt; 4</code>， 最大容量限制：<code>1 &lt;&lt; 30</code>)：</li>
</ul>
<ul>
<li>数组中还可以存放数组，每个数组中的一个存储单元存储的是 <code>Entry</code>(属性包括：<code>key, value, hash，Node&lt;K,V&gt; next</code>(数组+链表)) 结构的数据，<code>Entry</code>的实现是一个链表<code>Node</code>(属性和<code>Entry</code>相同)。其中元素在数组中的存储索引下标可以通过：(<code>hash % arr.length-1</code>) 得出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">put(key, value)&#123;  <span class="comment">// put底层伪代码</span></span><br><span class="line">	<span class="keyword">int</span> hashcode = key.hashcode();</span><br><span class="line">	<span class="keyword">int</span> index = hashcode % table.legnth;</span><br><span class="line">	table[index] = <span class="keyword">new</span> Entry(key, value, table[index]); <span class="comment">// 头插法，新结点指向数组上对应索引的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="jdk8-HashMap"><a href="#jdk8-HashMap" class="headerlink" title="jdk8 HashMap"></a><code>jdk8 HashMap</code></h2><ul>
<li><code>1.7</code>之前<code>put</code>是头插法，<code>1.8</code>之后是尾插法，头插法会出现链表循环的问题，后者不会，但都不是线程安全</li>
</ul>
<ul>
<li>数组：一段连续的存储单元来存储结构,插入慢<code>O(n)</code>查找快<code>O(1)</code>； 链表<code>Node</code>：一种物理存储单元上非连续、非顺序的存储结构，插入快<code>O(1)</code>查找慢<code>O(n)</code></li>
</ul>
<ul>
<li><code>HashMap</code>线程不安全，底层没有锁，线程安全的<code>HashMap：Collections.synchronizedMap()、new ConcurrentHashMap&lt;&gt;()</code>;</li>
</ul>
<ul>
<li><code>HashMap</code>底层是：数组+<code>Node</code>链表+的红黑树，每个数据单元都是一个<code>Node</code>结构。容量为<code>16</code>，负载因子<code>0.75</code>(即装载的内存超过容量的<code>3/4</code>会自动扩容，<code>HashMap</code>扩容为当前的<code>2</code>倍，即<code>2^(4+1)</code>，<code>ArrayList</code>扩容为原来的一半).</li>
</ul>
<ul>
<li><code>hashMap</code>的散列表，采用懒加载机制，只有第一次<code>put</code>时才会创建，而不是<code>new</code>就创建</li>
</ul>
<ul>
<li><code>Node</code>结构中包含<code>key、value、next、hash</code>字段，其中<code>next</code>字段是当发生<code>hash</code>冲突时，当前桶位中的<code>node</code>与冲突<code>node</code>连成一个链表要用的字段</li>
</ul>
<ul>
<li><code>hash</code>值是通过<code>key.hashCode()</code>二次加工得到的，加工原则是<code>key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)</code> ， 即高<code>16</code>位和低<code>16</code>位的异或。这样做主要是为了加大散列程度的散列化，也是因为<code>hash</code>寻址算法的缘故：</li>
</ul>
<ul>
<li><code>HashMap</code>可以存放<code>key</code>为空的元素：<code>map.put(null, &quot;xxx&quot;)</code> 当<code>key</code>为<code>null</code>时，<code>JVM</code>会单独分配一片空间用来存放该值，再次<code>put</code>一个<code>key</code>为<code>null</code>的值时会覆盖之前的</li>
</ul>
<ul>
<li><code>capacity</code>：当前数组容量，始终保持 <code>2^n</code>，可以扩容，扩容后数组大小为当前的 <code>2</code> 倍。</li>
</ul>
<ul>
<li><code>loadFactor</code>：负载因子，默认为<code>0.75</code>。</li>
</ul>
<ul>
<li><code>threshold</code>：扩容的阈值，等于<code>capacity * loadFactor</code>。</li>
</ul>
<blockquote>
<p> 1、扩容的数组的长度为什么保持 <code>2^n？</code></p>
</blockquote>
<p>其实这是为了保证通过hash方式获取下标的时候分布均匀。数组长度为2的<code>n</code>次幂的时候，不同的<code>key</code> 算得的 <code>index</code> 相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
<blockquote>
<p>2、为什么负载因子的值默认为 <code>0.75？</code></p>
</blockquote>
<p>加载因子是表示<code>Hash</code>表中元素的填满的程度。<br>加载因子越大，填满的元素越多，空间利用率越高，但冲突的机会加大了。<br>反之,加载因子越小，填满的元素越少，冲突的机会减小，但空间浪费多了。<br>冲突的机会越大，则查找的成本越高。反之，查找的成本越小。<br>因此,必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。</p>
<ul>
<li><code>Java7 HashMap</code> ，查找的时候，根据 <code>hash</code> 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 <code>O(n)</code>。</li>
</ul>
<p><strong>为了降低这部分的开销，在 <code>Java8</code> 中，当链表中的元素达到了 <code>8</code> 个，且散列表数组长度已经达到<code>64</code>，会将链表转换为红黑树，否则进行数组扩容，在这些位置进行查找的时候可以降低时间复杂度为 <code>O(logN)</code>。</strong></p>
<img data-src="/posts/52d9f7d3/2022-02-21-17-09-33.png" class="">

<p><strong>链表转化为红黑树有两个条件：</strong></p>
<p><code>putVal</code>时进行判断，链表长度到达<code>8</code>调用<code>treeifyBin</code> 转换红黑树的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// TREEIFY_THRESHOLD 值为8</span></span><br><span class="line">     treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure>

<p>但在转换红黑树前还会进行判断：数组长度是否小于<code>64</code>，小于则散列表<code>resize</code>扩容，大于等于<code>64</code>则链表转红黑树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表转红黑树</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 但在转换红黑树前还会进行判断：数组长度是否小于64</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) <span class="comment">// MIN_TREEIFY_CAPACITY值为64</span></span><br><span class="line">        resize(); 	<span class="comment">// 散列表扩容</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; <span class="comment">// 数组长度大于64，链表转为红黑树</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>当数组其中一个索引位置上的链表长度大于<code>8</code>时，调用转换红黑树方法<code>treeifyBin</code></p>
</li>
<li><p>当前散列表数组长度已经达到<code>64</code>，两个指标都要达到，否则就算<code>slot</code>内部链表长度达到<code>8</code>也不会链转树，而是发生一次<code>resize</code>散列表扩容</p>
</li>
</ol>
<h3 id="红黑树-RB-Tree"><a href="#红黑树-RB-Tree" class="headerlink" title="红黑树 RB-Tree"></a>红黑树 <code>RB-Tree</code></h3><ul>
<li>二叉查找树是不平衡的，可能会变成链表，因此需要采用红黑树（<code>RB-Tree</code>），插入和查询的 <code>O(n) = logn</code></li>
<li>红黑树只需要保证黑色结点高度平衡，且满足以下<code>5</code>个条件</li>
</ul>
<img data-src="/posts/52d9f7d3/2022-02-21-17-31-11.png" class="">

<h2 id="红黑树插入结点规律："><a href="#红黑树插入结点规律：" class="headerlink" title="红黑树插入结点规律："></a>红黑树插入结点规律：</h2><p>根结点是黑色的，不用进行调整<br>父节点是红色：</p>
<ol>
<li>叔叔的空的，旋转 + 变色(祖父结点和父节点变色)</li>
<li>叔叔的红色，父节点+叔叔节点变黑色，祖父结点变红色</li>
<li>叔叔是黑色，旋转+变色</li>
</ol>
<h2 id="红黑树主要特性"><a href="#红黑树主要特性" class="headerlink" title="红黑树主要特性"></a>红黑树主要特性</h2><ol>
<li>每个节点要么是黑色，要么是红色。（节点非黑即红）</li>
<li>根节点是黑色。</li>
<li>每个叶子节点（<code>NIL</code>）是黑色。 </li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。（也就是说父子节点不能同时为红色）</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（这一点是平衡的关键）</li>
</ol>
<h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            x.red = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123; <span class="comment">// 要插入的结点无父节点，因此设置为黑色</span></span><br><span class="line">                    x.red = <span class="keyword">false</span>; <span class="comment">// 新结点设置为黑色</span></span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)  <span class="comment">// 情况0：父节点是黑色的，或者无祖父结点，直接返回根节点</span></span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;   <span class="comment">// 如果父节点是祖父结点的左结点</span></span><br><span class="line">                    <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123; <span class="comment">// 情况2：叔叔结点不为空且是红色</span></span><br><span class="line">                        xppr.red = <span class="keyword">false</span>;  <span class="comment">// 叔叔结点变黑</span></span><br><span class="line">                        xp.red = <span class="keyword">false</span>;  <span class="comment">// 父节点变黑</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;  <span class="comment">// 祖父节点变红</span></span><br><span class="line">                        x = xpp; <span class="comment">// 递归到祖父结点，直到满足红黑树条件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;  <span class="comment">// 情况1或3：没有叔叔结点或者叔叔结点是黑色的</span></span><br><span class="line">                        <span class="keyword">if</span> (x == xp.right) &#123;  <span class="comment">// 新结点作为右节点时</span></span><br><span class="line">                            root = rotateLeft(root, x = xp);  <span class="comment">// 先左旋后，新节点变为父节点xp </span></span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent; <span class="comment">// </span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;  <span class="comment">// 新结点作为左节点时</span></span><br><span class="line">                            xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点变为黑色</span></span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateRight(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                        xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                            root = rotateRight(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>Java7</code> 中使用 <code>Entry</code> 来代表每个 <code>HashMap</code> 中的数据节点，<code>Java8</code> 中使用 <code>Node</code>，基本没有区别，都是 <code>key，value，hash</code> 和 <code>next</code> 这四个属性，不过，<code>Node</code> 只能用于链表的情况，红黑树的情况需要使用 <code>TreeNode。</code><br>我们根据数组元素中，第一个节点数据类型是 <code>Node</code> 还是 <code>TreeNode</code> 来判断该位置下是链表还是红黑树的。</p>
<h3 id="Put方法：和-Java7-稍微有点不一样的地方就是，Java7-是先扩容后插入新值的，Java8-先插值再扩容"><a href="#Put方法：和-Java7-稍微有点不一样的地方就是，Java7-是先扩容后插入新值的，Java8-先插值再扩容" class="headerlink" title="Put方法：和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容"></a><code>Put</code>方法：和 <code>Java7</code> 稍微有点不一样的地方就是，<code>Java7</code> 是先扩容后插入新值的，<code>Java8</code> 先插值再扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span></span><br><span class="line"><span class="comment">// 第四个参数 evict 我们这里不关心</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span></span><br><span class="line">    <span class="comment">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 数组该位置有数据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明数组该位置上是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);   <span class="comment">// 1.8改用尾插法插入链表的尾部</span></span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个，此时binCount= 8</span></span><br><span class="line">                    <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">// 树化：链表转为红黑树</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;</span></span><br><span class="line">        <span class="comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount; <span class="comment">// 每次修改+1，是一种fast-fail快速失败机制，是一种容错机制，会抛ConcurrentModification</span></span><br><span class="line">    <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)     <span class="comment">// 小于当前结点，则往左边插入</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)  <span class="comment">//大于当前结点，则往右边插入</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组扩容：resize-方法用于初始化数组或数组扩容，每次扩容后，容量为原来的-2-倍，并进行数据迁移。"><a href="#数组扩容：resize-方法用于初始化数组或数组扩容，每次扩容后，容量为原来的-2-倍，并进行数据迁移。" class="headerlink" title="数组扩容：resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。"></a>数组扩容：<code>resize()</code> 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 <code>2</code> 倍，并进行数据迁移。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 对应数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组大小扩大一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 将阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用新的数组大小初始化新的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始遍历原数组，进行数据迁移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是红黑树，具体我们就不展开了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 这块是处理链表的情况，</span></span><br><span class="line">                    <span class="comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                    <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第一条链表</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get分析过程"><a href="#get分析过程" class="headerlink" title="get分析过程"></a><code>get</code>分析过程</h3><ul>
<li>计算 <code>key</code> 的 <code>hash</code> 值，根据 <code>hash</code> 值找到对应数组下标: <code>hash &amp; (length-1)</code>.</li>
</ul>
<ul>
<li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步.</li>
</ul>
<ul>
<li>判断该元素类型是否是 <code>TreeNode</code>，如果是，用红黑树的方法取数据，如果不是，走第四步.</li>
</ul>
<ul>
<li>遍历链表，直到找到相等(<code>==</code>或<code>equals</code>)的 <code>key</code>.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是不是就是需要的</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 链表遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树退化为链表"><a href="#红黑树退化为链表" class="headerlink" title="红黑树退化为链表"></a>红黑树退化为链表</h3><ul>
<li><p><code>resize</code>的时候，对红黑树进行了拆分</p>
</li>
<li><p><code>resize</code>的时候，判断节点类型，如果是链表，则将链表拆分，如果是<code>TreeNode</code>，则执行<code>TreeNode</code>的<code>split</code>方法分割红黑树，而<code>split</code>方法中将红黑树转换为链表的分支如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这之前的逻辑是将红黑树每个节点的hash和一个bit进行&amp;运算，</span></span><br><span class="line"><span class="comment">//根据运算结果将树划分为两棵红黑树，lc表示其中一棵树的节点数</span></span><br><span class="line"><span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">    tab[index] = loHead.untreeify(map);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    tab[index] = loHead;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">        loHead.treeify(tab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里才用到了 <code>UNTREEIFY_THRESHOLD</code> 的判断，当红黑树节点元素小于等于<code>6</code>时，才调用<code>untreeify</code>方法转换回链表</p>
<h2 id="jdk8-concurentHashMap"><a href="#jdk8-concurentHashMap" class="headerlink" title="jdk8 concurentHashMap"></a><code>jdk8 concurentHashMap</code></h2><p><strong><code>ConcurrentHashMap</code>取消了<code>segment</code>分段锁，而采用<code>CAS+synchronized</code>来保证并发安全，整个看起来就像是优化过且线程安全的<code>HashMap</code>。数据结构跟<code>HashMap1.8</code>的结构一样，<code>Node</code>数组+链表+红黑树。 <code>synchronized</code>只锁定当前链表或红黑二叉树的首节点，这样只要<code>hash</code>不冲突，就不会产生并发，效率又提升<code>N</code>倍。桶中的结构可能是链表，也可能是红黑树，红黑树是为了提高查找效率。</strong></p>
<p>容器里保存的所有<code>BeanFactory</code>创建的单例<code>bean</code> 都放在一个 <code>ConcurrentHashMap</code> 中</p>
<p><code>TreeBin</code>：红黑树节点 <code>Node</code>：链表节点</p>
<img data-src="/posts/52d9f7d3/2022-02-21-17-49-35.png" class="">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// node数组最大容量：2^30=1073741824  </span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  MAXIMUM_CAPACITY =  <span class="number">1</span>  &lt;&lt;  <span class="number">30</span>    ;  </span><br><span class="line">  <span class="comment">// 默认初始值，必须是2的幂数  </span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  DEFAULT_CAPACITY =  <span class="number">16</span>    ;  </span><br><span class="line">  <span class="comment">//数组可能最大值，需要与toArray（）相关方法关联  </span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  MAX_ARRAY_SIZE = Integer.MAX_VALUE -  <span class="number">8</span>    ;  </span><br><span class="line">  <span class="comment">//并发级别，遗留下来的，为兼容以前的版本  </span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  DEFAULT_CONCURRENCY_LEVEL =  <span class="number">16</span>    ;  </span><br><span class="line">  <span class="comment">// 负载因子  </span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">float</span>  LOAD_FACTOR =  <span class="number">0</span>    <span class="number">.75f</span>;  </span><br><span class="line">  <span class="comment">// 链表转红黑树阀值,&gt; 8 链表转换为红黑树  </span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  TREEIFY_THRESHOLD =  <span class="number">8</span>    ;  </span><br><span class="line">  <span class="comment">//树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）  </span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  UNTREEIFY_THRESHOLD =  <span class="number">6</span>    ;  </span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  MIN_TREEIFY_CAPACITY =  <span class="number">64</span>    ;  </span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  MIN_TRANSFER_STRIDE =  <span class="number">16</span>    ;  </span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">int</span>  RESIZE_STAMP_BITS =  <span class="number">16</span>    ;  </span><br><span class="line">  <span class="comment">// 2^15-1，help resize的最大线程数  </span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  MAX_RESIZERS = (    <span class="number">1</span>  &lt;&lt; (    <span class="number">32</span>  - RESIZE_STAMP_BITS)) -  <span class="number">1</span>    ;  </span><br><span class="line">  <span class="comment">// 32-16=16，sizeCtl中记录size大小的偏移量  </span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  RESIZE_STAMP_SHIFT =  <span class="number">32</span>  - RESIZE_STAMP_BITS;  </span><br><span class="line">  <span class="comment">// forwarding nodes的hash值  </span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  MOVED     = -    <span class="number">1</span>    ;  </span><br><span class="line">  <span class="comment">// 树根节点的hash值  </span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  TREEBIN   = -    <span class="number">2</span>    ;  </span><br><span class="line">  <span class="comment">// ReservationNode的hash值  </span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  RESERVED  = -    <span class="number">3</span>    ;  </span><br><span class="line">  <span class="comment">// 可用处理器数量  </span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span>  NCPU = Runtime.getRuntime().availableProcessors();  </span><br><span class="line">  <span class="comment">//存放node的数组  </span></span><br><span class="line">  <span class="keyword">transient</span>  <span class="keyword">volatile</span>  Node&lt;K,V&gt;[] table;  </span><br><span class="line">  <span class="comment">/*控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义  </span></span><br><span class="line"><span class="comment">  *当为负数时：-    1    代表正在初始化，-N代表有N-    1    个线程正在 进行扩容  </span></span><br><span class="line"><span class="comment">  *当为    0    时：代表当时的table还没有被初始化  </span></span><br><span class="line"><span class="comment">  *当为正数时：表示初始化或者下一次进行扩容的大小  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">transient</span>  <span class="keyword">volatile</span>  <span class="keyword">int</span>  sizeCtl;  </span><br></pre></td></tr></table></figure>
<h3 id="HashMap没有的属性"><a href="#HashMap没有的属性" class="headerlink" title="HashMap没有的属性"></a><code>HashMap</code>没有的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     hash表初始化或扩容时的一个控制位标识量。</span></span><br><span class="line"><span class="comment">     负数代表正在进行初始化或扩容操作</span></span><br><span class="line"><span class="comment">     -1代表正在初始化</span></span><br><span class="line"><span class="comment">     -N 表示有N-1个线程正在进行扩容操作</span></span><br><span class="line"><span class="comment">     正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl; </span><br><span class="line">    <span class="comment">// 以下两个是用来控制扩容的时候 单线程进入的变量</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of bits used for generation stamp in sizeCtl.</span></span><br><span class="line"><span class="comment">     * Must be at least 6 for 32bit arrays.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bit shift for recording size stamp in sizeCtl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Encodings for Node hash fields. See above for explanation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash值是-1，表示这是一个forwardNode节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash值是-2  表示这时一个TreeBin节点</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Nod</code><br><code>Node</code>是<code>ConcurrentHashMap</code>存储结构的基本单元，继承于<code>HashMap</code>中的<code>Entry</code>，用于存储数据。就是一个链表，但是只允许对数据进行查找，不允许进行修改<br><code>TreeNode</code><br><code>TreeNode</code>继承于<code>Node</code>，但是数据结构换成了二叉树结构，它是红黑树的数据的存储结构，用于红黑树中存储数据，当链表的节点数大于8时会转换成红黑树的结构，他就是通过<code>TreeNode</code>作为存储结构代替<code>Node</code>来转换成黑红树源代码如下<br><code>TreeBin</code><br><code>TreeBin</code>从字面含义中可以理解为存储树形结构的容器，而树形结构就是指<code>TreeNode</code>，所以<code>TreeBin</code>就是封装<code>TreeNode</code>的容器，它提供转换黑红树的一些条件和锁的控制，部分源码结构如下</p>
</blockquote>
<h3 id="利用CAS和Synchronized进行高效的同步更新数据。"><a href="#利用CAS和Synchronized进行高效的同步更新数据。" class="headerlink" title="利用CAS和Synchronized进行高效的同步更新数据。"></a>利用<code>CAS</code>和<code>Synchronized</code>进行高效的同步更新数据。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ConcurrentHashMap 不允许插入null键，HashMap允许插入一个null键</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//for循环的作用：因为更新元素是使用CAS机制更新，需要不断的失败重试，直到成功为止。</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f：链表或红黑二叉树头结点，向链表中添加元素时，需要synchronized获取f的锁。</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//判断Node[]数组是否初始化，没有则进行初始化操作</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//通过hash定位Node[]数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头结点），添加失败则进入下次循环。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查到内部正在移动元素（Node[] 数组扩容）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//帮助它扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//锁住链表或红黑二叉树的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//判断f是否是链表的头结点</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//如果fh&gt;=0 是链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历链表所有节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//如果节点存在，则更新value</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//不存在则在链表尾部添加新节点。</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//TreeBin是红黑二叉树节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//添加树节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                      value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果链表长度已经达到临界值8 就需要把链表转换为树结构</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前ConcurrentHashMap的size数量+1</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>判断<code>Node[]</code>数组是否初始化，没有则进行初始化操作</li>
</ul>
<ul>
<li>通过<code>hash</code>定位<code>Node[]</code>数组的索引坐标，是否有<code>Node</code>节点，如果没有则使用<code>CAS</code>进行添加（链表的头结点），添加失败则进入下次循环。</li>
</ul>
<ul>
<li>检查到内部正在扩容，如果正在扩容，就帮助它一块扩容。</li>
</ul>
<ul>
<li>如果<code>f!=null</code>，则使用<code>synchronized</code>锁住<code>f</code>元素（链表/红黑二叉树的头元素）</li>
<li>如果是<code>Node</code>(链表结构)则执行链表的添加操作。</li>
<li>如果是<code>TreeNode</code>(树型结果)则执行树添加操作。</li>
</ul>
<ul>
<li>判断链表长度已经达到临界值<code>8</code> 就需要把链表转换为树结构。</li>
</ul>
<p><code>JDK8</code>中的<code>concurrentHashMap</code> 实现是锁分离的思想，它把锁分的比<code>segment（JDK1.7）</code>更细一些，只要<code>hash</code>不冲突，就不会出现并发获得锁的情况。它首先使用无锁操作<code>CAS</code>插入头结点，如果插入失败，说明已经有别的线程插入头结点了，再次循环进行操作。如果头结点已经存在，则通过<code>synchronized</code>获得头结点锁，进行后续的操作。性能比<code>segment</code>分段锁又再次提升。</p>
<h3 id="Synchronized在1-6之后锁升级的过程"><a href="#Synchronized在1-6之后锁升级的过程" class="headerlink" title="Synchronized在1.6之后锁升级的过程"></a><code>Synchronized</code>在<code>1.6</code>之后锁升级的过程</h3><p>一个对象一开始是无锁的状态，或者说是可偏向状态，会先去判断下，再进行升级过程。锁是支持偏向锁的，当付钱获取到锁的这个线程，会优先让它再去获取到这个锁，如果没有获取到这个锁，就升级成一个轻量级的<code>CAS</code>锁，即乐观锁，乐观锁是比较有交S换的过程；如果<code>CAS</code>没有设置成功就会进行一个自旋，自旋到一定次数才会升级成一个<code>Synchronized</code>这个重量级锁，保证了性能问题</p>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><ul>
<li><p>为什么<code>HashMap</code>使用红黑树而不使用<code>AVL</code>树</p>
</li>
<li><p><code>CurrentHashMap</code>中加读写锁，实际上是读写锁，如果写冲突就会等待，如果插入时间过长必然等待时间更长，而红黑树相对<code>AVL</code>树他的插入更快！</p>
</li>
</ul>
<ul>
<li>插入和删除方面，<code>AVL</code>树速度较慢：需要更高的旋转次数才能在修改时正确地重新平衡数据结构。</li>
</ul>
<ul>
<li>两个都给<code>O（log n）</code>查找，但平衡AVL树可能需要<code>O（log n）</code>旋转，而红黑树将需要最多两次旋转使其达到平衡</li>
</ul>
<ul>
<li><code>AVL</code>树的旋转比红黑树的旋转更加难以平衡和调试。</li>
</ul>

      <div class="tags">
          <a href="/tags/Java/" rel="tag"><i class="ic i-tag"></i> Java</a>
          <a href="/tags/HashMap/" rel="tag"><i class="ic i-tag"></i> HashMap</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2022-02-21 23:23:41" itemprop="dateModified" datetime="2022-02-21T23:23:41+08:00">2022-02-21</time>
  </span>
  <span id="posts/52d9f7d3/" class="item leancloud_visitors" data-flag-title="Java面试必问--HashMap的底层" title="Views">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">Views</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">times</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>JIN Mao <i class="ic i-at"><em>@</em></i>JIN MAO 's Blog
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://smile1231.github.io/posts/52d9f7d3/" title="Java面试必问--HashMap的底层">https://smile1231.github.io/posts/52d9f7d3/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/posts/feb84842/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciryrr3rj20zk0m8nhk.jpg" title="Java面试必问--ArrayList的底层">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> Java面试</span>
  <h3>Java面试必问--ArrayList的底层</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/posts/69c17d37/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeuibk9fj20zk0m8ay2.jpg" title="关于事务提交中踩坑">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> Mysql</span>
  <h3>关于事务提交中踩坑</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk7-HashMap"><span class="toc-number">1.</span> <span class="toc-text">jdk7 HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#put%E5%A4%B4%E6%8F%92%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">put头插法的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%85%B7%E4%BD%93%E6%95%B0%E7%BB%84%E4%BD%8D%E7%BD%AE%EF%BC%88indexFor%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">计算具体数组位置（indexFor）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E5%88%B0%E9%93%BE%E8%A1%A8%E4%B8%AD%EF%BC%88addEntry%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">添加节点到链表中（addEntry）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9%EF%BC%88resize%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">数组扩容（resize）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.5.</span> <span class="toc-text">get 过程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove"><span class="toc-number">1.6.</span> <span class="toc-text">remove</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk8-HashMap"><span class="toc-number">2.</span> <span class="toc-text">jdk8 HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91-RB-Tree"><span class="toc-number">2.1.</span> <span class="toc-text">红黑树 RB-Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9%E8%A7%84%E5%BE%8B%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">红黑树插入结点规律：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">红黑树主要特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">4.1.</span> <span class="toc-text">红黑树的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Put%E6%96%B9%E6%B3%95%EF%BC%9A%E5%92%8C-Java7-%E7%A8%8D%E5%BE%AE%E6%9C%89%E7%82%B9%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%9C%B0%E6%96%B9%E5%B0%B1%E6%98%AF%EF%BC%8CJava7-%E6%98%AF%E5%85%88%E6%89%A9%E5%AE%B9%E5%90%8E%E6%8F%92%E5%85%A5%E6%96%B0%E5%80%BC%E7%9A%84%EF%BC%8CJava8-%E5%85%88%E6%8F%92%E5%80%BC%E5%86%8D%E6%89%A9%E5%AE%B9"><span class="toc-number">4.2.</span> <span class="toc-text">Put方法：和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9%EF%BC%9Aresize-%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84%E6%88%96%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9%EF%BC%8C%E6%AF%8F%E6%AC%A1%E6%89%A9%E5%AE%B9%E5%90%8E%EF%BC%8C%E5%AE%B9%E9%87%8F%E4%B8%BA%E5%8E%9F%E6%9D%A5%E7%9A%84-2-%E5%80%8D%EF%BC%8C%E5%B9%B6%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E3%80%82"><span class="toc-number">4.3.</span> <span class="toc-text">数组扩容：resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">get分析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E9%80%80%E5%8C%96%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-number">4.5.</span> <span class="toc-text">红黑树退化为链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk8-concurentHashMap"><span class="toc-number">5.</span> <span class="toc-text">jdk8 concurentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%B2%A1%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">HashMap没有的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8CAS%E5%92%8CSynchronized%E8%BF%9B%E8%A1%8C%E9%AB%98%E6%95%88%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">5.2.</span> <span class="toc-text">利用CAS和Synchronized进行高效的同步更新数据。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">5.3.</span> <span class="toc-text">注意点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized%E5%9C%A81-6%E4%B9%8B%E5%90%8E%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">5.4.</span> <span class="toc-text">Synchronized在1.6之后锁升级的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95"><span class="toc-number">6.</span> <span class="toc-text">面试</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li class="active"><a href="/posts/52d9f7d3/" rel="bookmark" title="Java面试必问--HashMap的底层">Java面试必问--HashMap的底层</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="JIN Mao"
      data-src="/images/avatar.png">
  <p class="name" itemprop="name">JIN Mao</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">134</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">70</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">98</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NtaWxlMTIzMQ==" title="https:&#x2F;&#x2F;github.com&#x2F;smile1231"><i class="ic i-github"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>

</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/posts/feb84842/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/posts/69c17d37/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/posts/afe5178f/" title="关于设置git以及npm代理">关于设置git以及npm代理</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%89%8D%E7%AB%AF/" title="In 前端">前端</a>
<i class="ic i-angle-right"></i>
<a href="/categories/%E5%89%8D%E7%AB%AF/Css/" title="In Css">Css</a>
</div>

    <span><a href="/posts/7f59931c/" title="Css选择器">Css选择器</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Java%E9%9D%A2%E8%AF%95/" title="In Java面试">Java面试</a>
</div>

    <span><a href="/posts/a5258aa2/" title="Java面试小册子">Java面试小册子</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Mybtais/" title="In Mybtais">Mybtais</a>
</div>

    <span><a href="/posts/9aff665a/" title="mybatis中大于等于小于等于的写法">mybatis中大于等于小于等于的写法</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Java/" title="In Java">Java</a>
</div>

    <span><a href="/posts/1748805d/" title="java线程池与五种常用线程池策略使用与解析">java线程池与五种常用线程池策略使用与解析</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/posts/159c6098/" title="阻塞队列">阻塞队列</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Daily/" title="In Daily">Daily</a>
</div>

    <span><a href="/posts/9a0369ec/" title="布隆过滤器">布隆过滤器</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="In 数据库">数据库</a>
</div>

    <span><a href="/posts/388f5c14/" title="mysql日期加减">mysql日期加减</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/SAP/" title="In SAP">SAP</a>
</div>

    <span><a href="/posts/ef55dc85/" title="CEST与北京时间转换表">CEST与北京时间转换表</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/posts/bf4d20ae/" title="写在最前面">写在最前面</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2021 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">JIN Mao @ Jin Mao when to get rich ?</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="Symbols count total">557k words</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="Reading time total">8:26</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'posts/52d9f7d3/',
    favicon: {
      show: "You're welcome",
      hide: "Wait for you"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
